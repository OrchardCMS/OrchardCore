/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

///<reference path='../Lib/jquery/typings.d.ts' />
var applyFilter = function applyFilter(category, q) {
  var type = $('.modal-activities').data('activity-type');
  category = category || $('.activity-picker-categories .nav-link.active').attr('href').substr(1);
  q = q || $('.modal-activities input[type=search]').val();
  var $cards = $('.activity.col').show();
  // Remove activities whoes type doesn't match the configured activity type.
  $cards.filter(function (i, el) {
    return $(el).data('activity-type') != type;
  }).hide();
  if (q.length > 0) {
    // Remove activities whose title doesn't match the query.
    $cards.filter(function (i, el) {
      return $(el).find('.card-title').text().toLowerCase().indexOf(q.toLowerCase()) < 0 && q && q.length > 0;
    }).hide();
  } else {
    // Remove activities whose category doesn't match the selected one.
    $cards.filter(function (i, el) {
      return $(el).data('category').toLowerCase() != category.toLowerCase() && category.toLowerCase() != 'all';
    }).hide();
  }
  // Show or hide categories based on whether there are any available activities.
  $('.activity-picker-categories [data-category]').each(function (i, el) {
    var categoryListItem = $(el);
    var category = categoryListItem.data('category');
    // Count number of activities within this category and for the specified activity type (Event or Task).
    var activityCount = $(".activity.col[data-category='".concat(category, "'][data-activity-type='").concat(type, "']")).length;
    activityCount == 0 ? categoryListItem.hide() : categoryListItem.show();
  });
};
$(function () {
  $('.activity-picker-categories').on('click', '.nav-link', function (e) {
    applyFilter($(e.target).attr('href').substr(1), null);
  });
  $('.modal-activities input[type=search]').on('keyup', function (e) {
    applyFilter(null, $(e.target).val());
  });
  $('#activity-picker').on('show.bs.modal', function (event) {
    var modalEvent = event;
    var button = $(modalEvent.relatedTarget); // Button that triggered the modal.
    var title = button.data('picker-title');
    var type = button.data('activity-type');
    var modal = $(this);
    modal.find('[href="#all"]').click();
    modal.find('.modal-title').text(title);
    modal.data('activity-type', type);
    applyFilter(null, null);
  });
});
///<reference path="../../../Assets/Lib/jquery/typings.d.ts" />
$(function () {
  var generateWorkflowUrl = function generateWorkflowUrl() {
    var workflowTypeId = $('[data-workflow-type-id]').data('workflow-type-id');
    var activityId = $('[data-activity-id]').data('activity-id');
    var tokenLifeSpan = $('#token-lifespan').val();
    var generateUrl = $('[data-generate-url]').data('generate-url') + "?workflowTypeId=".concat(workflowTypeId, "&activityId=").concat(activityId, "&tokenLifeSpan=").concat(tokenLifeSpan);
    var antiforgeryHeaderName = $('[data-antiforgery-header-name]').data('antiforgery-header-name');
    var antiforgeryToken = $('[data-antiforgery-token]').data('antiforgery-token');
    var headers = {};
    headers[antiforgeryHeaderName] = antiforgeryToken;
    $.post({
      url: generateUrl,
      headers: headers
    }).done(function (url) {
      $('#workflow-url-text').val(url);
    });
  };
  $('#generate-url-button').on('click', function (e) {
    generateWorkflowUrl();
  });
  if ($('#workflow-url-text').val() == '') {
    generateWorkflowUrl();
  }
});
///<reference path='../Lib/jquery/typings.d.ts' />
///<reference path='../Lib/jsplumb/typings.d.ts' />
///<reference path='./workflow-models.ts' />
var WorkflowCanvas = /** @class */function () {
  function WorkflowCanvas(container, workflowType) {
    var _this = this;
    this.container = container;
    this.workflowType = workflowType;
    this.minCanvasHeight = 400;
    this.getActivityElements = function () {
      return $(_this.container).find('.activity');
    };
    this.getDefaults = function () {
      return {
        Anchor: "Continuous",
        DragOptions: {
          cursor: 'pointer',
          zIndex: 2000
        },
        EndpointStyles: [{
          fillStyle: '#225588'
        }],
        Endpoints: [["Dot", {
          radius: 7
        }], ["Blank"]],
        ConnectionOverlays: [["Arrow", {
          width: 12,
          length: 12,
          location: -5
        }]],
        ConnectorZIndex: 5
      };
    };
    this.createJsPlumbInstance = function () {
      return jsPlumb.getInstance({
        DragOptions: {
          cursor: 'pointer',
          zIndex: 2000
        },
        ConnectionOverlays: [['Arrow', {
          location: 1,
          visible: true,
          width: 11,
          length: 11
        }], ['Label', {
          location: 0.5,
          id: 'label',
          cssClass: 'connection-label'
        }]],
        Container: _this.container
      });
    };
    this.getEndpointColor = function (activity) {
      return activity.isBlocking || activity.isStart ? '#7ab02c' : activity.isEvent ? '#3a8acd' : '#7ab02c';
    };
    this.getSourceEndpointOptions = function (activity, outcome) {
      // The definition of source endpoints.
      var paintColor = _this.getEndpointColor(activity);
      return {
        endpoint: 'Dot',
        anchor: 'Continuous',
        paintStyle: {
          stroke: paintColor,
          fill: paintColor,
          radius: 7,
          strokeWidth: 1
        },
        isSource: true,
        connector: ['Flowchart', {
          stub: [40, 60],
          gap: 0,
          cornerRadius: 5,
          alwaysRespectStubs: true
        }],
        connectorStyle: {
          strokeWidth: 2,
          stroke: '#999999',
          joinstyle: 'round',
          outlineStroke: 'white',
          outlineWidth: 2
        },
        hoverPaintStyle: {
          fill: '#216477',
          stroke: '#216477'
        },
        connectorHoverStyle: {
          strokeWidth: 3,
          stroke: '#216477',
          outlineWidth: 5,
          outlineStroke: 'white'
        },
        connectorOverlays: [['Label', {
          location: [3, -1.5],
          cssClass: 'endpointSourceLabel'
        }]],
        dragOptions: {},
        uuid: "".concat(activity.id, "-").concat(outcome.name),
        parameters: {
          outcome: outcome
        }
      };
    };
    this.getActivity = function (id, activities) {
      if (activities === void 0) {
        activities = null;
      }
      if (!activities) {
        activities = this.workflowType.activities;
      }
      return $.grep(activities, function (x) {
        return x.id === id;
      })[0];
    };
    this.updateConnections = function (plumber) {
      var workflowId = _this.workflowType.id;
      // Connect activities.
      for (var _i = 0, _a = _this.workflowType.transitions; _i < _a.length; _i++) {
        var transitionModel = _a[_i];
        var sourceEndpointUuid = "".concat(transitionModel.sourceActivityId, "-").concat(transitionModel.sourceOutcomeName);
        var sourceEndpoint = plumber.getEndpoint(sourceEndpointUuid);
        var destinationElementId = "activity-".concat(workflowId, "-").concat(transitionModel.destinationActivityId);
        plumber.connect({
          source: sourceEndpoint,
          target: destinationElementId
        });
      }
    };
    this.updateCanvasHeight = function () {
      var $container = $(this.container);
      // Get the activity element with the highest Y coordinate.
      var $activityElements = $container.find(".activity");
      var currentElementTop = 0;
      var currentActivityHeight = 0;
      for (var _i = 0, _a = $activityElements.toArray(); _i < _a.length; _i++) {
        var activityElement = _a[_i];
        var $activityElement = $(activityElement);
        var top_1 = $activityElement.position().top;
        if (top_1 > currentElementTop) {
          currentElementTop = top_1;
          currentActivityHeight = $activityElement.height();
        }
      }
      var newCanvasHeight = currentElementTop + currentActivityHeight;
      var elementBottom = currentElementTop + currentActivityHeight;
      var stretchValue = 100;
      if (newCanvasHeight - elementBottom <= stretchValue) {
        newCanvasHeight += stretchValue;
      }
      $container.height(Math.max(this.minCanvasHeight, newCanvasHeight));
    };
  }
  return WorkflowCanvas;
}();
///<reference path='../Lib/jquery/typings.d.ts' />
///<reference path='../Lib/jsplumb/typings.d.ts' />
///<reference path='./workflow-models.ts' />
///<reference path='./workflow-canvas.ts' />
var __extends = this && this.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return _extendStatics(d, b);
  };
  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    _extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
// TODO: Re-implement this using a MVVM approach.
var WorkflowEditor = /** @class */function (_super) {
  __extends(WorkflowEditor, _super);
  function WorkflowEditor(container, workflowType, deleteActivityPrompt, localId, loadLocalState) {
    var _this = _super.call(this, container, workflowType) || this;
    _this.container = container;
    _this.workflowType = workflowType;
    _this.deleteActivityPrompt = deleteActivityPrompt;
    _this.localId = localId;
    _this.getState = function () {
      var $allActivityElements = $(_this.container).find('.activity');
      var workflow = {
        id: _this.workflowType.id,
        activities: [],
        transitions: [],
        removedActivities: _this.workflowType.removedActivities
      };
      // Collect activities.
      for (var i = 0; i < $allActivityElements.length; i++) {
        var $activityElement = $($allActivityElements[i]);
        var activityId = $activityElement.data('activity-id');
        var activityIsStart = $activityElement.data('activity-start');
        var activityIsEvent = $activityElement.data('activity-type') === 'Event';
        var activityPosition = $activityElement.position();
        var activity = _this.getActivity(activityId);
        workflow.activities.push({
          id: activityId,
          isStart: activityIsStart,
          isEvent: activityIsEvent,
          outcomes: activity.outcomes,
          x: activityPosition.left,
          y: activityPosition.top
        });
      }
      // Collect connections.
      var allConnections = _this.jsPlumbInstance.getConnections();
      for (var i = 0; i < allConnections.length; i++) {
        var connection = allConnections[i];
        var sourceEndpoint = connection.endpoints[0];
        var sourceOutcomeName = sourceEndpoint.getParameters().outcome.name;
        var sourceActivityId = $(connection.source).data('activity-id');
        var destinationActivityId = $(connection.target).data('activity-id');
        workflow.transitions.push({
          sourceActivityId: sourceActivityId,
          destinationActivityId: destinationActivityId,
          sourceOutcomeName: sourceOutcomeName
        });
      }
      return workflow;
    };
    _this.serialize = function () {
      var workflow = _this.getState();
      return JSON.stringify(workflow);
    };
    _this.saveLocalState = function () {
      sessionStorage[_this.localId] = _this.serialize();
    };
    _this.loadLocalState = function () {
      return JSON.parse(sessionStorage[_this.localId]);
    };
    var self = _this;
    jsPlumb.ready(function () {
      jsPlumb.importDefaults(_this.getDefaults());
      var plumber = _this.createJsPlumbInstance();
      // Listen for new connections.
      plumber.bind('connection', function (connInfo, originalEvent) {
        var connection = connInfo.connection;
        var outcome = connection.getParameters().outcome;
        var label = connection.getOverlay('label');
        label.setLabel(outcome.displayName);
      });
      var activityElements = _this.getActivityElements();
      var areEqualOutcomes = function areEqualOutcomes(outcomes1, outcomes2) {
        if (outcomes1.length != outcomes2.length) {
          return false;
        }
        for (var i = 0; i < outcomes1.length; i++) {
          var outcome1 = outcomes1[i];
          var outcome2 = outcomes2[i];
          if (outcome1.name != outcome2.displayName || outcome1.displayName != outcome2.displayName) {
            return false;
          }
        }
        return true;
      };
      // Suspend drawing and initialize.
      plumber.batch(function () {
        var serverworkflowType = _this.workflowType;
        var workflowId = _this.workflowType.id;
        if (loadLocalState) {
          var localState = _this.loadLocalState();
          if (localState) {
            _this.workflowType = localState;
          }
        }
        activityElements.each(function (_, activityElement) {
          var $activityElement = $(activityElement);
          var activityId = $activityElement.data('activity-id');
          var isDeleted = _this.workflowType.removedActivities.indexOf(activityId) > -1;
          if (isDeleted) {
            $activityElement.remove();
            return;
          }
          var activity = _this.getActivity(activityId);
          var serverActivity = _this.getActivity(activityId, serverworkflowType.activities);
          // Update the activity's visual state.
          if (loadLocalState) {
            if (activity == null) {
              // This is a newly added activity not yet added to local state.
              activity = serverActivity;
              _this.workflowType.activities.push(activity);
              activity.x = 50;
              activity.y = 50;
            } else {
              // The available outcomes might have changed when editing an activity,
              // so we need to check for that and update the client's activity outcomes if so.
              var sameOutcomes = areEqualOutcomes(activity.outcomes, serverActivity.outcomes);
              if (!sameOutcomes) {
                activity.outcomes = serverActivity.outcomes;
              }
              $activityElement.css({
                left: activity.x,
                top: activity.y
              }).toggleClass('activity-start', activity.isStart).data('activity-start', activity.isStart);
            }
          }
          // Make the activity draggable.
          plumber.draggable(activityElement, {
            grid: [10, 10],
            containment: true,
            start: function start(args) {
              _this.dragStart = {
                left: args.e.screenX,
                top: args.e.screenY
              };
            },
            stop: function stop(args) {
              _this.hasDragged = _this.dragStart.left != args.e.screenX || _this.dragStart.top != args.e.screenY;
              _this.updateCanvasHeight();
            }
          });
          // Configure the activity as a target.
          plumber.makeTarget(activityElement, {
            dropOptions: {
              hoverClass: 'hover'
            },
            anchor: 'Continuous',
            endpoint: ['Blank', {
              radius: 8
            }]
          });
          // Add source endpoints.
          for (var _i = 0, _a = activity.outcomes; _i < _a.length; _i++) {
            var outcome = _a[_i];
            var sourceEndpointOptions = _this.getSourceEndpointOptions(activity, outcome);
            plumber.addEndpoint(activityElement, {
              connectorOverlays: [['Label', {
                label: outcome.displayName,
                cssClass: 'connection-label'
              }]]
            }, sourceEndpointOptions);
          }
        });
        // Connect activities.
        _this.updateConnections(plumber);
        // Re-query the activity elements.
        activityElements = _this.getActivityElements();
        // Make all activity elements visible.
        activityElements.show();
        _this.updateCanvasHeight();
      });
      // Initialize popovers.
      activityElements.each(function (_, item) {
        var activityElement = $(item);
        activityElement.popover({
          trigger: 'manual',
          html: true,
          content: function content() {
            var $content = activityElement.find('.activity-commands').clone();
            var startButton = $content.find('.activity-start-action');
            var isStart = activityElement.data('activity-start') === true;
            var activityId = activityElement.data('activity-id');
            startButton.attr('aria-pressed', activityElement.data('activity-start'));
            startButton.toggleClass('active', isStart);
            $content.on('click', '.activity-start-action', function (e) {
              e.preventDefault();
              var button = $(e.currentTarget);
              var isStart = button.is('.active');
              activityElement.data('activity-start', isStart);
              activityElement.toggleClass('activity-start', isStart);
            });
            $content.on('click', '.activity-delete-action', function (e) {
              e.preventDefault();
              // TODO: The prompts are really annoying. Consider showing some sort of small message balloon somewhere to undo the action instead.
              //if (!confirm(self.deleteActivityPrompt)) {
              //    return;
              //}
              self.workflowType.removedActivities.push(activityId);
              plumber.remove(activityElement);
              activityElement.popover('dispose');
            });
            $content.on('click', '[data-persist-workflow]', function (e) {
              self.saveLocalState();
            });
            return $content.get(0);
          }
        });
      });
      $(container).on('click', '.activity', function (e) {
        if (_this.hasDragged) {
          _this.hasDragged = false;
          return;
        }
        // if any other popovers are visible, hide them
        if (_this.isPopoverVisible) {
          activityElements.popover('hide');
        }
        var sender = $(e.currentTarget);
        sender.popover('show');
        // handle clicking on the popover itself.
        $('.popover').off('click').on('click', function (e2) {
          e2.stopPropagation();
        });
        e.stopPropagation();
        _this.isPopoverVisible = true;
      });
      $(container).on('dblclick', '.activity', function (e) {
        var sender = $(e.currentTarget);
        var hasEditor = sender.data('activity-has-editor');
        if (hasEditor) {
          _this.saveLocalState();
          sender.find('.activity-edit-action').get(0).click();
        }
      });
      // Hide all popovers when clicking anywhere but on an activity.
      $('body').on('click', function (e) {
        activityElements.popover('hide');
        _this.isPopoverVisible = false;
      });
      // Save local changes if the event target has the 'data-persist-workflow' attribute.
      $('body').on('click', '[data-persist-workflow]', function (e) {
        _this.saveLocalState();
      });
      _this.jsPlumbInstance = plumber;
    });
    return _this;
  }
  return WorkflowEditor;
}(WorkflowCanvas);
$.fn.workflowEditor = function () {
  this.each(function (index, element) {
    var $element = $(element);
    var workflowType = $element.data('workflow-type');
    var deleteActivityPrompt = $element.data('workflow-delete-activity-prompt');
    var localId = $element.data('workflow-local-id');
    var loadLocalState = $element.data('workflow-load-local-state');
    workflowType.removedActivities = workflowType.removedActivities || [];
    $element.data('workflowEditor', new WorkflowEditor(element, workflowType, deleteActivityPrompt, localId, loadLocalState));
  });
  return this;
};
$(document).ready(function () {
  var workflowEditor = $('.workflow-canvas').workflowEditor().data('workflowEditor');
  $('#workflowEditorForm').on('submit', function (s, e) {
    var state = workflowEditor.serialize();
    $('#workflowStateInput').val(state);
  });
});