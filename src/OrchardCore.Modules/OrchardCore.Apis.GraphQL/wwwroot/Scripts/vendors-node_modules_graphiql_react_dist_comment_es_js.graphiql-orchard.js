"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_orchardcore_root"] = self["webpackChunk_orchardcore_root"] || []).push([["vendors-node_modules_graphiql_react_dist_comment_es_js"],{

/***/ "./node_modules/@graphiql/react/dist/comment.es.js":
/*!*********************************************************!*\
  !*** ./node_modules/@graphiql/react/dist/comment.es.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: () => (/* binding */ comment$1)\n/* harmony export */ });\n/* harmony import */ var _codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./codemirror.es.js */ \"./node_modules/@graphiql/react/dist/codemirror.es.js\");\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\n\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function(e) {\n    e && typeof e !== \"string\" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== \"default\" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n__name(_mergeNamespaces, \"_mergeNamespaces\");\nvar comment$2 = { exports: {} };\n(function(module, exports) {\n  (function(mod) {\n    mod(_codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__.a.exports);\n  })(function(CodeMirror) {\n    var noOptions = {};\n    var nonWS = /[^\\s\\u00a0]/;\n    var Pos = CodeMirror.Pos, cmp = CodeMirror.cmpPos;\n    function firstNonWS(str) {\n      var found = str.search(nonWS);\n      return found == -1 ? 0 : found;\n    }\n    __name(firstNonWS, \"firstNonWS\");\n    CodeMirror.commands.toggleComment = function(cm) {\n      cm.toggleComment();\n    };\n    CodeMirror.defineExtension(\"toggleComment\", function(options) {\n      if (!options)\n        options = noOptions;\n      var cm = this;\n      var minLine = Infinity, ranges = this.listSelections(), mode = null;\n      for (var i = ranges.length - 1; i >= 0; i--) {\n        var from = ranges[i].from(), to = ranges[i].to();\n        if (from.line >= minLine)\n          continue;\n        if (to.line >= minLine)\n          to = Pos(minLine, 0);\n        minLine = from.line;\n        if (mode == null) {\n          if (cm.uncomment(from, to, options))\n            mode = \"un\";\n          else {\n            cm.lineComment(from, to, options);\n            mode = \"line\";\n          }\n        } else if (mode == \"un\") {\n          cm.uncomment(from, to, options);\n        } else {\n          cm.lineComment(from, to, options);\n        }\n      }\n    });\n    function probablyInsideString(cm, pos, line) {\n      return /\\bstring\\b/.test(cm.getTokenTypeAt(Pos(pos.line, 0))) && !/^[\\'\\\"\\`]/.test(line);\n    }\n    __name(probablyInsideString, \"probablyInsideString\");\n    function getMode(cm, pos) {\n      var mode = cm.getMode();\n      return mode.useInnerComments === false || !mode.innerMode ? mode : cm.getModeAt(pos);\n    }\n    __name(getMode, \"getMode\");\n    CodeMirror.defineExtension(\"lineComment\", function(from, to, options) {\n      if (!options)\n        options = noOptions;\n      var self = this, mode = getMode(self, from);\n      var firstLine = self.getLine(from.line);\n      if (firstLine == null || probablyInsideString(self, from, firstLine))\n        return;\n      var commentString = options.lineComment || mode.lineComment;\n      if (!commentString) {\n        if (options.blockCommentStart || mode.blockCommentStart) {\n          options.fullLines = true;\n          self.blockComment(from, to, options);\n        }\n        return;\n      }\n      var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);\n      var pad = options.padding == null ? \" \" : options.padding;\n      var blankLines = options.commentBlankLines || from.line == to.line;\n      self.operation(function() {\n        if (options.indent) {\n          var baseString = null;\n          for (var i = from.line; i < end; ++i) {\n            var line = self.getLine(i);\n            var whitespace = line.slice(0, firstNonWS(line));\n            if (baseString == null || baseString.length > whitespace.length) {\n              baseString = whitespace;\n            }\n          }\n          for (var i = from.line; i < end; ++i) {\n            var line = self.getLine(i), cut = baseString.length;\n            if (!blankLines && !nonWS.test(line))\n              continue;\n            if (line.slice(0, cut) != baseString)\n              cut = firstNonWS(line);\n            self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));\n          }\n        } else {\n          for (var i = from.line; i < end; ++i) {\n            if (blankLines || nonWS.test(self.getLine(i)))\n              self.replaceRange(commentString + pad, Pos(i, 0));\n          }\n        }\n      });\n    });\n    CodeMirror.defineExtension(\"blockComment\", function(from, to, options) {\n      if (!options)\n        options = noOptions;\n      var self = this, mode = getMode(self, from);\n      var startString = options.blockCommentStart || mode.blockCommentStart;\n      var endString = options.blockCommentEnd || mode.blockCommentEnd;\n      if (!startString || !endString) {\n        if ((options.lineComment || mode.lineComment) && options.fullLines != false)\n          self.lineComment(from, to, options);\n        return;\n      }\n      if (/\\bcomment\\b/.test(self.getTokenTypeAt(Pos(from.line, 0))))\n        return;\n      var end = Math.min(to.line, self.lastLine());\n      if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end)))\n        --end;\n      var pad = options.padding == null ? \" \" : options.padding;\n      if (from.line > end)\n        return;\n      self.operation(function() {\n        if (options.fullLines != false) {\n          var lastLineHasText = nonWS.test(self.getLine(end));\n          self.replaceRange(pad + endString, Pos(end));\n          self.replaceRange(startString + pad, Pos(from.line, 0));\n          var lead = options.blockCommentLead || mode.blockCommentLead;\n          if (lead != null) {\n            for (var i = from.line + 1; i <= end; ++i)\n              if (i != end || lastLineHasText)\n                self.replaceRange(lead + pad, Pos(i, 0));\n          }\n        } else {\n          var atCursor = cmp(self.getCursor(\"to\"), to) == 0, empty = !self.somethingSelected();\n          self.replaceRange(endString, to);\n          if (atCursor)\n            self.setSelection(empty ? to : self.getCursor(\"from\"), to);\n          self.replaceRange(startString, from);\n        }\n      });\n    });\n    CodeMirror.defineExtension(\"uncomment\", function(from, to, options) {\n      if (!options)\n        options = noOptions;\n      var self = this, mode = getMode(self, from);\n      var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()), start = Math.min(from.line, end);\n      var lineString = options.lineComment || mode.lineComment, lines = [];\n      var pad = options.padding == null ? \" \" : options.padding, didSomething;\n      lineComment: {\n        if (!lineString)\n          break lineComment;\n        for (var i = start; i <= end; ++i) {\n          var line = self.getLine(i);\n          var found = line.indexOf(lineString);\n          if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1))))\n            found = -1;\n          if (found == -1 && nonWS.test(line))\n            break lineComment;\n          if (found > -1 && nonWS.test(line.slice(0, found)))\n            break lineComment;\n          lines.push(line);\n        }\n        self.operation(function() {\n          for (var i2 = start; i2 <= end; ++i2) {\n            var line2 = lines[i2 - start];\n            var pos = line2.indexOf(lineString), endPos = pos + lineString.length;\n            if (pos < 0)\n              continue;\n            if (line2.slice(endPos, endPos + pad.length) == pad)\n              endPos += pad.length;\n            didSomething = true;\n            self.replaceRange(\"\", Pos(i2, pos), Pos(i2, endPos));\n          }\n        });\n        if (didSomething)\n          return true;\n      }\n      var startString = options.blockCommentStart || mode.blockCommentStart;\n      var endString = options.blockCommentEnd || mode.blockCommentEnd;\n      if (!startString || !endString)\n        return false;\n      var lead = options.blockCommentLead || mode.blockCommentLead;\n      var startLine = self.getLine(start), open = startLine.indexOf(startString);\n      if (open == -1)\n        return false;\n      var endLine = end == start ? startLine : self.getLine(end);\n      var close = endLine.indexOf(endString, end == start ? open + startString.length : 0);\n      var insideStart = Pos(start, open + 1), insideEnd = Pos(end, close + 1);\n      if (close == -1 || !/comment/.test(self.getTokenTypeAt(insideStart)) || !/comment/.test(self.getTokenTypeAt(insideEnd)) || self.getRange(insideStart, insideEnd, \"\\n\").indexOf(endString) > -1)\n        return false;\n      var lastStart = startLine.lastIndexOf(startString, from.ch);\n      var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);\n      if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch)\n        return false;\n      firstEnd = endLine.indexOf(endString, to.ch);\n      var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);\n      lastStart = firstEnd == -1 || almostLastStart == -1 ? -1 : to.ch + almostLastStart;\n      if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch)\n        return false;\n      self.operation(function() {\n        self.replaceRange(\"\", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)), Pos(end, close + endString.length));\n        var openEnd = open + startString.length;\n        if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad)\n          openEnd += pad.length;\n        self.replaceRange(\"\", Pos(start, open), Pos(start, openEnd));\n        if (lead)\n          for (var i2 = start + 1; i2 <= end; ++i2) {\n            var line2 = self.getLine(i2), found2 = line2.indexOf(lead);\n            if (found2 == -1 || nonWS.test(line2.slice(0, found2)))\n              continue;\n            var foundEnd = found2 + lead.length;\n            if (pad && line2.slice(foundEnd, foundEnd + pad.length) == pad)\n              foundEnd += pad.length;\n            self.replaceRange(\"\", Pos(i2, found2), Pos(i2, foundEnd));\n          }\n      });\n      return true;\n    });\n  });\n})();\nvar comment = comment$2.exports;\nvar comment$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": comment\n}, [comment$2.exports]));\n\n\n\n//# sourceURL=webpack://@orchardcore/root/./node_modules/@graphiql/react/dist/comment.es.js?");

/***/ })

}]);