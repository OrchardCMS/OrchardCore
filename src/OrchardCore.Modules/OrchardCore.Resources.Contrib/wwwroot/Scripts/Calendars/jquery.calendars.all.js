/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/* http://keith-wood.name/calendars.html
   Calendars for jQuery v2.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

	function Calendars() {
		this.regionalOptions = [];
		this.regionalOptions[''] = {
			invalidCalendar: 'Calendar {0} not found',
			invalidDate: 'Invalid {0} date',
			invalidMonth: 'Invalid {0} month',
			invalidYear: 'Invalid {0} year',
			differentCalendars: 'Cannot mix {0} and {1} dates'
		};
		this.local = this.regionalOptions[''];
		this.calendars = {};
		this._localCals = {};
	}

	/** Create the calendars plugin.
		<p>Provides support for various world calendars in a consistent manner.</p>
	 	@class Calendars
		@example $.calendars.instance('julian').newDate(2014, 12, 25) */
	$.extend(Calendars.prototype, {

		/** Obtain a calendar implementation and localisation.
			@memberof Calendars
			@param [name='gregorian'] {string} The name of the calendar, e.g. 'gregorian', 'persian', 'islamic'.
			@param [language=''] {string} The language code to use for localisation (default is English).
			@return {Calendar} The calendar and localisation.
			@throws Error if calendar not found. */
		instance: function(name, language) {
			name = (name || 'gregorian').toLowerCase();
			language = language || '';
			var cal = this._localCals[name + '-' + language];
			if (!cal && this.calendars[name]) {
				cal = new this.calendars[name](language);
				this._localCals[name + '-' + language] = cal;
			}
			if (!cal) {
				throw (this.local.invalidCalendar || this.regionalOptions[''].invalidCalendar).
					replace(/\{0\}/, name);
			}
			return cal;
		},

		/** Create a new date - for today if no other parameters given.
			@memberof Calendars
			@param year {CDate|number} The date to copy or the year for the date.
			@param [month] {number} The month for the date.
			@param [day] {number} The day for the date.
			@param [calendar='gregorian'] {BaseCalendar|string} The underlying calendar or the name of the calendar.
			@param [language=''] {string} The language to use for localisation (default English).
			@return {CDate} The new date.
			@throws Error if an invalid date. */
		newDate: function(year, month, day, calendar, language) {
			calendar = (year != null && year.year ? year.calendar() : (typeof calendar === 'string' ?
				this.instance(calendar, language) : calendar)) || this.instance();
			return calendar.newDate(year, month, day);
		}
	});

	/** Generic date, based on a particular calendar.
		@class CDate
		@param calendar {BaseCalendar} The underlying calendar implementation.
		@param year {number} The year for this date.
		@param month {number} The month for this date.
		@param day {number} The day for this date.
		@return {CDate} The date object.
		@throws Error if an invalid date. */
	function CDate(calendar, year, month, day) {
		this._calendar = calendar;
		this._year = year;
		this._month = month;
		this._day = day;
		if (this._calendar._validateLevel === 0 &&
				!this._calendar.isValid(this._year, this._month, this._day)) {
			throw ($.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate).
				replace(/\{0\}/, this._calendar.local.name);
		}
	}

	/** Pad a numeric value with leading zeroes.
		@private
		@param value {number} The number to format.
		@param length {number} The minimum length.
		@return {string} The formatted number. */
	function pad(value, length) {
		value = '' + value;
		return '000000'.substring(0, length - value.length) + value;
	}

	$.extend(CDate.prototype, {

		/** Create a new date.
			@memberof CDate
			@param [year] {CDate|number} The date to copy or the year for the date (default this date).
			@param [month] {number} The month for the date.
			@param [day] {number} The day for the date.
			@return {CDate} The new date.
			@throws Error if an invalid date. */
		newDate: function(year, month, day) {
			return this._calendar.newDate((year == null ? this : year), month, day);
		},

		/** Set or retrieve the year for this date.
			@memberof CDate
			@param [year] {number} The year for the date.
			@return {number|CDate} The date's year (if no parameter) or the updated date.
			@throws Error if an invalid date. */
		year: function(year) {
			return (arguments.length === 0 ? this._year : this.set(year, 'y'));
		},

		/** Set or retrieve the month for this date.
			@memberof CDate
			@param [month] {number} The month for the date.
			@return {number|CDate} The date's month (if no parameter) or the updated date.
			@throws Error if an invalid date. */
		month: function(month) {
			return (arguments.length === 0 ? this._month : this.set(month, 'm'));
		},

		/** Set or retrieve the day for this date.
			@memberof CDate
			@param [day] {number} The day for the date.
			@return {number|CData} The date's day (if no parameter) or the updated date.
			@throws Error if an invalid date. */
		day: function(day) {
			return (arguments.length === 0 ? this._day : this.set(day, 'd'));
		},

		/** Set new values for this date.
			@memberof CDate
			@param year {number} The year for the date.
			@param month {number} The month for the date.
			@param day {number} The day for the date.
			@return {CDate} The updated date.
			@throws Error if an invalid date. */
		date: function(year, month, day) {
			if (!this._calendar.isValid(year, month, day)) {
				throw ($.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate).
					replace(/\{0\}/, this._calendar.local.name);
			}
			this._year = year;
			this._month = month;
			this._day = day;
			return this;
		},

		/** Determine whether this date is in a leap year.
			@memberof CDate
			@return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not. */
		leapYear: function() {
			return this._calendar.leapYear(this);
		},

		/** Retrieve the epoch designator for this date, e.g. BCE or CE.
			@memberof CDate
			@return {string} The current epoch. */
		epoch: function() {
			return this._calendar.epoch(this);
		},

		/** Format the year, if not a simple sequential number.
			@memberof CDate
			@return {string} The formatted year. */
		formatYear: function() {
			return this._calendar.formatYear(this);
		},

		/** Retrieve the month of the year for this date,
			i.e. the month's position within a numbered year.
			@memberof CDate
			@return {number} The month of the year: <code>minMonth</code> to months per year. */
		monthOfYear: function() {
			return this._calendar.monthOfYear(this);
		},

		/** Retrieve the week of the year for this date.
			@memberof CDate
			@return {number} The week of the year: 1 to weeks per year. */
		weekOfYear: function() {
			return this._calendar.weekOfYear(this);
		},

		/** Retrieve the number of days in the year for this date.
			@memberof CDate
			@return {number} The number of days in this year. */
		daysInYear: function() {
			return this._calendar.daysInYear(this);
		},

		/** Retrieve the day of the year for this date.
			@memberof CDate
			@return {number} The day of the year: 1 to days per year. */
		dayOfYear: function() {
			return this._calendar.dayOfYear(this);
		},

		/** Retrieve the number of days in the month for this date.
			@memberof CDate
			@return {number} The number of days. */
		daysInMonth: function() {
			return this._calendar.daysInMonth(this);
		},

		/** Retrieve the day of the week for this date.
			@memberof CDate
			@return {number} The day of the week: 0 to number of days - 1. */
		dayOfWeek: function() {
			return this._calendar.dayOfWeek(this);
		},

		/** Determine whether this date is a week day.
			@memberof CDate
			@return {boolean} <code>true</code> if a week day, <code>false</code> if not. */
		weekDay: function() {
			return this._calendar.weekDay(this);
		},

		/** Retrieve additional information about this date.
			@memberof CDate
			@return {object} Additional information - contents depends on calendar. */
		extraInfo: function() {
			return this._calendar.extraInfo(this);
		},

		/** Add period(s) to a date.
			@memberof CDate
			@param offset {number} The number of periods to adjust by.
			@param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
			@return {CDate} The updated date. */
		add: function(offset, period) {
			return this._calendar.add(this, offset, period);
		},

		/** Set a portion of the date.
			@memberof CDate
			@param value {number} The new value for the period.
			@param period {string} One of 'y' for year, 'm' for month, 'd' for day.
			@return {CDate} The updated date.
			@throws Error if not a valid date. */
		set: function(value, period) {
			return this._calendar.set(this, value, period);
		},

		/** Compare this date to another date.
			@memberof CDate
			@param date {CDate} The other date.
			@return {number} -1 if this date is before the other date,
					0 if they are equal, or +1 if this date is after the other date. */
		compareTo: function(date) {
			if (this._calendar.name !== date._calendar.name) {
				throw ($.calendars.local.differentCalendars || $.calendars.regionalOptions[''].differentCalendars).
					replace(/\{0\}/, this._calendar.local.name).replace(/\{1\}/, date._calendar.local.name);
			}
			var c = (this._year !== date._year ? this._year - date._year :
				this._month !== date._month ? this.monthOfYear() - date.monthOfYear() :
				this._day - date._day);
			return (c === 0 ? 0 : (c < 0 ? -1 : +1));
		},

		/** Retrieve the calendar backing this date.
			@memberof CDate
			@return {BaseCalendar} The calendar implementation. */
		calendar: function() {
			return this._calendar;
		},

		/** Retrieve the Julian date equivalent for this date,
			i.e. days since January 1, 4713 BCE Greenwich noon.
			@memberof CDate
			@return {number} The equivalent Julian date. */
		toJD: function() {
			return this._calendar.toJD(this);
		},

		/** Create a new date from a Julian date.
			@memberof CDate
			@param jd {number} The Julian date to convert.
			@return {CDate} The equivalent date. */
		fromJD: function(jd) {
			return this._calendar.fromJD(jd);
		},

		/** Convert this date to a standard (Gregorian) JavaScript Date.
			@memberof CDate
			@return {Date} The equivalent JavaScript date. */
		toJSDate: function() {
			return this._calendar.toJSDate(this);
		},

		/** Create a new date from a standard (Gregorian) JavaScript Date.
			@memberof CDate
			@param jsd {Date} The JavaScript date to convert.
			@return {CDate} The equivalent date. */
		fromJSDate: function(jsd) {
			return this._calendar.fromJSDate(jsd);
		},

		/** Convert to a string for display.
			@memberof CDate
			@return {string} This date as a string. */
		toString: function() {
			return (this.year() < 0 ? '-' : '') + pad(Math.abs(this.year()), 4) +
				'-' + pad(this.month(), 2) + '-' + pad(this.day(), 2);
		}
	});

	/** Basic functionality for all calendars.
		Other calendars should extend this:
		<pre>OtherCalendar.prototype = new BaseCalendar;</pre>
		@class BaseCalendar */
	function BaseCalendar() {
		this.shortYearCutoff = '+10';
	}

	$.extend(BaseCalendar.prototype, {
		_validateLevel: 0, // "Stack" to turn validation on/off

		/** Create a new date within this calendar - today if no parameters given.
			@memberof BaseCalendar
			@param year {CDate|number} The date to duplicate or the year for the date.
			@param [month] {number} The month for the date.
			@param [day] {number} The day for the date.
			@return {CDate} The new date.
			@throws Error if not a valid date or a different calendar used. */
		newDate: function(year, month, day) {
			if (year == null) {
				return this.today();
			}
			if (year.year) {
				this._validate(year, month, day,
					$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
				day = year.day();
				month = year.month();
				year = year.year();
			}
			return new CDate(this, year, month, day);
		},

		/** Create a new date for today.
			@memberof BaseCalendar
			@return {CDate} Today's date. */
		today: function() {
			return this.fromJSDate(new Date());
		},

		/** Retrieve the epoch designator for this date.
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {string} The current epoch.
			@throws Error if an invalid year or a different calendar used. */
		epoch: function(year) {
			var date = this._validate(year, this.minMonth, this.minDay,
				$.calendars.local.invalidYear || $.calendars.regionalOptions[''].invalidYear);
			return (date.year() < 0 ? this.local.epochs[0] : this.local.epochs[1]);
		},

		/** Format the year, if not a simple sequential number
			@memberof BaseCalendar
			@param year {CDate|number} The date to format or the year to format.
			@return {string} The formatted year.
			@throws Error if an invalid year or a different calendar used. */
		formatYear: function(year) {
			var date = this._validate(year, this.minMonth, this.minDay,
				$.calendars.local.invalidYear || $.calendars.regionalOptions[''].invalidYear);
			return (date.year() < 0 ? '-' : '') + pad(Math.abs(date.year()), 4)
		},

		/** Retrieve the number of months in a year.
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {number} The number of months.
			@throws Error if an invalid year or a different calendar used. */
		monthsInYear: function(year) {
			this._validate(year, this.minMonth, this.minDay,
				$.calendars.local.invalidYear || $.calendars.regionalOptions[''].invalidYear);
			return 12;
		},

		/** Calculate the month's ordinal position within the year -
			for those calendars that don't start at month 1!
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param month {number} The month to examine.
			@return {number} The ordinal position, starting from <code>minMonth</code>.
			@throws Error if an invalid year/month or a different calendar used. */
		monthOfYear: function(year, month) {
			var date = this._validate(year, month, this.minDay,
				$.calendars.local.invalidMonth || $.calendars.regionalOptions[''].invalidMonth);
			return (date.month() + this.monthsInYear(date) - this.firstMonth) %
				this.monthsInYear(date) + this.minMonth;
		},

		/** Calculate actual month from ordinal position, starting from minMonth.
			@memberof BaseCalendar
			@param year {number} The year to examine.
			@param ord {number} The month's ordinal position.
			@return {number} The month's number.
			@throws Error if an invalid year/month. */
		fromMonthOfYear: function(year, ord) {
			var m = (ord + this.firstMonth - 2 * this.minMonth) %
				this.monthsInYear(year) + this.minMonth;
			this._validate(year, m, this.minDay,
				$.calendars.local.invalidMonth || $.calendars.regionalOptions[''].invalidMonth);
			return m;
		},

		/** Retrieve the number of days in a year.
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {number} The number of days.
			@throws Error if an invalid year or a different calendar used. */
		daysInYear: function(year) {
			var date = this._validate(year, this.minMonth, this.minDay,
				$.calendars.local.invalidYear || $.calendars.regionalOptions[''].invalidYear);
			return (this.leapYear(date) ? 366 : 365);
		},

		/** Retrieve the day of the year for a date.
			@memberof BaseCalendar
			@param year {CDate|number} The date to convert or the year to convert.
			@param [month] {number} The month to convert.
			@param [day] {number} The day to convert.
			@return {number} The day of the year.
			@throws Error if an invalid date or a different calendar used. */
		dayOfYear: function(year, month, day) {
			var date = this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			return date.toJD() - this.newDate(date.year(),
				this.fromMonthOfYear(date.year(), this.minMonth), this.minDay).toJD() + 1;
		},

		/** Retrieve the number of days in a week.
			@memberof BaseCalendar
			@return {number} The number of days. */
		daysInWeek: function() {
			return 7;
		},

		/** Retrieve the day of the week for a date.
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {number} The day of the week: 0 to number of days - 1.
			@throws Error if an invalid date or a different calendar used. */
		dayOfWeek: function(year, month, day) {
			var date = this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			return (Math.floor(this.toJD(date)) + 2) % this.daysInWeek();
		},

		/** Retrieve additional information about a date.
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {object} Additional information - contents depends on calendar.
			@throws Error if an invalid date or a different calendar used. */
		extraInfo: function(year, month, day) {
			this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			return {};
		},

		/** Add period(s) to a date.
			Cater for no year zero.
			@memberof BaseCalendar
			@param date {CDate} The starting date.
			@param offset {number} The number of periods to adjust by.
			@param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
			@return {CDate} The updated date.
			@throws Error if a different calendar used. */
		add: function(date, offset, period) {
			this._validate(date, this.minMonth, this.minDay,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			return this._correctAdd(date, this._add(date, offset, period), offset, period);
		},

		/** Add period(s) to a date.
			@memberof BaseCalendar
			@private
			@param date {CDate} The starting date.
			@param offset {number} The number of periods to adjust by.
			@param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
			@return {CDate} The updated date. */
		_add: function(date, offset, period) {
			this._validateLevel++;
			if (period === 'd' || period === 'w') {
				var jd = date.toJD() + offset * (period === 'w' ? this.daysInWeek() : 1);
				var d = date.calendar().fromJD(jd);
				this._validateLevel--;
				return [d.year(), d.month(), d.day()];
			}
			try {
				var y = date.year() + (period === 'y' ? offset : 0);
				var m = date.monthOfYear() + (period === 'm' ? offset : 0);
				var d = date.day();// + (period === 'd' ? offset : 0) +
					//(period === 'w' ? offset * this.daysInWeek() : 0);
				var resyncYearMonth = function(calendar) {
					while (m < calendar.minMonth) {
						y--;
						m += calendar.monthsInYear(y);
					}
					var yearMonths = calendar.monthsInYear(y);
					while (m > yearMonths - 1 + calendar.minMonth) {
						y++;
						m -= yearMonths;
						yearMonths = calendar.monthsInYear(y);
					}
				};
				if (period === 'y') {
					if (date.month() !== this.fromMonthOfYear(y, m)) { // Hebrew
						m = this.newDate(y, date.month(), this.minDay).monthOfYear();
					}
					m = Math.min(m, this.monthsInYear(y));
					d = Math.min(d, this.daysInMonth(y, this.fromMonthOfYear(y, m)));
				}
				else if (period === 'm') {
					resyncYearMonth(this);
					d = Math.min(d, this.daysInMonth(y, this.fromMonthOfYear(y, m)));
				}
				var ymd = [y, this.fromMonthOfYear(y, m), d];
				this._validateLevel--;
				return ymd;
			}
			catch (e) {
				this._validateLevel--;
				throw e;
			}
		},

		/** Correct a candidate date after adding period(s) to a date.
			Handle no year zero if necessary.
			@memberof BaseCalendar
			@private
			@param date {CDate} The starting date.
			@param ymd {number[]} The added date.
			@param offset {number} The number of periods to adjust by.
			@param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
			@return {CDate} The updated date. */
		_correctAdd: function(date, ymd, offset, period) {
			if (!this.hasYearZero && (period === 'y' || period === 'm')) {
				if (ymd[0] === 0 || // In year zero
						(date.year() > 0) !== (ymd[0] > 0)) { // Crossed year zero
					var adj = {y: [1, 1, 'y'], m: [1, this.monthsInYear(-1), 'm'],
						w: [this.daysInWeek(), this.daysInYear(-1), 'd'],
						d: [1, this.daysInYear(-1), 'd']}[period];
					var dir = (offset < 0 ? -1 : +1);
					ymd = this._add(date, offset * adj[0] + dir * adj[1], adj[2]);
				}
			}
			return date.date(ymd[0], ymd[1], ymd[2]);
		},

		/** Set a portion of the date.
			@memberof BaseCalendar
			@param date {CDate} The starting date.
			@param value {number} The new value for the period.
			@param period {string} One of 'y' for year, 'm' for month, 'd' for day.
			@return {CDate} The updated date.
			@throws Error if an invalid date or a different calendar used. */
		set: function(date, value, period) {
			this._validate(date, this.minMonth, this.minDay,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			var y = (period === 'y' ? value : date.year());
			var m = (period === 'm' ? value : date.month());
			var d = (period === 'd' ? value : date.day());
			if (period === 'y' || period === 'm') {
				d = Math.min(d, this.daysInMonth(y, m));
			}
			return date.date(y, m, d);
		},

		/** Determine whether a date is valid for this calendar.
			@memberof BaseCalendar
			@param year {number} The year to examine.
			@param month {number} The month to examine.
			@param day {number} The day to examine.
			@return {boolean} <code>true</code> if a valid date, <code>false</code> if not. */
		isValid: function(year, month, day) {
			this._validateLevel++;
			var valid = (this.hasYearZero || year !== 0);
			if (valid) {
				var date = this.newDate(year, month, this.minDay);
				valid = (month >= this.minMonth && month - this.minMonth < this.monthsInYear(date)) &&
					(day >= this.minDay && day - this.minDay < this.daysInMonth(date));
			}
			this._validateLevel--;
			return valid;
		},

		/** Convert the date to a standard (Gregorian) JavaScript Date.
			@memberof BaseCalendar
			@param year {CDate|number} The date to convert or the year to convert.
			@param [month] {number} The month to convert.
			@param [day] {number} The day to convert.
			@return {Date} The equivalent JavaScript date.
			@throws Error if an invalid date or a different calendar used. */
		toJSDate: function(year, month, day) {
			var date = this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			return $.calendars.instance().fromJD(this.toJD(date)).toJSDate();
		},

		/** Convert the date from a standard (Gregorian) JavaScript Date.
			@memberof BaseCalendar
			@param jsd {Date} The JavaScript date.
			@return {CDate} The equivalent calendar date. */
		fromJSDate: function(jsd) {
			return this.fromJD($.calendars.instance().fromJSDate(jsd).toJD());
		},

		/** Check that a candidate date is from the same calendar and is valid.
			@memberof BaseCalendar
			@private
			@param year {CDate|number} The date to validate or the year to validate.
			@param [month] {number} The month to validate.
			@param [day] {number} The day to validate.
			@param error {string} Rrror message if invalid.
			@throws Error if different calendars used or invalid date. */
		_validate: function(year, month, day, error) {
			if (year.year) {
				if (this._validateLevel === 0 && this.name !== year.calendar().name) {
					throw ($.calendars.local.differentCalendars || $.calendars.regionalOptions[''].differentCalendars).
						replace(/\{0\}/, this.local.name).replace(/\{1\}/, year.calendar().local.name);
				}
				return year;
			}
			try {
				this._validateLevel++;
				if (this._validateLevel === 1 && !this.isValid(year, month, day)) {
					throw error.replace(/\{0\}/, this.local.name);
				}
				var date = this.newDate(year, month, day);
				this._validateLevel--;
				return date;
			}
			catch (e) {
				this._validateLevel--;
				throw e;
			}
		}
	});

	/** Implementation of the Proleptic Gregorian Calendar.
		See <a href=":http://en.wikipedia.org/wiki/Gregorian_calendar">http://en.wikipedia.org/wiki/Gregorian_calendar</a>
		and <a href="http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar">http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar</a>.
		@class GregorianCalendar
		@augments BaseCalendar
		@param [language=''] {string} The language code (default English) for localisation. */
	function GregorianCalendar(language) {
		this.local = this.regionalOptions[language] || this.regionalOptions[''];
	}

	GregorianCalendar.prototype = new BaseCalendar;

	$.extend(GregorianCalendar.prototype, {
		/** The calendar name.
			@memberof GregorianCalendar */
		name: 'Gregorian',
		 /** Julian date of start of Gregorian epoch: 1 January 0001 CE.
			@memberof GregorianCalendar */
		jdEpoch: 1721425.5,
		 /** Days per month in a common year.
			@memberof GregorianCalendar */
		daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
		 /** <code>true</code> if has a year zero, <code>false</code> if not.
			@memberof GregorianCalendar */
		hasYearZero: false,
		/** The minimum month number.
			@memberof GregorianCalendar */
		minMonth: 1,
		/** The first month in the year.
			@memberof GregorianCalendar */
		firstMonth: 1,
		 /** The minimum day number.
			@memberof GregorianCalendar */
		minDay: 1,

		/** Localisations for the plugin.
			Entries are objects indexed by the language code ('' being the default US/English).
			Each object has the following attributes.
			@memberof GregorianCalendar
			@property name {string} The calendar name.
			@property epochs {string[]} The epoch names.
			@property monthNames {string[]} The long names of the months of the year.
			@property monthNamesShort {string[]} The short names of the months of the year.
			@property dayNames {string[]} The long names of the days of the week.
			@property dayNamesShort {string[]} The short names of the days of the week.
			@property dayNamesMin {string[]} The minimal names of the days of the week.
			@property dateFormat {string} The date format for this calendar.
					See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
			@property firstDay {number} The number of the first day of the week, starting at 0.
			@property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
		regionalOptions: { // Localisations
			'': {
				name: 'Gregorian',
				epochs: ['BCE', 'CE'],
				monthNames: ['January', 'February', 'March', 'April', 'May', 'June',
				'July', 'August', 'September', 'October', 'November', 'December'],
				monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
				dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
				dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
				dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
				dateFormat: 'mm/dd/yyyy',
				firstDay: 0,
				isRTL: false
			}
		},
		
		/** Determine whether this date is in a leap year.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
			@throws Error if an invalid year or a different calendar used. */
		leapYear: function(year) {
			var date = this._validate(year, this.minMonth, this.minDay,
				$.calendars.local.invalidYear || $.calendars.regionalOptions[''].invalidYear);
			var year = date.year() + (date.year() < 0 ? 1 : 0); // No year zero
			return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
		},

		/** Determine the week of the year for a date - ISO 8601.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {number} The week of the year, starting from 1.
			@throws Error if an invalid date or a different calendar used. */
		weekOfYear: function(year, month, day) {
			// Find Thursday of this week starting on Monday
			var checkDate = this.newDate(year, month, day);
			checkDate.add(4 - (checkDate.dayOfWeek() || 7), 'd');
			return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
		},

		/** Retrieve the number of days in a month.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to examine or the year of the month.
			@param [month] {number} The month.
			@return {number} The number of days in this month.
			@throws Error if an invalid month/year or a different calendar used. */
		daysInMonth: function(year, month) {
			var date = this._validate(year, month, this.minDay,
				$.calendars.local.invalidMonth || $.calendars.regionalOptions[''].invalidMonth);
			return this.daysPerMonth[date.month() - 1] +
				(date.month() === 2 && this.leapYear(date.year()) ? 1 : 0);
		},

		/** Determine whether this date is a week day.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {boolean} <code>true</code> if a week day, <code>false</code> if not.
			@throws Error if an invalid date or a different calendar used. */
		weekDay: function(year, month, day) {
			return (this.dayOfWeek(year, month, day) || 7) < 6;
		},

		/** Retrieve the Julian date equivalent for this date,
			i.e. days since January 1, 4713 BCE Greenwich noon.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to convert or the year to convert.
			@param [month] {number} The month to convert.
			@param [day] {number} The day to convert.
			@return {number} The equivalent Julian date.
			@throws Error if an invalid date or a different calendar used. */
		toJD: function(year, month, day) {
			var date = this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			year = date.year();
			month = date.month();
			day = date.day();
			if (year < 0) { year++; } // No year zero
			// Jean Meeus algorithm, "Astronomical Algorithms", 1991
			if (month < 3) {
				month += 12;
				year--;
			}
			var a = Math.floor(year / 100);
			var b = 2 - a + Math.floor(a / 4);
			return Math.floor(365.25 * (year + 4716)) +
				Math.floor(30.6001 * (month + 1)) + day + b - 1524.5;
		},

		/** Create a new date from a Julian date.
			@memberof GregorianCalendar
			@param jd {number} The Julian date to convert.
			@return {CDate} The equivalent date. */
		fromJD: function(jd) {
			// Jean Meeus algorithm, "Astronomical Algorithms", 1991
			var z = Math.floor(jd + 0.5);
			var a = Math.floor((z - 1867216.25) / 36524.25);
			a = z + 1 + a - Math.floor(a / 4);
			var b = a + 1524;
			var c = Math.floor((b - 122.1) / 365.25);
			var d = Math.floor(365.25 * c);
			var e = Math.floor((b - d) / 30.6001);
			var day = b - d - Math.floor(e * 30.6001);
			var month = e - (e > 13.5 ? 13 : 1);
			var year = c - (month > 2.5 ? 4716 : 4715);
			if (year <= 0) { year--; } // No year zero
			return this.newDate(year, month, day);
		},

		/** Convert this date to a standard (Gregorian) JavaScript Date.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to convert or the year to convert.
			@param [month] {number} The month to convert.
			@param [day] {number} The day to convert.
			@return {Date} The equivalent JavaScript date.
			@throws Error if an invalid date or a different calendar used. */
		toJSDate: function(year, month, day) {
			var date = this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			var jsd = new Date(date.year(), date.month() - 1, date.day());
			jsd.setHours(0);
			jsd.setMinutes(0);
			jsd.setSeconds(0);
			jsd.setMilliseconds(0);
			// Hours may be non-zero on daylight saving cut-over:
			// > 12 when midnight changeover, but then cannot generate
			// midnight datetime, so jump to 1AM, otherwise reset.
			jsd.setHours(jsd.getHours() > 12 ? jsd.getHours() + 2 : 0);
			return jsd;
		},

		/** Create a new date from a standard (Gregorian) JavaScript Date.
			@memberof GregorianCalendar
			@param jsd {Date} The JavaScript date to convert.
			@return {CDate} The equivalent date. */
		fromJSDate: function(jsd) {
			return this.newDate(jsd.getFullYear(), jsd.getMonth() + 1, jsd.getDate());
		}
	});

	// Singleton manager
	$.calendars = new Calendars();

	// Date template
	$.calendars.cdate = CDate;

	// Base calendar template
	$.calendars.baseCalendar = BaseCalendar;

	// Gregorian calendar implementation
	$.calendars.calendars.gregorian = GregorianCalendar;

})(jQuery);
/* http://keith-wood.name/calendars.html
   Calendars extras for jQuery v2.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

	$.extend($.calendars.regionalOptions[''], {
		invalidArguments: 'Invalid arguments',
		invalidFormat: 'Cannot format a date from another calendar',
		missingNumberAt: 'Missing number at position {0}',
		unknownNameAt: 'Unknown name at position {0}',
		unexpectedLiteralAt: 'Unexpected literal at position {0}',
		unexpectedText: 'Additional text found at end'
	});
	$.calendars.local = $.calendars.regionalOptions[''];

	$.extend($.calendars.cdate.prototype, {

		/** Format this date.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof CDate
			@param [format] {string} The date format to use (see <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a>).
			@return {string} The formatted date. */
		formatDate: function(format) {
			return this._calendar.formatDate(format || '', this);
		}
	});

	$.extend($.calendars.baseCalendar.prototype, {

		UNIX_EPOCH: $.calendars.instance().newDate(1970, 1, 1).toJD(),
		SECS_PER_DAY: 24 * 60 * 60,
		TICKS_EPOCH: $.calendars.instance().jdEpoch, // 1 January 0001 CE
		TICKS_PER_DAY: 24 * 60 * 60 * 10000000,

		/** Date form for ATOM (RFC 3339/ISO 8601).
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		ATOM: 'yyyy-mm-dd',
		/** Date form for cookies.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		COOKIE: 'D, dd M yyyy',
		/** Date form for full date.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		FULL: 'DD, MM d, yyyy',
		/** Date form for ISO 8601.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		ISO_8601: 'yyyy-mm-dd',
		/** Date form for Julian date.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		JULIAN: 'J',
		/** Date form for RFC 822.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RFC_822: 'D, d M yy',
		/** Date form for RFC 850.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RFC_850: 'DD, dd-M-yy',
		/** Date form for RFC 1036.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RFC_1036: 'D, d M yy',
		/** Date form for RFC 1123.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RFC_1123: 'D, d M yyyy',
		/** Date form for RFC 2822.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RFC_2822: 'D, d M yyyy',
		/** Date form for RSS (RFC 822).
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RSS: 'D, d M yy',
		/** Date form for Windows ticks.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		TICKS: '!',
		/** Date form for Unix timestamp.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		TIMESTAMP: '@',
		/** Date form for W3c (ISO 8601).
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		W3C: 'yyyy-mm-dd',

		/** Format a date object into a string value.
			The format can be combinations of the following:
			<ul>
			<li>d  - day of month (no leading zero)</li>
			<li>dd - day of month (two digit)</li>
			<li>o  - day of year (no leading zeros)</li>
			<li>oo - day of year (three digit)</li>
			<li>D  - day name short</li>
			<li>DD - day name long</li>
			<li>w  - week of year (no leading zero)</li>
			<li>ww - week of year (two digit)</li>
			<li>m  - month of year (no leading zero)</li>
			<li>mm - month of year (two digit)</li>
			<li>M  - month name short</li>
			<li>MM - month name long</li>
			<li>yy - year (two digit)</li>
			<li>yyyy - year (four digit)</li>
			<li>YYYY - formatted year</li>
			<li>J  - Julian date (days since January 1, 4713 BCE Greenwich noon)</li>
			<li>@  - Unix timestamp (s since 01/01/1970)</li>
			<li>!  - Windows ticks (100ns since 01/01/0001)</li>
			<li>'...' - literal text</li>
			<li>'' - single quote</li>
			</ul>
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar
			@param [format] {string} The desired format of the date (defaults to calendar format).
			@param date {CDate} The date value to format.
			@param [settings] {object} Addition options, whose attributes include:
			@property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
			@property [dayNames] {string[]} Names of the days from Sunday.
			@property [monthNamesShort] {string[]} Abbreviated names of the months.
			@property [monthNames] {string[]} Names of the months.
			@property [calculateWeek] {CalendarsPickerCalculateWeek} Function that determines week of the year.
			@return {string} The date in the above format.
			@throws Errors if the date is from a different calendar. */
		formatDate: function(format, date, settings) {
			if (typeof format !== 'string') {
				settings = date;
				date = format;
				format = '';
			}
			if (!date) {
				return '';
			}
			if (date.calendar() !== this) {
				throw $.calendars.local.invalidFormat || $.calendars.regionalOptions[''].invalidFormat;
			}
			format = format || this.local.dateFormat;
			settings = settings || {};
			var dayNamesShort = settings.dayNamesShort || this.local.dayNamesShort;
			var dayNames = settings.dayNames || this.local.dayNames;
			var monthNamesShort = settings.monthNamesShort || this.local.monthNamesShort;
			var monthNames = settings.monthNames || this.local.monthNames;
			var calculateWeek = settings.calculateWeek || this.local.calculateWeek;
			// Check whether a format character is doubled
			var doubled = function(match, step) {
				var matches = 1;
				while (iFormat + matches < format.length && format.charAt(iFormat + matches) === match) {
					matches++;
				}
				iFormat += matches - 1;
				return Math.floor(matches / (step || 1)) > 1;
			};
			// Format a number, with leading zeroes if necessary
			var formatNumber = function(match, value, len, step) {
				var num = '' + value;
				if (doubled(match, step)) {
					while (num.length < len) {
						num = '0' + num;
					}
				}
				return num;
			};
			// Format a name, short or long as requested
			var formatName = function(match, value, shortNames, longNames) {
				return (doubled(match) ? longNames[value] : shortNames[value]);
			};
			var output = '';
			var literal = false;
			for (var iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !doubled("'")) {
						literal = false;
					}
					else {
						output += format.charAt(iFormat);
					}
				}
				else {
					switch (format.charAt(iFormat)) {
						case 'd': output += formatNumber('d', date.day(), 2); break;
						case 'D': output += formatName('D', date.dayOfWeek(),
							dayNamesShort, dayNames); break;
						case 'o': output += formatNumber('o', date.dayOfYear(), 3); break;
						case 'w': output += formatNumber('w', date.weekOfYear(), 2); break;
						case 'm': output += formatNumber('m', date.month(), 2); break;
						case 'M': output += formatName('M', date.month() - this.minMonth,
							monthNamesShort, monthNames); break;
						case 'y':
							output += (doubled('y', 2) ? date.year() :
								(date.year() % 100 < 10 ? '0' : '') + date.year() % 100);
							break;
						case 'Y':
							doubled('Y', 2);
							output += date.formatYear();
							break;
						case 'J': output += date.toJD(); break;
						case '@': output += (date.toJD() - this.UNIX_EPOCH) * this.SECS_PER_DAY; break;
						case '!': output += (date.toJD() - this.TICKS_EPOCH) * this.TICKS_PER_DAY; break;
						case "'":
							if (doubled("'")) {
								output += "'";
							}
							else {
								literal = true;
							}
							break;
						default:
							output += format.charAt(iFormat);
					}
				}
			}
			return output;
		},

		/** Parse a string value into a date object.
			See <a href="#formatDate"><code>formatDate</code></a> for the possible formats, plus:
			<ul>
			<li>* - ignore rest of string</li>
			</ul>
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar
			@param format {string} The expected format of the date ('' for default calendar format).
			@param value {string} The date in the above format.
			@param [settings] {object} Additional options whose attributes include:
			@property [shortYearCutoff] {number} The cutoff year for determining the century.
			@property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
			@property [dayNames] {string[]} Names of the days from Sunday.
			@property [monthNamesShort] {string[]} Abbreviated names of the months.
			@property [monthNames] {string[]} Names of the months.
			@return {CDate} The extracted date value or <code>null</code> if value is blank.
			@throws Errors if the format and/or value are missing,
					if the value doesn't match the format, or if the date is invalid. */
		parseDate: function(format, value, settings) {
			if (value == null) {
				throw $.calendars.local.invalidArguments || $.calendars.regionalOptions[''].invalidArguments;
			}
			value = (typeof value === 'object' ? value.toString() : value + '');
			if (value === '') {
				return null;
			}
			format = format || this.local.dateFormat;
			settings = settings || {};
			var shortYearCutoff = settings.shortYearCutoff || this.shortYearCutoff;
			shortYearCutoff = (typeof shortYearCutoff !== 'string' ? shortYearCutoff :
				this.today().year() % 100 + parseInt(shortYearCutoff, 10));
			var dayNamesShort = settings.dayNamesShort || this.local.dayNamesShort;
			var dayNames = settings.dayNames || this.local.dayNames;
			var monthNamesShort = settings.monthNamesShort || this.local.monthNamesShort;
			var monthNames = settings.monthNames || this.local.monthNames;
			var jd = -1;
			var year = -1;
			var month = -1;
			var day = -1;
			var doy = -1;
			var shortYear = false;
			var literal = false;
			// Check whether a format character is doubled
			var doubled = function(match, step) {
				var matches = 1;
				while (iFormat + matches < format.length && format.charAt(iFormat + matches) === match) {
					matches++;
				}
				iFormat += matches - 1;
				return Math.floor(matches / (step || 1)) > 1;
			};
			// Extract a number from the string value
			var getNumber = function(match, step) {
				var isDoubled = doubled(match, step);
				var size = [2, 3, isDoubled ? 4 : 2, isDoubled ? 4 : 2, 10, 11, 20]['oyYJ@!'.indexOf(match) + 1];
				var digits = new RegExp('^-?\\d{1,' + size + '}');
				var num = value.substring(iValue).match(digits);
				if (!num) {
					throw ($.calendars.local.missingNumberAt || $.calendars.regionalOptions[''].missingNumberAt).
						replace(/\{0\}/, iValue);
				}
				iValue += num[0].length;
				return parseInt(num[0], 10);
			};
			// Extract a name from the string value and convert to an index
			var calendar = this;
			var getName = function(match, shortNames, longNames, step) {
				var names = (doubled(match, step) ? longNames : shortNames);
				for (var i = 0; i < names.length; i++) {
					if (value.substr(iValue, names[i].length).toLowerCase() === names[i].toLowerCase()) {
						iValue += names[i].length;
						return i + calendar.minMonth;
					}
				}
				throw ($.calendars.local.unknownNameAt || $.calendars.regionalOptions[''].unknownNameAt).
					replace(/\{0\}/, iValue);
			};
			// Confirm that a literal character matches the string value
			var checkLiteral = function() {
				if (value.charAt(iValue) !== format.charAt(iFormat)) {
					throw ($.calendars.local.unexpectedLiteralAt ||
						$.calendars.regionalOptions[''].unexpectedLiteralAt).replace(/\{0\}/, iValue);
				}
				iValue++;
			};
			var iValue = 0;
			for (var iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !doubled("'")) {
						literal = false;
					}
					else {
						checkLiteral();
					}
				}
				else {
					switch (format.charAt(iFormat)) {
						case 'd': day = getNumber('d'); break;
						case 'D': getName('D', dayNamesShort, dayNames); break;
						case 'o': doy = getNumber('o'); break;
						case 'w': getNumber('w'); break;
						case 'm': month = getNumber('m'); break;
						case 'M': month = getName('M', monthNamesShort, monthNames); break;
						case 'y':
							var iSave = iFormat;
							shortYear = !doubled('y', 2);
							iFormat = iSave;
							year = getNumber('y', 2);
							break;
						case 'Y': year = getNumber('Y', 2); break;
						case 'J':
							jd = getNumber('J') + 0.5;
							if (value.charAt(iValue) === '.') {
								iValue++;
								getNumber('J');
							}
							break;
						case '@': jd = getNumber('@') / this.SECS_PER_DAY + this.UNIX_EPOCH; break;
						case '!': jd = getNumber('!') / this.TICKS_PER_DAY + this.TICKS_EPOCH; break;
						case '*': iValue = value.length; break;
						case "'":
							if (doubled("'")) {
								checkLiteral();
							}
							else {
								literal = true;
							}
							break;
						default: checkLiteral();
					}
				}
			}
			if (iValue < value.length) {
				throw $.calendars.local.unexpectedText || $.calendars.regionalOptions[''].unexpectedText;
			}
			if (year === -1) {
				year = this.today().year();
			}
			else if (year < 100 && shortYear) {
				year += (shortYearCutoff === -1 ? 1900 : this.today().year() -
					this.today().year() % 100 - (year <= shortYearCutoff ? 0 : 100));
			}
			if (doy > -1) {
				month = 1;
				day = doy;
				for (var dim = this.daysInMonth(year, month); day > dim; dim = this.daysInMonth(year, month)) {
					month++;
					day -= dim;
				}
			}
			return (jd > -1 ? this.fromJD(jd) : this.newDate(year, month, day));
		},

		/** A date may be specified as an exact value or a relative one.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar
			@param dateSpec {CDate|number|string} The date as an object or string in the given format or
					an offset - numeric days from today, or string amounts and periods, e.g. '+1m +2w'.
			@param defaultDate {CDate} The date to use if no other supplied, may be <code>null</code>.
			@param currentDate {CDate} The current date as a possible basis for relative dates,
					if <code>null</code> today is used (optional)
			@param [dateFormat] {string} The expected date format - see <a href="#formatDate"><code>formatDate</code></a>.
			@param [settings] {object} Additional options whose attributes include:
			@property [shortYearCutoff] {number} The cutoff year for determining the century.
			@property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
			@property [dayNames] {string[]} Names of the days from Sunday.
			@property [monthNamesShort] {string[]} Abbreviated names of the months.
			@property [monthNames] {string[]} Names of the months.
			@return {CDate} The decoded date. */
		determineDate: function(dateSpec, defaultDate, currentDate, dateFormat, settings) {
			if (currentDate && typeof currentDate !== 'object') {
				settings = dateFormat;
				dateFormat = currentDate;
				currentDate = null;
			}
			if (typeof dateFormat !== 'string') {
				settings = dateFormat;
				dateFormat = '';
			}
			var calendar = this;
			var offsetString = function(offset) {
				try {
					return calendar.parseDate(dateFormat, offset, settings);
				}
				catch (e) {
					// Ignore
				}
				offset = offset.toLowerCase();
				var date = (offset.match(/^c/) && currentDate ?
					currentDate.newDate() : null) || calendar.today();
				var pattern = /([+-]?[0-9]+)\s*(d|w|m|y)?/g;
				var matches = pattern.exec(offset);
				while (matches) {
					date.add(parseInt(matches[1], 10), matches[2] || 'd');
					matches = pattern.exec(offset);
				}
				return date;
			};
			defaultDate = (defaultDate ? defaultDate.newDate() : null);
			dateSpec = (dateSpec == null ? defaultDate :
				(typeof dateSpec === 'string' ? offsetString(dateSpec) : (typeof dateSpec === 'number' ?
				(isNaN(dateSpec) || dateSpec === Infinity || dateSpec === -Infinity ? defaultDate :
				calendar.today().add(dateSpec, 'd')) : calendar.newDate(dateSpec))));
			return dateSpec;
		}
	});

})(jQuery);
/* http://keith-wood.name/calendars.html
   Calendars date picker for jQuery v2.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

	var pluginName = 'calendarsPicker';


	/** Create the calendars datepicker plugin.
		<p>Sets an input field to popup a calendar for date entry,
			or a <code>div</code> or <code>span</code> to show an inline calendar.</p>
		<p>Expects HTML like:</p>
		<pre>&lt;input type="text"> or &lt;div>&lt;/div></pre>
		<p>Provide inline configuration like:</p>
		<pre>&lt;input type="text" data-calendarsPicker="name: 'value'"/></pre>
	 	@class CalendarsPicker
		@augments JQPlugin
		@example $(selector).calendarsPicker()
 $(selector).calendarsPicker({minDate: 0, maxDate: '+1m +1w'}) */
	$.JQPlugin.createPlugin({
	
		/** The name of the plugin.
			@memberof CalendarsPicker */
		name: pluginName,
		
		/** Default template for generating a datepicker.
			Insert anywhere:
			<ul>
			<li>'{l10n:name}' to insert localised value for name,</li>
			<li>'{link:name}' to insert a link trigger for command name,</li>
			<li>'{button:name}' to insert a button trigger for command name,</li>
			<li>'{popup:start}...{popup:end}' to mark a section for inclusion in a popup datepicker only,</li>
			<li>'{inline:start}...{inline:end}' to mark a section for inclusion in an inline datepicker only.</li>
			</ul>
			@memberof CalendarsPicker
			@property picker {string} Overall structure: '{months}' to insert calendar months.
			@property monthRow {string} One row of months: '{months}' to insert calendar months.
			@property month {string} A single month: '{monthHeader<em>:dateFormat</em>}' to insert the month header -
						<em>dateFormat</em> is optional and defaults to 'MM yyyy',
						'{weekHeader}' to insert a week header, '{weeks}' to insert the month's weeks.
			@property weekHeader {string} A week header: '{days}' to insert individual day names.
			@property dayHeader {string} Individual day header: '{day}' to insert day name.
			@property week {string} One week of the month: '{days}' to insert the week's days,
						'{weekOfYear}' to insert week of year.
			@property day {string} An individual day: '{day}' to insert day value.
			@property monthSelector {string} jQuery selector, relative to picker, for a single month.
			@property daySelector {string} jQuery selector, relative to picker, for individual days.
			@property rtlClass {string} Class for right-to-left (RTL) languages.
			@property multiClass {string} Class for multi-month datepickers.
			@property defaultClass {string} Class for selectable dates.
			@property selectedClass {string} Class for currently selected dates.
			@property highlightedClass {string} Class for highlighted dates.
			@property todayClass {string} Class for today.
			@property otherMonthClass {string} Class for days from other months.
			@property weekendClass {string} Class for days on weekends.
			@property commandClass {string} Class prefix for commands.
			@property commandButtonClass {string} Extra class(es) for commands that are buttons.
			@property commandLinkClass {string} Extra class(es) for commands that are links.
			@property disabledClass {string} Class for disabled commands. */
		defaultRenderer: {
			picker: '<div class="calendars">' +
			'<div class="calendars-nav">{link:prev}{link:today}{link:next}</div>{months}' +
			'{popup:start}<div class="calendars-ctrl">{link:clear}{link:close}</div>{popup:end}' +
			'<div class="calendars-clear-fix"></div></div>',
			monthRow: '<div class="calendars-month-row">{months}</div>',
			month: '<div class="calendars-month"><div class="calendars-month-header">{monthHeader}</div>' +
			'<table><thead>{weekHeader}</thead><tbody>{weeks}</tbody></table></div>',
			weekHeader: '<tr>{days}</tr>',
			dayHeader: '<th>{day}</th>',
			week: '<tr>{days}</tr>',
			day: '<td>{day}</td>',
			monthSelector: '.calendars-month',
			daySelector: 'td',
			rtlClass: 'calendars-rtl',
			multiClass: 'calendars-multi',
			defaultClass: '',
			selectedClass: 'calendars-selected',
			highlightedClass: 'calendars-highlight',
			todayClass: 'calendars-today',
			otherMonthClass: 'calendars-other-month',
			weekendClass: 'calendars-weekend',
			commandClass: 'calendars-cmd',
			commandButtonClass: '',
			commandLinkClass: '',
			disabledClass: 'calendars-disabled'
		},
	
		/** Command actions that may be added to a layout by name.
			<ul>
			<li>prev - Show the previous month (based on <code>monthsToStep</code> option) - <em>PageUp</em></li>
			<li>prevJump - Show the previous year (based on <code>monthsToJump</code> option) - <em>Ctrl+PageUp</em></li>
			<li>next - Show the next month (based on <code>monthsToStep</code> option) - <em>PageDown</em></li>
			<li>nextJump - Show the next year (based on <code>monthsToJump</code> option) - <em>Ctrl+PageDown</em></li>
			<li>current - Show the currently selected month or today's if none selected - <em>Ctrl+Home</em></li>
			<li>today - Show today's month - <em>Ctrl+Home</em></li>
			<li>clear - Erase the date and close the datepicker popup - <em>Ctrl+End</em></li>
			<li>close - Close the datepicker popup - <em>Esc</em></li>
			<li>prevWeek - Move the cursor to the previous week - <em>Ctrl+Up</em></li>
			<li>prevDay - Move the cursor to the previous day - <em>Ctrl+Left</em></li>
			<li>nextDay - Move the cursor to the next day - <em>Ctrl+Right</em></li>
			<li>nextWeek - Move the cursor to the next week - <em>Ctrl+Down</em></li>
			</ul>
			The command name is the key name and is used to add the command to a layout
			with '{button:name}' or '{link:name}'. Each has the following attributes.
			@memberof CalendarsPicker
			@property text {string} The field in the regional settings for the displayed text.
			@property status {string} The field in the regional settings for the status text.
			@property keystroke {object} The keystroke to trigger the action, with attributes:
				<code>keyCode</code> {number} the code for the keystroke,
				<code>ctrlKey</code> {boolean} <code>true</code> if <em>Ctrl</em> is required,
				<code>altKey</code> {boolean} <code>true</code> if <em>Alt</em> is required,
				<code>shiftKey</code> {boolean} <code>true</code> if <em>Shift</em> is required.
			@property enabled {CalendarsPickerCommandEnabled} The function that indicates the command is enabled.
			@property date {CalendarsPickerCommandDate} The function to get the date associated with this action.
			@property action {CalendarsPickerCommandAction} The function that implements the action. */
		commands: {
			prev: {text: 'prevText', status: 'prevStatus', // Previous month
				keystroke: {keyCode: 33}, // Page up
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					return (!minDate || inst.drawDate.newDate().
						add(1 - inst.options.monthsToStep - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay).add(-1, 'd').compareTo(minDate) !== -1); },
				date: function(inst) {
					return inst.drawDate.newDate().
						add(-inst.options.monthsToStep - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay); },
				action: function(inst) {
					plugin.changeMonth(this, -inst.options.monthsToStep); }
			},
			prevJump: {text: 'prevJumpText', status: 'prevJumpStatus', // Previous year
				keystroke: {keyCode: 33, ctrlKey: true}, // Ctrl + Page up
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					return (!minDate || inst.drawDate.newDate().
						add(1 - inst.options.monthsToJump - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay).add(-1, 'd').compareTo(minDate) !== -1); },
				date: function(inst) {
					return inst.drawDate.newDate().
						add(-inst.options.monthsToJump - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay); },
				action: function(inst) {
					plugin.changeMonth(this, -inst.options.monthsToJump); }
			},
			next: {text: 'nextText', status: 'nextStatus', // Next month
				keystroke: {keyCode: 34}, // Page down
				enabled: function(inst) {
					var maxDate = inst.get('maxDate');
					return (!maxDate || inst.drawDate.newDate().
						add(inst.options.monthsToStep - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay).compareTo(maxDate) !== +1); },
				date: function(inst) {
					return inst.drawDate.newDate().
						add(inst.options.monthsToStep - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay); },
				action: function(inst) {
					plugin.changeMonth(this, inst.options.monthsToStep); }
			},
			nextJump: {text: 'nextJumpText', status: 'nextJumpStatus', // Next year
				keystroke: {keyCode: 34, ctrlKey: true}, // Ctrl + Page down
				enabled: function(inst) {
					var maxDate = inst.get('maxDate');
					return (!maxDate || inst.drawDate.newDate().
						add(inst.options.monthsToJump - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay).compareTo(maxDate) !== +1);	},
				date: function(inst) {
					return inst.drawDate.newDate().
						add(inst.options.monthsToJump - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay); },
				action: function(inst) {
					plugin.changeMonth(this, inst.options.monthsToJump); }
			},
			current: {text: 'currentText', status: 'currentStatus', // Current month
				keystroke: {keyCode: 36, ctrlKey: true}, // Ctrl + Home
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					var maxDate = inst.get('maxDate');
					var curDate = inst.selectedDates[0] || inst.options.calendar.today();
					return (!minDate || curDate.compareTo(minDate) !== -1) &&
						(!maxDate || curDate.compareTo(maxDate) !== +1); },
				date: function(inst) {
					return inst.selectedDates[0] || inst.options.calendar.today(); },
				action: function(inst) {
					var curDate = inst.selectedDates[0] || inst.options.calendar.today();
					plugin.showMonth(this, curDate.year(), curDate.month()); }
			},
			today: {text: 'todayText', status: 'todayStatus', // Today's month
				keystroke: {keyCode: 36, ctrlKey: true}, // Ctrl + Home
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					var maxDate = inst.get('maxDate');
					return (!minDate || inst.options.calendar.today().compareTo(minDate) !== -1) &&
						(!maxDate || inst.options.calendar.today().compareTo(maxDate) !== +1); },
				date: function(inst) { return inst.options.calendar.today(); },
				action: function(inst) { plugin.showMonth(this); }
			},
			clear: {text: 'clearText', status: 'clearStatus', // Clear the datepicker
				keystroke: {keyCode: 35, ctrlKey: true}, // Ctrl + End
				enabled: function(inst) { return true; },
				date: function(inst) { return null; },
				action: function(inst) { plugin.clear(this); }
			},
			close: {text: 'closeText', status: 'closeStatus', // Close the datepicker
				keystroke: {keyCode: 27}, // Escape
				enabled: function(inst) { return true; },
				date: function(inst) { return null; },
				action: function(inst) { plugin.hide(this); }
			},
			prevWeek: {text: 'prevWeekText', status: 'prevWeekStatus', // Previous week
				keystroke: {keyCode: 38, ctrlKey: true}, // Ctrl + Up
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					return (!minDate || inst.drawDate.newDate().
						add(-inst.options.calendar.daysInWeek(), 'd').compareTo(minDate) !== -1); },
				date: function(inst) { return inst.drawDate.newDate().
					add(-inst.options.calendar.daysInWeek(), 'd'); },
				action: function(inst) { plugin.changeDay(this, -inst.options.calendar.daysInWeek()); }
			},
			prevDay: {text: 'prevDayText', status: 'prevDayStatus', // Previous day
				keystroke: {keyCode: 37, ctrlKey: true}, // Ctrl + Left
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					return (!minDate || inst.drawDate.newDate().add(-1, 'd').
						compareTo(minDate) !== -1); },
				date: function(inst) { return inst.drawDate.newDate().add(-1, 'd'); },
				action: function(inst) { plugin.changeDay(this, -1); }
			},
			nextDay: {text: 'nextDayText', status: 'nextDayStatus', // Next day
				keystroke: {keyCode: 39, ctrlKey: true}, // Ctrl + Right
				enabled: function(inst) {
					var maxDate = inst.get('maxDate');
					return (!maxDate || inst.drawDate.newDate().add(1, 'd').
						compareTo(maxDate) !== +1); },
				date: function(inst) { return inst.drawDate.newDate().add(1, 'd'); },
				action: function(inst) { plugin.changeDay(this, 1); }
			},
			nextWeek: {text: 'nextWeekText', status: 'nextWeekStatus', // Next week
				keystroke: {keyCode: 40, ctrlKey: true}, // Ctrl + Down
				enabled: function(inst) {
					var maxDate = inst.get('maxDate');
					return (!maxDate || inst.drawDate.newDate().
						add(inst.options.calendar.daysInWeek(), 'd').compareTo(maxDate) !== +1); },
				date: function(inst) { return inst.drawDate.newDate().
					add(inst.options.calendar.daysInWeek(), 'd'); },
				action: function(inst) { plugin.changeDay(this, inst.options.calendar.daysInWeek()); }
			}
		},

		/** Determine whether a command is enabled.
			@callback CalendarsPickerCommandEnabled
			@param inst {object} The current instance settings.
			@return {boolean} <code>true</code> if this command is enabled, <code>false</code> if not.
			@example enabled: function(inst) {
	return !!inst.curMinDate();
 } */

		/** Calculate the representative date for a command.
			@callback CalendarsPickerCommandDate
			@param inst {object} The current instance settings.
			@return {CDate} A date appropriate for this command.
			@example date: function(inst) {
	return inst.curMinDate();
 } */

		/** Perform the action for a command.
			@callback CalendarsPickerCommandAction
			@param inst {object} The current instance settings.
			@example date: function(inst) {
	$.datepick.setDate(inst.elem, inst.curMinDate());
 } */

		/** Calculate the week of the year for a date.
			@callback CalendarsPickerCalculateWeek
			@param date {CDate} The date to evaluate.
			@return {number} The week of the year.
			@example calculateWeek: function(date) {
	var startYear = $.calendars.newDate(date.year(), 1, 1);
	return Math.floor((date.dayOfYear() - startYear.dayOfYear()) / 7) + 1;
 } */

		/** Provide information about an individual date shown in the calendar.
			@callback CalendarsPickerOnDate
			@param date {CDate} The date to evaluate.
			@return {object} Information about that date, with the properties above.
			@property selectable {boolean} <code>true</code> if this date can be selected.
			@property dateClass {string} Class(es) to be applied to the date.
			@property content {string} The date cell content.
			@property tooltip {string} A popup tooltip for the date.
			@example onDate: function(date) {
	return {selectable: date.day() > 0 && date.day() &lt; 5,
		dateClass: date.day() === 4 ? 'last-day' : ''};
 } */

		/** Update the datepicker display.
			@callback CalendarsPickerOnShow
			@param picker {jQuery} The datepicker <code>div</code> to be shown.
			@param inst {object} The current instance settings.
			@example onShow: function(picker, inst) {
	picker.append('&lt;button type="button">Hi&lt;/button>').
		find('button:last').click(function() {
			alert('Hi!');
		});
 } */

		/** React to navigating through the months/years.
			@callback CalendarsPickerOnChangeMonthYear
			@param year {number} The new year.
			@param month {number} The new month (1 to 12).
			@example onChangeMonthYear: function(year, month) {
	alert('Now in ' + month + '/' + year);
 } */
			
		/** Datepicker on select callback.
			Triggered when a date is selected.
			@callback CalendarsPickerOnSelect
			@param dates {CDate[]} The selected date(s).
			@example onSelect: function(dates) {
 	alert('Selected ' + dates);
 } */
			
		/** Datepicker on close callback.
			Triggered when a popup calendar is closed.
			@callback CalendarsPickerOnClose
			@param dates {CDate[]} The selected date(s).
			@example onClose: function(dates) {
 	alert('Selected ' + dates);
 } */
		
		/** Default settings for the plugin.
			@memberof CalendarsPicker
			@property [calendar=$.calendars.instance()] {Calendar} The calendar for this datepicker.
			@property [pickerClass=''] {string} CSS class to add to this instance of the datepicker.
			@property [showOnFocus=true] {boolean} <code>true</code> for popup on focus, <code>false</code> for not.
			@property [showTrigger=null] {string|Element|jQuery} Element to be cloned for a trigger, <code>null</code> for none.
			@property [showAnim='show'] {string} Name of jQuery animation for popup, '' for no animation.
			@property [showOptions=null] {object} Options for enhanced animations.
			@property [showSpeed='normal'] {string} Duration of display/closure.
			@property [popupContainer=null] {string|Element|jQuery} The element to which a popup calendar is added, <code>null</code> for body.
			@property [alignment='bottom'] {string} Alignment of popup - with nominated corner of input:
						'top' or 'bottom' aligns depending on language direction,
						'topLeft', 'topRight', 'bottomLeft', 'bottomRight'.
			@property [fixedWeeks=false] {boolean} <code>true</code> to always show 6 weeks, <code>false</code> to only show as many as are needed.
			@property [firstDay=null] {number} First day of the week, 0 = Sunday, 1 = Monday, etc., <code>null</code> for <code>calendar</code> default.
			@property [calculateWeek=null] {CalendarsPickerCalculateWeek} Calculate week of the year from a date, <code>null</code> for <code>calendar</code> default.
			@property [monthsToShow=1] {number|number[]} How many months to show, cols or [rows, cols].
			@property [monthsOffset=0] {number} How many months to offset the primary month by;
						may be a function that takes the date and returns the offset.
			@property [monthsToStep=1] {number} How many months to move when prev/next clicked.
			@property [monthsToJump=12] {number} How many months to move when large prev/next clicked.
			@property [useMouseWheel=true] {boolean} <code>true</code> to use mousewheel if available, <code>false</code> to never use it.
			@property [changeMonth=true] {boolean} <code>true</code> to change month/year via drop-down, <code>false</code> for navigation only.
			@property [yearRange='c-10:c+10'] {string} Range of years to show in drop-down: 'any' for direct text entry
						or 'start:end', where start/end are '+-nn' for relative to today
						or 'c+-nn' for relative to the currently selected date
						or 'nnnn' for an absolute year.
			@property [showOtherMonths=false] {boolean} <code>true</code> to show dates from other months, <code>false</code> to not show them.
			@property [selectOtherMonths=false] {boolean} <code>true</code> to allow selection of dates from other months too.
			@property [defaultDate=null] {string|number|CDate} Date to show if no other selected.
			@property [selectDefaultDate=false] {boolean} <code>true</code> to pre-select the default date if no other is chosen.
			@property [minDate=null] {string|number|CDate} The minimum selectable date.
			@property [maxDate=null] {string|number|CDate} The maximum selectable date.
			@property [dateFormat='mm/dd/yyyy'] {string} Format for dates.
			@property [autoSize=false] {boolean} <code>true</code> to size the input field according to the date format.
			@property [rangeSelect=false] {boolean} Allows for selecting a date range on one date picker.
			@property [rangeSeparator=' - '] {string} Text between two dates in a range.
			@property [multiSelect=0] {number} Maximum number of selectable dates, zero for single select.
			@property [multiSeparator=','] {string} Text between multiple dates.
			@property [onDate=null] {CalendarsPickerOnDate} Callback as a date is added to the datepicker.
			@property [onShow=null] {CalendarsPickerOnShow} Callback just before a datepicker is shown.
			@property [onChangeMonthYear=null] {CalendarsPickerOnChangeMonthYear} Callback when a new month/year is selected.
			@property [onSelect=null] {CalendarsPickerOnSelect} Callback when a date is selected.
			@property [onClose=null] {CalendarsPickerOnClose} Callback when a datepicker is closed.
			@property [altField=null] {string|Element|jQuery} Alternate field to update in synch with the datepicker.
			@property [altFormat=null] {string} Date format for alternate field, defaults to <code>dateFormat</code>.
			@property [constrainInput=true] {boolean} <code>true</code> to constrain typed input to <code>dateFormat</code> allowed characters.
			@property [commandsAsDateFormat=false] {boolean} <code>true</code> to apply
						<code><a href="#formatDate">formatDate</a></code> to the command texts.
			@property [commands=this.commands] {object} Command actions that may be added to a layout by name. */
		defaultOptions: {
			calendar: $.calendars.instance(),
			pickerClass: '',
			showOnFocus: true,
			showTrigger: null,
			showAnim: 'show',
			showOptions: {},
			showSpeed: 'normal',
			popupContainer: null,
			alignment: 'bottom',
			fixedWeeks: false,
			firstDay: null,
			calculateWeek: null,
			monthsToShow: 1,
			monthsOffset: 0,
			monthsToStep: 1,
			monthsToJump: 12,
			useMouseWheel: true,
			changeMonth: true,
			yearRange: 'c-10:c+10',
			showOtherMonths: false,
			selectOtherMonths: false,
			defaultDate: null,
			selectDefaultDate: false,
			minDate: null,
			maxDate: null,
			dateFormat: null,
			autoSize: false,
			rangeSelect: false,
			rangeSeparator: ' - ',
			multiSelect: 0,
			multiSeparator: ',',
			onDate: null,
			onShow: null,
			onChangeMonthYear: null,
			onSelect: null,
			onClose: null,
			altField: null,
			altFormat: null,
			constrainInput: true,
			commandsAsDateFormat: false,
			commands: {} // this.commands
		},

		/** Localisations for the plugin.
			Entries are objects indexed by the language code ('' being the default US/English).
			Each object has the following attributes.
			@memberof CalendarsPicker
			@property [renderer=this.defaultRenderer] {string} The rendering templates.
			@property [prevText='&lt;Prev'] {string} Text for the previous month command.
			@property [prevStatus='Show the previous month'] {string} Status text for the previous month command.
			@property [prevJumpText='&lt;&lt;'] {string} Text for the previous year command.
			@property [prevJumpStatus='Show the previous year'] {string} Status text for the previous year command.
			@property [nextText='Next&gt;'] {string} Text for the next month command.
			@property [nextStatus='Show the next month'] {string} Status text for the next month command.
			@property [nextJumpText='&gt;&gt;'] {string} Text for the next year command.
			@property [nextJumpStatus='Show the next year'] {string} Status text for the next year command.
			@property [currentText='Current'] {string} Text for the current month command.
			@property [currentStatus='Show the current month'] {string} Status text for the current month command.
			@property [todayText='Today'] {string} Text for the today's month command.
			@property [todayStatus='Show today\'s month'] {string} Status text for the today's month command.
			@property [clearText='Clear'] {string} Text for the clear command.
			@property [clearStatus='Clear all the dates'] {string} Status text for the clear command.
			@property [closeText='Close'] {string} Text for the close command.
			@property [closeStatus='Close the datepicker'] {string} Status text for the close command.
			@property [yearStatus='Change the year'] {string} Status text for year selection.
			@property [earlierText='&#160;&#160;'] {string} Text for earlier years.
			@property [laterText='&#160;&#160;'] {string} Text for later years.
			@property [monthStatus='Change the month'] {string} Status text for month selection.
			@property [weekText='Wk'] {string} Text for week of the year column header.
			@property [weekStatus='Week of the year'] {string} Status text for week of the year column header.
			@property [dayStatus='Select DD,&#160;M&#160;d,&#160;yyyy'] {string} Status text for selectable days.
			@property [defaultStatus='Select a date'] {string} Status text shown by default.
			@property [isRTL=false] {boolean} <code>true</code> if language is right-to-left. */
		regionalOptions: { // Available regional settings, indexed by language/country code
			'': { // Default regional settings - English/US
				renderer: {}, // this.defaultRenderer
				prevText: '&lt;Prev',
				prevStatus: 'Show the previous month',
				prevJumpText: '&lt;&lt;',
				prevJumpStatus: 'Show the previous year',
				nextText: 'Next&gt;',
				nextStatus: 'Show the next month',
				nextJumpText: '&gt;&gt;',
				nextJumpStatus: 'Show the next year',
				currentText: 'Current',
				currentStatus: 'Show the current month',
				todayText: 'Today',
				todayStatus: 'Show today\'s month',
				clearText: 'Clear',
				clearStatus: 'Clear all the dates',
				closeText: 'Close',
				closeStatus: 'Close the datepicker',
				yearStatus: 'Change the year',
				earlierText: '&#160;&#160;',
				laterText: '&#160;&#160;',
				monthStatus: 'Change the month',
				weekText: 'Wk',
				weekStatus: 'Week of the year',
				dayStatus: 'Select DD, M d, yyyy',
				defaultStatus: 'Select a date',
				isRTL: false
			}
		},
		
		/** Names of getter methods - those that can't be chained.
			@memberof CalendarsPicker */
		_getters: ['getDate', 'isDisabled', 'isSelectable', 'retrieveDate'],

		_disabled: [],
		
		_popupClass: 'calendars-popup', // Marker for popup division
		_triggerClass: 'calendars-trigger', // Marker for trigger element
		_disableClass: 'calendars-disable', // Marker for disabled element
		_monthYearClass: 'calendars-month-year', // Marker for month/year inputs
		_curMonthClass: 'calendars-month-', // Marker for current month/year
		_anyYearClass: 'calendars-any-year', // Marker for year direct input
		_curDoWClass: 'calendars-dow-', // Marker for day of week

		_init: function() {
			this.defaultOptions.commands = this.commands;
			this.regionalOptions[''].renderer = this.defaultRenderer;
			this._super();
		},

		_instSettings: function(elem, options) {
			return {selectedDates: [], drawDate: null, pickingRange: false,
				inline: ($.inArray(elem[0].nodeName.toLowerCase(), ['div', 'span']) > -1),
				get: function(name) { // Get a setting value, computing if necessary
					if ($.inArray(name, ['defaultDate', 'minDate', 'maxDate']) > -1) { // Decode date settings
						return this.options.calendar.determineDate(this.options[name], null,
							this.selectedDates[0], this.get('dateFormat'), this.getConfig());
					}
					if (name === 'dateFormat') {
						return this.options.dateFormat || this.options.calendar.local.dateFormat;
					}
					return this.options[name];
				},
				curMinDate: function() {
					return (this.pickingRange ? this.selectedDates[0] : this.get('minDate'));
				},
				getConfig: function() {
					return {dayNamesShort: this.options.dayNamesShort, dayNames: this.options.dayNames,
						monthNamesShort: this.options.monthNamesShort, monthNames: this.options.monthNames,
						calculateWeek: this.options.calculateWeek, shortYearCutoff: this.options.shortYearCutoff};
				}
			};
		},

		_postAttach: function(elem, inst) {
			if (inst.inline) {
				inst.drawDate = plugin._checkMinMax((inst.selectedDates[0] ||
					inst.get('defaultDate') || inst.options.calendar.today()).newDate(), inst);
				inst.prevDate = inst.drawDate.newDate();
				this._update(elem[0]);
				if ($.fn.mousewheel) {
					elem.mousewheel(this._doMouseWheel);
				}
			}
			else {
				this._attachments(elem, inst);
				elem.on('keydown.' + inst.name, this._keyDown).on('keypress.' + inst.name, this._keyPress).
					on('keyup.' + inst.name, this._keyUp);
				if (elem.attr('disabled')) {
					this.disable(elem[0]);
				}
			}
		},

		_optionsChanged: function(elem, inst, options) {
			if (options.calendar && options.calendar !== inst.options.calendar) {
				var discardDate = function(name) {
					return (typeof inst.options[name] === 'object' ? null : inst.options[name]);
				};
				options = $.extend({defaultDate: discardDate('defaultDate'),
					minDate: discardDate('minDate'), maxDate: discardDate('maxDate')}, options);
				inst.selectedDates = [];
				inst.drawDate = null;
			}
			var dates = inst.selectedDates;
			$.extend(inst.options, options);
			this.setDate(elem[0], dates, null, false, true);
			inst.pickingRange = false;
			var calendar = inst.options.calendar;
			var defaultDate = inst.get('defaultDate');
			inst.drawDate = this._checkMinMax((defaultDate ? defaultDate : inst.drawDate) ||
				defaultDate || calendar.today(), inst).newDate();
			if (!inst.inline) {
				this._attachments(elem, inst);
			}
			if (inst.inline || inst.div) {
				this._update(elem[0]);
			}
		},

		/** Attach events and trigger, if necessary.
			@memberof CalendarsPicker
			@private
			@param elem {jQuery} The control to affect.
			@param inst {object} The current instance settings. */
		_attachments: function(elem, inst) {
			elem.off('focus.' + inst.name);
			if (inst.options.showOnFocus) {
				elem.on('focus.' + inst.name, this.show);
			}
			if (inst.trigger) {
				inst.trigger.remove();
			}
			var trigger = inst.options.showTrigger;
			inst.trigger = (!trigger ? $([]) :
				$(trigger).clone().removeAttr('id').addClass(this._triggerClass)
					[inst.options.isRTL ? 'insertBefore' : 'insertAfter'](elem).
					click(function() {
						if (!plugin.isDisabled(elem[0])) {
							plugin[plugin.curInst === inst ? 'hide' : 'show'](elem[0]);
						}
					}));
			this._autoSize(elem, inst);
			var dates = this._extractDates(inst, elem.val());
			if (dates) {
				this.setDate(elem[0], dates, null, true);
			}
			var defaultDate = inst.get('defaultDate');
			if (inst.options.selectDefaultDate && defaultDate && inst.selectedDates.length === 0) {
				this.setDate(elem[0], (defaultDate || inst.options.calendar.today()).newDate());
			}
		},

		/** Apply the maximum length for the date format.
			@memberof CalendarsPicker
			@private
			@param elem {jQuery} The control to affect.
			@param inst {object} The current instance settings. */
		_autoSize: function(elem, inst) {
			if (inst.options.autoSize && !inst.inline) {
				var calendar = inst.options.calendar;
				var date = calendar.newDate(2009, 10, 20); // Ensure double digits
				var dateFormat = inst.get('dateFormat');
				if (dateFormat.match(/[DM]/)) {
					var findMax = function(names) {
						var max = 0;
						var maxI = 0;
						for (var i = 0; i < names.length; i++) {
							if (names[i].length > max) {
								max = names[i].length;
								maxI = i;
							}
						}
						return maxI;
					};
					date.month(findMax(calendar.local[dateFormat.match(/MM/) ? // Longest month
						'monthNames' : 'monthNamesShort']) + 1);
					date.day(findMax(calendar.local[dateFormat.match(/DD/) ? // Longest day
						'dayNames' : 'dayNamesShort']) + 20 - date.dayOfWeek());
				}
				inst.elem.attr('size', date.formatDate(dateFormat).length);
			}
		},

		_preDestroy: function(elem, inst) {
			if (inst.trigger) {
				inst.trigger.remove();
			}
			elem.empty().off('.' + inst.name);
			if (inst.inline && $.fn.mousewheel) {
				elem.unmousewheel();
			}
			if (!inst.inline && inst.options.autoSize) {
				elem.removeAttr('size');
			}
		},

		/** Apply multiple event functions.
			@memberof CalendarsPicker
			@param fns {function} The functions to apply.
			@example onShow: multipleEvents(fn1, fn2, ...) */
		multipleEvents: function(fns) {
			var funcs = arguments;
			return function(args) {
				for (var i = 0; i < funcs.length; i++) {
					funcs[i].apply(this, arguments);
				}
			};
		},

		/** Enable the control.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@example $(selector).datepick('enable') */
		enable: function(elem) {
			elem = $(elem);
			if (!elem.hasClass(this._getMarker())) {
				return;
			}
			var inst = this._getInst(elem);
			if (inst.inline) {
				elem.children('.' + this._disableClass).remove().end().
					find('button,select').prop('disabled', false).end().
					find('a').attr('href', 'javascript:void(0)');
			}
			else {
				elem.prop('disabled', false);
				inst.trigger.filter('button.' + this._triggerClass).prop('disabled', false).end().
					filter('img.' + this._triggerClass).css({opacity: '1.0', cursor: ''});
			}
			this._disabled = $.map(this._disabled,
				function(value) { return (value === elem[0] ? null : value); }); // Delete entry
		},

		/** Disable the control.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@example $(selector).datepick('disable') */
		disable: function(elem) {
			elem = $(elem);
			if (!elem.hasClass(this._getMarker())) {
				return;
			}
			var inst = this._getInst(elem);
			if (inst.inline) {
				var inline = elem.children(':last');
				var offset = inline.offset();
				var relOffset = {left: 0, top: 0};
				inline.parents().each(function() {
					if ($(this).css('position') === 'relative') {
						relOffset = $(this).offset();
						return false;
					}
				});
				var zIndex = elem.css('zIndex');
				zIndex = (zIndex === 'auto' ? 0 : parseInt(zIndex, 10)) + 1;
				elem.prepend('<div class="' + this._disableClass + '" style="' +
					'width: ' + inline.outerWidth() + 'px; height: ' + inline.outerHeight() +
					'px; left: ' + (offset.left - relOffset.left) + 'px; top: ' +
					(offset.top - relOffset.top) + 'px; z-index: ' + zIndex + '"></div>').
					find('button,select').prop('disabled', true).end().
					find('a').removeAttr('href');
			}
			else {
				elem.prop('disabled', true);
				inst.trigger.filter('button.' + this._triggerClass).prop('disabled', true).end().
					filter('img.' + this._triggerClass).css({opacity: '0.5', cursor: 'default'});
			}
			this._disabled = $.map(this._disabled,
				function(value) { return (value === elem[0] ? null : value); }); // Delete entry
			this._disabled.push(elem[0]);
		},

		/** Is the first field in a jQuery collection disabled as a datepicker?
			@memberof CalendarsPicker
			@param elem {Element} The control to examine.
			@return {boolean} <code>true</code> if disabled, <code>false</code> if enabled.
			@example if ($(selector).datepick('isDisabled')) {...} */
		isDisabled: function(elem) {
			return (elem && $.inArray(elem, this._disabled) > -1);
		},

		/** Show a popup datepicker.
			@memberof CalendarsPicker
			@param elem {Event|Element} a focus event or the control to use.
			@example $(selector).datepick('show') */
		show: function(elem) {
			elem = $(elem.target || elem);
			var inst = plugin._getInst(elem);
			if (plugin.curInst === inst) {
				return;
			}
			if (plugin.curInst) {
				plugin.hide(plugin.curInst, true);
			}
			if (!$.isEmptyObject(inst)) {
				// Retrieve existing date(s)
				inst.lastVal = null;
				inst.selectedDates = plugin._extractDates(inst, elem.val());
				inst.pickingRange = false;
				inst.drawDate = plugin._checkMinMax((inst.selectedDates[0] ||
					inst.get('defaultDate') || inst.options.calendar.today()).newDate(), inst);
				inst.prevDate = inst.drawDate.newDate();
				plugin.curInst = inst;
				// Generate content
				plugin._update(elem[0], true);
				// Adjust position before showing
				var offset = plugin._checkOffset(inst);
				inst.div.css({left: offset.left, top: offset.top});
				// And display
				var showAnim = inst.options.showAnim;
				var showSpeed = inst.options.showSpeed;
				showSpeed = (showSpeed === 'normal' && $.ui &&
					parseInt($.ui.version.substring(2)) >= 8 ? '_default' : showSpeed);
				if ($.effects && ($.effects[showAnim] || ($.effects.effect && $.effects.effect[showAnim]))) {
					var data = inst.div.data(); // Update old effects data
					for (var key in data) {
						if (key.match(/^ec\.storage\./)) {
							data[key] = inst._mainDiv.css(key.replace(/ec\.storage\./, ''));
						}
					}
					inst.div.data(data).show(showAnim, inst.options.showOptions, showSpeed);
				}
				else {
					inst.div[showAnim || 'show'](showAnim ? showSpeed : 0);
				}
			}
		},

		/** Extract possible dates from a string.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@param text {string} The text to extract from.
			@return {CDate[]} The extracted dates. */
		_extractDates: function(inst, datesText) {
			if (datesText === inst.lastVal) {
				return;
			}
			inst.lastVal = datesText;
			datesText = datesText.split(inst.options.multiSelect ? inst.options.multiSeparator :
				(inst.options.rangeSelect ? inst.options.rangeSeparator : '\x00'));
			var dates = [];
			for (var i = 0; i < datesText.length; i++) {
				try {
					var date = inst.options.calendar.parseDate(inst.get('dateFormat'), datesText[i]);
					if (date) {
						var found = false;
						for (var j = 0; j < dates.length; j++) {
							if (dates[j].compareTo(date) === 0) {
								found = true;
								break;
							}
						}
						if (!found) {
							dates.push(date);
						}
					}
				}
				catch (e) {
					// Ignore
				}
			}
			dates.splice(inst.options.multiSelect || (inst.options.rangeSelect ? 2 : 1), dates.length);
			if (inst.options.rangeSelect && dates.length === 1) {
				dates[1] = dates[0];
			}
			return dates;
		},

		/** Update the datepicker display.
			@memberof CalendarsPicker
			@private
			@param elem {Event|Element} a focus event or the control to use.
			@param hidden {boolean} <code>true</code> to initially hide the datepicker. */
		_update: function(elem, hidden) {
			elem = $(elem.target || elem);
			var inst = plugin._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				if (inst.inline || plugin.curInst === inst) {
					if ($.isFunction(inst.options.onChangeMonthYear) && (!inst.prevDate ||
							inst.prevDate.year() !== inst.drawDate.year() ||
							inst.prevDate.month() !== inst.drawDate.month())) {
						inst.options.onChangeMonthYear.apply(elem[0],
							[inst.drawDate.year(), inst.drawDate.month()]);
					}
				}
				if (inst.inline) {
					var index = $('a, :input', elem).index($(':focus', elem));
					elem.html(this._generateContent(elem[0], inst));
					var focus = elem.find('a, :input');
					focus.eq(Math.max(Math.min(index, focus.length - 1), 0)).focus();
				}
				else if (plugin.curInst === inst) {
					if (!inst.div) {
						inst.div = $('<div></div>').addClass(this._popupClass).
							css({display: (hidden ? 'none' : 'static'), position: 'absolute',
								left: elem.offset().left, top: elem.offset().top + elem.outerHeight()}).
							appendTo($(inst.options.popupContainer || 'body'));
						if ($.fn.mousewheel) {
							inst.div.mousewheel(this._doMouseWheel);
						}
					}
					inst.div.html(this._generateContent(elem[0], inst));
					elem.focus();
				}
			}
		},

		/** Update the input field and any alternate field with the current dates.
			@memberof CalendarsPicker
			@private
			@param elem {Element} The control to use.
			@param keyUp {boolean} <code>true</code> if coming from <code>keyUp</code> processing (internal). */
		_updateInput: function(elem, keyUp) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				var value = '';
				var altValue = '';
				var sep = (inst.options.multiSelect ? inst.options.multiSeparator :
					inst.options.rangeSeparator);
				var calendar = inst.options.calendar;
				var dateFormat = inst.get('dateFormat');
				var altFormat = inst.options.altFormat || dateFormat;
				for (var i = 0; i < inst.selectedDates.length; i++) {
					value += (keyUp ? '' : (i > 0 ? sep : '') +
						calendar.formatDate(dateFormat, inst.selectedDates[i]));
					altValue += (i > 0 ? sep : '') +
						calendar.formatDate(altFormat, inst.selectedDates[i]);
				}
				if (!inst.inline && !keyUp) {
					$(elem).val(value);
				}
				$(inst.options.altField).val(altValue);
				if ($.isFunction(inst.options.onSelect) && !keyUp && !inst.inSelect) {
					inst.inSelect = true; // Prevent endless loops
					inst.options.onSelect.apply(elem, [inst.selectedDates]);
					inst.inSelect = false;
				}
			}
		},

		/** Retrieve the size of left and top borders for an element.
			@memberof CalendarsPicker
			@private
			@param elem {jQuery} The element of interest.
			@return {number[]} The left and top borders. */
		_getBorders: function(elem) {
			var convert = function(value) {
				return {thin: 1, medium: 3, thick: 5}[value] || value;
			};
			return [parseFloat(convert(elem.css('border-left-width'))),
				parseFloat(convert(elem.css('border-top-width')))];
		},

		/** Check positioning to remain on the screen.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@return {object} The updated offset for the datepicker. */
		_checkOffset: function(inst) {
			var base = (inst.elem.is(':hidden') && inst.trigger ? inst.trigger : inst.elem);
			var offset = base.offset();
			var browserWidth = $(window).width();
			var browserHeight = $(window).height();
			if (browserWidth === 0) {
				return offset;
			}
			var isFixed = false;
			$(inst.elem).parents().each(function() {
				isFixed |= $(this).css('position') === 'fixed';
				return !isFixed;
			});
			var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			var above = offset.top - (isFixed ? scrollY : 0) - inst.div.outerHeight();
			var below = offset.top - (isFixed ? scrollY : 0) + base.outerHeight();
			var alignL = offset.left - (isFixed ? scrollX : 0);
			var alignR = offset.left - (isFixed ? scrollX : 0) + base.outerWidth() - inst.div.outerWidth();
			var tooWide = (offset.left - scrollX + inst.div.outerWidth()) > browserWidth;
			var tooHigh = (offset.top - scrollY + inst.elem.outerHeight() +
				inst.div.outerHeight()) > browserHeight;
			inst.div.css('position', isFixed ? 'fixed' : 'absolute');
			var alignment = inst.options.alignment;
			if (alignment === 'topLeft') {
				offset = {left: alignL, top: above};
			}
			else if (alignment === 'topRight') {
				offset = {left: alignR, top: above};
			}
			else if (alignment === 'bottomLeft') {
				offset = {left: alignL, top: below};
			}
			else if (alignment === 'bottomRight') {
				offset = {left: alignR, top: below};
			}
			else if (alignment === 'top') {
				offset = {left: (inst.options.isRTL || tooWide ? alignR : alignL), top: above};
			}
			else { // bottom
				offset = {left: (inst.options.isRTL || tooWide ? alignR : alignL),
					top: (tooHigh ? above : below)};
			}
			offset.left = Math.max((isFixed ? 0 : scrollX), offset.left);
			offset.top = Math.max((isFixed ? 0 : scrollY), offset.top);
			return offset;
		},

		/** Close date picker if clicked elsewhere.
			@memberof CalendarsPicker
			@private
			@param event {MouseEvent} The mouse click to check. */
		_checkExternalClick: function(event) {
			if (!plugin.curInst) {
				return;
			}
			var elem = $(event.target);
			if (elem.closest('.' + plugin._popupClass + ',.' + plugin._triggerClass).length === 0 &&
					!elem.hasClass(plugin._getMarker())) {
				plugin.hide(plugin.curInst);
			}
		},

		/** Hide a popup datepicker.
			@memberof CalendarsPicker
			@param elem {Element|object} The control to use or the current instance settings.
			@param immediate {boolean} <code>true</code> to close immediately without animation (internal).
			@example $(selector).datepick('hide') */
		hide: function(elem, immediate) {
			if (!elem) {
				return;
			}
			var inst = this._getInst(elem);
			if ($.isEmptyObject(inst)) {
				inst = elem;
			}
			if (inst && inst === plugin.curInst) {
				var showAnim = (immediate ? '' : inst.options.showAnim);
				var showSpeed = inst.options.showSpeed;
				showSpeed = (showSpeed === 'normal' && $.ui &&
					parseInt($.ui.version.substring(2)) >= 8 ? '_default' : showSpeed);
				var postProcess = function() {
					if (!inst.div) {
						return;
					}
					inst.div.remove();
					inst.div = null;
					plugin.curInst = null;
					if ($.isFunction(inst.options.onClose)) {
						inst.options.onClose.apply(elem, [inst.selectedDates]);
					}
				};
				inst.div.stop();
				if ($.effects && ($.effects[showAnim] || ($.effects.effect && $.effects.effect[showAnim]))) {
					inst.div.hide(showAnim, inst.options.showOptions, showSpeed, postProcess);
				}
				else {
					var hideAnim = (showAnim === 'slideDown' ? 'slideUp' :
						(showAnim === 'fadeIn' ? 'fadeOut' : 'hide'));
					inst.div[hideAnim]((showAnim ? showSpeed : ''), postProcess);
				}
				if (!showAnim) {
					postProcess();
				}
			}
		},

		/** Handle keystrokes in the datepicker.
			@memberof CalendarsPicker
			@private
			@param event {KeyEvent} The keystroke.
			@return {boolean} <code>true</code> if not handled, <code>false</code> if handled. */
		_keyDown: function(event) {
			var elem = (event.data && event.data.elem) || event.target;
			var inst = plugin._getInst(elem);
			var handled = false;
			if (inst.inline || inst.div) {
				if (event.keyCode === 9) { // Tab - close
					plugin.hide(elem);
				}
				else if (event.keyCode === 13) { // Enter - select
					plugin.selectDate(elem,
						$('a.' + inst.options.renderer.highlightedClass, inst.div)[0]);
					handled = true;
				}
				else { // Command keystrokes
					var commands = inst.options.commands;
					for (var name in commands) {
						var command = commands[name];
						if (command.keystroke.keyCode === event.keyCode &&
								!!command.keystroke.ctrlKey === !!(event.ctrlKey || event.metaKey) &&
								!!command.keystroke.altKey === event.altKey &&
								!!command.keystroke.shiftKey === event.shiftKey) {
							plugin.performAction(elem, name);
							handled = true;
							break;
						}
					}
				}
			}
			else { // Show on 'current' keystroke
				var command = inst.options.commands.current;
				if (command.keystroke.keyCode === event.keyCode &&
						!!command.keystroke.ctrlKey === !!(event.ctrlKey || event.metaKey) &&
						!!command.keystroke.altKey === event.altKey &&
						!!command.keystroke.shiftKey === event.shiftKey) {
					plugin.show(elem);
					handled = true;
				}
			}
			inst.ctrlKey = ((event.keyCode < 48 && event.keyCode !== 32) || event.ctrlKey || event.metaKey);
			if (handled) {
				event.preventDefault();
				event.stopPropagation();
			}
			return !handled;
		},

		/** Filter keystrokes in the datepicker.
			@memberof CalendarsPicker
			@private
			@param event {KeyEvent} The keystroke.
			@return {boolean} <code>true</code> if allowed, <code>false</code> if not allowed. */
		_keyPress: function(event) {
			var inst = plugin._getInst((event.data && event.data.elem) || event.target);
			if (!$.isEmptyObject(inst) && inst.options.constrainInput) {
				var ch = String.fromCharCode(event.keyCode || event.charCode);
				var allowedChars = plugin._allowedChars(inst);
				return (event.metaKey || inst.ctrlKey || ch < ' ' ||
					!allowedChars || allowedChars.indexOf(ch) > -1);
			}
			return true;
		},

		/** Determine the set of characters allowed by the date format.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@return {string} The set of allowed characters, or <code>null</code> if anything allowed. */
		_allowedChars: function(inst) {
			var allowedChars = (inst.options.multiSelect ? inst.options.multiSeparator :
				(inst.options.rangeSelect ? inst.options.rangeSeparator : ''));
			var literal = false;
			var hasNum = false;
			var dateFormat = inst.get('dateFormat');
			for (var i = 0; i < dateFormat.length; i++) {
				var ch = dateFormat.charAt(i);
				if (literal) {
					if (ch === "'" && dateFormat.charAt(i + 1) !== "'") {
						literal = false;
					}
					else {
						allowedChars += ch;
					}
				}
				else {
					switch (ch) {
						case 'd': case 'm': case 'o': case 'w':
							allowedChars += (hasNum ? '' : '0123456789'); hasNum = true; break;
						case 'y': case '@': case '!':
							allowedChars += (hasNum ? '' : '0123456789') + '-'; hasNum = true; break;
						case 'J':
							allowedChars += (hasNum ? '' : '0123456789') + '-.'; hasNum = true; break;
						case 'D': case 'M': case 'Y':
							return null; // Accept anything
						case "'":
							if (dateFormat.charAt(i + 1) === "'") {
								allowedChars += "'";
							}
							else {
								literal = true;
							}
							break;
						default:
							allowedChars += ch;
					}
				}
			}
			return allowedChars;
		},

		/** Synchronise datepicker with the field.
			@memberof CalendarsPicker
			@private
			@param event {KeyEvent} The keystroke.
			@return {boolean} <code>true</code> if allowed, <code>false</code> if not allowed. */
		_keyUp: function(event) {
			var elem = (event.data && event.data.elem) || event.target;
			var inst = plugin._getInst(elem);
			if (!$.isEmptyObject(inst) && !inst.ctrlKey && inst.lastVal !== inst.elem.val()) {
				try {
					var dates = plugin._extractDates(inst, inst.elem.val());
					if (dates.length > 0) {
						plugin.setDate(elem, dates, null, true);
					}
				}
				catch (event) {
					// Ignore
				}
			}
			return true;
		},

		/** Increment/decrement month/year on mouse wheel activity.
			@memberof CalendarsPicker
			@private
			@param event {event} The mouse wheel event.
			@param delta {number} The amount of change. */
		_doMouseWheel: function(event, delta) {
			var elem = (plugin.curInst && plugin.curInst.elem[0]) ||
				$(event.target).closest('.' + plugin._getMarker())[0];
			if (plugin.isDisabled(elem)) {
				return;
			}
			var inst = plugin._getInst(elem);
			if (inst.options.useMouseWheel) {
				delta = (delta < 0 ? -1 : +1);
				plugin.changeMonth(elem, -inst.options[event.ctrlKey ? 'monthsToJump' : 'monthsToStep'] * delta);
			}
			event.preventDefault();
		},

		/** Clear an input and close a popup datepicker.
			@memberof CalendarsPicker
			@param elem {Element} The control to use.
			@example $(selector).datepick('clear') */
		clear: function(elem) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				inst.selectedDates = [];
				this.hide(elem);
				var defaultDate = inst.get('defaultDate');
				if (inst.options.selectDefaultDate && defaultDate) {
					this.setDate(elem, (defaultDate || inst.options.calendar.today()).newDate());
				}
				else {
					this._updateInput(elem);
				}
			}
		},

		/** Retrieve the selected date(s) for a datepicker.
			@memberof CalendarsPicker
			@param elem {Element} The control to examine.
			@return {CDate[]} The selected date(s).
			@example var dates = $(selector).datepick('getDate') */
		getDate: function(elem) {
			var inst = this._getInst(elem);
			return (!$.isEmptyObject(inst) ? inst.selectedDates : []);
		},

		/** Set the selected date(s) for a datepicker.
			@memberof CalendarsPicker
			@param elem {Element} the control to examine.
			@param dates {CDate|number|string|array} the selected date(s).
			@param [endDate] {CDate|number|string} the ending date for a range.
			@param [keyUp] {boolean} <code>true</code> if coming from <code>keyUp</code> processing (internal).
			@param [setOpt] {boolean} <code>true</code> if coming from option processing (internal).
			@example $(selector).datepick('setDate', new Date(2014, 12-1, 25))
 $(selector).datepick('setDate', '12/25/2014', '01/01/2015')
 $(selector).datepick('setDate', [date1, date2, date3]) */
		setDate: function(elem, dates, endDate, keyUp, setOpt) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				if (!$.isArray(dates)) {
					dates = [dates];
					if (endDate) {
						dates.push(endDate);
					}
				}
				var minDate = inst.get('minDate');
				var maxDate = inst.get('maxDate');
				var curDate = inst.selectedDates[0];
				inst.selectedDates = [];
				for (var i = 0; i < dates.length; i++) {
					var date = inst.options.calendar.determineDate(
						dates[i], null, curDate, inst.get('dateFormat'), inst.getConfig());
					if (date) {
						if ((!minDate || date.compareTo(minDate) !== -1) &&
								(!maxDate || date.compareTo(maxDate) !== +1)) {
							var found = false;
							for (var j = 0; j < inst.selectedDates.length; j++) {
								if (inst.selectedDates[j].compareTo(date) === 0) {
									found = true;
									break;
								}
							}
							if (!found) {
								inst.selectedDates.push(date);
							}
						}
					}
				}
				inst.selectedDates.splice(inst.options.multiSelect ||
					(inst.options.rangeSelect ? 2 : 1), inst.selectedDates.length);
				if (inst.options.rangeSelect) {
					switch (inst.selectedDates.length) {
						case 1: inst.selectedDates[1] = inst.selectedDates[0]; break;
						case 2: inst.selectedDates[1] =
							(inst.selectedDates[0].compareTo(inst.selectedDates[1]) === +1 ?
							inst.selectedDates[0] : inst.selectedDates[1]); break;
					}
					inst.pickingRange = false;
				}
				inst.prevDate = (inst.drawDate ? inst.drawDate.newDate() : null);
				inst.drawDate = this._checkMinMax((inst.selectedDates[0] ||
					inst.get('defaultDate') || inst.options.calendar.today()).newDate(), inst);
				if (!setOpt) {
					this._update(elem);
					this._updateInput(elem, keyUp);
				}
			}
		},

		/** Determine whether a date is selectable for this datepicker.
			@memberof CalendarsPicker
			@private
			@param elem {Element} The control to check.
			@param date {CDate|string|number} The date to check.
			@return {boolean} <code>true</code> if selectable, <code>false</code> if not.
			@example var selectable = $(selector).datepick('isSelectable', date) */
		isSelectable: function(elem, date) {
			var inst = this._getInst(elem);
			if ($.isEmptyObject(inst)) {
				return false;
			}
			date = inst.options.calendar.determineDate(date,
				inst.selectedDates[0] || inst.options.calendar.today(), null,
				inst.options.dateFormat, inst.getConfig());
			return this._isSelectable(elem, date, inst.options.onDate,
				inst.get('minDate'), inst.get('maxDate'));
		},

		/** Internally determine whether a date is selectable for this datepicker.
			@memberof CalendarsPicker
			@private
			@param elem {Element} the control to check.
			@param date {CDate} The date to check.
			@param onDate {function|boolean} Any <code>onDate</code> callback or <code>callback.selectable</code>.
			@param minDate {CDate} The minimum allowed date.
			@param maxDate {CDate} The maximum allowed date.
			@return {boolean} <code>true</code> if selectable, <code>false</code> if not. */
		_isSelectable: function(elem, date, onDate, minDate, maxDate) {
			var dateInfo = (typeof onDate === 'boolean' ? {selectable: onDate} :
				(!$.isFunction(onDate) ? {} : onDate.apply(elem, [date, true])));
			return (dateInfo.selectable !== false) &&
				(!minDate || date.toJD() >= minDate.toJD()) && (!maxDate || date.toJD() <= maxDate.toJD());
		},

		/** Perform a named action for a datepicker.
			@memberof CalendarsPicker
			@param elem {element} The control to affect.
			@param action {string} The name of the action. */
		performAction: function(elem, action) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst) && !this.isDisabled(elem)) {
				var commands = inst.options.commands;
				if (commands[action] && commands[action].enabled.apply(elem, [inst])) {
					commands[action].action.apply(elem, [inst]);
				}
			}
		},

		/** Set the currently shown month, defaulting to today's.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@param [year] {number} The year to show.
			@param [month] {number} The month to show (1-12).
			@param [day] {number} The day to show.
			@example $(selector).datepick('showMonth', 2014, 12, 25) */
		showMonth: function(elem, year, month, day) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst) && (day != null ||
					(inst.drawDate.year() !== year || inst.drawDate.month() !== month))) {
				inst.prevDate = inst.drawDate.newDate();
				var calendar = inst.options.calendar;
				var show = this._checkMinMax((year != null ?
					calendar.newDate(year, month, 1) : calendar.today()), inst);
				inst.drawDate.date(show.year(), show.month(), 
					(day != null ? day : Math.min(inst.drawDate.day(),
					calendar.daysInMonth(show.year(), show.month()))));
				this._update(elem);
			}
		},

		/** Adjust the currently shown month.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@param offset {number} The number of months to change by.
			@example $(selector).datepick('changeMonth', 2)*/
		changeMonth: function(elem, offset) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				var date = inst.drawDate.newDate().add(offset, 'm');
				this.showMonth(elem, date.year(), date.month());
			}
		},

		/** Adjust the currently shown day.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@param offset {number} The number of days to change by.
			@example $(selector).datepick('changeDay', 7)*/
		changeDay: function(elem, offset) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				var date = inst.drawDate.newDate().add(offset, 'd');
				this.showMonth(elem, date.year(), date.month(), date.day());
			}
		},

		/** Restrict a date to the minimum/maximum specified.
			@memberof CalendarsPicker
			@private
			@param date {CDate} The date to check.
			@param inst {object} The current instance settings. */
		_checkMinMax: function(date, inst) {
			var minDate = inst.get('minDate');
			var maxDate = inst.get('maxDate');
			date = (minDate && date.compareTo(minDate) === -1 ? minDate.newDate() : date);
			date = (maxDate && date.compareTo(maxDate) === +1 ? maxDate.newDate() : date);
			return date;
		},

		/** Retrieve the date associated with an entry in the datepicker.
			@memberof CalendarsPicker
			@param elem {Element} The control to examine.
			@param target {Element} The selected datepicker element.
			@return {CDate} The corresponding date, or <code>null</code>.			
			@example var date = $(selector).datepick('retrieveDate', $('div.datepick-popup a:contains(10)')[0]) */
		retrieveDate: function(elem, target) {
			var inst = this._getInst(elem);
			return ($.isEmptyObject(inst) ? null : inst.options.calendar.fromJD(
				parseFloat(target.className.replace(/^.*jd(\d+\.5).*$/, '$1'))));
		},

		/** Select a date for this datepicker.
			@memberof CalendarsPicker
			@param elem {Element} The control to examine.
			@param target {Element} The selected datepicker element.
			@example $(selector).datepick('selectDate', $('div.datepick-popup a:contains(10)')[0]) */
		selectDate: function(elem, target) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst) && !this.isDisabled(elem)) {
				var date = this.retrieveDate(elem, target);
				if (inst.options.multiSelect) {
					var found = false;
					for (var i = 0; i < inst.selectedDates.length; i++) {
						if (date.compareTo(inst.selectedDates[i]) === 0) {
							inst.selectedDates.splice(i, 1);
							found = true;
							break;
						}
					}
					if (!found && inst.selectedDates.length < inst.options.multiSelect) {
						inst.selectedDates.push(date);
					}
				}
				else if (inst.options.rangeSelect) {
					if (inst.pickingRange) {
						inst.selectedDates[1] = date;
					}
					else {
						inst.selectedDates = [date, date];
					}
					inst.pickingRange = !inst.pickingRange;
				}
				else {
					inst.selectedDates = [date];
				}
				inst.prevDate = inst.drawDate = date.newDate();
				this._updateInput(elem);
				if (inst.inline || inst.pickingRange || inst.selectedDates.length <
						(inst.options.multiSelect || (inst.options.rangeSelect ? 2 : 1))) {
					this._update(elem);
				}
				else {
					this.hide(elem);
				}
			}
		},

		/** Generate the datepicker content for this control.
			@memberof CalendarsPicker
			@private
			@param elem {Element} The control to affect.
			@param inst {object} The current instance settings.
			@return {jQuery} The datepicker content */
		_generateContent: function(elem, inst) {
			var monthsToShow = inst.options.monthsToShow;
			monthsToShow = ($.isArray(monthsToShow) ? monthsToShow : [1, monthsToShow]);
			inst.drawDate = this._checkMinMax(
				inst.drawDate || inst.get('defaultDate') || inst.options.calendar.today(), inst);
			var drawDate = inst.drawDate.newDate().add(-inst.options.monthsOffset, 'm');
			// Generate months
			var monthRows = '';
			for (var row = 0; row < monthsToShow[0]; row++) {
				var months = '';
				for (var col = 0; col < monthsToShow[1]; col++) {
					months += this._generateMonth(elem, inst, drawDate.year(),
						drawDate.month(), inst.options.calendar, inst.options.renderer, (row === 0 && col === 0));
					drawDate.add(1, 'm');
				}
				monthRows += this._prepare(inst.options.renderer.monthRow, inst).replace(/\{months\}/, months);
			}
			var picker = this._prepare(inst.options.renderer.picker, inst).replace(/\{months\}/, monthRows).
				replace(/\{weekHeader\}/g, this._generateDayHeaders(inst, inst.options.calendar, inst.options.renderer));
			// Add commands
			var addCommand = function(type, open, close, name, classes) {
				if (picker.indexOf('{' + type + ':' + name + '}') === -1) {
					return;
				}
				var command = inst.options.commands[name];
				var date = (inst.options.commandsAsDateFormat ? command.date.apply(elem, [inst]) : null);
				picker = picker.replace(new RegExp('\\{' + type + ':' + name + '\\}', 'g'),
					'<' + open + (command.status ? ' title="' + inst.options[command.status] + '"' : '') +
					' class="' + inst.options.renderer.commandClass + ' ' +
					inst.options.renderer.commandClass + '-' + name + ' ' + classes +
					(command.enabled(inst) ? '' : ' ' + inst.options.renderer.disabledClass) + '">' +
					(date ? date.formatDate(inst.options[command.text]) :
					inst.options[command.text]) + '</' + close + '>');
			};
			for (var name in inst.options.commands) {
				addCommand('button', 'button type="button"', 'button', name,
					inst.options.renderer.commandButtonClass);
				addCommand('link', 'a href="javascript:void(0)"', 'a', name,
					inst.options.renderer.commandLinkClass);
			}
			picker = $(picker);
			if (monthsToShow[1] > 1) {
				var count = 0;
				$(inst.options.renderer.monthSelector, picker).each(function() {
					var nth = ++count % monthsToShow[1];
					$(this).addClass(nth === 1 ? 'first' : (nth === 0 ? 'last' : ''));
				});
			}
			// Add datepicker behaviour
			var self = this;
			function removeHighlight() {
				(inst.inline ? $(this).closest('.' + self._getMarker()) : inst.div).
					find(inst.options.renderer.daySelector + ' a').
					removeClass(inst.options.renderer.highlightedClass);
			}
			picker.find(inst.options.renderer.daySelector + ' a').hover(
					function() {
						removeHighlight.apply(this);
						$(this).addClass(inst.options.renderer.highlightedClass);
					},
					removeHighlight).
				click(function() {
					self.selectDate(elem, this);
				}).end().
				find('select.' + this._monthYearClass + ':not(.' + this._anyYearClass + ')').
				change(function() {
					var monthYear = $(this).val().split('/');
					self.showMonth(elem, parseInt(monthYear[1], 10), parseInt(monthYear[0], 10));
				}).end().
				find('select.' + this._anyYearClass).click(function() {
					$(this).css('visibility', 'hidden').
						next('input').css({left: this.offsetLeft, top: this.offsetTop,
						width: this.offsetWidth, height: this.offsetHeight}).show().focus();
				}).end().
				find('input.' + self._monthYearClass).change(function() {
					try {
						var year = parseInt($(this).val(), 10);
						year = (isNaN(year) ? inst.drawDate.year() : year);
						self.showMonth(elem, year, inst.drawDate.month(), inst.drawDate.day());
					}
					catch (e) {
						alert(e);
					}
				}).keydown(function(event) {
					if (event.keyCode === 13) { // Enter
						$(event.elem).change();
					}
					else if (event.keyCode === 27) { // Escape
						$(event.elem).hide().prev('select').css('visibility', 'visible');
						inst.elem.focus();
					}
				});
			// Add keyboard handling
			var data = {elem: inst.elem[0]};
			picker.keydown(data, this._keyDown).keypress(data, this._keyPress).keyup(data, this._keyUp);
			// Add command behaviour
			picker.find('.' + inst.options.renderer.commandClass).click(function() {
					if (!$(this).hasClass(inst.options.renderer.disabledClass)) {
						var action = this.className.replace(
							new RegExp('^.*' + inst.options.renderer.commandClass + '-([^ ]+).*$'), '$1');
						plugin.performAction(elem, action);
					}
				});
			// Add classes
			if (inst.options.isRTL) {
				picker.addClass(inst.options.renderer.rtlClass);
			}
			if (monthsToShow[0] * monthsToShow[1] > 1) {
				picker.addClass(inst.options.renderer.multiClass);
			}
			if (inst.options.pickerClass) {
				picker.addClass(inst.options.pickerClass);
			}
			// Resize
			$('body').append(picker);
			var width = 0;
			picker.find(inst.options.renderer.monthSelector).each(function() {
				width += $(this).outerWidth();
			});
			picker.width(width / monthsToShow[0]);
			// Pre-show customisation
			if ($.isFunction(inst.options.onShow)) {
				inst.options.onShow.apply(elem, [picker, inst.options.calendar, inst]);
			}
			return picker;
		},

		/** Generate the content for a single month.
			@memberof CalendarsPicker
			@private
			@param elem {Element} The control to affect.
			@param inst {object} The current instance settings.
			@param year {number} The year to generate.
			@param month {number} The month to generate.
			@param calendar {BaseCalendar} The current calendar.
			@param renderer {object} The rendering templates.
			@param first {boolean} <code>true</code> if first of multiple months.
			@return {string} The month content. */
		_generateMonth: function(elem, inst, year, month, calendar, renderer, first) {
			var daysInMonth = calendar.daysInMonth(year, month);
			var monthsToShow = inst.options.monthsToShow;
			monthsToShow = ($.isArray(monthsToShow) ? monthsToShow : [1, monthsToShow]);
			var fixedWeeks = inst.options.fixedWeeks || (monthsToShow[0] * monthsToShow[1] > 1);
			var firstDay = inst.options.firstDay;
			firstDay = (firstDay == null ? calendar.local.firstDay : firstDay);
			var leadDays = (calendar.dayOfWeek(year, month, calendar.minDay) -
				firstDay + calendar.daysInWeek()) % calendar.daysInWeek();
			var numWeeks = (fixedWeeks ? 6 : Math.ceil((leadDays + daysInMonth) / calendar.daysInWeek()));
			var selectOtherMonths = inst.options.selectOtherMonths && inst.options.showOtherMonths;
			var minDate = (inst.pickingRange ? inst.selectedDates[0] : inst.get('minDate'));
			var maxDate = inst.get('maxDate');
			var showWeeks = renderer.week.indexOf('{weekOfYear}') > -1;
			var today = calendar.today();
			var drawDate = calendar.newDate(year, month, calendar.minDay);
			drawDate.add(-leadDays - (fixedWeeks &&
				(drawDate.dayOfWeek() === firstDay || drawDate.daysInMonth() < calendar.daysInWeek())?
				calendar.daysInWeek() : 0), 'd');
			var jd = drawDate.toJD();
			// Generate weeks
			var weeks = '';
			for (var week = 0; week < numWeeks; week++) {
				var weekOfYear = (!showWeeks ? '' : '<span class="jd' + jd + '">' +
					($.isFunction(inst.options.calculateWeek) ?
					inst.options.calculateWeek(drawDate) : drawDate.weekOfYear()) + '</span>');
				var days = '';
				for (var day = 0; day < calendar.daysInWeek(); day++) {
					var selected = false;
					if (inst.options.rangeSelect && inst.selectedDates.length > 0) {
						selected = (drawDate.compareTo(inst.selectedDates[0]) !== -1 &&
							drawDate.compareTo(inst.selectedDates[1]) !== +1)
					}
					else {
						for (var i = 0; i < inst.selectedDates.length; i++) {
							if (inst.selectedDates[i].compareTo(drawDate) === 0) {
								selected = true;
								break;
							}
						}
					}
					var dateInfo = (!$.isFunction(inst.options.onDate) ? {} :
						inst.options.onDate.apply(elem, [drawDate, drawDate.month() === month]));
					var selectable = (selectOtherMonths || drawDate.month() === month) &&
						this._isSelectable(elem, drawDate, dateInfo.selectable, minDate, maxDate);
					days += this._prepare(renderer.day, inst).replace(/\{day\}/g,
						(selectable ? '<a href="javascript:void(0)"' : '<span') +
						' class="jd' + jd + ' ' + (dateInfo.dateClass || '') +
						(selected && (selectOtherMonths || drawDate.month() === month) ?
						' ' + renderer.selectedClass : '') +
						(selectable ? ' ' + renderer.defaultClass : '') +
						(drawDate.weekDay() ? '' : ' ' + renderer.weekendClass) +
						(drawDate.month() === month ? '' : ' ' + renderer.otherMonthClass) +
						(drawDate.compareTo(today) === 0 && drawDate.month() === month ?
						' ' + renderer.todayClass : '') +
						(drawDate.compareTo(inst.drawDate) === 0 && drawDate.month() === month ?
						' ' + renderer.highlightedClass : '') + '"' +
						(dateInfo.title || (inst.options.dayStatus && selectable) ? ' title="' +
						(dateInfo.title || drawDate.formatDate(inst.options.dayStatus)) + '"' : '') + '>' +
						(inst.options.showOtherMonths || drawDate.month() === month ?
						dateInfo.content || drawDate.day() : '&#160;') +
						(selectable ? '</a>' : '</span>'));
					drawDate.add(1, 'd');
					jd++;
				}
				weeks += this._prepare(renderer.week, inst).replace(/\{days\}/g, days).
					replace(/\{weekOfYear\}/g, weekOfYear);
			}
			var monthHeader = this._prepare(renderer.month, inst).match(/\{monthHeader(:[^\}]+)?\}/);
			monthHeader = (monthHeader[0].length <= 13 ? 'MM yyyy' :
				monthHeader[0].substring(13, monthHeader[0].length - 1));
			monthHeader = (first ? this._generateMonthSelection(
				inst, year, month, minDate, maxDate, monthHeader, calendar, renderer) :
				calendar.formatDate(monthHeader, calendar.newDate(year, month, calendar.minDay)));
			var weekHeader = this._prepare(renderer.weekHeader, inst).
				replace(/\{days\}/g, this._generateDayHeaders(inst, calendar, renderer));
			return this._prepare(renderer.month, inst).replace(/\{monthHeader(:[^\}]+)?\}/g, monthHeader).
				replace(/\{weekHeader\}/g, weekHeader).replace(/\{weeks\}/g, weeks);
		},

		/** Generate the HTML for the day headers.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@param calendar {BaseCalendar} The current calendar.
			@param renderer {object} The rendering templates.
			@return {string} A week's worth of day headers. */
		_generateDayHeaders: function(inst, calendar, renderer) {
			var firstDay = inst.options.firstDay;
			firstDay = (firstDay == null ? calendar.local.firstDay : firstDay);
			var header = '';
			for (var day = 0; day < calendar.daysInWeek(); day++) {
				var dow = (day + firstDay) % calendar.daysInWeek();
				header += this._prepare(renderer.dayHeader, inst).replace(/\{day\}/g,
					'<span class="' + this._curDoWClass + dow + '" title="' +
					calendar.local.dayNames[dow] + '">' + calendar.local.dayNamesMin[dow] + '</span>');
			}
			return header;
		},

		/** Generate selection controls for month.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@param year {number} The year to generate.
			@param month {number} The month to generate.
			@param minDate {CDate} The minimum date allowed.
			@param maxDate {CDate} The maximum date allowed.
			@param monthHeader {string} The month/year format.
			@param calendar {BaseCalendar} The current calendar.
			@return {string} The month selection content. */
		_generateMonthSelection: function(inst, year, month, minDate, maxDate, monthHeader, calendar) {
			if (!inst.options.changeMonth) {
				return calendar.formatDate(monthHeader, calendar.newDate(year, month, 1));
			}
			// Months
			var monthNames = calendar.local[
				'monthNames' + (monthHeader.match(/mm/i) ? '' : 'Short')];
			var html = monthHeader.replace(/m+/i, '\\x2E').replace(/y+/i, '\\x2F');
			var selector = '<select class="' + this._monthYearClass +
				'" title="' + inst.options.monthStatus + '">';
			var maxMonth = calendar.monthsInYear(year) + calendar.minMonth;
			for (var m = calendar.minMonth; m < maxMonth; m++) {
				if ((!minDate || calendar.newDate(year, m,
						calendar.daysInMonth(year, m) - 1 + calendar.minDay).
						compareTo(minDate) !== -1) &&
						(!maxDate || calendar.newDate(year, m, calendar.minDay).
						compareTo(maxDate) !== +1)) {
					selector += '<option value="' + m + '/' + year + '"' +
						(month === m ? ' selected="selected"' : '') + '>' +
						monthNames[m - calendar.minMonth] + '</option>';
				}
			}
			selector += '</select>';
			html = html.replace(/\\x2E/, selector);
			// Years
			var yearRange = inst.options.yearRange;
			if (yearRange === 'any') {
				selector = '<select class="' + this._monthYearClass + ' ' + this._anyYearClass +
					'" title="' + inst.options.yearStatus + '">' +
					'<option>' + year + '</option></select>' +
					'<input class="' + this._monthYearClass + ' ' + this._curMonthClass +
					month + '" value="' + year + '">';
			}
			else {
				yearRange = yearRange.split(':');
				var todayYear = calendar.today().year();
				var start = (yearRange[0].match('c[+-].*') ? year + parseInt(yearRange[0].substring(1), 10) :
					((yearRange[0].match('[+-].*') ? todayYear : 0) + parseInt(yearRange[0], 10)));
				var end = (yearRange[1].match('c[+-].*') ? year + parseInt(yearRange[1].substring(1), 10) :
					((yearRange[1].match('[+-].*') ? todayYear : 0) + parseInt(yearRange[1], 10)));
				selector = '<select class="' + this._monthYearClass +
					'" title="' + inst.options.yearStatus + '">';
				start = calendar.newDate(start + 1, calendar.firstMonth, calendar.minDay).add(-1, 'd');
				end = calendar.newDate(end, calendar.firstMonth, calendar.minDay);
				var addYear = function(y, yDisplay) {
					if (y !== 0 || calendar.hasYearZero) {
						selector += '<option value="' +
							Math.min(month, calendar.monthsInYear(y) - 1 + calendar.minMonth) +
							'/' + y + '"' + (year === y ? ' selected="selected"' : '') + '>' +
							(yDisplay || y) + '</option>';
					}
				};
				if (start.toJD() < end.toJD()) {
					start = (minDate && minDate.compareTo(start) === +1 ? minDate : start).year();
					end = (maxDate && maxDate.compareTo(end) === -1 ? maxDate : end).year();
					var earlierLater = Math.floor((end - start) / 2);
					if (!minDate || minDate.year() < start) {
						addYear(start - earlierLater, inst.options.earlierText);
					}
					for (var y = start; y <= end; y++) {
						addYear(y);
					}
					if (!maxDate || maxDate.year() > end) {
						addYear(end + earlierLater, inst.options.laterText);
					}
				}
				else {
					start = (maxDate && maxDate.compareTo(start) === -1 ? maxDate : start).year();
					end = (minDate && minDate.compareTo(end) === +1 ? minDate : end).year();
					var earlierLater = Math.floor((start - end) / 2);
					if (!maxDate || maxDate.year() > start) {
						addYear(start + earlierLater, inst.options.earlierText);
					}
					for (var y = start; y >= end; y--) {
						addYear(y);
					}
					if (!minDate || minDate.year() < end) {
						addYear(end - earlierLater, inst.options.laterText);
					}
				}
				selector += '</select>';
			}
			html = html.replace(/\\x2F/, selector);
			return html;
		},

		/** Prepare a render template for use.
			Exclude popup/inline sections that are not applicable.
			Localise text of the form: {l10n:name}.
			@memberof CalendarsPicker
			@private
			@param text {string} The text to localise.
			@param inst {object} The current instance settings.
			@return {string} The localised text. */
		_prepare: function(text, inst) {
			var replaceSection = function(type, retain) {
				while (true) {
					var start = text.indexOf('{' + type + ':start}');
					if (start === -1) {
						return;
					}
					var end = text.substring(start).indexOf('{' + type + ':end}');
					if (end > -1) {
						text = text.substring(0, start) +
							(retain ? text.substr(start + type.length + 8, end - type.length - 8) : '') +
							text.substring(start + end + type.length + 6);
					}
				}
			};
			replaceSection('inline', inst.inline);
			replaceSection('popup', !inst.inline);
			var pattern = /\{l10n:([^\}]+)\}/;
			var matches = null;
			while (matches = pattern.exec(text)) {
				text = text.replace(matches[0], inst.options[matches[1]]);
			}
			return text;
		}
	});

	var plugin = $.calendarsPicker; // Singleton instance

	$(function() {
		$(document).on('mousedown.' + pluginName, plugin._checkExternalClick).
			on('resize.' + pluginName, function() { plugin.hide(plugin.curInst); });
	});

})(jQuery);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5jYWxlbmRhcnMuYWxsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxBQUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoianF1ZXJ5LmNhbGVuZGFycy5hbGwuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBodHRwOi8va2VpdGgtd29vZC5uYW1lL2NhbGVuZGFycy5odG1sXHJcbiAgIENhbGVuZGFycyBmb3IgalF1ZXJ5IHYyLjAuMS5cclxuICAgV3JpdHRlbiBieSBLZWl0aCBXb29kIChrYndvb2R7YXR9aWluZXQuY29tLmF1KSBBdWd1c3QgMjAwOS5cclxuICAgQXZhaWxhYmxlIHVuZGVyIHRoZSBNSVQgKGh0dHA6Ly9rZWl0aC13b29kLm5hbWUvbGljZW5jZS5odG1sKSBsaWNlbnNlLiBcclxuICAgUGxlYXNlIGF0dHJpYnV0ZSB0aGUgYXV0aG9yIGlmIHlvdSB1c2UgaXQuICovXHJcblxyXG4oZnVuY3Rpb24oJCkgeyAvLyBIaWRlIHNjb3BlLCBubyAkIGNvbmZsaWN0XHJcblxyXG5cdGZ1bmN0aW9uIENhbGVuZGFycygpIHtcclxuXHRcdHRoaXMucmVnaW9uYWxPcHRpb25zID0gW107XHJcblx0XHR0aGlzLnJlZ2lvbmFsT3B0aW9uc1snJ10gPSB7XHJcblx0XHRcdGludmFsaWRDYWxlbmRhcjogJ0NhbGVuZGFyIHswfSBub3QgZm91bmQnLFxyXG5cdFx0XHRpbnZhbGlkRGF0ZTogJ0ludmFsaWQgezB9IGRhdGUnLFxyXG5cdFx0XHRpbnZhbGlkTW9udGg6ICdJbnZhbGlkIHswfSBtb250aCcsXHJcblx0XHRcdGludmFsaWRZZWFyOiAnSW52YWxpZCB7MH0geWVhcicsXHJcblx0XHRcdGRpZmZlcmVudENhbGVuZGFyczogJ0Nhbm5vdCBtaXggezB9IGFuZCB7MX0gZGF0ZXMnXHJcblx0XHR9O1xyXG5cdFx0dGhpcy5sb2NhbCA9IHRoaXMucmVnaW9uYWxPcHRpb25zWycnXTtcclxuXHRcdHRoaXMuY2FsZW5kYXJzID0ge307XHJcblx0XHR0aGlzLl9sb2NhbENhbHMgPSB7fTtcclxuXHR9XHJcblxyXG5cdC8qKiBDcmVhdGUgdGhlIGNhbGVuZGFycyBwbHVnaW4uXHJcblx0XHQ8cD5Qcm92aWRlcyBzdXBwb3J0IGZvciB2YXJpb3VzIHdvcmxkIGNhbGVuZGFycyBpbiBhIGNvbnNpc3RlbnQgbWFubmVyLjwvcD5cclxuXHQgXHRAY2xhc3MgQ2FsZW5kYXJzXHJcblx0XHRAZXhhbXBsZSAkLmNhbGVuZGFycy5pbnN0YW5jZSgnanVsaWFuJykubmV3RGF0ZSgyMDE0LCAxMiwgMjUpICovXHJcblx0JC5leHRlbmQoQ2FsZW5kYXJzLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdC8qKiBPYnRhaW4gYSBjYWxlbmRhciBpbXBsZW1lbnRhdGlvbiBhbmQgbG9jYWxpc2F0aW9uLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzXHJcblx0XHRcdEBwYXJhbSBbbmFtZT0nZ3JlZ29yaWFuJ10ge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGNhbGVuZGFyLCBlLmcuICdncmVnb3JpYW4nLCAncGVyc2lhbicsICdpc2xhbWljJy5cclxuXHRcdFx0QHBhcmFtIFtsYW5ndWFnZT0nJ10ge3N0cmluZ30gVGhlIGxhbmd1YWdlIGNvZGUgdG8gdXNlIGZvciBsb2NhbGlzYXRpb24gKGRlZmF1bHQgaXMgRW5nbGlzaCkuXHJcblx0XHRcdEByZXR1cm4ge0NhbGVuZGFyfSBUaGUgY2FsZW5kYXIgYW5kIGxvY2FsaXNhdGlvbi5cclxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBjYWxlbmRhciBub3QgZm91bmQuICovXHJcblx0XHRpbnN0YW5jZTogZnVuY3Rpb24obmFtZSwgbGFuZ3VhZ2UpIHtcclxuXHRcdFx0bmFtZSA9IChuYW1lIHx8ICdncmVnb3JpYW4nKS50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0XHRsYW5ndWFnZSA9IGxhbmd1YWdlIHx8ICcnO1xyXG5cdFx0XHR2YXIgY2FsID0gdGhpcy5fbG9jYWxDYWxzW25hbWUgKyAnLScgKyBsYW5ndWFnZV07XHJcblx0XHRcdGlmICghY2FsICYmIHRoaXMuY2FsZW5kYXJzW25hbWVdKSB7XHJcblx0XHRcdFx0Y2FsID0gbmV3IHRoaXMuY2FsZW5kYXJzW25hbWVdKGxhbmd1YWdlKTtcclxuXHRcdFx0XHR0aGlzLl9sb2NhbENhbHNbbmFtZSArICctJyArIGxhbmd1YWdlXSA9IGNhbDtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIWNhbCkge1xyXG5cdFx0XHRcdHRocm93ICh0aGlzLmxvY2FsLmludmFsaWRDYWxlbmRhciB8fCB0aGlzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZENhbGVuZGFyKS5cclxuXHRcdFx0XHRcdHJlcGxhY2UoL1xcezBcXH0vLCBuYW1lKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gY2FsO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQ3JlYXRlIGEgbmV3IGRhdGUgLSBmb3IgdG9kYXkgaWYgbm8gb3RoZXIgcGFyYW1ldGVycyBnaXZlbi5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1xyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBjb3B5IG9yIHRoZSB5ZWFyIGZvciB0aGUgZGF0ZS5cclxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIGZvciB0aGUgZGF0ZS5cclxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgZm9yIHRoZSBkYXRlLlxyXG5cdFx0XHRAcGFyYW0gW2NhbGVuZGFyPSdncmVnb3JpYW4nXSB7QmFzZUNhbGVuZGFyfHN0cmluZ30gVGhlIHVuZGVybHlpbmcgY2FsZW5kYXIgb3IgdGhlIG5hbWUgb2YgdGhlIGNhbGVuZGFyLlxyXG5cdFx0XHRAcGFyYW0gW2xhbmd1YWdlPScnXSB7c3RyaW5nfSBUaGUgbGFuZ3VhZ2UgdG8gdXNlIGZvciBsb2NhbGlzYXRpb24gKGRlZmF1bHQgRW5nbGlzaCkuXHJcblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgbmV3IGRhdGUuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlLiAqL1xyXG5cdFx0bmV3RGF0ZTogZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSwgY2FsZW5kYXIsIGxhbmd1YWdlKSB7XHJcblx0XHRcdGNhbGVuZGFyID0gKHllYXIgIT0gbnVsbCAmJiB5ZWFyLnllYXIgPyB5ZWFyLmNhbGVuZGFyKCkgOiAodHlwZW9mIGNhbGVuZGFyID09PSAnc3RyaW5nJyA/XHJcblx0XHRcdFx0dGhpcy5pbnN0YW5jZShjYWxlbmRhciwgbGFuZ3VhZ2UpIDogY2FsZW5kYXIpKSB8fCB0aGlzLmluc3RhbmNlKCk7XHJcblx0XHRcdHJldHVybiBjYWxlbmRhci5uZXdEYXRlKHllYXIsIG1vbnRoLCBkYXkpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvKiogR2VuZXJpYyBkYXRlLCBiYXNlZCBvbiBhIHBhcnRpY3VsYXIgY2FsZW5kYXIuXHJcblx0XHRAY2xhc3MgQ0RhdGVcclxuXHRcdEBwYXJhbSBjYWxlbmRhciB7QmFzZUNhbGVuZGFyfSBUaGUgdW5kZXJseWluZyBjYWxlbmRhciBpbXBsZW1lbnRhdGlvbi5cclxuXHRcdEBwYXJhbSB5ZWFyIHtudW1iZXJ9IFRoZSB5ZWFyIGZvciB0aGlzIGRhdGUuXHJcblx0XHRAcGFyYW0gbW9udGgge251bWJlcn0gVGhlIG1vbnRoIGZvciB0aGlzIGRhdGUuXHJcblx0XHRAcGFyYW0gZGF5IHtudW1iZXJ9IFRoZSBkYXkgZm9yIHRoaXMgZGF0ZS5cclxuXHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgZGF0ZSBvYmplY3QuXHJcblx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZS4gKi9cclxuXHRmdW5jdGlvbiBDRGF0ZShjYWxlbmRhciwgeWVhciwgbW9udGgsIGRheSkge1xyXG5cdFx0dGhpcy5fY2FsZW5kYXIgPSBjYWxlbmRhcjtcclxuXHRcdHRoaXMuX3llYXIgPSB5ZWFyO1xyXG5cdFx0dGhpcy5fbW9udGggPSBtb250aDtcclxuXHRcdHRoaXMuX2RheSA9IGRheTtcclxuXHRcdGlmICh0aGlzLl9jYWxlbmRhci5fdmFsaWRhdGVMZXZlbCA9PT0gMCAmJlxyXG5cdFx0XHRcdCF0aGlzLl9jYWxlbmRhci5pc1ZhbGlkKHRoaXMuX3llYXIsIHRoaXMuX21vbnRoLCB0aGlzLl9kYXkpKSB7XHJcblx0XHRcdHRocm93ICgkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWREYXRlKS5cclxuXHRcdFx0XHRyZXBsYWNlKC9cXHswXFx9LywgdGhpcy5fY2FsZW5kYXIubG9jYWwubmFtZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKiogUGFkIGEgbnVtZXJpYyB2YWx1ZSB3aXRoIGxlYWRpbmcgemVyb2VzLlxyXG5cdFx0QHByaXZhdGVcclxuXHRcdEBwYXJhbSB2YWx1ZSB7bnVtYmVyfSBUaGUgbnVtYmVyIHRvIGZvcm1hdC5cclxuXHRcdEBwYXJhbSBsZW5ndGgge251bWJlcn0gVGhlIG1pbmltdW0gbGVuZ3RoLlxyXG5cdFx0QHJldHVybiB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIG51bWJlci4gKi9cclxuXHRmdW5jdGlvbiBwYWQodmFsdWUsIGxlbmd0aCkge1xyXG5cdFx0dmFsdWUgPSAnJyArIHZhbHVlO1xyXG5cdFx0cmV0dXJuICcwMDAwMDAnLnN1YnN0cmluZygwLCBsZW5ndGggLSB2YWx1ZS5sZW5ndGgpICsgdmFsdWU7XHJcblx0fVxyXG5cclxuXHQkLmV4dGVuZChDRGF0ZS5wcm90b3R5cGUsIHtcclxuXHJcblx0XHQvKiogQ3JlYXRlIGEgbmV3IGRhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxyXG5cdFx0XHRAcGFyYW0gW3llYXJdIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGNvcHkgb3IgdGhlIHllYXIgZm9yIHRoZSBkYXRlIChkZWZhdWx0IHRoaXMgZGF0ZSkuXHJcblx0XHRcdEBwYXJhbSBbbW9udGhdIHtudW1iZXJ9IFRoZSBtb250aCBmb3IgdGhlIGRhdGUuXHJcblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IGZvciB0aGUgZGF0ZS5cclxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBuZXcgZGF0ZS5cclxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUuICovXHJcblx0XHRuZXdEYXRlOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5uZXdEYXRlKCh5ZWFyID09IG51bGwgPyB0aGlzIDogeWVhciksIG1vbnRoLCBkYXkpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogU2V0IG9yIHJldHJpZXZlIHRoZSB5ZWFyIGZvciB0aGlzIGRhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxyXG5cdFx0XHRAcGFyYW0gW3llYXJdIHtudW1iZXJ9IFRoZSB5ZWFyIGZvciB0aGUgZGF0ZS5cclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfENEYXRlfSBUaGUgZGF0ZSdzIHllYXIgKGlmIG5vIHBhcmFtZXRlcikgb3IgdGhlIHVwZGF0ZWQgZGF0ZS5cclxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUuICovXHJcblx0XHR5ZWFyOiBmdW5jdGlvbih5ZWFyKSB7XHJcblx0XHRcdHJldHVybiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCA/IHRoaXMuX3llYXIgOiB0aGlzLnNldCh5ZWFyLCAneScpKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFNldCBvciByZXRyaWV2ZSB0aGUgbW9udGggZm9yIHRoaXMgZGF0ZS5cclxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXHJcblx0XHRcdEBwYXJhbSBbbW9udGhdIHtudW1iZXJ9IFRoZSBtb250aCBmb3IgdGhlIGRhdGUuXHJcblx0XHRcdEByZXR1cm4ge251bWJlcnxDRGF0ZX0gVGhlIGRhdGUncyBtb250aCAoaWYgbm8gcGFyYW1ldGVyKSBvciB0aGUgdXBkYXRlZCBkYXRlLlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZS4gKi9cclxuXHRcdG1vbnRoOiBmdW5jdGlvbihtb250aCkge1xyXG5cdFx0XHRyZXR1cm4gKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgPyB0aGlzLl9tb250aCA6IHRoaXMuc2V0KG1vbnRoLCAnbScpKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFNldCBvciByZXRyaWV2ZSB0aGUgZGF5IGZvciB0aGlzIGRhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxyXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSBmb3IgdGhlIGRhdGUuXHJcblx0XHRcdEByZXR1cm4ge251bWJlcnxDRGF0YX0gVGhlIGRhdGUncyBkYXkgKGlmIG5vIHBhcmFtZXRlcikgb3IgdGhlIHVwZGF0ZWQgZGF0ZS5cclxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUuICovXHJcblx0XHRkYXk6IGZ1bmN0aW9uKGRheSkge1xyXG5cdFx0XHRyZXR1cm4gKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgPyB0aGlzLl9kYXkgOiB0aGlzLnNldChkYXksICdkJykpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogU2V0IG5ldyB2YWx1ZXMgZm9yIHRoaXMgZGF0ZS5cclxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtudW1iZXJ9IFRoZSB5ZWFyIGZvciB0aGUgZGF0ZS5cclxuXHRcdFx0QHBhcmFtIG1vbnRoIHtudW1iZXJ9IFRoZSBtb250aCBmb3IgdGhlIGRhdGUuXHJcblx0XHRcdEBwYXJhbSBkYXkge251bWJlcn0gVGhlIGRheSBmb3IgdGhlIGRhdGUuXHJcblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgdXBkYXRlZCBkYXRlLlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZS4gKi9cclxuXHRcdGRhdGU6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcclxuXHRcdFx0aWYgKCF0aGlzLl9jYWxlbmRhci5pc1ZhbGlkKHllYXIsIG1vbnRoLCBkYXkpKSB7XHJcblx0XHRcdFx0dGhyb3cgKCQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWREYXRlIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZERhdGUpLlxyXG5cdFx0XHRcdFx0cmVwbGFjZSgvXFx7MFxcfS8sIHRoaXMuX2NhbGVuZGFyLmxvY2FsLm5hbWUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX3llYXIgPSB5ZWFyO1xyXG5cdFx0XHR0aGlzLl9tb250aCA9IG1vbnRoO1xyXG5cdFx0XHR0aGlzLl9kYXkgPSBkYXk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBkYXRlIGlzIGluIGEgbGVhcCB5ZWFyLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcclxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhpcyBpcyBhIGxlYXAgeWVhciwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdC4gKi9cclxuXHRcdGxlYXBZZWFyOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbGVuZGFyLmxlYXBZZWFyKHRoaXMpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIGVwb2NoIGRlc2lnbmF0b3IgZm9yIHRoaXMgZGF0ZSwgZS5nLiBCQ0Ugb3IgQ0UuXHJcblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxyXG5cdFx0XHRAcmV0dXJuIHtzdHJpbmd9IFRoZSBjdXJyZW50IGVwb2NoLiAqL1xyXG5cdFx0ZXBvY2g6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIuZXBvY2godGhpcyk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBGb3JtYXQgdGhlIHllYXIsIGlmIG5vdCBhIHNpbXBsZSBzZXF1ZW50aWFsIG51bWJlci5cclxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXHJcblx0XHRcdEByZXR1cm4ge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB5ZWFyLiAqL1xyXG5cdFx0Zm9ybWF0WWVhcjogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5mb3JtYXRZZWFyKHRoaXMpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIG1vbnRoIG9mIHRoZSB5ZWFyIGZvciB0aGlzIGRhdGUsXHJcblx0XHRcdGkuZS4gdGhlIG1vbnRoJ3MgcG9zaXRpb24gd2l0aGluIGEgbnVtYmVyZWQgeWVhci5cclxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXHJcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIG1vbnRoIG9mIHRoZSB5ZWFyOiA8Y29kZT5taW5Nb250aDwvY29kZT4gdG8gbW9udGhzIHBlciB5ZWFyLiAqL1xyXG5cdFx0bW9udGhPZlllYXI6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIubW9udGhPZlllYXIodGhpcyk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgd2VlayBvZiB0aGUgeWVhciBmb3IgdGhpcyBkYXRlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgd2VlayBvZiB0aGUgeWVhcjogMSB0byB3ZWVrcyBwZXIgeWVhci4gKi9cclxuXHRcdHdlZWtPZlllYXI6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIud2Vla09mWWVhcih0aGlzKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGUgeWVhciBmb3IgdGhpcyBkYXRlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGRheXMgaW4gdGhpcyB5ZWFyLiAqL1xyXG5cdFx0ZGF5c0luWWVhcjogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5kYXlzSW5ZZWFyKHRoaXMpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIGRheSBvZiB0aGUgeWVhciBmb3IgdGhpcyBkYXRlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgZGF5IG9mIHRoZSB5ZWFyOiAxIHRvIGRheXMgcGVyIHllYXIuICovXHJcblx0XHRkYXlPZlllYXI6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIuZGF5T2ZZZWFyKHRoaXMpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoZSBtb250aCBmb3IgdGhpcyBkYXRlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGRheXMuICovXHJcblx0XHRkYXlzSW5Nb250aDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5kYXlzSW5Nb250aCh0aGlzKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBkYXkgb2YgdGhlIHdlZWsgZm9yIHRoaXMgZGF0ZS5cclxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXHJcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIGRheSBvZiB0aGUgd2VlazogMCB0byBudW1iZXIgb2YgZGF5cyAtIDEuICovXHJcblx0XHRkYXlPZldlZWs6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIuZGF5T2ZXZWVrKHRoaXMpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBkYXRlIGlzIGEgd2VlayBkYXkuXHJcblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxyXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBhIHdlZWsgZGF5LCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90LiAqL1xyXG5cdFx0d2Vla0RheTogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci53ZWVrRGF5KHRoaXMpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIGRhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxyXG5cdFx0XHRAcmV0dXJuIHtvYmplY3R9IEFkZGl0aW9uYWwgaW5mb3JtYXRpb24gLSBjb250ZW50cyBkZXBlbmRzIG9uIGNhbGVuZGFyLiAqL1xyXG5cdFx0ZXh0cmFJbmZvOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbGVuZGFyLmV4dHJhSW5mbyh0aGlzKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEFkZCBwZXJpb2QocykgdG8gYSBkYXRlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcclxuXHRcdFx0QHBhcmFtIG9mZnNldCB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHBlcmlvZHMgdG8gYWRqdXN0IGJ5LlxyXG5cdFx0XHRAcGFyYW0gcGVyaW9kIHtzdHJpbmd9IE9uZSBvZiAneScgZm9yIHllYXIsICdtJyBmb3IgbW9udGgsICd3JyBmb3Igd2VlaywgJ2QnIGZvciBkYXkuXHJcblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgdXBkYXRlZCBkYXRlLiAqL1xyXG5cdFx0YWRkOiBmdW5jdGlvbihvZmZzZXQsIHBlcmlvZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIuYWRkKHRoaXMsIG9mZnNldCwgcGVyaW9kKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFNldCBhIHBvcnRpb24gb2YgdGhlIGRhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxyXG5cdFx0XHRAcGFyYW0gdmFsdWUge251bWJlcn0gVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHBlcmlvZC5cclxuXHRcdFx0QHBhcmFtIHBlcmlvZCB7c3RyaW5nfSBPbmUgb2YgJ3knIGZvciB5ZWFyLCAnbScgZm9yIG1vbnRoLCAnZCcgZm9yIGRheS5cclxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSB1cGRhdGVkIGRhdGUuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgbm90IGEgdmFsaWQgZGF0ZS4gKi9cclxuXHRcdHNldDogZnVuY3Rpb24odmFsdWUsIHBlcmlvZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIuc2V0KHRoaXMsIHZhbHVlLCBwZXJpb2QpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQ29tcGFyZSB0aGlzIGRhdGUgdG8gYW5vdGhlciBkYXRlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcclxuXHRcdFx0QHBhcmFtIGRhdGUge0NEYXRlfSBUaGUgb3RoZXIgZGF0ZS5cclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSAtMSBpZiB0aGlzIGRhdGUgaXMgYmVmb3JlIHRoZSBvdGhlciBkYXRlLFxyXG5cdFx0XHRcdFx0MCBpZiB0aGV5IGFyZSBlcXVhbCwgb3IgKzEgaWYgdGhpcyBkYXRlIGlzIGFmdGVyIHRoZSBvdGhlciBkYXRlLiAqL1xyXG5cdFx0Y29tcGFyZVRvOiBmdW5jdGlvbihkYXRlKSB7XHJcblx0XHRcdGlmICh0aGlzLl9jYWxlbmRhci5uYW1lICE9PSBkYXRlLl9jYWxlbmRhci5uYW1lKSB7XHJcblx0XHRcdFx0dGhyb3cgKCQuY2FsZW5kYXJzLmxvY2FsLmRpZmZlcmVudENhbGVuZGFycyB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmRpZmZlcmVudENhbGVuZGFycykuXHJcblx0XHRcdFx0XHRyZXBsYWNlKC9cXHswXFx9LywgdGhpcy5fY2FsZW5kYXIubG9jYWwubmFtZSkucmVwbGFjZSgvXFx7MVxcfS8sIGRhdGUuX2NhbGVuZGFyLmxvY2FsLm5hbWUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBjID0gKHRoaXMuX3llYXIgIT09IGRhdGUuX3llYXIgPyB0aGlzLl95ZWFyIC0gZGF0ZS5feWVhciA6XHJcblx0XHRcdFx0dGhpcy5fbW9udGggIT09IGRhdGUuX21vbnRoID8gdGhpcy5tb250aE9mWWVhcigpIC0gZGF0ZS5tb250aE9mWWVhcigpIDpcclxuXHRcdFx0XHR0aGlzLl9kYXkgLSBkYXRlLl9kYXkpO1xyXG5cdFx0XHRyZXR1cm4gKGMgPT09IDAgPyAwIDogKGMgPCAwID8gLTEgOiArMSkpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIGNhbGVuZGFyIGJhY2tpbmcgdGhpcyBkYXRlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcclxuXHRcdFx0QHJldHVybiB7QmFzZUNhbGVuZGFyfSBUaGUgY2FsZW5kYXIgaW1wbGVtZW50YXRpb24uICovXHJcblx0XHRjYWxlbmRhcjogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhcjtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBKdWxpYW4gZGF0ZSBlcXVpdmFsZW50IGZvciB0aGlzIGRhdGUsXHJcblx0XHRcdGkuZS4gZGF5cyBzaW5jZSBKYW51YXJ5IDEsIDQ3MTMgQkNFIEdyZWVud2ljaCBub29uLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgZXF1aXZhbGVudCBKdWxpYW4gZGF0ZS4gKi9cclxuXHRcdHRvSkQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIudG9KRCh0aGlzKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIENyZWF0ZSBhIG5ldyBkYXRlIGZyb20gYSBKdWxpYW4gZGF0ZS5cclxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXHJcblx0XHRcdEBwYXJhbSBqZCB7bnVtYmVyfSBUaGUgSnVsaWFuIGRhdGUgdG8gY29udmVydC5cclxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBlcXVpdmFsZW50IGRhdGUuICovXHJcblx0XHRmcm9tSkQ6IGZ1bmN0aW9uKGpkKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5mcm9tSkQoamQpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQ29udmVydCB0aGlzIGRhdGUgdG8gYSBzdGFuZGFyZCAoR3JlZ29yaWFuKSBKYXZhU2NyaXB0IERhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxyXG5cdFx0XHRAcmV0dXJuIHtEYXRlfSBUaGUgZXF1aXZhbGVudCBKYXZhU2NyaXB0IGRhdGUuICovXHJcblx0XHR0b0pTRGF0ZTogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci50b0pTRGF0ZSh0aGlzKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIENyZWF0ZSBhIG5ldyBkYXRlIGZyb20gYSBzdGFuZGFyZCAoR3JlZ29yaWFuKSBKYXZhU2NyaXB0IERhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxyXG5cdFx0XHRAcGFyYW0ganNkIHtEYXRlfSBUaGUgSmF2YVNjcmlwdCBkYXRlIHRvIGNvbnZlcnQuXHJcblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgZXF1aXZhbGVudCBkYXRlLiAqL1xyXG5cdFx0ZnJvbUpTRGF0ZTogZnVuY3Rpb24oanNkKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5mcm9tSlNEYXRlKGpzZCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBDb252ZXJ0IHRvIGEgc3RyaW5nIGZvciBkaXNwbGF5LlxyXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcclxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGlzIGRhdGUgYXMgYSBzdHJpbmcuICovXHJcblx0XHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiAodGhpcy55ZWFyKCkgPCAwID8gJy0nIDogJycpICsgcGFkKE1hdGguYWJzKHRoaXMueWVhcigpKSwgNCkgK1xyXG5cdFx0XHRcdCctJyArIHBhZCh0aGlzLm1vbnRoKCksIDIpICsgJy0nICsgcGFkKHRoaXMuZGF5KCksIDIpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvKiogQmFzaWMgZnVuY3Rpb25hbGl0eSBmb3IgYWxsIGNhbGVuZGFycy5cclxuXHRcdE90aGVyIGNhbGVuZGFycyBzaG91bGQgZXh0ZW5kIHRoaXM6XHJcblx0XHQ8cHJlPk90aGVyQ2FsZW5kYXIucHJvdG90eXBlID0gbmV3IEJhc2VDYWxlbmRhcjs8L3ByZT5cclxuXHRcdEBjbGFzcyBCYXNlQ2FsZW5kYXIgKi9cclxuXHRmdW5jdGlvbiBCYXNlQ2FsZW5kYXIoKSB7XHJcblx0XHR0aGlzLnNob3J0WWVhckN1dG9mZiA9ICcrMTAnO1xyXG5cdH1cclxuXHJcblx0JC5leHRlbmQoQmFzZUNhbGVuZGFyLnByb3RvdHlwZSwge1xyXG5cdFx0X3ZhbGlkYXRlTGV2ZWw6IDAsIC8vIFwiU3RhY2tcIiB0byB0dXJuIHZhbGlkYXRpb24gb24vb2ZmXHJcblxyXG5cdFx0LyoqIENyZWF0ZSBhIG5ldyBkYXRlIHdpdGhpbiB0aGlzIGNhbGVuZGFyIC0gdG9kYXkgaWYgbm8gcGFyYW1ldGVycyBnaXZlbi5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBkdXBsaWNhdGUgb3IgdGhlIHllYXIgZm9yIHRoZSBkYXRlLlxyXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggZm9yIHRoZSBkYXRlLlxyXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSBmb3IgdGhlIGRhdGUuXHJcblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgbmV3IGRhdGUuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgbm90IGEgdmFsaWQgZGF0ZSBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0bmV3RGF0ZTogZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSkge1xyXG5cdFx0XHRpZiAoeWVhciA9PSBudWxsKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMudG9kYXkoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoeWVhci55ZWFyKSB7XHJcblx0XHRcdFx0dGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIGRheSxcclxuXHRcdFx0XHRcdCQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWREYXRlIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZERhdGUpO1xyXG5cdFx0XHRcdGRheSA9IHllYXIuZGF5KCk7XHJcblx0XHRcdFx0bW9udGggPSB5ZWFyLm1vbnRoKCk7XHJcblx0XHRcdFx0eWVhciA9IHllYXIueWVhcigpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBuZXcgQ0RhdGUodGhpcywgeWVhciwgbW9udGgsIGRheSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBDcmVhdGUgYSBuZXcgZGF0ZSBmb3IgdG9kYXkuXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcclxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRvZGF5J3MgZGF0ZS4gKi9cclxuXHRcdHRvZGF5OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZnJvbUpTRGF0ZShuZXcgRGF0ZSgpKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBlcG9jaCBkZXNpZ25hdG9yIGZvciB0aGlzIGRhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciB0byBleGFtaW5lLlxyXG5cdFx0XHRAcmV0dXJuIHtzdHJpbmd9IFRoZSBjdXJyZW50IGVwb2NoLlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgeWVhciBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0ZXBvY2g6IGZ1bmN0aW9uKHllYXIpIHtcclxuXHRcdFx0dmFyIGRhdGUgPSB0aGlzLl92YWxpZGF0ZSh5ZWFyLCB0aGlzLm1pbk1vbnRoLCB0aGlzLm1pbkRheSxcclxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkWWVhciB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWRZZWFyKTtcclxuXHRcdFx0cmV0dXJuIChkYXRlLnllYXIoKSA8IDAgPyB0aGlzLmxvY2FsLmVwb2Noc1swXSA6IHRoaXMubG9jYWwuZXBvY2hzWzFdKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEZvcm1hdCB0aGUgeWVhciwgaWYgbm90IGEgc2ltcGxlIHNlcXVlbnRpYWwgbnVtYmVyXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZm9ybWF0IG9yIHRoZSB5ZWFyIHRvIGZvcm1hdC5cclxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHllYXIuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCB5ZWFyIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXHJcblx0XHRmb3JtYXRZZWFyOiBmdW5jdGlvbih5ZWFyKSB7XHJcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgdGhpcy5taW5Nb250aCwgdGhpcy5taW5EYXksXHJcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZFllYXIgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkWWVhcik7XHJcblx0XHRcdHJldHVybiAoZGF0ZS55ZWFyKCkgPCAwID8gJy0nIDogJycpICsgcGFkKE1hdGguYWJzKGRhdGUueWVhcigpKSwgNClcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBudW1iZXIgb2YgbW9udGhzIGluIGEgeWVhci5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXHJcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBtb250aHMuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCB5ZWFyIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXHJcblx0XHRtb250aHNJblllYXI6IGZ1bmN0aW9uKHllYXIpIHtcclxuXHRcdFx0dGhpcy5fdmFsaWRhdGUoeWVhciwgdGhpcy5taW5Nb250aCwgdGhpcy5taW5EYXksXHJcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZFllYXIgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkWWVhcik7XHJcblx0XHRcdHJldHVybiAxMjtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIENhbGN1bGF0ZSB0aGUgbW9udGgncyBvcmRpbmFsIHBvc2l0aW9uIHdpdGhpbiB0aGUgeWVhciAtXHJcblx0XHRcdGZvciB0aG9zZSBjYWxlbmRhcnMgdGhhdCBkb24ndCBzdGFydCBhdCBtb250aCAxIVxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGV4YW1pbmUgb3IgdGhlIHllYXIgdG8gZXhhbWluZS5cclxuXHRcdFx0QHBhcmFtIG1vbnRoIHtudW1iZXJ9IFRoZSBtb250aCB0byBleGFtaW5lLlxyXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBvcmRpbmFsIHBvc2l0aW9uLCBzdGFydGluZyBmcm9tIDxjb2RlPm1pbk1vbnRoPC9jb2RlPi5cclxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIHllYXIvbW9udGggb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cclxuXHRcdG1vbnRoT2ZZZWFyOiBmdW5jdGlvbih5ZWFyLCBtb250aCkge1xyXG5cdFx0XHR2YXIgZGF0ZSA9IHRoaXMuX3ZhbGlkYXRlKHllYXIsIG1vbnRoLCB0aGlzLm1pbkRheSxcclxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkTW9udGggfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkTW9udGgpO1xyXG5cdFx0XHRyZXR1cm4gKGRhdGUubW9udGgoKSArIHRoaXMubW9udGhzSW5ZZWFyKGRhdGUpIC0gdGhpcy5maXJzdE1vbnRoKSAlXHJcblx0XHRcdFx0dGhpcy5tb250aHNJblllYXIoZGF0ZSkgKyB0aGlzLm1pbk1vbnRoO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQ2FsY3VsYXRlIGFjdHVhbCBtb250aCBmcm9tIG9yZGluYWwgcG9zaXRpb24sIHN0YXJ0aW5nIGZyb20gbWluTW9udGguXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIHllYXIge251bWJlcn0gVGhlIHllYXIgdG8gZXhhbWluZS5cclxuXHRcdFx0QHBhcmFtIG9yZCB7bnVtYmVyfSBUaGUgbW9udGgncyBvcmRpbmFsIHBvc2l0aW9uLlxyXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBtb250aCdzIG51bWJlci5cclxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIHllYXIvbW9udGguICovXHJcblx0XHRmcm9tTW9udGhPZlllYXI6IGZ1bmN0aW9uKHllYXIsIG9yZCkge1xyXG5cdFx0XHR2YXIgbSA9IChvcmQgKyB0aGlzLmZpcnN0TW9udGggLSAyICogdGhpcy5taW5Nb250aCkgJVxyXG5cdFx0XHRcdHRoaXMubW9udGhzSW5ZZWFyKHllYXIpICsgdGhpcy5taW5Nb250aDtcclxuXHRcdFx0dGhpcy5fdmFsaWRhdGUoeWVhciwgbSwgdGhpcy5taW5EYXksXHJcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZE1vbnRoIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZE1vbnRoKTtcclxuXHRcdFx0cmV0dXJuIG07XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgbnVtYmVyIG9mIGRheXMgaW4gYSB5ZWFyLlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGV4YW1pbmUgb3IgdGhlIHllYXIgdG8gZXhhbWluZS5cclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGRheXMuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCB5ZWFyIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXHJcblx0XHRkYXlzSW5ZZWFyOiBmdW5jdGlvbih5ZWFyKSB7XHJcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgdGhpcy5taW5Nb250aCwgdGhpcy5taW5EYXksXHJcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZFllYXIgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkWWVhcik7XHJcblx0XHRcdHJldHVybiAodGhpcy5sZWFwWWVhcihkYXRlKSA/IDM2NiA6IDM2NSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgZGF5IG9mIHRoZSB5ZWFyIGZvciBhIGRhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gY29udmVydCBvciB0aGUgeWVhciB0byBjb252ZXJ0LlxyXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gY29udmVydC5cclxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgdG8gY29udmVydC5cclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgZGF5IG9mIHRoZSB5ZWFyLlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZSBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0ZGF5T2ZZZWFyOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XHJcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIGRheSxcclxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWREYXRlKTtcclxuXHRcdFx0cmV0dXJuIGRhdGUudG9KRCgpIC0gdGhpcy5uZXdEYXRlKGRhdGUueWVhcigpLFxyXG5cdFx0XHRcdHRoaXMuZnJvbU1vbnRoT2ZZZWFyKGRhdGUueWVhcigpLCB0aGlzLm1pbk1vbnRoKSwgdGhpcy5taW5EYXkpLnRvSkQoKSArIDE7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgbnVtYmVyIG9mIGRheXMgaW4gYSB3ZWVrLlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXHJcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBkYXlzLiAqL1xyXG5cdFx0ZGF5c0luV2VlazogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiA3O1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIGRheSBvZiB0aGUgd2VlayBmb3IgYSBkYXRlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGV4YW1pbmUgb3IgdGhlIHllYXIgdG8gZXhhbWluZS5cclxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIGV4YW1pbmUuXHJcblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIGV4YW1pbmUuXHJcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIGRheSBvZiB0aGUgd2VlazogMCB0byBudW1iZXIgb2YgZGF5cyAtIDEuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXHJcblx0XHRkYXlPZldlZWs6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcclxuXHRcdFx0dmFyIGRhdGUgPSB0aGlzLl92YWxpZGF0ZSh5ZWFyLCBtb250aCwgZGF5LFxyXG5cdFx0XHRcdCQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWREYXRlIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZERhdGUpO1xyXG5cdFx0XHRyZXR1cm4gKE1hdGguZmxvb3IodGhpcy50b0pEKGRhdGUpKSArIDIpICUgdGhpcy5kYXlzSW5XZWVrKCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXRyaWV2ZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IGEgZGF0ZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXHJcblx0XHRcdEBwYXJhbSBbbW9udGhdIHtudW1iZXJ9IFRoZSBtb250aCB0byBleGFtaW5lLlxyXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSB0byBleGFtaW5lLlxyXG5cdFx0XHRAcmV0dXJuIHtvYmplY3R9IEFkZGl0aW9uYWwgaW5mb3JtYXRpb24gLSBjb250ZW50cyBkZXBlbmRzIG9uIGNhbGVuZGFyLlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZSBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0ZXh0cmFJbmZvOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XHJcblx0XHRcdHRoaXMuX3ZhbGlkYXRlKHllYXIsIG1vbnRoLCBkYXksXHJcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZERhdGUgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkRGF0ZSk7XHJcblx0XHRcdHJldHVybiB7fTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEFkZCBwZXJpb2QocykgdG8gYSBkYXRlLlxyXG5cdFx0XHRDYXRlciBmb3Igbm8geWVhciB6ZXJvLlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSBkYXRlIHtDRGF0ZX0gVGhlIHN0YXJ0aW5nIGRhdGUuXHJcblx0XHRcdEBwYXJhbSBvZmZzZXQge251bWJlcn0gVGhlIG51bWJlciBvZiBwZXJpb2RzIHRvIGFkanVzdCBieS5cclxuXHRcdFx0QHBhcmFtIHBlcmlvZCB7c3RyaW5nfSBPbmUgb2YgJ3knIGZvciB5ZWFyLCAnbScgZm9yIG1vbnRoLCAndycgZm9yIHdlZWssICdkJyBmb3IgZGF5LlxyXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gVGhlIHVwZGF0ZWQgZGF0ZS5cclxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0YWRkOiBmdW5jdGlvbihkYXRlLCBvZmZzZXQsIHBlcmlvZCkge1xyXG5cdFx0XHR0aGlzLl92YWxpZGF0ZShkYXRlLCB0aGlzLm1pbk1vbnRoLCB0aGlzLm1pbkRheSxcclxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWREYXRlKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX2NvcnJlY3RBZGQoZGF0ZSwgdGhpcy5fYWRkKGRhdGUsIG9mZnNldCwgcGVyaW9kKSwgb2Zmc2V0LCBwZXJpb2QpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQWRkIHBlcmlvZChzKSB0byBhIGRhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGRhdGUge0NEYXRlfSBUaGUgc3RhcnRpbmcgZGF0ZS5cclxuXHRcdFx0QHBhcmFtIG9mZnNldCB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHBlcmlvZHMgdG8gYWRqdXN0IGJ5LlxyXG5cdFx0XHRAcGFyYW0gcGVyaW9kIHtzdHJpbmd9IE9uZSBvZiAneScgZm9yIHllYXIsICdtJyBmb3IgbW9udGgsICd3JyBmb3Igd2VlaywgJ2QnIGZvciBkYXkuXHJcblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgdXBkYXRlZCBkYXRlLiAqL1xyXG5cdFx0X2FkZDogZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0LCBwZXJpb2QpIHtcclxuXHRcdFx0dGhpcy5fdmFsaWRhdGVMZXZlbCsrO1xyXG5cdFx0XHRpZiAocGVyaW9kID09PSAnZCcgfHwgcGVyaW9kID09PSAndycpIHtcclxuXHRcdFx0XHR2YXIgamQgPSBkYXRlLnRvSkQoKSArIG9mZnNldCAqIChwZXJpb2QgPT09ICd3JyA/IHRoaXMuZGF5c0luV2VlaygpIDogMSk7XHJcblx0XHRcdFx0dmFyIGQgPSBkYXRlLmNhbGVuZGFyKCkuZnJvbUpEKGpkKTtcclxuXHRcdFx0XHR0aGlzLl92YWxpZGF0ZUxldmVsLS07XHJcblx0XHRcdFx0cmV0dXJuIFtkLnllYXIoKSwgZC5tb250aCgpLCBkLmRheSgpXTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdHZhciB5ID0gZGF0ZS55ZWFyKCkgKyAocGVyaW9kID09PSAneScgPyBvZmZzZXQgOiAwKTtcclxuXHRcdFx0XHR2YXIgbSA9IGRhdGUubW9udGhPZlllYXIoKSArIChwZXJpb2QgPT09ICdtJyA/IG9mZnNldCA6IDApO1xyXG5cdFx0XHRcdHZhciBkID0gZGF0ZS5kYXkoKTsvLyArIChwZXJpb2QgPT09ICdkJyA/IG9mZnNldCA6IDApICtcclxuXHRcdFx0XHRcdC8vKHBlcmlvZCA9PT0gJ3cnID8gb2Zmc2V0ICogdGhpcy5kYXlzSW5XZWVrKCkgOiAwKTtcclxuXHRcdFx0XHR2YXIgcmVzeW5jWWVhck1vbnRoID0gZnVuY3Rpb24oY2FsZW5kYXIpIHtcclxuXHRcdFx0XHRcdHdoaWxlIChtIDwgY2FsZW5kYXIubWluTW9udGgpIHtcclxuXHRcdFx0XHRcdFx0eS0tO1xyXG5cdFx0XHRcdFx0XHRtICs9IGNhbGVuZGFyLm1vbnRoc0luWWVhcih5KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHZhciB5ZWFyTW9udGhzID0gY2FsZW5kYXIubW9udGhzSW5ZZWFyKHkpO1xyXG5cdFx0XHRcdFx0d2hpbGUgKG0gPiB5ZWFyTW9udGhzIC0gMSArIGNhbGVuZGFyLm1pbk1vbnRoKSB7XHJcblx0XHRcdFx0XHRcdHkrKztcclxuXHRcdFx0XHRcdFx0bSAtPSB5ZWFyTW9udGhzO1xyXG5cdFx0XHRcdFx0XHR5ZWFyTW9udGhzID0gY2FsZW5kYXIubW9udGhzSW5ZZWFyKHkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdFx0aWYgKHBlcmlvZCA9PT0gJ3knKSB7XHJcblx0XHRcdFx0XHRpZiAoZGF0ZS5tb250aCgpICE9PSB0aGlzLmZyb21Nb250aE9mWWVhcih5LCBtKSkgeyAvLyBIZWJyZXdcclxuXHRcdFx0XHRcdFx0bSA9IHRoaXMubmV3RGF0ZSh5LCBkYXRlLm1vbnRoKCksIHRoaXMubWluRGF5KS5tb250aE9mWWVhcigpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bSA9IE1hdGgubWluKG0sIHRoaXMubW9udGhzSW5ZZWFyKHkpKTtcclxuXHRcdFx0XHRcdGQgPSBNYXRoLm1pbihkLCB0aGlzLmRheXNJbk1vbnRoKHksIHRoaXMuZnJvbU1vbnRoT2ZZZWFyKHksIG0pKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKHBlcmlvZCA9PT0gJ20nKSB7XHJcblx0XHRcdFx0XHRyZXN5bmNZZWFyTW9udGgodGhpcyk7XHJcblx0XHRcdFx0XHRkID0gTWF0aC5taW4oZCwgdGhpcy5kYXlzSW5Nb250aCh5LCB0aGlzLmZyb21Nb250aE9mWWVhcih5LCBtKSkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgeW1kID0gW3ksIHRoaXMuZnJvbU1vbnRoT2ZZZWFyKHksIG0pLCBkXTtcclxuXHRcdFx0XHR0aGlzLl92YWxpZGF0ZUxldmVsLS07XHJcblx0XHRcdFx0cmV0dXJuIHltZDtcclxuXHRcdFx0fVxyXG5cdFx0XHRjYXRjaCAoZSkge1xyXG5cdFx0XHRcdHRoaXMuX3ZhbGlkYXRlTGV2ZWwtLTtcclxuXHRcdFx0XHR0aHJvdyBlO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBDb3JyZWN0IGEgY2FuZGlkYXRlIGRhdGUgYWZ0ZXIgYWRkaW5nIHBlcmlvZChzKSB0byBhIGRhdGUuXHJcblx0XHRcdEhhbmRsZSBubyB5ZWFyIHplcm8gaWYgbmVjZXNzYXJ5LlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBkYXRlIHtDRGF0ZX0gVGhlIHN0YXJ0aW5nIGRhdGUuXHJcblx0XHRcdEBwYXJhbSB5bWQge251bWJlcltdfSBUaGUgYWRkZWQgZGF0ZS5cclxuXHRcdFx0QHBhcmFtIG9mZnNldCB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHBlcmlvZHMgdG8gYWRqdXN0IGJ5LlxyXG5cdFx0XHRAcGFyYW0gcGVyaW9kIHtzdHJpbmd9IE9uZSBvZiAneScgZm9yIHllYXIsICdtJyBmb3IgbW9udGgsICd3JyBmb3Igd2VlaywgJ2QnIGZvciBkYXkuXHJcblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgdXBkYXRlZCBkYXRlLiAqL1xyXG5cdFx0X2NvcnJlY3RBZGQ6IGZ1bmN0aW9uKGRhdGUsIHltZCwgb2Zmc2V0LCBwZXJpb2QpIHtcclxuXHRcdFx0aWYgKCF0aGlzLmhhc1llYXJaZXJvICYmIChwZXJpb2QgPT09ICd5JyB8fCBwZXJpb2QgPT09ICdtJykpIHtcclxuXHRcdFx0XHRpZiAoeW1kWzBdID09PSAwIHx8IC8vIEluIHllYXIgemVyb1xyXG5cdFx0XHRcdFx0XHQoZGF0ZS55ZWFyKCkgPiAwKSAhPT0gKHltZFswXSA+IDApKSB7IC8vIENyb3NzZWQgeWVhciB6ZXJvXHJcblx0XHRcdFx0XHR2YXIgYWRqID0ge3k6IFsxLCAxLCAneSddLCBtOiBbMSwgdGhpcy5tb250aHNJblllYXIoLTEpLCAnbSddLFxyXG5cdFx0XHRcdFx0XHR3OiBbdGhpcy5kYXlzSW5XZWVrKCksIHRoaXMuZGF5c0luWWVhcigtMSksICdkJ10sXHJcblx0XHRcdFx0XHRcdGQ6IFsxLCB0aGlzLmRheXNJblllYXIoLTEpLCAnZCddfVtwZXJpb2RdO1xyXG5cdFx0XHRcdFx0dmFyIGRpciA9IChvZmZzZXQgPCAwID8gLTEgOiArMSk7XHJcblx0XHRcdFx0XHR5bWQgPSB0aGlzLl9hZGQoZGF0ZSwgb2Zmc2V0ICogYWRqWzBdICsgZGlyICogYWRqWzFdLCBhZGpbMl0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZGF0ZS5kYXRlKHltZFswXSwgeW1kWzFdLCB5bWRbMl0pO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogU2V0IGEgcG9ydGlvbiBvZiB0aGUgZGF0ZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxyXG5cdFx0XHRAcGFyYW0gZGF0ZSB7Q0RhdGV9IFRoZSBzdGFydGluZyBkYXRlLlxyXG5cdFx0XHRAcGFyYW0gdmFsdWUge251bWJlcn0gVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHBlcmlvZC5cclxuXHRcdFx0QHBhcmFtIHBlcmlvZCB7c3RyaW5nfSBPbmUgb2YgJ3knIGZvciB5ZWFyLCAnbScgZm9yIG1vbnRoLCAnZCcgZm9yIGRheS5cclxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSB1cGRhdGVkIGRhdGUuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXHJcblx0XHRzZXQ6IGZ1bmN0aW9uKGRhdGUsIHZhbHVlLCBwZXJpb2QpIHtcclxuXHRcdFx0dGhpcy5fdmFsaWRhdGUoZGF0ZSwgdGhpcy5taW5Nb250aCwgdGhpcy5taW5EYXksXHJcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZERhdGUgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkRGF0ZSk7XHJcblx0XHRcdHZhciB5ID0gKHBlcmlvZCA9PT0gJ3knID8gdmFsdWUgOiBkYXRlLnllYXIoKSk7XHJcblx0XHRcdHZhciBtID0gKHBlcmlvZCA9PT0gJ20nID8gdmFsdWUgOiBkYXRlLm1vbnRoKCkpO1xyXG5cdFx0XHR2YXIgZCA9IChwZXJpb2QgPT09ICdkJyA/IHZhbHVlIDogZGF0ZS5kYXkoKSk7XHJcblx0XHRcdGlmIChwZXJpb2QgPT09ICd5JyB8fCBwZXJpb2QgPT09ICdtJykge1xyXG5cdFx0XHRcdGQgPSBNYXRoLm1pbihkLCB0aGlzLmRheXNJbk1vbnRoKHksIG0pKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZGF0ZS5kYXRlKHksIG0sIGQpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogRGV0ZXJtaW5lIHdoZXRoZXIgYSBkYXRlIGlzIHZhbGlkIGZvciB0aGlzIGNhbGVuZGFyLlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtudW1iZXJ9IFRoZSB5ZWFyIHRvIGV4YW1pbmUuXHJcblx0XHRcdEBwYXJhbSBtb250aCB7bnVtYmVyfSBUaGUgbW9udGggdG8gZXhhbWluZS5cclxuXHRcdFx0QHBhcmFtIGRheSB7bnVtYmVyfSBUaGUgZGF5IHRvIGV4YW1pbmUuXHJcblx0XHRcdEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGEgdmFsaWQgZGF0ZSwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdC4gKi9cclxuXHRcdGlzVmFsaWQ6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcclxuXHRcdFx0dGhpcy5fdmFsaWRhdGVMZXZlbCsrO1xyXG5cdFx0XHR2YXIgdmFsaWQgPSAodGhpcy5oYXNZZWFyWmVybyB8fCB5ZWFyICE9PSAwKTtcclxuXHRcdFx0aWYgKHZhbGlkKSB7XHJcblx0XHRcdFx0dmFyIGRhdGUgPSB0aGlzLm5ld0RhdGUoeWVhciwgbW9udGgsIHRoaXMubWluRGF5KTtcclxuXHRcdFx0XHR2YWxpZCA9IChtb250aCA+PSB0aGlzLm1pbk1vbnRoICYmIG1vbnRoIC0gdGhpcy5taW5Nb250aCA8IHRoaXMubW9udGhzSW5ZZWFyKGRhdGUpKSAmJlxyXG5cdFx0XHRcdFx0KGRheSA+PSB0aGlzLm1pbkRheSAmJiBkYXkgLSB0aGlzLm1pbkRheSA8IHRoaXMuZGF5c0luTW9udGgoZGF0ZSkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX3ZhbGlkYXRlTGV2ZWwtLTtcclxuXHRcdFx0cmV0dXJuIHZhbGlkO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQ29udmVydCB0aGUgZGF0ZSB0byBhIHN0YW5kYXJkIChHcmVnb3JpYW4pIEphdmFTY3JpcHQgRGF0ZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBjb252ZXJ0IG9yIHRoZSB5ZWFyIHRvIGNvbnZlcnQuXHJcblx0XHRcdEBwYXJhbSBbbW9udGhdIHtudW1iZXJ9IFRoZSBtb250aCB0byBjb252ZXJ0LlxyXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSB0byBjb252ZXJ0LlxyXG5cdFx0XHRAcmV0dXJuIHtEYXRlfSBUaGUgZXF1aXZhbGVudCBKYXZhU2NyaXB0IGRhdGUuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXHJcblx0XHR0b0pTRGF0ZTogZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSkge1xyXG5cdFx0XHR2YXIgZGF0ZSA9IHRoaXMuX3ZhbGlkYXRlKHllYXIsIG1vbnRoLCBkYXksXHJcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZERhdGUgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkRGF0ZSk7XHJcblx0XHRcdHJldHVybiAkLmNhbGVuZGFycy5pbnN0YW5jZSgpLmZyb21KRCh0aGlzLnRvSkQoZGF0ZSkpLnRvSlNEYXRlKCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBDb252ZXJ0IHRoZSBkYXRlIGZyb20gYSBzdGFuZGFyZCAoR3JlZ29yaWFuKSBKYXZhU2NyaXB0IERhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIGpzZCB7RGF0ZX0gVGhlIEphdmFTY3JpcHQgZGF0ZS5cclxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBlcXVpdmFsZW50IGNhbGVuZGFyIGRhdGUuICovXHJcblx0XHRmcm9tSlNEYXRlOiBmdW5jdGlvbihqc2QpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZnJvbUpEKCQuY2FsZW5kYXJzLmluc3RhbmNlKCkuZnJvbUpTRGF0ZShqc2QpLnRvSkQoKSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBDaGVjayB0aGF0IGEgY2FuZGlkYXRlIGRhdGUgaXMgZnJvbSB0aGUgc2FtZSBjYWxlbmRhciBhbmQgaXMgdmFsaWQuXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gdmFsaWRhdGUgb3IgdGhlIHllYXIgdG8gdmFsaWRhdGUuXHJcblx0XHRcdEBwYXJhbSBbbW9udGhdIHtudW1iZXJ9IFRoZSBtb250aCB0byB2YWxpZGF0ZS5cclxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgdG8gdmFsaWRhdGUuXHJcblx0XHRcdEBwYXJhbSBlcnJvciB7c3RyaW5nfSBScnJvciBtZXNzYWdlIGlmIGludmFsaWQuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgZGlmZmVyZW50IGNhbGVuZGFycyB1c2VkIG9yIGludmFsaWQgZGF0ZS4gKi9cclxuXHRcdF92YWxpZGF0ZTogZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSwgZXJyb3IpIHtcclxuXHRcdFx0aWYgKHllYXIueWVhcikge1xyXG5cdFx0XHRcdGlmICh0aGlzLl92YWxpZGF0ZUxldmVsID09PSAwICYmIHRoaXMubmFtZSAhPT0geWVhci5jYWxlbmRhcigpLm5hbWUpIHtcclxuXHRcdFx0XHRcdHRocm93ICgkLmNhbGVuZGFycy5sb2NhbC5kaWZmZXJlbnRDYWxlbmRhcnMgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5kaWZmZXJlbnRDYWxlbmRhcnMpLlxyXG5cdFx0XHRcdFx0XHRyZXBsYWNlKC9cXHswXFx9LywgdGhpcy5sb2NhbC5uYW1lKS5yZXBsYWNlKC9cXHsxXFx9LywgeWVhci5jYWxlbmRhcigpLmxvY2FsLm5hbWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4geWVhcjtcclxuXHRcdFx0fVxyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdHRoaXMuX3ZhbGlkYXRlTGV2ZWwrKztcclxuXHRcdFx0XHRpZiAodGhpcy5fdmFsaWRhdGVMZXZlbCA9PT0gMSAmJiAhdGhpcy5pc1ZhbGlkKHllYXIsIG1vbnRoLCBkYXkpKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBlcnJvci5yZXBsYWNlKC9cXHswXFx9LywgdGhpcy5sb2NhbC5uYW1lKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIGRhdGUgPSB0aGlzLm5ld0RhdGUoeWVhciwgbW9udGgsIGRheSk7XHJcblx0XHRcdFx0dGhpcy5fdmFsaWRhdGVMZXZlbC0tO1xyXG5cdFx0XHRcdHJldHVybiBkYXRlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGNhdGNoIChlKSB7XHJcblx0XHRcdFx0dGhpcy5fdmFsaWRhdGVMZXZlbC0tO1xyXG5cdFx0XHRcdHRocm93IGU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0LyoqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBQcm9sZXB0aWMgR3JlZ29yaWFuIENhbGVuZGFyLlxyXG5cdFx0U2VlIDxhIGhyZWY9XCI6aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HcmVnb3JpYW5fY2FsZW5kYXJcIj5odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyZWdvcmlhbl9jYWxlbmRhcjwvYT5cclxuXHRcdGFuZCA8YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qcm9sZXB0aWNfR3JlZ29yaWFuX2NhbGVuZGFyXCI+aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qcm9sZXB0aWNfR3JlZ29yaWFuX2NhbGVuZGFyPC9hPi5cclxuXHRcdEBjbGFzcyBHcmVnb3JpYW5DYWxlbmRhclxyXG5cdFx0QGF1Z21lbnRzIEJhc2VDYWxlbmRhclxyXG5cdFx0QHBhcmFtIFtsYW5ndWFnZT0nJ10ge3N0cmluZ30gVGhlIGxhbmd1YWdlIGNvZGUgKGRlZmF1bHQgRW5nbGlzaCkgZm9yIGxvY2FsaXNhdGlvbi4gKi9cclxuXHRmdW5jdGlvbiBHcmVnb3JpYW5DYWxlbmRhcihsYW5ndWFnZSkge1xyXG5cdFx0dGhpcy5sb2NhbCA9IHRoaXMucmVnaW9uYWxPcHRpb25zW2xhbmd1YWdlXSB8fCB0aGlzLnJlZ2lvbmFsT3B0aW9uc1snJ107XHJcblx0fVxyXG5cclxuXHRHcmVnb3JpYW5DYWxlbmRhci5wcm90b3R5cGUgPSBuZXcgQmFzZUNhbGVuZGFyO1xyXG5cclxuXHQkLmV4dGVuZChHcmVnb3JpYW5DYWxlbmRhci5wcm90b3R5cGUsIHtcclxuXHRcdC8qKiBUaGUgY2FsZW5kYXIgbmFtZS5cclxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyICovXHJcblx0XHRuYW1lOiAnR3JlZ29yaWFuJyxcclxuXHRcdCAvKiogSnVsaWFuIGRhdGUgb2Ygc3RhcnQgb2YgR3JlZ29yaWFuIGVwb2NoOiAxIEphbnVhcnkgMDAwMSBDRS5cclxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyICovXHJcblx0XHRqZEVwb2NoOiAxNzIxNDI1LjUsXHJcblx0XHQgLyoqIERheXMgcGVyIG1vbnRoIGluIGEgY29tbW9uIHllYXIuXHJcblx0XHRcdEBtZW1iZXJvZiBHcmVnb3JpYW5DYWxlbmRhciAqL1xyXG5cdFx0ZGF5c1Blck1vbnRoOiBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV0sXHJcblx0XHQgLyoqIDxjb2RlPnRydWU8L2NvZGU+IGlmIGhhcyBhIHllYXIgemVybywgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdC5cclxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyICovXHJcblx0XHRoYXNZZWFyWmVybzogZmFsc2UsXHJcblx0XHQvKiogVGhlIG1pbmltdW0gbW9udGggbnVtYmVyLlxyXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXIgKi9cclxuXHRcdG1pbk1vbnRoOiAxLFxyXG5cdFx0LyoqIFRoZSBmaXJzdCBtb250aCBpbiB0aGUgeWVhci5cclxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyICovXHJcblx0XHRmaXJzdE1vbnRoOiAxLFxyXG5cdFx0IC8qKiBUaGUgbWluaW11bSBkYXkgbnVtYmVyLlxyXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXIgKi9cclxuXHRcdG1pbkRheTogMSxcclxuXHJcblx0XHQvKiogTG9jYWxpc2F0aW9ucyBmb3IgdGhlIHBsdWdpbi5cclxuXHRcdFx0RW50cmllcyBhcmUgb2JqZWN0cyBpbmRleGVkIGJ5IHRoZSBsYW5ndWFnZSBjb2RlICgnJyBiZWluZyB0aGUgZGVmYXVsdCBVUy9FbmdsaXNoKS5cclxuXHRcdFx0RWFjaCBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlcy5cclxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyXHJcblx0XHRcdEBwcm9wZXJ0eSBuYW1lIHtzdHJpbmd9IFRoZSBjYWxlbmRhciBuYW1lLlxyXG5cdFx0XHRAcHJvcGVydHkgZXBvY2hzIHtzdHJpbmdbXX0gVGhlIGVwb2NoIG5hbWVzLlxyXG5cdFx0XHRAcHJvcGVydHkgbW9udGhOYW1lcyB7c3RyaW5nW119IFRoZSBsb25nIG5hbWVzIG9mIHRoZSBtb250aHMgb2YgdGhlIHllYXIuXHJcblx0XHRcdEBwcm9wZXJ0eSBtb250aE5hbWVzU2hvcnQge3N0cmluZ1tdfSBUaGUgc2hvcnQgbmFtZXMgb2YgdGhlIG1vbnRocyBvZiB0aGUgeWVhci5cclxuXHRcdFx0QHByb3BlcnR5IGRheU5hbWVzIHtzdHJpbmdbXX0gVGhlIGxvbmcgbmFtZXMgb2YgdGhlIGRheXMgb2YgdGhlIHdlZWsuXHJcblx0XHRcdEBwcm9wZXJ0eSBkYXlOYW1lc1Nob3J0IHtzdHJpbmdbXX0gVGhlIHNob3J0IG5hbWVzIG9mIHRoZSBkYXlzIG9mIHRoZSB3ZWVrLlxyXG5cdFx0XHRAcHJvcGVydHkgZGF5TmFtZXNNaW4ge3N0cmluZ1tdfSBUaGUgbWluaW1hbCBuYW1lcyBvZiB0aGUgZGF5cyBvZiB0aGUgd2Vlay5cclxuXHRcdFx0QHByb3BlcnR5IGRhdGVGb3JtYXQge3N0cmluZ30gVGhlIGRhdGUgZm9ybWF0IGZvciB0aGlzIGNhbGVuZGFyLlxyXG5cdFx0XHRcdFx0U2VlIHRoZSBvcHRpb25zIG9uIDxhIGhyZWY9XCJCYXNlQ2FsZW5kYXIuaHRtbCNmb3JtYXREYXRlXCI+PGNvZGU+Zm9ybWF0RGF0ZTwvY29kZT48L2E+IGZvciBkZXRhaWxzLlxyXG5cdFx0XHRAcHJvcGVydHkgZmlyc3REYXkge251bWJlcn0gVGhlIG51bWJlciBvZiB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLCBzdGFydGluZyBhdCAwLlxyXG5cdFx0XHRAcHJvcGVydHkgaXNSVEwge251bWJlcn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhpcyBsb2NhbGlzYXRpb24gcmVhZHMgcmlnaHQtdG8tbGVmdC4gKi9cclxuXHRcdHJlZ2lvbmFsT3B0aW9uczogeyAvLyBMb2NhbGlzYXRpb25zXHJcblx0XHRcdCcnOiB7XHJcblx0XHRcdFx0bmFtZTogJ0dyZWdvcmlhbicsXHJcblx0XHRcdFx0ZXBvY2hzOiBbJ0JDRScsICdDRSddLFxyXG5cdFx0XHRcdG1vbnRoTmFtZXM6IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsXHJcblx0XHRcdFx0J0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ10sXHJcblx0XHRcdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ10sXHJcblx0XHRcdFx0ZGF5TmFtZXM6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcclxuXHRcdFx0XHRkYXlOYW1lc1Nob3J0OiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxyXG5cdFx0XHRcdGRheU5hbWVzTWluOiBbJ1N1JywgJ01vJywgJ1R1JywgJ1dlJywgJ1RoJywgJ0ZyJywgJ1NhJ10sXHJcblx0XHRcdFx0ZGF0ZUZvcm1hdDogJ21tL2RkL3l5eXknLFxyXG5cdFx0XHRcdGZpcnN0RGF5OiAwLFxyXG5cdFx0XHRcdGlzUlRMOiBmYWxzZVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvKiogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBkYXRlIGlzIGluIGEgbGVhcCB5ZWFyLlxyXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciB0byBleGFtaW5lLlxyXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGlzIGlzIGEgbGVhcCB5ZWFyLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90LlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgeWVhciBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0bGVhcFllYXI6IGZ1bmN0aW9uKHllYXIpIHtcclxuXHRcdFx0dmFyIGRhdGUgPSB0aGlzLl92YWxpZGF0ZSh5ZWFyLCB0aGlzLm1pbk1vbnRoLCB0aGlzLm1pbkRheSxcclxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkWWVhciB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWRZZWFyKTtcclxuXHRcdFx0dmFyIHllYXIgPSBkYXRlLnllYXIoKSArIChkYXRlLnllYXIoKSA8IDAgPyAxIDogMCk7IC8vIE5vIHllYXIgemVyb1xyXG5cdFx0XHRyZXR1cm4geWVhciAlIDQgPT09IDAgJiYgKHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBEZXRlcm1pbmUgdGhlIHdlZWsgb2YgdGhlIHllYXIgZm9yIGEgZGF0ZSAtIElTTyA4NjAxLlxyXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciB0byBleGFtaW5lLlxyXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gZXhhbWluZS5cclxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgdG8gZXhhbWluZS5cclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgd2VlayBvZiB0aGUgeWVhciwgc3RhcnRpbmcgZnJvbSAxLlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZSBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0d2Vla09mWWVhcjogZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSkge1xyXG5cdFx0XHQvLyBGaW5kIFRodXJzZGF5IG9mIHRoaXMgd2VlayBzdGFydGluZyBvbiBNb25kYXlcclxuXHRcdFx0dmFyIGNoZWNrRGF0ZSA9IHRoaXMubmV3RGF0ZSh5ZWFyLCBtb250aCwgZGF5KTtcclxuXHRcdFx0Y2hlY2tEYXRlLmFkZCg0IC0gKGNoZWNrRGF0ZS5kYXlPZldlZWsoKSB8fCA3KSwgJ2QnKTtcclxuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoKGNoZWNrRGF0ZS5kYXlPZlllYXIoKSAtIDEpIC8gNykgKyAxO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIG51bWJlciBvZiBkYXlzIGluIGEgbW9udGguXHJcblx0XHRcdEBtZW1iZXJvZiBHcmVnb3JpYW5DYWxlbmRhclxyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIG9mIHRoZSBtb250aC5cclxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoLlxyXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGlzIG1vbnRoLlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgbW9udGgveWVhciBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0ZGF5c0luTW9udGg6IGZ1bmN0aW9uKHllYXIsIG1vbnRoKSB7XHJcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIHRoaXMubWluRGF5LFxyXG5cdFx0XHRcdCQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWRNb250aCB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWRNb250aCk7XHJcblx0XHRcdHJldHVybiB0aGlzLmRheXNQZXJNb250aFtkYXRlLm1vbnRoKCkgLSAxXSArXHJcblx0XHRcdFx0KGRhdGUubW9udGgoKSA9PT0gMiAmJiB0aGlzLmxlYXBZZWFyKGRhdGUueWVhcigpKSA/IDEgOiAwKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIERldGVybWluZSB3aGV0aGVyIHRoaXMgZGF0ZSBpcyBhIHdlZWsgZGF5LlxyXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciB0byBleGFtaW5lLlxyXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gZXhhbWluZS5cclxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgdG8gZXhhbWluZS5cclxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgYSB3ZWVrIGRheSwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdC5cclxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cclxuXHRcdHdlZWtEYXk6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcclxuXHRcdFx0cmV0dXJuICh0aGlzLmRheU9mV2Vlayh5ZWFyLCBtb250aCwgZGF5KSB8fCA3KSA8IDY7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgSnVsaWFuIGRhdGUgZXF1aXZhbGVudCBmb3IgdGhpcyBkYXRlLFxyXG5cdFx0XHRpLmUuIGRheXMgc2luY2UgSmFudWFyeSAxLCA0NzEzIEJDRSBHcmVlbndpY2ggbm9vbi5cclxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGNvbnZlcnQgb3IgdGhlIHllYXIgdG8gY29udmVydC5cclxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIGNvbnZlcnQuXHJcblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIGNvbnZlcnQuXHJcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIGVxdWl2YWxlbnQgSnVsaWFuIGRhdGUuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXHJcblx0XHR0b0pEOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XHJcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIGRheSxcclxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWREYXRlKTtcclxuXHRcdFx0eWVhciA9IGRhdGUueWVhcigpO1xyXG5cdFx0XHRtb250aCA9IGRhdGUubW9udGgoKTtcclxuXHRcdFx0ZGF5ID0gZGF0ZS5kYXkoKTtcclxuXHRcdFx0aWYgKHllYXIgPCAwKSB7IHllYXIrKzsgfSAvLyBObyB5ZWFyIHplcm9cclxuXHRcdFx0Ly8gSmVhbiBNZWV1cyBhbGdvcml0aG0sIFwiQXN0cm9ub21pY2FsIEFsZ29yaXRobXNcIiwgMTk5MVxyXG5cdFx0XHRpZiAobW9udGggPCAzKSB7XHJcblx0XHRcdFx0bW9udGggKz0gMTI7XHJcblx0XHRcdFx0eWVhci0tO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBhID0gTWF0aC5mbG9vcih5ZWFyIC8gMTAwKTtcclxuXHRcdFx0dmFyIGIgPSAyIC0gYSArIE1hdGguZmxvb3IoYSAvIDQpO1xyXG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vcigzNjUuMjUgKiAoeWVhciArIDQ3MTYpKSArXHJcblx0XHRcdFx0TWF0aC5mbG9vcigzMC42MDAxICogKG1vbnRoICsgMSkpICsgZGF5ICsgYiAtIDE1MjQuNTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIENyZWF0ZSBhIG5ldyBkYXRlIGZyb20gYSBKdWxpYW4gZGF0ZS5cclxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSBqZCB7bnVtYmVyfSBUaGUgSnVsaWFuIGRhdGUgdG8gY29udmVydC5cclxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBlcXVpdmFsZW50IGRhdGUuICovXHJcblx0XHRmcm9tSkQ6IGZ1bmN0aW9uKGpkKSB7XHJcblx0XHRcdC8vIEplYW4gTWVldXMgYWxnb3JpdGhtLCBcIkFzdHJvbm9taWNhbCBBbGdvcml0aG1zXCIsIDE5OTFcclxuXHRcdFx0dmFyIHogPSBNYXRoLmZsb29yKGpkICsgMC41KTtcclxuXHRcdFx0dmFyIGEgPSBNYXRoLmZsb29yKCh6IC0gMTg2NzIxNi4yNSkgLyAzNjUyNC4yNSk7XHJcblx0XHRcdGEgPSB6ICsgMSArIGEgLSBNYXRoLmZsb29yKGEgLyA0KTtcclxuXHRcdFx0dmFyIGIgPSBhICsgMTUyNDtcclxuXHRcdFx0dmFyIGMgPSBNYXRoLmZsb29yKChiIC0gMTIyLjEpIC8gMzY1LjI1KTtcclxuXHRcdFx0dmFyIGQgPSBNYXRoLmZsb29yKDM2NS4yNSAqIGMpO1xyXG5cdFx0XHR2YXIgZSA9IE1hdGguZmxvb3IoKGIgLSBkKSAvIDMwLjYwMDEpO1xyXG5cdFx0XHR2YXIgZGF5ID0gYiAtIGQgLSBNYXRoLmZsb29yKGUgKiAzMC42MDAxKTtcclxuXHRcdFx0dmFyIG1vbnRoID0gZSAtIChlID4gMTMuNSA/IDEzIDogMSk7XHJcblx0XHRcdHZhciB5ZWFyID0gYyAtIChtb250aCA+IDIuNSA/IDQ3MTYgOiA0NzE1KTtcclxuXHRcdFx0aWYgKHllYXIgPD0gMCkgeyB5ZWFyLS07IH0gLy8gTm8geWVhciB6ZXJvXHJcblx0XHRcdHJldHVybiB0aGlzLm5ld0RhdGUoeWVhciwgbW9udGgsIGRheSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBDb252ZXJ0IHRoaXMgZGF0ZSB0byBhIHN0YW5kYXJkIChHcmVnb3JpYW4pIEphdmFTY3JpcHQgRGF0ZS5cclxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGNvbnZlcnQgb3IgdGhlIHllYXIgdG8gY29udmVydC5cclxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIGNvbnZlcnQuXHJcblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIGNvbnZlcnQuXHJcblx0XHRcdEByZXR1cm4ge0RhdGV9IFRoZSBlcXVpdmFsZW50IEphdmFTY3JpcHQgZGF0ZS5cclxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cclxuXHRcdHRvSlNEYXRlOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XHJcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIGRheSxcclxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWREYXRlKTtcclxuXHRcdFx0dmFyIGpzZCA9IG5ldyBEYXRlKGRhdGUueWVhcigpLCBkYXRlLm1vbnRoKCkgLSAxLCBkYXRlLmRheSgpKTtcclxuXHRcdFx0anNkLnNldEhvdXJzKDApO1xyXG5cdFx0XHRqc2Quc2V0TWludXRlcygwKTtcclxuXHRcdFx0anNkLnNldFNlY29uZHMoMCk7XHJcblx0XHRcdGpzZC5zZXRNaWxsaXNlY29uZHMoMCk7XHJcblx0XHRcdC8vIEhvdXJzIG1heSBiZSBub24temVybyBvbiBkYXlsaWdodCBzYXZpbmcgY3V0LW92ZXI6XHJcblx0XHRcdC8vID4gMTIgd2hlbiBtaWRuaWdodCBjaGFuZ2VvdmVyLCBidXQgdGhlbiBjYW5ub3QgZ2VuZXJhdGVcclxuXHRcdFx0Ly8gbWlkbmlnaHQgZGF0ZXRpbWUsIHNvIGp1bXAgdG8gMUFNLCBvdGhlcndpc2UgcmVzZXQuXHJcblx0XHRcdGpzZC5zZXRIb3Vycyhqc2QuZ2V0SG91cnMoKSA+IDEyID8ganNkLmdldEhvdXJzKCkgKyAyIDogMCk7XHJcblx0XHRcdHJldHVybiBqc2Q7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBDcmVhdGUgYSBuZXcgZGF0ZSBmcm9tIGEgc3RhbmRhcmQgKEdyZWdvcmlhbikgSmF2YVNjcmlwdCBEYXRlLlxyXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIGpzZCB7RGF0ZX0gVGhlIEphdmFTY3JpcHQgZGF0ZSB0byBjb252ZXJ0LlxyXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gVGhlIGVxdWl2YWxlbnQgZGF0ZS4gKi9cclxuXHRcdGZyb21KU0RhdGU6IGZ1bmN0aW9uKGpzZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5uZXdEYXRlKGpzZC5nZXRGdWxsWWVhcigpLCBqc2QuZ2V0TW9udGgoKSArIDEsIGpzZC5nZXREYXRlKCkpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvLyBTaW5nbGV0b24gbWFuYWdlclxyXG5cdCQuY2FsZW5kYXJzID0gbmV3IENhbGVuZGFycygpO1xyXG5cclxuXHQvLyBEYXRlIHRlbXBsYXRlXHJcblx0JC5jYWxlbmRhcnMuY2RhdGUgPSBDRGF0ZTtcclxuXHJcblx0Ly8gQmFzZSBjYWxlbmRhciB0ZW1wbGF0ZVxyXG5cdCQuY2FsZW5kYXJzLmJhc2VDYWxlbmRhciA9IEJhc2VDYWxlbmRhcjtcclxuXHJcblx0Ly8gR3JlZ29yaWFuIGNhbGVuZGFyIGltcGxlbWVudGF0aW9uXHJcblx0JC5jYWxlbmRhcnMuY2FsZW5kYXJzLmdyZWdvcmlhbiA9IEdyZWdvcmlhbkNhbGVuZGFyO1xyXG5cclxufSkoalF1ZXJ5KTtcclxuLyogaHR0cDovL2tlaXRoLXdvb2QubmFtZS9jYWxlbmRhcnMuaHRtbFxyXG4gICBDYWxlbmRhcnMgZXh0cmFzIGZvciBqUXVlcnkgdjIuMC4xLlxyXG4gICBXcml0dGVuIGJ5IEtlaXRoIFdvb2QgKGtid29vZHthdH1paW5ldC5jb20uYXUpIEF1Z3VzdCAyMDA5LlxyXG4gICBBdmFpbGFibGUgdW5kZXIgdGhlIE1JVCAoaHR0cDovL2tlaXRoLXdvb2QubmFtZS9saWNlbmNlLmh0bWwpIGxpY2Vuc2UuIFxyXG4gICBQbGVhc2UgYXR0cmlidXRlIHRoZSBhdXRob3IgaWYgeW91IHVzZSBpdC4gKi9cclxuXHJcbihmdW5jdGlvbigkKSB7IC8vIEhpZGUgc2NvcGUsIG5vICQgY29uZmxpY3RcclxuXHJcblx0JC5leHRlbmQoJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXSwge1xyXG5cdFx0aW52YWxpZEFyZ3VtZW50czogJ0ludmFsaWQgYXJndW1lbnRzJyxcclxuXHRcdGludmFsaWRGb3JtYXQ6ICdDYW5ub3QgZm9ybWF0IGEgZGF0ZSBmcm9tIGFub3RoZXIgY2FsZW5kYXInLFxyXG5cdFx0bWlzc2luZ051bWJlckF0OiAnTWlzc2luZyBudW1iZXIgYXQgcG9zaXRpb24gezB9JyxcclxuXHRcdHVua25vd25OYW1lQXQ6ICdVbmtub3duIG5hbWUgYXQgcG9zaXRpb24gezB9JyxcclxuXHRcdHVuZXhwZWN0ZWRMaXRlcmFsQXQ6ICdVbmV4cGVjdGVkIGxpdGVyYWwgYXQgcG9zaXRpb24gezB9JyxcclxuXHRcdHVuZXhwZWN0ZWRUZXh0OiAnQWRkaXRpb25hbCB0ZXh0IGZvdW5kIGF0IGVuZCdcclxuXHR9KTtcclxuXHQkLmNhbGVuZGFycy5sb2NhbCA9ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ107XHJcblxyXG5cdCQuZXh0ZW5kKCQuY2FsZW5kYXJzLmNkYXRlLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdC8qKiBGb3JtYXQgdGhpcyBkYXRlLlxyXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXHJcblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxyXG5cdFx0XHRAcGFyYW0gW2Zvcm1hdF0ge3N0cmluZ30gVGhlIGRhdGUgZm9ybWF0IHRvIHVzZSAoc2VlIDxhIGhyZWY9XCJCYXNlQ2FsZW5kYXIuaHRtbCNmb3JtYXREYXRlXCI+PGNvZGU+Zm9ybWF0RGF0ZTwvY29kZT48L2E+KS5cclxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIGRhdGUuICovXHJcblx0XHRmb3JtYXREYXRlOiBmdW5jdGlvbihmb3JtYXQpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbGVuZGFyLmZvcm1hdERhdGUoZm9ybWF0IHx8ICcnLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0JC5leHRlbmQoJC5jYWxlbmRhcnMuYmFzZUNhbGVuZGFyLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdFVOSVhfRVBPQ0g6ICQuY2FsZW5kYXJzLmluc3RhbmNlKCkubmV3RGF0ZSgxOTcwLCAxLCAxKS50b0pEKCksXHJcblx0XHRTRUNTX1BFUl9EQVk6IDI0ICogNjAgKiA2MCxcclxuXHRcdFRJQ0tTX0VQT0NIOiAkLmNhbGVuZGFycy5pbnN0YW5jZSgpLmpkRXBvY2gsIC8vIDEgSmFudWFyeSAwMDAxIENFXHJcblx0XHRUSUNLU19QRVJfREFZOiAyNCAqIDYwICogNjAgKiAxMDAwMDAwMCxcclxuXHJcblx0XHQvKiogRGF0ZSBmb3JtIGZvciBBVE9NIChSRkMgMzMzOS9JU08gODYwMSkuXHJcblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xyXG5cdFx0QVRPTTogJ3l5eXktbW0tZGQnLFxyXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgY29va2llcy5cclxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyICovXHJcblx0XHRDT09LSUU6ICdELCBkZCBNIHl5eXknLFxyXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgZnVsbCBkYXRlLlxyXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXIgKi9cclxuXHRcdEZVTEw6ICdERCwgTU0gZCwgeXl5eScsXHJcblx0XHQvKiogRGF0ZSBmb3JtIGZvciBJU08gODYwMS5cclxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyICovXHJcblx0XHRJU09fODYwMTogJ3l5eXktbW0tZGQnLFxyXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgSnVsaWFuIGRhdGUuXHJcblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xyXG5cdFx0SlVMSUFOOiAnSicsXHJcblx0XHQvKiogRGF0ZSBmb3JtIGZvciBSRkMgODIyLlxyXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXIgKi9cclxuXHRcdFJGQ184MjI6ICdELCBkIE0geXknLFxyXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgUkZDIDg1MC5cclxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyICovXHJcblx0XHRSRkNfODUwOiAnREQsIGRkLU0teXknLFxyXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgUkZDIDEwMzYuXHJcblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xyXG5cdFx0UkZDXzEwMzY6ICdELCBkIE0geXknLFxyXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgUkZDIDExMjMuXHJcblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xyXG5cdFx0UkZDXzExMjM6ICdELCBkIE0geXl5eScsXHJcblx0XHQvKiogRGF0ZSBmb3JtIGZvciBSRkMgMjgyMi5cclxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyICovXHJcblx0XHRSRkNfMjgyMjogJ0QsIGQgTSB5eXl5JyxcclxuXHRcdC8qKiBEYXRlIGZvcm0gZm9yIFJTUyAoUkZDIDgyMikuXHJcblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xyXG5cdFx0UlNTOiAnRCwgZCBNIHl5JyxcclxuXHRcdC8qKiBEYXRlIGZvcm0gZm9yIFdpbmRvd3MgdGlja3MuXHJcblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xyXG5cdFx0VElDS1M6ICchJyxcclxuXHRcdC8qKiBEYXRlIGZvcm0gZm9yIFVuaXggdGltZXN0YW1wLlxyXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXIgKi9cclxuXHRcdFRJTUVTVEFNUDogJ0AnLFxyXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgVzNjIChJU08gODYwMSkuXHJcblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xyXG5cdFx0VzNDOiAneXl5eS1tbS1kZCcsXHJcblxyXG5cdFx0LyoqIEZvcm1hdCBhIGRhdGUgb2JqZWN0IGludG8gYSBzdHJpbmcgdmFsdWUuXHJcblx0XHRcdFRoZSBmb3JtYXQgY2FuIGJlIGNvbWJpbmF0aW9ucyBvZiB0aGUgZm9sbG93aW5nOlxyXG5cdFx0XHQ8dWw+XHJcblx0XHRcdDxsaT5kICAtIGRheSBvZiBtb250aCAobm8gbGVhZGluZyB6ZXJvKTwvbGk+XHJcblx0XHRcdDxsaT5kZCAtIGRheSBvZiBtb250aCAodHdvIGRpZ2l0KTwvbGk+XHJcblx0XHRcdDxsaT5vICAtIGRheSBvZiB5ZWFyIChubyBsZWFkaW5nIHplcm9zKTwvbGk+XHJcblx0XHRcdDxsaT5vbyAtIGRheSBvZiB5ZWFyICh0aHJlZSBkaWdpdCk8L2xpPlxyXG5cdFx0XHQ8bGk+RCAgLSBkYXkgbmFtZSBzaG9ydDwvbGk+XHJcblx0XHRcdDxsaT5ERCAtIGRheSBuYW1lIGxvbmc8L2xpPlxyXG5cdFx0XHQ8bGk+dyAgLSB3ZWVrIG9mIHllYXIgKG5vIGxlYWRpbmcgemVybyk8L2xpPlxyXG5cdFx0XHQ8bGk+d3cgLSB3ZWVrIG9mIHllYXIgKHR3byBkaWdpdCk8L2xpPlxyXG5cdFx0XHQ8bGk+bSAgLSBtb250aCBvZiB5ZWFyIChubyBsZWFkaW5nIHplcm8pPC9saT5cclxuXHRcdFx0PGxpPm1tIC0gbW9udGggb2YgeWVhciAodHdvIGRpZ2l0KTwvbGk+XHJcblx0XHRcdDxsaT5NICAtIG1vbnRoIG5hbWUgc2hvcnQ8L2xpPlxyXG5cdFx0XHQ8bGk+TU0gLSBtb250aCBuYW1lIGxvbmc8L2xpPlxyXG5cdFx0XHQ8bGk+eXkgLSB5ZWFyICh0d28gZGlnaXQpPC9saT5cclxuXHRcdFx0PGxpPnl5eXkgLSB5ZWFyIChmb3VyIGRpZ2l0KTwvbGk+XHJcblx0XHRcdDxsaT5ZWVlZIC0gZm9ybWF0dGVkIHllYXI8L2xpPlxyXG5cdFx0XHQ8bGk+SiAgLSBKdWxpYW4gZGF0ZSAoZGF5cyBzaW5jZSBKYW51YXJ5IDEsIDQ3MTMgQkNFIEdyZWVud2ljaCBub29uKTwvbGk+XHJcblx0XHRcdDxsaT5AICAtIFVuaXggdGltZXN0YW1wIChzIHNpbmNlIDAxLzAxLzE5NzApPC9saT5cclxuXHRcdFx0PGxpPiEgIC0gV2luZG93cyB0aWNrcyAoMTAwbnMgc2luY2UgMDEvMDEvMDAwMSk8L2xpPlxyXG5cdFx0XHQ8bGk+Jy4uLicgLSBsaXRlcmFsIHRleHQ8L2xpPlxyXG5cdFx0XHQ8bGk+JycgLSBzaW5nbGUgcXVvdGU8L2xpPlxyXG5cdFx0XHQ8L3VsPlxyXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIFtmb3JtYXRdIHtzdHJpbmd9IFRoZSBkZXNpcmVkIGZvcm1hdCBvZiB0aGUgZGF0ZSAoZGVmYXVsdHMgdG8gY2FsZW5kYXIgZm9ybWF0KS5cclxuXHRcdFx0QHBhcmFtIGRhdGUge0NEYXRlfSBUaGUgZGF0ZSB2YWx1ZSB0byBmb3JtYXQuXHJcblx0XHRcdEBwYXJhbSBbc2V0dGluZ3NdIHtvYmplY3R9IEFkZGl0aW9uIG9wdGlvbnMsIHdob3NlIGF0dHJpYnV0ZXMgaW5jbHVkZTpcclxuXHRcdFx0QHByb3BlcnR5IFtkYXlOYW1lc1Nob3J0XSB7c3RyaW5nW119IEFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5LlxyXG5cdFx0XHRAcHJvcGVydHkgW2RheU5hbWVzXSB7c3RyaW5nW119IE5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5LlxyXG5cdFx0XHRAcHJvcGVydHkgW21vbnRoTmFtZXNTaG9ydF0ge3N0cmluZ1tdfSBBYmJyZXZpYXRlZCBuYW1lcyBvZiB0aGUgbW9udGhzLlxyXG5cdFx0XHRAcHJvcGVydHkgW21vbnRoTmFtZXNdIHtzdHJpbmdbXX0gTmFtZXMgb2YgdGhlIG1vbnRocy5cclxuXHRcdFx0QHByb3BlcnR5IFtjYWxjdWxhdGVXZWVrXSB7Q2FsZW5kYXJzUGlja2VyQ2FsY3VsYXRlV2Vla30gRnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdlZWsgb2YgdGhlIHllYXIuXHJcblx0XHRcdEByZXR1cm4ge3N0cmluZ30gVGhlIGRhdGUgaW4gdGhlIGFib3ZlIGZvcm1hdC5cclxuXHRcdFx0QHRocm93cyBFcnJvcnMgaWYgdGhlIGRhdGUgaXMgZnJvbSBhIGRpZmZlcmVudCBjYWxlbmRhci4gKi9cclxuXHRcdGZvcm1hdERhdGU6IGZ1bmN0aW9uKGZvcm1hdCwgZGF0ZSwgc2V0dGluZ3MpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBmb3JtYXQgIT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdFx0c2V0dGluZ3MgPSBkYXRlO1xyXG5cdFx0XHRcdGRhdGUgPSBmb3JtYXQ7XHJcblx0XHRcdFx0Zm9ybWF0ID0gJyc7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFkYXRlKSB7XHJcblx0XHRcdFx0cmV0dXJuICcnO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChkYXRlLmNhbGVuZGFyKCkgIT09IHRoaXMpIHtcclxuXHRcdFx0XHR0aHJvdyAkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRm9ybWF0IHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZEZvcm1hdDtcclxuXHRcdFx0fVxyXG5cdFx0XHRmb3JtYXQgPSBmb3JtYXQgfHwgdGhpcy5sb2NhbC5kYXRlRm9ybWF0O1xyXG5cdFx0XHRzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xyXG5cdFx0XHR2YXIgZGF5TmFtZXNTaG9ydCA9IHNldHRpbmdzLmRheU5hbWVzU2hvcnQgfHwgdGhpcy5sb2NhbC5kYXlOYW1lc1Nob3J0O1xyXG5cdFx0XHR2YXIgZGF5TmFtZXMgPSBzZXR0aW5ncy5kYXlOYW1lcyB8fCB0aGlzLmxvY2FsLmRheU5hbWVzO1xyXG5cdFx0XHR2YXIgbW9udGhOYW1lc1Nob3J0ID0gc2V0dGluZ3MubW9udGhOYW1lc1Nob3J0IHx8IHRoaXMubG9jYWwubW9udGhOYW1lc1Nob3J0O1xyXG5cdFx0XHR2YXIgbW9udGhOYW1lcyA9IHNldHRpbmdzLm1vbnRoTmFtZXMgfHwgdGhpcy5sb2NhbC5tb250aE5hbWVzO1xyXG5cdFx0XHR2YXIgY2FsY3VsYXRlV2VlayA9IHNldHRpbmdzLmNhbGN1bGF0ZVdlZWsgfHwgdGhpcy5sb2NhbC5jYWxjdWxhdGVXZWVrO1xyXG5cdFx0XHQvLyBDaGVjayB3aGV0aGVyIGEgZm9ybWF0IGNoYXJhY3RlciBpcyBkb3VibGVkXHJcblx0XHRcdHZhciBkb3VibGVkID0gZnVuY3Rpb24obWF0Y2gsIHN0ZXApIHtcclxuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9IDE7XHJcblx0XHRcdFx0d2hpbGUgKGlGb3JtYXQgKyBtYXRjaGVzIDwgZm9ybWF0Lmxlbmd0aCAmJiBmb3JtYXQuY2hhckF0KGlGb3JtYXQgKyBtYXRjaGVzKSA9PT0gbWF0Y2gpIHtcclxuXHRcdFx0XHRcdG1hdGNoZXMrKztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aUZvcm1hdCArPSBtYXRjaGVzIC0gMTtcclxuXHRcdFx0XHRyZXR1cm4gTWF0aC5mbG9vcihtYXRjaGVzIC8gKHN0ZXAgfHwgMSkpID4gMTtcclxuXHRcdFx0fTtcclxuXHRcdFx0Ly8gRm9ybWF0IGEgbnVtYmVyLCB3aXRoIGxlYWRpbmcgemVyb2VzIGlmIG5lY2Vzc2FyeVxyXG5cdFx0XHR2YXIgZm9ybWF0TnVtYmVyID0gZnVuY3Rpb24obWF0Y2gsIHZhbHVlLCBsZW4sIHN0ZXApIHtcclxuXHRcdFx0XHR2YXIgbnVtID0gJycgKyB2YWx1ZTtcclxuXHRcdFx0XHRpZiAoZG91YmxlZChtYXRjaCwgc3RlcCkpIHtcclxuXHRcdFx0XHRcdHdoaWxlIChudW0ubGVuZ3RoIDwgbGVuKSB7XHJcblx0XHRcdFx0XHRcdG51bSA9ICcwJyArIG51bTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIG51bTtcclxuXHRcdFx0fTtcclxuXHRcdFx0Ly8gRm9ybWF0IGEgbmFtZSwgc2hvcnQgb3IgbG9uZyBhcyByZXF1ZXN0ZWRcclxuXHRcdFx0dmFyIGZvcm1hdE5hbWUgPSBmdW5jdGlvbihtYXRjaCwgdmFsdWUsIHNob3J0TmFtZXMsIGxvbmdOYW1lcykge1xyXG5cdFx0XHRcdHJldHVybiAoZG91YmxlZChtYXRjaCkgPyBsb25nTmFtZXNbdmFsdWVdIDogc2hvcnROYW1lc1t2YWx1ZV0pO1xyXG5cdFx0XHR9O1xyXG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XHJcblx0XHRcdHZhciBsaXRlcmFsID0gZmFsc2U7XHJcblx0XHRcdGZvciAodmFyIGlGb3JtYXQgPSAwOyBpRm9ybWF0IDwgZm9ybWF0Lmxlbmd0aDsgaUZvcm1hdCsrKSB7XHJcblx0XHRcdFx0aWYgKGxpdGVyYWwpIHtcclxuXHRcdFx0XHRcdGlmIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpID09PSBcIidcIiAmJiAhZG91YmxlZChcIidcIikpIHtcclxuXHRcdFx0XHRcdFx0bGl0ZXJhbCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHN3aXRjaCAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xyXG5cdFx0XHRcdFx0XHRjYXNlICdkJzogb3V0cHV0ICs9IGZvcm1hdE51bWJlcignZCcsIGRhdGUuZGF5KCksIDIpOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnRCc6IG91dHB1dCArPSBmb3JtYXROYW1lKCdEJywgZGF0ZS5kYXlPZldlZWsoKSxcclxuXHRcdFx0XHRcdFx0XHRkYXlOYW1lc1Nob3J0LCBkYXlOYW1lcyk7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdvJzogb3V0cHV0ICs9IGZvcm1hdE51bWJlcignbycsIGRhdGUuZGF5T2ZZZWFyKCksIDMpOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAndyc6IG91dHB1dCArPSBmb3JtYXROdW1iZXIoJ3cnLCBkYXRlLndlZWtPZlllYXIoKSwgMik7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdtJzogb3V0cHV0ICs9IGZvcm1hdE51bWJlcignbScsIGRhdGUubW9udGgoKSwgMik7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdNJzogb3V0cHV0ICs9IGZvcm1hdE5hbWUoJ00nLCBkYXRlLm1vbnRoKCkgLSB0aGlzLm1pbk1vbnRoLFxyXG5cdFx0XHRcdFx0XHRcdG1vbnRoTmFtZXNTaG9ydCwgbW9udGhOYW1lcyk7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICd5JzpcclxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gKGRvdWJsZWQoJ3knLCAyKSA/IGRhdGUueWVhcigpIDpcclxuXHRcdFx0XHRcdFx0XHRcdChkYXRlLnllYXIoKSAlIDEwMCA8IDEwID8gJzAnIDogJycpICsgZGF0ZS55ZWFyKCkgJSAxMDApO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdZJzpcclxuXHRcdFx0XHRcdFx0XHRkb3VibGVkKCdZJywgMik7XHJcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGRhdGUuZm9ybWF0WWVhcigpO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdKJzogb3V0cHV0ICs9IGRhdGUudG9KRCgpOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnQCc6IG91dHB1dCArPSAoZGF0ZS50b0pEKCkgLSB0aGlzLlVOSVhfRVBPQ0gpICogdGhpcy5TRUNTX1BFUl9EQVk7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICchJzogb3V0cHV0ICs9IChkYXRlLnRvSkQoKSAtIHRoaXMuVElDS1NfRVBPQ0gpICogdGhpcy5USUNLU19QRVJfREFZOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSBcIidcIjpcclxuXHRcdFx0XHRcdFx0XHRpZiAoZG91YmxlZChcIidcIikpIHtcclxuXHRcdFx0XHRcdFx0XHRcdG91dHB1dCArPSBcIidcIjtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRsaXRlcmFsID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBvdXRwdXQ7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBQYXJzZSBhIHN0cmluZyB2YWx1ZSBpbnRvIGEgZGF0ZSBvYmplY3QuXHJcblx0XHRcdFNlZSA8YSBocmVmPVwiI2Zvcm1hdERhdGVcIj48Y29kZT5mb3JtYXREYXRlPC9jb2RlPjwvYT4gZm9yIHRoZSBwb3NzaWJsZSBmb3JtYXRzLCBwbHVzOlxyXG5cdFx0XHQ8dWw+XHJcblx0XHRcdDxsaT4qIC0gaWdub3JlIHJlc3Qgb2Ygc3RyaW5nPC9saT5cclxuXHRcdFx0PC91bD5cclxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSBmb3JtYXQge3N0cmluZ30gVGhlIGV4cGVjdGVkIGZvcm1hdCBvZiB0aGUgZGF0ZSAoJycgZm9yIGRlZmF1bHQgY2FsZW5kYXIgZm9ybWF0KS5cclxuXHRcdFx0QHBhcmFtIHZhbHVlIHtzdHJpbmd9IFRoZSBkYXRlIGluIHRoZSBhYm92ZSBmb3JtYXQuXHJcblx0XHRcdEBwYXJhbSBbc2V0dGluZ3NdIHtvYmplY3R9IEFkZGl0aW9uYWwgb3B0aW9ucyB3aG9zZSBhdHRyaWJ1dGVzIGluY2x1ZGU6XHJcblx0XHRcdEBwcm9wZXJ0eSBbc2hvcnRZZWFyQ3V0b2ZmXSB7bnVtYmVyfSBUaGUgY3V0b2ZmIHllYXIgZm9yIGRldGVybWluaW5nIHRoZSBjZW50dXJ5LlxyXG5cdFx0XHRAcHJvcGVydHkgW2RheU5hbWVzU2hvcnRdIHtzdHJpbmdbXX0gQWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkuXHJcblx0XHRcdEBwcm9wZXJ0eSBbZGF5TmFtZXNdIHtzdHJpbmdbXX0gTmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkuXHJcblx0XHRcdEBwcm9wZXJ0eSBbbW9udGhOYW1lc1Nob3J0XSB7c3RyaW5nW119IEFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBtb250aHMuXHJcblx0XHRcdEBwcm9wZXJ0eSBbbW9udGhOYW1lc10ge3N0cmluZ1tdfSBOYW1lcyBvZiB0aGUgbW9udGhzLlxyXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gVGhlIGV4dHJhY3RlZCBkYXRlIHZhbHVlIG9yIDxjb2RlPm51bGw8L2NvZGU+IGlmIHZhbHVlIGlzIGJsYW5rLlxyXG5cdFx0XHRAdGhyb3dzIEVycm9ycyBpZiB0aGUgZm9ybWF0IGFuZC9vciB2YWx1ZSBhcmUgbWlzc2luZyxcclxuXHRcdFx0XHRcdGlmIHRoZSB2YWx1ZSBkb2Vzbid0IG1hdGNoIHRoZSBmb3JtYXQsIG9yIGlmIHRoZSBkYXRlIGlzIGludmFsaWQuICovXHJcblx0XHRwYXJzZURhdGU6IGZ1bmN0aW9uKGZvcm1hdCwgdmFsdWUsIHNldHRpbmdzKSB7XHJcblx0XHRcdGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcblx0XHRcdFx0dGhyb3cgJC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZEFyZ3VtZW50cyB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWRBcmd1bWVudHM7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFsdWUgPSAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZSArICcnKTtcclxuXHRcdFx0aWYgKHZhbHVlID09PSAnJykge1xyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvcm1hdCA9IGZvcm1hdCB8fCB0aGlzLmxvY2FsLmRhdGVGb3JtYXQ7XHJcblx0XHRcdHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XHJcblx0XHRcdHZhciBzaG9ydFllYXJDdXRvZmYgPSBzZXR0aW5ncy5zaG9ydFllYXJDdXRvZmYgfHwgdGhpcy5zaG9ydFllYXJDdXRvZmY7XHJcblx0XHRcdHNob3J0WWVhckN1dG9mZiA9ICh0eXBlb2Ygc2hvcnRZZWFyQ3V0b2ZmICE9PSAnc3RyaW5nJyA/IHNob3J0WWVhckN1dG9mZiA6XHJcblx0XHRcdFx0dGhpcy50b2RheSgpLnllYXIoKSAlIDEwMCArIHBhcnNlSW50KHNob3J0WWVhckN1dG9mZiwgMTApKTtcclxuXHRcdFx0dmFyIGRheU5hbWVzU2hvcnQgPSBzZXR0aW5ncy5kYXlOYW1lc1Nob3J0IHx8IHRoaXMubG9jYWwuZGF5TmFtZXNTaG9ydDtcclxuXHRcdFx0dmFyIGRheU5hbWVzID0gc2V0dGluZ3MuZGF5TmFtZXMgfHwgdGhpcy5sb2NhbC5kYXlOYW1lcztcclxuXHRcdFx0dmFyIG1vbnRoTmFtZXNTaG9ydCA9IHNldHRpbmdzLm1vbnRoTmFtZXNTaG9ydCB8fCB0aGlzLmxvY2FsLm1vbnRoTmFtZXNTaG9ydDtcclxuXHRcdFx0dmFyIG1vbnRoTmFtZXMgPSBzZXR0aW5ncy5tb250aE5hbWVzIHx8IHRoaXMubG9jYWwubW9udGhOYW1lcztcclxuXHRcdFx0dmFyIGpkID0gLTE7XHJcblx0XHRcdHZhciB5ZWFyID0gLTE7XHJcblx0XHRcdHZhciBtb250aCA9IC0xO1xyXG5cdFx0XHR2YXIgZGF5ID0gLTE7XHJcblx0XHRcdHZhciBkb3kgPSAtMTtcclxuXHRcdFx0dmFyIHNob3J0WWVhciA9IGZhbHNlO1xyXG5cdFx0XHR2YXIgbGl0ZXJhbCA9IGZhbHNlO1xyXG5cdFx0XHQvLyBDaGVjayB3aGV0aGVyIGEgZm9ybWF0IGNoYXJhY3RlciBpcyBkb3VibGVkXHJcblx0XHRcdHZhciBkb3VibGVkID0gZnVuY3Rpb24obWF0Y2gsIHN0ZXApIHtcclxuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9IDE7XHJcblx0XHRcdFx0d2hpbGUgKGlGb3JtYXQgKyBtYXRjaGVzIDwgZm9ybWF0Lmxlbmd0aCAmJiBmb3JtYXQuY2hhckF0KGlGb3JtYXQgKyBtYXRjaGVzKSA9PT0gbWF0Y2gpIHtcclxuXHRcdFx0XHRcdG1hdGNoZXMrKztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aUZvcm1hdCArPSBtYXRjaGVzIC0gMTtcclxuXHRcdFx0XHRyZXR1cm4gTWF0aC5mbG9vcihtYXRjaGVzIC8gKHN0ZXAgfHwgMSkpID4gMTtcclxuXHRcdFx0fTtcclxuXHRcdFx0Ly8gRXh0cmFjdCBhIG51bWJlciBmcm9tIHRoZSBzdHJpbmcgdmFsdWVcclxuXHRcdFx0dmFyIGdldE51bWJlciA9IGZ1bmN0aW9uKG1hdGNoLCBzdGVwKSB7XHJcblx0XHRcdFx0dmFyIGlzRG91YmxlZCA9IGRvdWJsZWQobWF0Y2gsIHN0ZXApO1xyXG5cdFx0XHRcdHZhciBzaXplID0gWzIsIDMsIGlzRG91YmxlZCA/IDQgOiAyLCBpc0RvdWJsZWQgPyA0IDogMiwgMTAsIDExLCAyMF1bJ295WUpAIScuaW5kZXhPZihtYXRjaCkgKyAxXTtcclxuXHRcdFx0XHR2YXIgZGlnaXRzID0gbmV3IFJlZ0V4cCgnXi0/XFxcXGR7MSwnICsgc2l6ZSArICd9Jyk7XHJcblx0XHRcdFx0dmFyIG51bSA9IHZhbHVlLnN1YnN0cmluZyhpVmFsdWUpLm1hdGNoKGRpZ2l0cyk7XHJcblx0XHRcdFx0aWYgKCFudW0pIHtcclxuXHRcdFx0XHRcdHRocm93ICgkLmNhbGVuZGFycy5sb2NhbC5taXNzaW5nTnVtYmVyQXQgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5taXNzaW5nTnVtYmVyQXQpLlxyXG5cdFx0XHRcdFx0XHRyZXBsYWNlKC9cXHswXFx9LywgaVZhbHVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aVZhbHVlICs9IG51bVswXS5sZW5ndGg7XHJcblx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KG51bVswXSwgMTApO1xyXG5cdFx0XHR9O1xyXG5cdFx0XHQvLyBFeHRyYWN0IGEgbmFtZSBmcm9tIHRoZSBzdHJpbmcgdmFsdWUgYW5kIGNvbnZlcnQgdG8gYW4gaW5kZXhcclxuXHRcdFx0dmFyIGNhbGVuZGFyID0gdGhpcztcclxuXHRcdFx0dmFyIGdldE5hbWUgPSBmdW5jdGlvbihtYXRjaCwgc2hvcnROYW1lcywgbG9uZ05hbWVzLCBzdGVwKSB7XHJcblx0XHRcdFx0dmFyIG5hbWVzID0gKGRvdWJsZWQobWF0Y2gsIHN0ZXApID8gbG9uZ05hbWVzIDogc2hvcnROYW1lcyk7XHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0aWYgKHZhbHVlLnN1YnN0cihpVmFsdWUsIG5hbWVzW2ldLmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gbmFtZXNbaV0udG9Mb3dlckNhc2UoKSkge1xyXG5cdFx0XHRcdFx0XHRpVmFsdWUgKz0gbmFtZXNbaV0ubGVuZ3RoO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gaSArIGNhbGVuZGFyLm1pbk1vbnRoO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aHJvdyAoJC5jYWxlbmRhcnMubG9jYWwudW5rbm93bk5hbWVBdCB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLnVua25vd25OYW1lQXQpLlxyXG5cdFx0XHRcdFx0cmVwbGFjZSgvXFx7MFxcfS8sIGlWYWx1ZSk7XHJcblx0XHRcdH07XHJcblx0XHRcdC8vIENvbmZpcm0gdGhhdCBhIGxpdGVyYWwgY2hhcmFjdGVyIG1hdGNoZXMgdGhlIHN0cmluZyB2YWx1ZVxyXG5cdFx0XHR2YXIgY2hlY2tMaXRlcmFsID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0aWYgKHZhbHVlLmNoYXJBdChpVmFsdWUpICE9PSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpKSB7XHJcblx0XHRcdFx0XHR0aHJvdyAoJC5jYWxlbmRhcnMubG9jYWwudW5leHBlY3RlZExpdGVyYWxBdCB8fFxyXG5cdFx0XHRcdFx0XHQkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLnVuZXhwZWN0ZWRMaXRlcmFsQXQpLnJlcGxhY2UoL1xcezBcXH0vLCBpVmFsdWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpVmFsdWUrKztcclxuXHRcdFx0fTtcclxuXHRcdFx0dmFyIGlWYWx1ZSA9IDA7XHJcblx0XHRcdGZvciAodmFyIGlGb3JtYXQgPSAwOyBpRm9ybWF0IDwgZm9ybWF0Lmxlbmd0aDsgaUZvcm1hdCsrKSB7XHJcblx0XHRcdFx0aWYgKGxpdGVyYWwpIHtcclxuXHRcdFx0XHRcdGlmIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpID09PSBcIidcIiAmJiAhZG91YmxlZChcIidcIikpIHtcclxuXHRcdFx0XHRcdFx0bGl0ZXJhbCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdGNoZWNrTGl0ZXJhbCgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHN3aXRjaCAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xyXG5cdFx0XHRcdFx0XHRjYXNlICdkJzogZGF5ID0gZ2V0TnVtYmVyKCdkJyk7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdEJzogZ2V0TmFtZSgnRCcsIGRheU5hbWVzU2hvcnQsIGRheU5hbWVzKTsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ28nOiBkb3kgPSBnZXROdW1iZXIoJ28nKTsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ3cnOiBnZXROdW1iZXIoJ3cnKTsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ20nOiBtb250aCA9IGdldE51bWJlcignbScpOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnTSc6IG1vbnRoID0gZ2V0TmFtZSgnTScsIG1vbnRoTmFtZXNTaG9ydCwgbW9udGhOYW1lcyk7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICd5JzpcclxuXHRcdFx0XHRcdFx0XHR2YXIgaVNhdmUgPSBpRm9ybWF0O1xyXG5cdFx0XHRcdFx0XHRcdHNob3J0WWVhciA9ICFkb3VibGVkKCd5JywgMik7XHJcblx0XHRcdFx0XHRcdFx0aUZvcm1hdCA9IGlTYXZlO1xyXG5cdFx0XHRcdFx0XHRcdHllYXIgPSBnZXROdW1iZXIoJ3knLCAyKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnWSc6IHllYXIgPSBnZXROdW1iZXIoJ1knLCAyKTsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ0onOlxyXG5cdFx0XHRcdFx0XHRcdGpkID0gZ2V0TnVtYmVyKCdKJykgKyAwLjU7XHJcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlLmNoYXJBdChpVmFsdWUpID09PSAnLicpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlWYWx1ZSsrO1xyXG5cdFx0XHRcdFx0XHRcdFx0Z2V0TnVtYmVyKCdKJyk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdAJzogamQgPSBnZXROdW1iZXIoJ0AnKSAvIHRoaXMuU0VDU19QRVJfREFZICsgdGhpcy5VTklYX0VQT0NIOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnISc6IGpkID0gZ2V0TnVtYmVyKCchJykgLyB0aGlzLlRJQ0tTX1BFUl9EQVkgKyB0aGlzLlRJQ0tTX0VQT0NIOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnKic6IGlWYWx1ZSA9IHZhbHVlLmxlbmd0aDsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgXCInXCI6XHJcblx0XHRcdFx0XHRcdFx0aWYgKGRvdWJsZWQoXCInXCIpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRjaGVja0xpdGVyYWwoKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRsaXRlcmFsID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGRlZmF1bHQ6IGNoZWNrTGl0ZXJhbCgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoaVZhbHVlIDwgdmFsdWUubGVuZ3RoKSB7XHJcblx0XHRcdFx0dGhyb3cgJC5jYWxlbmRhcnMubG9jYWwudW5leHBlY3RlZFRleHQgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS51bmV4cGVjdGVkVGV4dDtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoeWVhciA9PT0gLTEpIHtcclxuXHRcdFx0XHR5ZWFyID0gdGhpcy50b2RheSgpLnllYXIoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmICh5ZWFyIDwgMTAwICYmIHNob3J0WWVhcikge1xyXG5cdFx0XHRcdHllYXIgKz0gKHNob3J0WWVhckN1dG9mZiA9PT0gLTEgPyAxOTAwIDogdGhpcy50b2RheSgpLnllYXIoKSAtXHJcblx0XHRcdFx0XHR0aGlzLnRvZGF5KCkueWVhcigpICUgMTAwIC0gKHllYXIgPD0gc2hvcnRZZWFyQ3V0b2ZmID8gMCA6IDEwMCkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChkb3kgPiAtMSkge1xyXG5cdFx0XHRcdG1vbnRoID0gMTtcclxuXHRcdFx0XHRkYXkgPSBkb3k7XHJcblx0XHRcdFx0Zm9yICh2YXIgZGltID0gdGhpcy5kYXlzSW5Nb250aCh5ZWFyLCBtb250aCk7IGRheSA+IGRpbTsgZGltID0gdGhpcy5kYXlzSW5Nb250aCh5ZWFyLCBtb250aCkpIHtcclxuXHRcdFx0XHRcdG1vbnRoKys7XHJcblx0XHRcdFx0XHRkYXkgLT0gZGltO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gKGpkID4gLTEgPyB0aGlzLmZyb21KRChqZCkgOiB0aGlzLm5ld0RhdGUoeWVhciwgbW9udGgsIGRheSkpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQSBkYXRlIG1heSBiZSBzcGVjaWZpZWQgYXMgYW4gZXhhY3QgdmFsdWUgb3IgYSByZWxhdGl2ZSBvbmUuXHJcblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxyXG5cdFx0XHRAcGFyYW0gZGF0ZVNwZWMge0NEYXRlfG51bWJlcnxzdHJpbmd9IFRoZSBkYXRlIGFzIGFuIG9iamVjdCBvciBzdHJpbmcgaW4gdGhlIGdpdmVuIGZvcm1hdCBvclxyXG5cdFx0XHRcdFx0YW4gb2Zmc2V0IC0gbnVtZXJpYyBkYXlzIGZyb20gdG9kYXksIG9yIHN0cmluZyBhbW91bnRzIGFuZCBwZXJpb2RzLCBlLmcuICcrMW0gKzJ3Jy5cclxuXHRcdFx0QHBhcmFtIGRlZmF1bHREYXRlIHtDRGF0ZX0gVGhlIGRhdGUgdG8gdXNlIGlmIG5vIG90aGVyIHN1cHBsaWVkLCBtYXkgYmUgPGNvZGU+bnVsbDwvY29kZT4uXHJcblx0XHRcdEBwYXJhbSBjdXJyZW50RGF0ZSB7Q0RhdGV9IFRoZSBjdXJyZW50IGRhdGUgYXMgYSBwb3NzaWJsZSBiYXNpcyBmb3IgcmVsYXRpdmUgZGF0ZXMsXHJcblx0XHRcdFx0XHRpZiA8Y29kZT5udWxsPC9jb2RlPiB0b2RheSBpcyB1c2VkIChvcHRpb25hbClcclxuXHRcdFx0QHBhcmFtIFtkYXRlRm9ybWF0XSB7c3RyaW5nfSBUaGUgZXhwZWN0ZWQgZGF0ZSBmb3JtYXQgLSBzZWUgPGEgaHJlZj1cIiNmb3JtYXREYXRlXCI+PGNvZGU+Zm9ybWF0RGF0ZTwvY29kZT48L2E+LlxyXG5cdFx0XHRAcGFyYW0gW3NldHRpbmdzXSB7b2JqZWN0fSBBZGRpdGlvbmFsIG9wdGlvbnMgd2hvc2UgYXR0cmlidXRlcyBpbmNsdWRlOlxyXG5cdFx0XHRAcHJvcGVydHkgW3Nob3J0WWVhckN1dG9mZl0ge251bWJlcn0gVGhlIGN1dG9mZiB5ZWFyIGZvciBkZXRlcm1pbmluZyB0aGUgY2VudHVyeS5cclxuXHRcdFx0QHByb3BlcnR5IFtkYXlOYW1lc1Nob3J0XSB7c3RyaW5nW119IEFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5LlxyXG5cdFx0XHRAcHJvcGVydHkgW2RheU5hbWVzXSB7c3RyaW5nW119IE5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5LlxyXG5cdFx0XHRAcHJvcGVydHkgW21vbnRoTmFtZXNTaG9ydF0ge3N0cmluZ1tdfSBBYmJyZXZpYXRlZCBuYW1lcyBvZiB0aGUgbW9udGhzLlxyXG5cdFx0XHRAcHJvcGVydHkgW21vbnRoTmFtZXNdIHtzdHJpbmdbXX0gTmFtZXMgb2YgdGhlIG1vbnRocy5cclxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBkZWNvZGVkIGRhdGUuICovXHJcblx0XHRkZXRlcm1pbmVEYXRlOiBmdW5jdGlvbihkYXRlU3BlYywgZGVmYXVsdERhdGUsIGN1cnJlbnREYXRlLCBkYXRlRm9ybWF0LCBzZXR0aW5ncykge1xyXG5cdFx0XHRpZiAoY3VycmVudERhdGUgJiYgdHlwZW9mIGN1cnJlbnREYXRlICE9PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRcdHNldHRpbmdzID0gZGF0ZUZvcm1hdDtcclxuXHRcdFx0XHRkYXRlRm9ybWF0ID0gY3VycmVudERhdGU7XHJcblx0XHRcdFx0Y3VycmVudERhdGUgPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0eXBlb2YgZGF0ZUZvcm1hdCAhPT0gJ3N0cmluZycpIHtcclxuXHRcdFx0XHRzZXR0aW5ncyA9IGRhdGVGb3JtYXQ7XHJcblx0XHRcdFx0ZGF0ZUZvcm1hdCA9ICcnO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBjYWxlbmRhciA9IHRoaXM7XHJcblx0XHRcdHZhciBvZmZzZXRTdHJpbmcgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGNhbGVuZGFyLnBhcnNlRGF0ZShkYXRlRm9ybWF0LCBvZmZzZXQsIHNldHRpbmdzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRcdC8vIElnbm9yZVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRvZmZzZXQgPSBvZmZzZXQudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0XHR2YXIgZGF0ZSA9IChvZmZzZXQubWF0Y2goL15jLykgJiYgY3VycmVudERhdGUgP1xyXG5cdFx0XHRcdFx0Y3VycmVudERhdGUubmV3RGF0ZSgpIDogbnVsbCkgfHwgY2FsZW5kYXIudG9kYXkoKTtcclxuXHRcdFx0XHR2YXIgcGF0dGVybiA9IC8oWystXT9bMC05XSspXFxzKihkfHd8bXx5KT8vZztcclxuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9IHBhdHRlcm4uZXhlYyhvZmZzZXQpO1xyXG5cdFx0XHRcdHdoaWxlIChtYXRjaGVzKSB7XHJcblx0XHRcdFx0XHRkYXRlLmFkZChwYXJzZUludChtYXRjaGVzWzFdLCAxMCksIG1hdGNoZXNbMl0gfHwgJ2QnKTtcclxuXHRcdFx0XHRcdG1hdGNoZXMgPSBwYXR0ZXJuLmV4ZWMob2Zmc2V0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGRhdGU7XHJcblx0XHRcdH07XHJcblx0XHRcdGRlZmF1bHREYXRlID0gKGRlZmF1bHREYXRlID8gZGVmYXVsdERhdGUubmV3RGF0ZSgpIDogbnVsbCk7XHJcblx0XHRcdGRhdGVTcGVjID0gKGRhdGVTcGVjID09IG51bGwgPyBkZWZhdWx0RGF0ZSA6XHJcblx0XHRcdFx0KHR5cGVvZiBkYXRlU3BlYyA9PT0gJ3N0cmluZycgPyBvZmZzZXRTdHJpbmcoZGF0ZVNwZWMpIDogKHR5cGVvZiBkYXRlU3BlYyA9PT0gJ251bWJlcicgP1xyXG5cdFx0XHRcdChpc05hTihkYXRlU3BlYykgfHwgZGF0ZVNwZWMgPT09IEluZmluaXR5IHx8IGRhdGVTcGVjID09PSAtSW5maW5pdHkgPyBkZWZhdWx0RGF0ZSA6XHJcblx0XHRcdFx0Y2FsZW5kYXIudG9kYXkoKS5hZGQoZGF0ZVNwZWMsICdkJykpIDogY2FsZW5kYXIubmV3RGF0ZShkYXRlU3BlYykpKSk7XHJcblx0XHRcdHJldHVybiBkYXRlU3BlYztcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcbn0pKGpRdWVyeSk7XHJcbi8qIGh0dHA6Ly9rZWl0aC13b29kLm5hbWUvY2FsZW5kYXJzLmh0bWxcclxuICAgQ2FsZW5kYXJzIGRhdGUgcGlja2VyIGZvciBqUXVlcnkgdjIuMC4xLlxyXG4gICBXcml0dGVuIGJ5IEtlaXRoIFdvb2QgKGtid29vZHthdH1paW5ldC5jb20uYXUpIEF1Z3VzdCAyMDA5LlxyXG4gICBBdmFpbGFibGUgdW5kZXIgdGhlIE1JVCAoaHR0cDovL2tlaXRoLXdvb2QubmFtZS9saWNlbmNlLmh0bWwpIGxpY2Vuc2UuIFxyXG4gICBQbGVhc2UgYXR0cmlidXRlIHRoZSBhdXRob3IgaWYgeW91IHVzZSBpdC4gKi9cclxuXHJcbihmdW5jdGlvbigkKSB7IC8vIEhpZGUgc2NvcGUsIG5vICQgY29uZmxpY3RcclxuXHJcblx0dmFyIHBsdWdpbk5hbWUgPSAnY2FsZW5kYXJzUGlja2VyJztcclxuXHJcblxyXG5cdC8qKiBDcmVhdGUgdGhlIGNhbGVuZGFycyBkYXRlcGlja2VyIHBsdWdpbi5cclxuXHRcdDxwPlNldHMgYW4gaW5wdXQgZmllbGQgdG8gcG9wdXAgYSBjYWxlbmRhciBmb3IgZGF0ZSBlbnRyeSxcclxuXHRcdFx0b3IgYSA8Y29kZT5kaXY8L2NvZGU+IG9yIDxjb2RlPnNwYW48L2NvZGU+IHRvIHNob3cgYW4gaW5saW5lIGNhbGVuZGFyLjwvcD5cclxuXHRcdDxwPkV4cGVjdHMgSFRNTCBsaWtlOjwvcD5cclxuXHRcdDxwcmU+Jmx0O2lucHV0IHR5cGU9XCJ0ZXh0XCI+IG9yICZsdDtkaXY+Jmx0Oy9kaXY+PC9wcmU+XHJcblx0XHQ8cD5Qcm92aWRlIGlubGluZSBjb25maWd1cmF0aW9uIGxpa2U6PC9wPlxyXG5cdFx0PHByZT4mbHQ7aW5wdXQgdHlwZT1cInRleHRcIiBkYXRhLWNhbGVuZGFyc1BpY2tlcj1cIm5hbWU6ICd2YWx1ZSdcIi8+PC9wcmU+XHJcblx0IFx0QGNsYXNzIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0QGF1Z21lbnRzIEpRUGx1Z2luXHJcblx0XHRAZXhhbXBsZSAkKHNlbGVjdG9yKS5jYWxlbmRhcnNQaWNrZXIoKVxyXG4gJChzZWxlY3RvcikuY2FsZW5kYXJzUGlja2VyKHttaW5EYXRlOiAwLCBtYXhEYXRlOiAnKzFtICsxdyd9KSAqL1xyXG5cdCQuSlFQbHVnaW4uY3JlYXRlUGx1Z2luKHtcclxuXHRcclxuXHRcdC8qKiBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyICovXHJcblx0XHRuYW1lOiBwbHVnaW5OYW1lLFxyXG5cdFx0XHJcblx0XHQvKiogRGVmYXVsdCB0ZW1wbGF0ZSBmb3IgZ2VuZXJhdGluZyBhIGRhdGVwaWNrZXIuXHJcblx0XHRcdEluc2VydCBhbnl3aGVyZTpcclxuXHRcdFx0PHVsPlxyXG5cdFx0XHQ8bGk+J3tsMTBuOm5hbWV9JyB0byBpbnNlcnQgbG9jYWxpc2VkIHZhbHVlIGZvciBuYW1lLDwvbGk+XHJcblx0XHRcdDxsaT4ne2xpbms6bmFtZX0nIHRvIGluc2VydCBhIGxpbmsgdHJpZ2dlciBmb3IgY29tbWFuZCBuYW1lLDwvbGk+XHJcblx0XHRcdDxsaT4ne2J1dHRvbjpuYW1lfScgdG8gaW5zZXJ0IGEgYnV0dG9uIHRyaWdnZXIgZm9yIGNvbW1hbmQgbmFtZSw8L2xpPlxyXG5cdFx0XHQ8bGk+J3twb3B1cDpzdGFydH0uLi57cG9wdXA6ZW5kfScgdG8gbWFyayBhIHNlY3Rpb24gZm9yIGluY2x1c2lvbiBpbiBhIHBvcHVwIGRhdGVwaWNrZXIgb25seSw8L2xpPlxyXG5cdFx0XHQ8bGk+J3tpbmxpbmU6c3RhcnR9Li4ue2lubGluZTplbmR9JyB0byBtYXJrIGEgc2VjdGlvbiBmb3IgaW5jbHVzaW9uIGluIGFuIGlubGluZSBkYXRlcGlja2VyIG9ubHkuPC9saT5cclxuXHRcdFx0PC91bD5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJvcGVydHkgcGlja2VyIHtzdHJpbmd9IE92ZXJhbGwgc3RydWN0dXJlOiAne21vbnRoc30nIHRvIGluc2VydCBjYWxlbmRhciBtb250aHMuXHJcblx0XHRcdEBwcm9wZXJ0eSBtb250aFJvdyB7c3RyaW5nfSBPbmUgcm93IG9mIG1vbnRoczogJ3ttb250aHN9JyB0byBpbnNlcnQgY2FsZW5kYXIgbW9udGhzLlxyXG5cdFx0XHRAcHJvcGVydHkgbW9udGgge3N0cmluZ30gQSBzaW5nbGUgbW9udGg6ICd7bW9udGhIZWFkZXI8ZW0+OmRhdGVGb3JtYXQ8L2VtPn0nIHRvIGluc2VydCB0aGUgbW9udGggaGVhZGVyIC1cclxuXHRcdFx0XHRcdFx0PGVtPmRhdGVGb3JtYXQ8L2VtPiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gJ01NIHl5eXknLFxyXG5cdFx0XHRcdFx0XHQne3dlZWtIZWFkZXJ9JyB0byBpbnNlcnQgYSB3ZWVrIGhlYWRlciwgJ3t3ZWVrc30nIHRvIGluc2VydCB0aGUgbW9udGgncyB3ZWVrcy5cclxuXHRcdFx0QHByb3BlcnR5IHdlZWtIZWFkZXIge3N0cmluZ30gQSB3ZWVrIGhlYWRlcjogJ3tkYXlzfScgdG8gaW5zZXJ0IGluZGl2aWR1YWwgZGF5IG5hbWVzLlxyXG5cdFx0XHRAcHJvcGVydHkgZGF5SGVhZGVyIHtzdHJpbmd9IEluZGl2aWR1YWwgZGF5IGhlYWRlcjogJ3tkYXl9JyB0byBpbnNlcnQgZGF5IG5hbWUuXHJcblx0XHRcdEBwcm9wZXJ0eSB3ZWVrIHtzdHJpbmd9IE9uZSB3ZWVrIG9mIHRoZSBtb250aDogJ3tkYXlzfScgdG8gaW5zZXJ0IHRoZSB3ZWVrJ3MgZGF5cyxcclxuXHRcdFx0XHRcdFx0J3t3ZWVrT2ZZZWFyfScgdG8gaW5zZXJ0IHdlZWsgb2YgeWVhci5cclxuXHRcdFx0QHByb3BlcnR5IGRheSB7c3RyaW5nfSBBbiBpbmRpdmlkdWFsIGRheTogJ3tkYXl9JyB0byBpbnNlcnQgZGF5IHZhbHVlLlxyXG5cdFx0XHRAcHJvcGVydHkgbW9udGhTZWxlY3RvciB7c3RyaW5nfSBqUXVlcnkgc2VsZWN0b3IsIHJlbGF0aXZlIHRvIHBpY2tlciwgZm9yIGEgc2luZ2xlIG1vbnRoLlxyXG5cdFx0XHRAcHJvcGVydHkgZGF5U2VsZWN0b3Ige3N0cmluZ30galF1ZXJ5IHNlbGVjdG9yLCByZWxhdGl2ZSB0byBwaWNrZXIsIGZvciBpbmRpdmlkdWFsIGRheXMuXHJcblx0XHRcdEBwcm9wZXJ0eSBydGxDbGFzcyB7c3RyaW5nfSBDbGFzcyBmb3IgcmlnaHQtdG8tbGVmdCAoUlRMKSBsYW5ndWFnZXMuXHJcblx0XHRcdEBwcm9wZXJ0eSBtdWx0aUNsYXNzIHtzdHJpbmd9IENsYXNzIGZvciBtdWx0aS1tb250aCBkYXRlcGlja2Vycy5cclxuXHRcdFx0QHByb3BlcnR5IGRlZmF1bHRDbGFzcyB7c3RyaW5nfSBDbGFzcyBmb3Igc2VsZWN0YWJsZSBkYXRlcy5cclxuXHRcdFx0QHByb3BlcnR5IHNlbGVjdGVkQ2xhc3Mge3N0cmluZ30gQ2xhc3MgZm9yIGN1cnJlbnRseSBzZWxlY3RlZCBkYXRlcy5cclxuXHRcdFx0QHByb3BlcnR5IGhpZ2hsaWdodGVkQ2xhc3Mge3N0cmluZ30gQ2xhc3MgZm9yIGhpZ2hsaWdodGVkIGRhdGVzLlxyXG5cdFx0XHRAcHJvcGVydHkgdG9kYXlDbGFzcyB7c3RyaW5nfSBDbGFzcyBmb3IgdG9kYXkuXHJcblx0XHRcdEBwcm9wZXJ0eSBvdGhlck1vbnRoQ2xhc3Mge3N0cmluZ30gQ2xhc3MgZm9yIGRheXMgZnJvbSBvdGhlciBtb250aHMuXHJcblx0XHRcdEBwcm9wZXJ0eSB3ZWVrZW5kQ2xhc3Mge3N0cmluZ30gQ2xhc3MgZm9yIGRheXMgb24gd2Vla2VuZHMuXHJcblx0XHRcdEBwcm9wZXJ0eSBjb21tYW5kQ2xhc3Mge3N0cmluZ30gQ2xhc3MgcHJlZml4IGZvciBjb21tYW5kcy5cclxuXHRcdFx0QHByb3BlcnR5IGNvbW1hbmRCdXR0b25DbGFzcyB7c3RyaW5nfSBFeHRyYSBjbGFzcyhlcykgZm9yIGNvbW1hbmRzIHRoYXQgYXJlIGJ1dHRvbnMuXHJcblx0XHRcdEBwcm9wZXJ0eSBjb21tYW5kTGlua0NsYXNzIHtzdHJpbmd9IEV4dHJhIGNsYXNzKGVzKSBmb3IgY29tbWFuZHMgdGhhdCBhcmUgbGlua3MuXHJcblx0XHRcdEBwcm9wZXJ0eSBkaXNhYmxlZENsYXNzIHtzdHJpbmd9IENsYXNzIGZvciBkaXNhYmxlZCBjb21tYW5kcy4gKi9cclxuXHRcdGRlZmF1bHRSZW5kZXJlcjoge1xyXG5cdFx0XHRwaWNrZXI6ICc8ZGl2IGNsYXNzPVwiY2FsZW5kYXJzXCI+JyArXHJcblx0XHRcdCc8ZGl2IGNsYXNzPVwiY2FsZW5kYXJzLW5hdlwiPntsaW5rOnByZXZ9e2xpbms6dG9kYXl9e2xpbms6bmV4dH08L2Rpdj57bW9udGhzfScgK1xyXG5cdFx0XHQne3BvcHVwOnN0YXJ0fTxkaXYgY2xhc3M9XCJjYWxlbmRhcnMtY3RybFwiPntsaW5rOmNsZWFyfXtsaW5rOmNsb3NlfTwvZGl2Pntwb3B1cDplbmR9JyArXHJcblx0XHRcdCc8ZGl2IGNsYXNzPVwiY2FsZW5kYXJzLWNsZWFyLWZpeFwiPjwvZGl2PjwvZGl2PicsXHJcblx0XHRcdG1vbnRoUm93OiAnPGRpdiBjbGFzcz1cImNhbGVuZGFycy1tb250aC1yb3dcIj57bW9udGhzfTwvZGl2PicsXHJcblx0XHRcdG1vbnRoOiAnPGRpdiBjbGFzcz1cImNhbGVuZGFycy1tb250aFwiPjxkaXYgY2xhc3M9XCJjYWxlbmRhcnMtbW9udGgtaGVhZGVyXCI+e21vbnRoSGVhZGVyfTwvZGl2PicgK1xyXG5cdFx0XHQnPHRhYmxlPjx0aGVhZD57d2Vla0hlYWRlcn08L3RoZWFkPjx0Ym9keT57d2Vla3N9PC90Ym9keT48L3RhYmxlPjwvZGl2PicsXHJcblx0XHRcdHdlZWtIZWFkZXI6ICc8dHI+e2RheXN9PC90cj4nLFxyXG5cdFx0XHRkYXlIZWFkZXI6ICc8dGg+e2RheX08L3RoPicsXHJcblx0XHRcdHdlZWs6ICc8dHI+e2RheXN9PC90cj4nLFxyXG5cdFx0XHRkYXk6ICc8dGQ+e2RheX08L3RkPicsXHJcblx0XHRcdG1vbnRoU2VsZWN0b3I6ICcuY2FsZW5kYXJzLW1vbnRoJyxcclxuXHRcdFx0ZGF5U2VsZWN0b3I6ICd0ZCcsXHJcblx0XHRcdHJ0bENsYXNzOiAnY2FsZW5kYXJzLXJ0bCcsXHJcblx0XHRcdG11bHRpQ2xhc3M6ICdjYWxlbmRhcnMtbXVsdGknLFxyXG5cdFx0XHRkZWZhdWx0Q2xhc3M6ICcnLFxyXG5cdFx0XHRzZWxlY3RlZENsYXNzOiAnY2FsZW5kYXJzLXNlbGVjdGVkJyxcclxuXHRcdFx0aGlnaGxpZ2h0ZWRDbGFzczogJ2NhbGVuZGFycy1oaWdobGlnaHQnLFxyXG5cdFx0XHR0b2RheUNsYXNzOiAnY2FsZW5kYXJzLXRvZGF5JyxcclxuXHRcdFx0b3RoZXJNb250aENsYXNzOiAnY2FsZW5kYXJzLW90aGVyLW1vbnRoJyxcclxuXHRcdFx0d2Vla2VuZENsYXNzOiAnY2FsZW5kYXJzLXdlZWtlbmQnLFxyXG5cdFx0XHRjb21tYW5kQ2xhc3M6ICdjYWxlbmRhcnMtY21kJyxcclxuXHRcdFx0Y29tbWFuZEJ1dHRvbkNsYXNzOiAnJyxcclxuXHRcdFx0Y29tbWFuZExpbmtDbGFzczogJycsXHJcblx0XHRcdGRpc2FibGVkQ2xhc3M6ICdjYWxlbmRhcnMtZGlzYWJsZWQnXHJcblx0XHR9LFxyXG5cdFxyXG5cdFx0LyoqIENvbW1hbmQgYWN0aW9ucyB0aGF0IG1heSBiZSBhZGRlZCB0byBhIGxheW91dCBieSBuYW1lLlxyXG5cdFx0XHQ8dWw+XHJcblx0XHRcdDxsaT5wcmV2IC0gU2hvdyB0aGUgcHJldmlvdXMgbW9udGggKGJhc2VkIG9uIDxjb2RlPm1vbnRoc1RvU3RlcDwvY29kZT4gb3B0aW9uKSAtIDxlbT5QYWdlVXA8L2VtPjwvbGk+XHJcblx0XHRcdDxsaT5wcmV2SnVtcCAtIFNob3cgdGhlIHByZXZpb3VzIHllYXIgKGJhc2VkIG9uIDxjb2RlPm1vbnRoc1RvSnVtcDwvY29kZT4gb3B0aW9uKSAtIDxlbT5DdHJsK1BhZ2VVcDwvZW0+PC9saT5cclxuXHRcdFx0PGxpPm5leHQgLSBTaG93IHRoZSBuZXh0IG1vbnRoIChiYXNlZCBvbiA8Y29kZT5tb250aHNUb1N0ZXA8L2NvZGU+IG9wdGlvbikgLSA8ZW0+UGFnZURvd248L2VtPjwvbGk+XHJcblx0XHRcdDxsaT5uZXh0SnVtcCAtIFNob3cgdGhlIG5leHQgeWVhciAoYmFzZWQgb24gPGNvZGU+bW9udGhzVG9KdW1wPC9jb2RlPiBvcHRpb24pIC0gPGVtPkN0cmwrUGFnZURvd248L2VtPjwvbGk+XHJcblx0XHRcdDxsaT5jdXJyZW50IC0gU2hvdyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG1vbnRoIG9yIHRvZGF5J3MgaWYgbm9uZSBzZWxlY3RlZCAtIDxlbT5DdHJsK0hvbWU8L2VtPjwvbGk+XHJcblx0XHRcdDxsaT50b2RheSAtIFNob3cgdG9kYXkncyBtb250aCAtIDxlbT5DdHJsK0hvbWU8L2VtPjwvbGk+XHJcblx0XHRcdDxsaT5jbGVhciAtIEVyYXNlIHRoZSBkYXRlIGFuZCBjbG9zZSB0aGUgZGF0ZXBpY2tlciBwb3B1cCAtIDxlbT5DdHJsK0VuZDwvZW0+PC9saT5cclxuXHRcdFx0PGxpPmNsb3NlIC0gQ2xvc2UgdGhlIGRhdGVwaWNrZXIgcG9wdXAgLSA8ZW0+RXNjPC9lbT48L2xpPlxyXG5cdFx0XHQ8bGk+cHJldldlZWsgLSBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIHByZXZpb3VzIHdlZWsgLSA8ZW0+Q3RybCtVcDwvZW0+PC9saT5cclxuXHRcdFx0PGxpPnByZXZEYXkgLSBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIHByZXZpb3VzIGRheSAtIDxlbT5DdHJsK0xlZnQ8L2VtPjwvbGk+XHJcblx0XHRcdDxsaT5uZXh0RGF5IC0gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBuZXh0IGRheSAtIDxlbT5DdHJsK1JpZ2h0PC9lbT48L2xpPlxyXG5cdFx0XHQ8bGk+bmV4dFdlZWsgLSBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIG5leHQgd2VlayAtIDxlbT5DdHJsK0Rvd248L2VtPjwvbGk+XHJcblx0XHRcdDwvdWw+XHJcblx0XHRcdFRoZSBjb21tYW5kIG5hbWUgaXMgdGhlIGtleSBuYW1lIGFuZCBpcyB1c2VkIHRvIGFkZCB0aGUgY29tbWFuZCB0byBhIGxheW91dFxyXG5cdFx0XHR3aXRoICd7YnV0dG9uOm5hbWV9JyBvciAne2xpbms6bmFtZX0nLiBFYWNoIGhhcyB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXMuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByb3BlcnR5IHRleHQge3N0cmluZ30gVGhlIGZpZWxkIGluIHRoZSByZWdpb25hbCBzZXR0aW5ncyBmb3IgdGhlIGRpc3BsYXllZCB0ZXh0LlxyXG5cdFx0XHRAcHJvcGVydHkgc3RhdHVzIHtzdHJpbmd9IFRoZSBmaWVsZCBpbiB0aGUgcmVnaW9uYWwgc2V0dGluZ3MgZm9yIHRoZSBzdGF0dXMgdGV4dC5cclxuXHRcdFx0QHByb3BlcnR5IGtleXN0cm9rZSB7b2JqZWN0fSBUaGUga2V5c3Ryb2tlIHRvIHRyaWdnZXIgdGhlIGFjdGlvbiwgd2l0aCBhdHRyaWJ1dGVzOlxyXG5cdFx0XHRcdDxjb2RlPmtleUNvZGU8L2NvZGU+IHtudW1iZXJ9IHRoZSBjb2RlIGZvciB0aGUga2V5c3Ryb2tlLFxyXG5cdFx0XHRcdDxjb2RlPmN0cmxLZXk8L2NvZGU+IHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiA8ZW0+Q3RybDwvZW0+IGlzIHJlcXVpcmVkLFxyXG5cdFx0XHRcdDxjb2RlPmFsdEtleTwvY29kZT4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIDxlbT5BbHQ8L2VtPiBpcyByZXF1aXJlZCxcclxuXHRcdFx0XHQ8Y29kZT5zaGlmdEtleTwvY29kZT4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIDxlbT5TaGlmdDwvZW0+IGlzIHJlcXVpcmVkLlxyXG5cdFx0XHRAcHJvcGVydHkgZW5hYmxlZCB7Q2FsZW5kYXJzUGlja2VyQ29tbWFuZEVuYWJsZWR9IFRoZSBmdW5jdGlvbiB0aGF0IGluZGljYXRlcyB0aGUgY29tbWFuZCBpcyBlbmFibGVkLlxyXG5cdFx0XHRAcHJvcGVydHkgZGF0ZSB7Q2FsZW5kYXJzUGlja2VyQ29tbWFuZERhdGV9IFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGRhdGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgYWN0aW9uLlxyXG5cdFx0XHRAcHJvcGVydHkgYWN0aW9uIHtDYWxlbmRhcnNQaWNrZXJDb21tYW5kQWN0aW9ufSBUaGUgZnVuY3Rpb24gdGhhdCBpbXBsZW1lbnRzIHRoZSBhY3Rpb24uICovXHJcblx0XHRjb21tYW5kczoge1xyXG5cdFx0XHRwcmV2OiB7dGV4dDogJ3ByZXZUZXh0Jywgc3RhdHVzOiAncHJldlN0YXR1cycsIC8vIFByZXZpb3VzIG1vbnRoXHJcblx0XHRcdFx0a2V5c3Ryb2tlOiB7a2V5Q29kZTogMzN9LCAvLyBQYWdlIHVwXHJcblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHRcdFx0dmFyIG1pbkRhdGUgPSBpbnN0LmN1ck1pbkRhdGUoKTtcclxuXHRcdFx0XHRcdHJldHVybiAoIW1pbkRhdGUgfHwgaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuXHJcblx0XHRcdFx0XHRcdGFkZCgxIC0gaW5zdC5vcHRpb25zLm1vbnRoc1RvU3RlcCAtIGluc3Qub3B0aW9ucy5tb250aHNPZmZzZXQsICdtJykuXHJcblx0XHRcdFx0XHRcdGRheShpbnN0Lm9wdGlvbnMuY2FsZW5kYXIubWluRGF5KS5hZGQoLTEsICdkJykuY29tcGFyZVRvKG1pbkRhdGUpICE9PSAtMSk7IH0sXHJcblx0XHRcdFx0ZGF0ZTogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxyXG5cdFx0XHRcdFx0XHRhZGQoLWluc3Qub3B0aW9ucy5tb250aHNUb1N0ZXAgLSBpbnN0Lm9wdGlvbnMubW9udGhzT2Zmc2V0LCAnbScpLlxyXG5cdFx0XHRcdFx0XHRkYXkoaW5zdC5vcHRpb25zLmNhbGVuZGFyLm1pbkRheSk7IH0sXHJcblx0XHRcdFx0YWN0aW9uOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdFx0XHRwbHVnaW4uY2hhbmdlTW9udGgodGhpcywgLWluc3Qub3B0aW9ucy5tb250aHNUb1N0ZXApOyB9XHJcblx0XHRcdH0sXHJcblx0XHRcdHByZXZKdW1wOiB7dGV4dDogJ3ByZXZKdW1wVGV4dCcsIHN0YXR1czogJ3ByZXZKdW1wU3RhdHVzJywgLy8gUHJldmlvdXMgeWVhclxyXG5cdFx0XHRcdGtleXN0cm9rZToge2tleUNvZGU6IDMzLCBjdHJsS2V5OiB0cnVlfSwgLy8gQ3RybCArIFBhZ2UgdXBcclxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdFx0XHR2YXIgbWluRGF0ZSA9IGluc3QuY3VyTWluRGF0ZSgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuICghbWluRGF0ZSB8fCBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5cclxuXHRcdFx0XHRcdFx0YWRkKDEgLSBpbnN0Lm9wdGlvbnMubW9udGhzVG9KdW1wIC0gaW5zdC5vcHRpb25zLm1vbnRoc09mZnNldCwgJ20nKS5cclxuXHRcdFx0XHRcdFx0ZGF5KGluc3Qub3B0aW9ucy5jYWxlbmRhci5taW5EYXkpLmFkZCgtMSwgJ2QnKS5jb21wYXJlVG8obWluRGF0ZSkgIT09IC0xKTsgfSxcclxuXHRcdFx0XHRkYXRlOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuXHJcblx0XHRcdFx0XHRcdGFkZCgtaW5zdC5vcHRpb25zLm1vbnRoc1RvSnVtcCAtIGluc3Qub3B0aW9ucy5tb250aHNPZmZzZXQsICdtJykuXHJcblx0XHRcdFx0XHRcdGRheShpbnN0Lm9wdGlvbnMuY2FsZW5kYXIubWluRGF5KTsgfSxcclxuXHRcdFx0XHRhY3Rpb246IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0XHRcdHBsdWdpbi5jaGFuZ2VNb250aCh0aGlzLCAtaW5zdC5vcHRpb25zLm1vbnRoc1RvSnVtcCk7IH1cclxuXHRcdFx0fSxcclxuXHRcdFx0bmV4dDoge3RleHQ6ICduZXh0VGV4dCcsIHN0YXR1czogJ25leHRTdGF0dXMnLCAvLyBOZXh0IG1vbnRoXHJcblx0XHRcdFx0a2V5c3Ryb2tlOiB7a2V5Q29kZTogMzR9LCAvLyBQYWdlIGRvd25cclxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdFx0XHR2YXIgbWF4RGF0ZSA9IGluc3QuZ2V0KCdtYXhEYXRlJyk7XHJcblx0XHRcdFx0XHRyZXR1cm4gKCFtYXhEYXRlIHx8IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxyXG5cdFx0XHRcdFx0XHRhZGQoaW5zdC5vcHRpb25zLm1vbnRoc1RvU3RlcCAtIGluc3Qub3B0aW9ucy5tb250aHNPZmZzZXQsICdtJykuXHJcblx0XHRcdFx0XHRcdGRheShpbnN0Lm9wdGlvbnMuY2FsZW5kYXIubWluRGF5KS5jb21wYXJlVG8obWF4RGF0ZSkgIT09ICsxKTsgfSxcclxuXHRcdFx0XHRkYXRlOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuXHJcblx0XHRcdFx0XHRcdGFkZChpbnN0Lm9wdGlvbnMubW9udGhzVG9TdGVwIC0gaW5zdC5vcHRpb25zLm1vbnRoc09mZnNldCwgJ20nKS5cclxuXHRcdFx0XHRcdFx0ZGF5KGluc3Qub3B0aW9ucy5jYWxlbmRhci5taW5EYXkpOyB9LFxyXG5cdFx0XHRcdGFjdGlvbjogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHRcdFx0cGx1Z2luLmNoYW5nZU1vbnRoKHRoaXMsIGluc3Qub3B0aW9ucy5tb250aHNUb1N0ZXApOyB9XHJcblx0XHRcdH0sXHJcblx0XHRcdG5leHRKdW1wOiB7dGV4dDogJ25leHRKdW1wVGV4dCcsIHN0YXR1czogJ25leHRKdW1wU3RhdHVzJywgLy8gTmV4dCB5ZWFyXHJcblx0XHRcdFx0a2V5c3Ryb2tlOiB7a2V5Q29kZTogMzQsIGN0cmxLZXk6IHRydWV9LCAvLyBDdHJsICsgUGFnZSBkb3duXHJcblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHRcdFx0dmFyIG1heERhdGUgPSBpbnN0LmdldCgnbWF4RGF0ZScpO1xyXG5cdFx0XHRcdFx0cmV0dXJuICghbWF4RGF0ZSB8fCBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5cclxuXHRcdFx0XHRcdFx0YWRkKGluc3Qub3B0aW9ucy5tb250aHNUb0p1bXAgLSBpbnN0Lm9wdGlvbnMubW9udGhzT2Zmc2V0LCAnbScpLlxyXG5cdFx0XHRcdFx0XHRkYXkoaW5zdC5vcHRpb25zLmNhbGVuZGFyLm1pbkRheSkuY29tcGFyZVRvKG1heERhdGUpICE9PSArMSk7XHR9LFxyXG5cdFx0XHRcdGRhdGU6IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0XHRcdHJldHVybiBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5cclxuXHRcdFx0XHRcdFx0YWRkKGluc3Qub3B0aW9ucy5tb250aHNUb0p1bXAgLSBpbnN0Lm9wdGlvbnMubW9udGhzT2Zmc2V0LCAnbScpLlxyXG5cdFx0XHRcdFx0XHRkYXkoaW5zdC5vcHRpb25zLmNhbGVuZGFyLm1pbkRheSk7IH0sXHJcblx0XHRcdFx0YWN0aW9uOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdFx0XHRwbHVnaW4uY2hhbmdlTW9udGgodGhpcywgaW5zdC5vcHRpb25zLm1vbnRoc1RvSnVtcCk7IH1cclxuXHRcdFx0fSxcclxuXHRcdFx0Y3VycmVudDoge3RleHQ6ICdjdXJyZW50VGV4dCcsIHN0YXR1czogJ2N1cnJlbnRTdGF0dXMnLCAvLyBDdXJyZW50IG1vbnRoXHJcblx0XHRcdFx0a2V5c3Ryb2tlOiB7a2V5Q29kZTogMzYsIGN0cmxLZXk6IHRydWV9LCAvLyBDdHJsICsgSG9tZVxyXG5cdFx0XHRcdGVuYWJsZWQ6IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0XHRcdHZhciBtaW5EYXRlID0gaW5zdC5jdXJNaW5EYXRlKCk7XHJcblx0XHRcdFx0XHR2YXIgbWF4RGF0ZSA9IGluc3QuZ2V0KCdtYXhEYXRlJyk7XHJcblx0XHRcdFx0XHR2YXIgY3VyRGF0ZSA9IGluc3Quc2VsZWN0ZWREYXRlc1swXSB8fCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKTtcclxuXHRcdFx0XHRcdHJldHVybiAoIW1pbkRhdGUgfHwgY3VyRGF0ZS5jb21wYXJlVG8obWluRGF0ZSkgIT09IC0xKSAmJlxyXG5cdFx0XHRcdFx0XHQoIW1heERhdGUgfHwgY3VyRGF0ZS5jb21wYXJlVG8obWF4RGF0ZSkgIT09ICsxKTsgfSxcclxuXHRcdFx0XHRkYXRlOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gaW5zdC5zZWxlY3RlZERhdGVzWzBdIHx8IGluc3Qub3B0aW9ucy5jYWxlbmRhci50b2RheSgpOyB9LFxyXG5cdFx0XHRcdGFjdGlvbjogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHRcdFx0dmFyIGN1ckRhdGUgPSBpbnN0LnNlbGVjdGVkRGF0ZXNbMF0gfHwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCk7XHJcblx0XHRcdFx0XHRwbHVnaW4uc2hvd01vbnRoKHRoaXMsIGN1ckRhdGUueWVhcigpLCBjdXJEYXRlLm1vbnRoKCkpOyB9XHJcblx0XHRcdH0sXHJcblx0XHRcdHRvZGF5OiB7dGV4dDogJ3RvZGF5VGV4dCcsIHN0YXR1czogJ3RvZGF5U3RhdHVzJywgLy8gVG9kYXkncyBtb250aFxyXG5cdFx0XHRcdGtleXN0cm9rZToge2tleUNvZGU6IDM2LCBjdHJsS2V5OiB0cnVlfSwgLy8gQ3RybCArIEhvbWVcclxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdFx0XHR2YXIgbWluRGF0ZSA9IGluc3QuY3VyTWluRGF0ZSgpO1xyXG5cdFx0XHRcdFx0dmFyIG1heERhdGUgPSBpbnN0LmdldCgnbWF4RGF0ZScpO1xyXG5cdFx0XHRcdFx0cmV0dXJuICghbWluRGF0ZSB8fCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKS5jb21wYXJlVG8obWluRGF0ZSkgIT09IC0xKSAmJlxyXG5cdFx0XHRcdFx0XHQoIW1heERhdGUgfHwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCkuY29tcGFyZVRvKG1heERhdGUpICE9PSArMSk7IH0sXHJcblx0XHRcdFx0ZGF0ZTogZnVuY3Rpb24oaW5zdCkgeyByZXR1cm4gaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCk7IH0sXHJcblx0XHRcdFx0YWN0aW9uOiBmdW5jdGlvbihpbnN0KSB7IHBsdWdpbi5zaG93TW9udGgodGhpcyk7IH1cclxuXHRcdFx0fSxcclxuXHRcdFx0Y2xlYXI6IHt0ZXh0OiAnY2xlYXJUZXh0Jywgc3RhdHVzOiAnY2xlYXJTdGF0dXMnLCAvLyBDbGVhciB0aGUgZGF0ZXBpY2tlclxyXG5cdFx0XHRcdGtleXN0cm9rZToge2tleUNvZGU6IDM1LCBjdHJsS2V5OiB0cnVlfSwgLy8gQ3RybCArIEVuZFxyXG5cdFx0XHRcdGVuYWJsZWQ6IGZ1bmN0aW9uKGluc3QpIHsgcmV0dXJuIHRydWU7IH0sXHJcblx0XHRcdFx0ZGF0ZTogZnVuY3Rpb24oaW5zdCkgeyByZXR1cm4gbnVsbDsgfSxcclxuXHRcdFx0XHRhY3Rpb246IGZ1bmN0aW9uKGluc3QpIHsgcGx1Z2luLmNsZWFyKHRoaXMpOyB9XHJcblx0XHRcdH0sXHJcblx0XHRcdGNsb3NlOiB7dGV4dDogJ2Nsb3NlVGV4dCcsIHN0YXR1czogJ2Nsb3NlU3RhdHVzJywgLy8gQ2xvc2UgdGhlIGRhdGVwaWNrZXJcclxuXHRcdFx0XHRrZXlzdHJva2U6IHtrZXlDb2RlOiAyN30sIC8vIEVzY2FwZVxyXG5cdFx0XHRcdGVuYWJsZWQ6IGZ1bmN0aW9uKGluc3QpIHsgcmV0dXJuIHRydWU7IH0sXHJcblx0XHRcdFx0ZGF0ZTogZnVuY3Rpb24oaW5zdCkgeyByZXR1cm4gbnVsbDsgfSxcclxuXHRcdFx0XHRhY3Rpb246IGZ1bmN0aW9uKGluc3QpIHsgcGx1Z2luLmhpZGUodGhpcyk7IH1cclxuXHRcdFx0fSxcclxuXHRcdFx0cHJldldlZWs6IHt0ZXh0OiAncHJldldlZWtUZXh0Jywgc3RhdHVzOiAncHJldldlZWtTdGF0dXMnLCAvLyBQcmV2aW91cyB3ZWVrXHJcblx0XHRcdFx0a2V5c3Ryb2tlOiB7a2V5Q29kZTogMzgsIGN0cmxLZXk6IHRydWV9LCAvLyBDdHJsICsgVXBcclxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdFx0XHR2YXIgbWluRGF0ZSA9IGluc3QuY3VyTWluRGF0ZSgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuICghbWluRGF0ZSB8fCBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5cclxuXHRcdFx0XHRcdFx0YWRkKC1pbnN0Lm9wdGlvbnMuY2FsZW5kYXIuZGF5c0luV2VlaygpLCAnZCcpLmNvbXBhcmVUbyhtaW5EYXRlKSAhPT0gLTEpOyB9LFxyXG5cdFx0XHRcdGRhdGU6IGZ1bmN0aW9uKGluc3QpIHsgcmV0dXJuIGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxyXG5cdFx0XHRcdFx0YWRkKC1pbnN0Lm9wdGlvbnMuY2FsZW5kYXIuZGF5c0luV2VlaygpLCAnZCcpOyB9LFxyXG5cdFx0XHRcdGFjdGlvbjogZnVuY3Rpb24oaW5zdCkgeyBwbHVnaW4uY2hhbmdlRGF5KHRoaXMsIC1pbnN0Lm9wdGlvbnMuY2FsZW5kYXIuZGF5c0luV2VlaygpKTsgfVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRwcmV2RGF5OiB7dGV4dDogJ3ByZXZEYXlUZXh0Jywgc3RhdHVzOiAncHJldkRheVN0YXR1cycsIC8vIFByZXZpb3VzIGRheVxyXG5cdFx0XHRcdGtleXN0cm9rZToge2tleUNvZGU6IDM3LCBjdHJsS2V5OiB0cnVlfSwgLy8gQ3RybCArIExlZnRcclxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdFx0XHR2YXIgbWluRGF0ZSA9IGluc3QuY3VyTWluRGF0ZSgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuICghbWluRGF0ZSB8fCBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5hZGQoLTEsICdkJykuXHJcblx0XHRcdFx0XHRcdGNvbXBhcmVUbyhtaW5EYXRlKSAhPT0gLTEpOyB9LFxyXG5cdFx0XHRcdGRhdGU6IGZ1bmN0aW9uKGluc3QpIHsgcmV0dXJuIGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLmFkZCgtMSwgJ2QnKTsgfSxcclxuXHRcdFx0XHRhY3Rpb246IGZ1bmN0aW9uKGluc3QpIHsgcGx1Z2luLmNoYW5nZURheSh0aGlzLCAtMSk7IH1cclxuXHRcdFx0fSxcclxuXHRcdFx0bmV4dERheToge3RleHQ6ICduZXh0RGF5VGV4dCcsIHN0YXR1czogJ25leHREYXlTdGF0dXMnLCAvLyBOZXh0IGRheVxyXG5cdFx0XHRcdGtleXN0cm9rZToge2tleUNvZGU6IDM5LCBjdHJsS2V5OiB0cnVlfSwgLy8gQ3RybCArIFJpZ2h0XHJcblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHRcdFx0dmFyIG1heERhdGUgPSBpbnN0LmdldCgnbWF4RGF0ZScpO1xyXG5cdFx0XHRcdFx0cmV0dXJuICghbWF4RGF0ZSB8fCBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5hZGQoMSwgJ2QnKS5cclxuXHRcdFx0XHRcdFx0Y29tcGFyZVRvKG1heERhdGUpICE9PSArMSk7IH0sXHJcblx0XHRcdFx0ZGF0ZTogZnVuY3Rpb24oaW5zdCkgeyByZXR1cm4gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuYWRkKDEsICdkJyk7IH0sXHJcblx0XHRcdFx0YWN0aW9uOiBmdW5jdGlvbihpbnN0KSB7IHBsdWdpbi5jaGFuZ2VEYXkodGhpcywgMSk7IH1cclxuXHRcdFx0fSxcclxuXHRcdFx0bmV4dFdlZWs6IHt0ZXh0OiAnbmV4dFdlZWtUZXh0Jywgc3RhdHVzOiAnbmV4dFdlZWtTdGF0dXMnLCAvLyBOZXh0IHdlZWtcclxuXHRcdFx0XHRrZXlzdHJva2U6IHtrZXlDb2RlOiA0MCwgY3RybEtleTogdHJ1ZX0sIC8vIEN0cmwgKyBEb3duXHJcblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHRcdFx0dmFyIG1heERhdGUgPSBpbnN0LmdldCgnbWF4RGF0ZScpO1xyXG5cdFx0XHRcdFx0cmV0dXJuICghbWF4RGF0ZSB8fCBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5cclxuXHRcdFx0XHRcdFx0YWRkKGluc3Qub3B0aW9ucy5jYWxlbmRhci5kYXlzSW5XZWVrKCksICdkJykuY29tcGFyZVRvKG1heERhdGUpICE9PSArMSk7IH0sXHJcblx0XHRcdFx0ZGF0ZTogZnVuY3Rpb24oaW5zdCkgeyByZXR1cm4gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuXHJcblx0XHRcdFx0XHRhZGQoaW5zdC5vcHRpb25zLmNhbGVuZGFyLmRheXNJbldlZWsoKSwgJ2QnKTsgfSxcclxuXHRcdFx0XHRhY3Rpb246IGZ1bmN0aW9uKGluc3QpIHsgcGx1Z2luLmNoYW5nZURheSh0aGlzLCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIuZGF5c0luV2VlaygpKTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBEZXRlcm1pbmUgd2hldGhlciBhIGNvbW1hbmQgaXMgZW5hYmxlZC5cclxuXHRcdFx0QGNhbGxiYWNrIENhbGVuZGFyc1BpY2tlckNvbW1hbmRFbmFibGVkXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxyXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGlzIGNvbW1hbmQgaXMgZW5hYmxlZCwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdC5cclxuXHRcdFx0QGV4YW1wbGUgZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkge1xyXG5cdHJldHVybiAhIWluc3QuY3VyTWluRGF0ZSgpO1xyXG4gfSAqL1xyXG5cclxuXHRcdC8qKiBDYWxjdWxhdGUgdGhlIHJlcHJlc2VudGF0aXZlIGRhdGUgZm9yIGEgY29tbWFuZC5cclxuXHRcdFx0QGNhbGxiYWNrIENhbGVuZGFyc1BpY2tlckNvbW1hbmREYXRlXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxyXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gQSBkYXRlIGFwcHJvcHJpYXRlIGZvciB0aGlzIGNvbW1hbmQuXHJcblx0XHRcdEBleGFtcGxlIGRhdGU6IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRyZXR1cm4gaW5zdC5jdXJNaW5EYXRlKCk7XHJcbiB9ICovXHJcblxyXG5cdFx0LyoqIFBlcmZvcm0gdGhlIGFjdGlvbiBmb3IgYSBjb21tYW5kLlxyXG5cdFx0XHRAY2FsbGJhY2sgQ2FsZW5kYXJzUGlja2VyQ29tbWFuZEFjdGlvblxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cclxuXHRcdFx0QGV4YW1wbGUgZGF0ZTogZnVuY3Rpb24oaW5zdCkge1xyXG5cdCQuZGF0ZXBpY2suc2V0RGF0ZShpbnN0LmVsZW0sIGluc3QuY3VyTWluRGF0ZSgpKTtcclxuIH0gKi9cclxuXHJcblx0XHQvKiogQ2FsY3VsYXRlIHRoZSB3ZWVrIG9mIHRoZSB5ZWFyIGZvciBhIGRhdGUuXHJcblx0XHRcdEBjYWxsYmFjayBDYWxlbmRhcnNQaWNrZXJDYWxjdWxhdGVXZWVrXHJcblx0XHRcdEBwYXJhbSBkYXRlIHtDRGF0ZX0gVGhlIGRhdGUgdG8gZXZhbHVhdGUuXHJcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIHdlZWsgb2YgdGhlIHllYXIuXHJcblx0XHRcdEBleGFtcGxlIGNhbGN1bGF0ZVdlZWs6IGZ1bmN0aW9uKGRhdGUpIHtcclxuXHR2YXIgc3RhcnRZZWFyID0gJC5jYWxlbmRhcnMubmV3RGF0ZShkYXRlLnllYXIoKSwgMSwgMSk7XHJcblx0cmV0dXJuIE1hdGguZmxvb3IoKGRhdGUuZGF5T2ZZZWFyKCkgLSBzdGFydFllYXIuZGF5T2ZZZWFyKCkpIC8gNykgKyAxO1xyXG4gfSAqL1xyXG5cclxuXHRcdC8qKiBQcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IGFuIGluZGl2aWR1YWwgZGF0ZSBzaG93biBpbiB0aGUgY2FsZW5kYXIuXHJcblx0XHRcdEBjYWxsYmFjayBDYWxlbmRhcnNQaWNrZXJPbkRhdGVcclxuXHRcdFx0QHBhcmFtIGRhdGUge0NEYXRlfSBUaGUgZGF0ZSB0byBldmFsdWF0ZS5cclxuXHRcdFx0QHJldHVybiB7b2JqZWN0fSBJbmZvcm1hdGlvbiBhYm91dCB0aGF0IGRhdGUsIHdpdGggdGhlIHByb3BlcnRpZXMgYWJvdmUuXHJcblx0XHRcdEBwcm9wZXJ0eSBzZWxlY3RhYmxlIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGlzIGRhdGUgY2FuIGJlIHNlbGVjdGVkLlxyXG5cdFx0XHRAcHJvcGVydHkgZGF0ZUNsYXNzIHtzdHJpbmd9IENsYXNzKGVzKSB0byBiZSBhcHBsaWVkIHRvIHRoZSBkYXRlLlxyXG5cdFx0XHRAcHJvcGVydHkgY29udGVudCB7c3RyaW5nfSBUaGUgZGF0ZSBjZWxsIGNvbnRlbnQuXHJcblx0XHRcdEBwcm9wZXJ0eSB0b29sdGlwIHtzdHJpbmd9IEEgcG9wdXAgdG9vbHRpcCBmb3IgdGhlIGRhdGUuXHJcblx0XHRcdEBleGFtcGxlIG9uRGF0ZTogZnVuY3Rpb24oZGF0ZSkge1xyXG5cdHJldHVybiB7c2VsZWN0YWJsZTogZGF0ZS5kYXkoKSA+IDAgJiYgZGF0ZS5kYXkoKSAmbHQ7IDUsXHJcblx0XHRkYXRlQ2xhc3M6IGRhdGUuZGF5KCkgPT09IDQgPyAnbGFzdC1kYXknIDogJyd9O1xyXG4gfSAqL1xyXG5cclxuXHRcdC8qKiBVcGRhdGUgdGhlIGRhdGVwaWNrZXIgZGlzcGxheS5cclxuXHRcdFx0QGNhbGxiYWNrIENhbGVuZGFyc1BpY2tlck9uU2hvd1xyXG5cdFx0XHRAcGFyYW0gcGlja2VyIHtqUXVlcnl9IFRoZSBkYXRlcGlja2VyIDxjb2RlPmRpdjwvY29kZT4gdG8gYmUgc2hvd24uXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxyXG5cdFx0XHRAZXhhbXBsZSBvblNob3c6IGZ1bmN0aW9uKHBpY2tlciwgaW5zdCkge1xyXG5cdHBpY2tlci5hcHBlbmQoJyZsdDtidXR0b24gdHlwZT1cImJ1dHRvblwiPkhpJmx0Oy9idXR0b24+JykuXHJcblx0XHRmaW5kKCdidXR0b246bGFzdCcpLmNsaWNrKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRhbGVydCgnSGkhJyk7XHJcblx0XHR9KTtcclxuIH0gKi9cclxuXHJcblx0XHQvKiogUmVhY3QgdG8gbmF2aWdhdGluZyB0aHJvdWdoIHRoZSBtb250aHMveWVhcnMuXHJcblx0XHRcdEBjYWxsYmFjayBDYWxlbmRhcnNQaWNrZXJPbkNoYW5nZU1vbnRoWWVhclxyXG5cdFx0XHRAcGFyYW0geWVhciB7bnVtYmVyfSBUaGUgbmV3IHllYXIuXHJcblx0XHRcdEBwYXJhbSBtb250aCB7bnVtYmVyfSBUaGUgbmV3IG1vbnRoICgxIHRvIDEyKS5cclxuXHRcdFx0QGV4YW1wbGUgb25DaGFuZ2VNb250aFllYXI6IGZ1bmN0aW9uKHllYXIsIG1vbnRoKSB7XHJcblx0YWxlcnQoJ05vdyBpbiAnICsgbW9udGggKyAnLycgKyB5ZWFyKTtcclxuIH0gKi9cclxuXHRcdFx0XHJcblx0XHQvKiogRGF0ZXBpY2tlciBvbiBzZWxlY3QgY2FsbGJhY2suXHJcblx0XHRcdFRyaWdnZXJlZCB3aGVuIGEgZGF0ZSBpcyBzZWxlY3RlZC5cclxuXHRcdFx0QGNhbGxiYWNrIENhbGVuZGFyc1BpY2tlck9uU2VsZWN0XHJcblx0XHRcdEBwYXJhbSBkYXRlcyB7Q0RhdGVbXX0gVGhlIHNlbGVjdGVkIGRhdGUocykuXHJcblx0XHRcdEBleGFtcGxlIG9uU2VsZWN0OiBmdW5jdGlvbihkYXRlcykge1xyXG4gXHRhbGVydCgnU2VsZWN0ZWQgJyArIGRhdGVzKTtcclxuIH0gKi9cclxuXHRcdFx0XHJcblx0XHQvKiogRGF0ZXBpY2tlciBvbiBjbG9zZSBjYWxsYmFjay5cclxuXHRcdFx0VHJpZ2dlcmVkIHdoZW4gYSBwb3B1cCBjYWxlbmRhciBpcyBjbG9zZWQuXHJcblx0XHRcdEBjYWxsYmFjayBDYWxlbmRhcnNQaWNrZXJPbkNsb3NlXHJcblx0XHRcdEBwYXJhbSBkYXRlcyB7Q0RhdGVbXX0gVGhlIHNlbGVjdGVkIGRhdGUocykuXHJcblx0XHRcdEBleGFtcGxlIG9uQ2xvc2U6IGZ1bmN0aW9uKGRhdGVzKSB7XHJcbiBcdGFsZXJ0KCdTZWxlY3RlZCAnICsgZGF0ZXMpO1xyXG4gfSAqL1xyXG5cdFx0XHJcblx0XHQvKiogRGVmYXVsdCBzZXR0aW5ncyBmb3IgdGhlIHBsdWdpbi5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJvcGVydHkgW2NhbGVuZGFyPSQuY2FsZW5kYXJzLmluc3RhbmNlKCldIHtDYWxlbmRhcn0gVGhlIGNhbGVuZGFyIGZvciB0aGlzIGRhdGVwaWNrZXIuXHJcblx0XHRcdEBwcm9wZXJ0eSBbcGlja2VyQ2xhc3M9JyddIHtzdHJpbmd9IENTUyBjbGFzcyB0byBhZGQgdG8gdGhpcyBpbnN0YW5jZSBvZiB0aGUgZGF0ZXBpY2tlci5cclxuXHRcdFx0QHByb3BlcnR5IFtzaG93T25Gb2N1cz10cnVlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gZm9yIHBvcHVwIG9uIGZvY3VzLCA8Y29kZT5mYWxzZTwvY29kZT4gZm9yIG5vdC5cclxuXHRcdFx0QHByb3BlcnR5IFtzaG93VHJpZ2dlcj1udWxsXSB7c3RyaW5nfEVsZW1lbnR8alF1ZXJ5fSBFbGVtZW50IHRvIGJlIGNsb25lZCBmb3IgYSB0cmlnZ2VyLCA8Y29kZT5udWxsPC9jb2RlPiBmb3Igbm9uZS5cclxuXHRcdFx0QHByb3BlcnR5IFtzaG93QW5pbT0nc2hvdyddIHtzdHJpbmd9IE5hbWUgb2YgalF1ZXJ5IGFuaW1hdGlvbiBmb3IgcG9wdXAsICcnIGZvciBubyBhbmltYXRpb24uXHJcblx0XHRcdEBwcm9wZXJ0eSBbc2hvd09wdGlvbnM9bnVsbF0ge29iamVjdH0gT3B0aW9ucyBmb3IgZW5oYW5jZWQgYW5pbWF0aW9ucy5cclxuXHRcdFx0QHByb3BlcnR5IFtzaG93U3BlZWQ9J25vcm1hbCddIHtzdHJpbmd9IER1cmF0aW9uIG9mIGRpc3BsYXkvY2xvc3VyZS5cclxuXHRcdFx0QHByb3BlcnR5IFtwb3B1cENvbnRhaW5lcj1udWxsXSB7c3RyaW5nfEVsZW1lbnR8alF1ZXJ5fSBUaGUgZWxlbWVudCB0byB3aGljaCBhIHBvcHVwIGNhbGVuZGFyIGlzIGFkZGVkLCA8Y29kZT5udWxsPC9jb2RlPiBmb3IgYm9keS5cclxuXHRcdFx0QHByb3BlcnR5IFthbGlnbm1lbnQ9J2JvdHRvbSddIHtzdHJpbmd9IEFsaWdubWVudCBvZiBwb3B1cCAtIHdpdGggbm9taW5hdGVkIGNvcm5lciBvZiBpbnB1dDpcclxuXHRcdFx0XHRcdFx0J3RvcCcgb3IgJ2JvdHRvbScgYWxpZ25zIGRlcGVuZGluZyBvbiBsYW5ndWFnZSBkaXJlY3Rpb24sXHJcblx0XHRcdFx0XHRcdCd0b3BMZWZ0JywgJ3RvcFJpZ2h0JywgJ2JvdHRvbUxlZnQnLCAnYm90dG9tUmlnaHQnLlxyXG5cdFx0XHRAcHJvcGVydHkgW2ZpeGVkV2Vla3M9ZmFsc2VdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiB0byBhbHdheXMgc2hvdyA2IHdlZWtzLCA8Y29kZT5mYWxzZTwvY29kZT4gdG8gb25seSBzaG93IGFzIG1hbnkgYXMgYXJlIG5lZWRlZC5cclxuXHRcdFx0QHByb3BlcnR5IFtmaXJzdERheT1udWxsXSB7bnVtYmVyfSBGaXJzdCBkYXkgb2YgdGhlIHdlZWssIDAgPSBTdW5kYXksIDEgPSBNb25kYXksIGV0Yy4sIDxjb2RlPm51bGw8L2NvZGU+IGZvciA8Y29kZT5jYWxlbmRhcjwvY29kZT4gZGVmYXVsdC5cclxuXHRcdFx0QHByb3BlcnR5IFtjYWxjdWxhdGVXZWVrPW51bGxdIHtDYWxlbmRhcnNQaWNrZXJDYWxjdWxhdGVXZWVrfSBDYWxjdWxhdGUgd2VlayBvZiB0aGUgeWVhciBmcm9tIGEgZGF0ZSwgPGNvZGU+bnVsbDwvY29kZT4gZm9yIDxjb2RlPmNhbGVuZGFyPC9jb2RlPiBkZWZhdWx0LlxyXG5cdFx0XHRAcHJvcGVydHkgW21vbnRoc1RvU2hvdz0xXSB7bnVtYmVyfG51bWJlcltdfSBIb3cgbWFueSBtb250aHMgdG8gc2hvdywgY29scyBvciBbcm93cywgY29sc10uXHJcblx0XHRcdEBwcm9wZXJ0eSBbbW9udGhzT2Zmc2V0PTBdIHtudW1iZXJ9IEhvdyBtYW55IG1vbnRocyB0byBvZmZzZXQgdGhlIHByaW1hcnkgbW9udGggYnk7XHJcblx0XHRcdFx0XHRcdG1heSBiZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIGRhdGUgYW5kIHJldHVybnMgdGhlIG9mZnNldC5cclxuXHRcdFx0QHByb3BlcnR5IFttb250aHNUb1N0ZXA9MV0ge251bWJlcn0gSG93IG1hbnkgbW9udGhzIHRvIG1vdmUgd2hlbiBwcmV2L25leHQgY2xpY2tlZC5cclxuXHRcdFx0QHByb3BlcnR5IFttb250aHNUb0p1bXA9MTJdIHtudW1iZXJ9IEhvdyBtYW55IG1vbnRocyB0byBtb3ZlIHdoZW4gbGFyZ2UgcHJldi9uZXh0IGNsaWNrZWQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbdXNlTW91c2VXaGVlbD10cnVlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gdXNlIG1vdXNld2hlZWwgaWYgYXZhaWxhYmxlLCA8Y29kZT5mYWxzZTwvY29kZT4gdG8gbmV2ZXIgdXNlIGl0LlxyXG5cdFx0XHRAcHJvcGVydHkgW2NoYW5nZU1vbnRoPXRydWVdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiB0byBjaGFuZ2UgbW9udGgveWVhciB2aWEgZHJvcC1kb3duLCA8Y29kZT5mYWxzZTwvY29kZT4gZm9yIG5hdmlnYXRpb24gb25seS5cclxuXHRcdFx0QHByb3BlcnR5IFt5ZWFyUmFuZ2U9J2MtMTA6YysxMCddIHtzdHJpbmd9IFJhbmdlIG9mIHllYXJzIHRvIHNob3cgaW4gZHJvcC1kb3duOiAnYW55JyBmb3IgZGlyZWN0IHRleHQgZW50cnlcclxuXHRcdFx0XHRcdFx0b3IgJ3N0YXJ0OmVuZCcsIHdoZXJlIHN0YXJ0L2VuZCBhcmUgJystbm4nIGZvciByZWxhdGl2ZSB0byB0b2RheVxyXG5cdFx0XHRcdFx0XHRvciAnYystbm4nIGZvciByZWxhdGl2ZSB0byB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGVcclxuXHRcdFx0XHRcdFx0b3IgJ25ubm4nIGZvciBhbiBhYnNvbHV0ZSB5ZWFyLlxyXG5cdFx0XHRAcHJvcGVydHkgW3Nob3dPdGhlck1vbnRocz1mYWxzZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIHNob3cgZGF0ZXMgZnJvbSBvdGhlciBtb250aHMsIDxjb2RlPmZhbHNlPC9jb2RlPiB0byBub3Qgc2hvdyB0aGVtLlxyXG5cdFx0XHRAcHJvcGVydHkgW3NlbGVjdE90aGVyTW9udGhzPWZhbHNlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gYWxsb3cgc2VsZWN0aW9uIG9mIGRhdGVzIGZyb20gb3RoZXIgbW9udGhzIHRvby5cclxuXHRcdFx0QHByb3BlcnR5IFtkZWZhdWx0RGF0ZT1udWxsXSB7c3RyaW5nfG51bWJlcnxDRGF0ZX0gRGF0ZSB0byBzaG93IGlmIG5vIG90aGVyIHNlbGVjdGVkLlxyXG5cdFx0XHRAcHJvcGVydHkgW3NlbGVjdERlZmF1bHREYXRlPWZhbHNlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gcHJlLXNlbGVjdCB0aGUgZGVmYXVsdCBkYXRlIGlmIG5vIG90aGVyIGlzIGNob3Nlbi5cclxuXHRcdFx0QHByb3BlcnR5IFttaW5EYXRlPW51bGxdIHtzdHJpbmd8bnVtYmVyfENEYXRlfSBUaGUgbWluaW11bSBzZWxlY3RhYmxlIGRhdGUuXHJcblx0XHRcdEBwcm9wZXJ0eSBbbWF4RGF0ZT1udWxsXSB7c3RyaW5nfG51bWJlcnxDRGF0ZX0gVGhlIG1heGltdW0gc2VsZWN0YWJsZSBkYXRlLlxyXG5cdFx0XHRAcHJvcGVydHkgW2RhdGVGb3JtYXQ9J21tL2RkL3l5eXknXSB7c3RyaW5nfSBGb3JtYXQgZm9yIGRhdGVzLlxyXG5cdFx0XHRAcHJvcGVydHkgW2F1dG9TaXplPWZhbHNlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gc2l6ZSB0aGUgaW5wdXQgZmllbGQgYWNjb3JkaW5nIHRvIHRoZSBkYXRlIGZvcm1hdC5cclxuXHRcdFx0QHByb3BlcnR5IFtyYW5nZVNlbGVjdD1mYWxzZV0ge2Jvb2xlYW59IEFsbG93cyBmb3Igc2VsZWN0aW5nIGEgZGF0ZSByYW5nZSBvbiBvbmUgZGF0ZSBwaWNrZXIuXHJcblx0XHRcdEBwcm9wZXJ0eSBbcmFuZ2VTZXBhcmF0b3I9JyAtICddIHtzdHJpbmd9IFRleHQgYmV0d2VlbiB0d28gZGF0ZXMgaW4gYSByYW5nZS5cclxuXHRcdFx0QHByb3BlcnR5IFttdWx0aVNlbGVjdD0wXSB7bnVtYmVyfSBNYXhpbXVtIG51bWJlciBvZiBzZWxlY3RhYmxlIGRhdGVzLCB6ZXJvIGZvciBzaW5nbGUgc2VsZWN0LlxyXG5cdFx0XHRAcHJvcGVydHkgW211bHRpU2VwYXJhdG9yPScsJ10ge3N0cmluZ30gVGV4dCBiZXR3ZWVuIG11bHRpcGxlIGRhdGVzLlxyXG5cdFx0XHRAcHJvcGVydHkgW29uRGF0ZT1udWxsXSB7Q2FsZW5kYXJzUGlja2VyT25EYXRlfSBDYWxsYmFjayBhcyBhIGRhdGUgaXMgYWRkZWQgdG8gdGhlIGRhdGVwaWNrZXIuXHJcblx0XHRcdEBwcm9wZXJ0eSBbb25TaG93PW51bGxdIHtDYWxlbmRhcnNQaWNrZXJPblNob3d9IENhbGxiYWNrIGp1c3QgYmVmb3JlIGEgZGF0ZXBpY2tlciBpcyBzaG93bi5cclxuXHRcdFx0QHByb3BlcnR5IFtvbkNoYW5nZU1vbnRoWWVhcj1udWxsXSB7Q2FsZW5kYXJzUGlja2VyT25DaGFuZ2VNb250aFllYXJ9IENhbGxiYWNrIHdoZW4gYSBuZXcgbW9udGgveWVhciBpcyBzZWxlY3RlZC5cclxuXHRcdFx0QHByb3BlcnR5IFtvblNlbGVjdD1udWxsXSB7Q2FsZW5kYXJzUGlja2VyT25TZWxlY3R9IENhbGxiYWNrIHdoZW4gYSBkYXRlIGlzIHNlbGVjdGVkLlxyXG5cdFx0XHRAcHJvcGVydHkgW29uQ2xvc2U9bnVsbF0ge0NhbGVuZGFyc1BpY2tlck9uQ2xvc2V9IENhbGxiYWNrIHdoZW4gYSBkYXRlcGlja2VyIGlzIGNsb3NlZC5cclxuXHRcdFx0QHByb3BlcnR5IFthbHRGaWVsZD1udWxsXSB7c3RyaW5nfEVsZW1lbnR8alF1ZXJ5fSBBbHRlcm5hdGUgZmllbGQgdG8gdXBkYXRlIGluIHN5bmNoIHdpdGggdGhlIGRhdGVwaWNrZXIuXHJcblx0XHRcdEBwcm9wZXJ0eSBbYWx0Rm9ybWF0PW51bGxdIHtzdHJpbmd9IERhdGUgZm9ybWF0IGZvciBhbHRlcm5hdGUgZmllbGQsIGRlZmF1bHRzIHRvIDxjb2RlPmRhdGVGb3JtYXQ8L2NvZGU+LlxyXG5cdFx0XHRAcHJvcGVydHkgW2NvbnN0cmFpbklucHV0PXRydWVdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiB0byBjb25zdHJhaW4gdHlwZWQgaW5wdXQgdG8gPGNvZGU+ZGF0ZUZvcm1hdDwvY29kZT4gYWxsb3dlZCBjaGFyYWN0ZXJzLlxyXG5cdFx0XHRAcHJvcGVydHkgW2NvbW1hbmRzQXNEYXRlRm9ybWF0PWZhbHNlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gYXBwbHlcclxuXHRcdFx0XHRcdFx0PGNvZGU+PGEgaHJlZj1cIiNmb3JtYXREYXRlXCI+Zm9ybWF0RGF0ZTwvYT48L2NvZGU+IHRvIHRoZSBjb21tYW5kIHRleHRzLlxyXG5cdFx0XHRAcHJvcGVydHkgW2NvbW1hbmRzPXRoaXMuY29tbWFuZHNdIHtvYmplY3R9IENvbW1hbmQgYWN0aW9ucyB0aGF0IG1heSBiZSBhZGRlZCB0byBhIGxheW91dCBieSBuYW1lLiAqL1xyXG5cdFx0ZGVmYXVsdE9wdGlvbnM6IHtcclxuXHRcdFx0Y2FsZW5kYXI6ICQuY2FsZW5kYXJzLmluc3RhbmNlKCksXHJcblx0XHRcdHBpY2tlckNsYXNzOiAnJyxcclxuXHRcdFx0c2hvd09uRm9jdXM6IHRydWUsXHJcblx0XHRcdHNob3dUcmlnZ2VyOiBudWxsLFxyXG5cdFx0XHRzaG93QW5pbTogJ3Nob3cnLFxyXG5cdFx0XHRzaG93T3B0aW9uczoge30sXHJcblx0XHRcdHNob3dTcGVlZDogJ25vcm1hbCcsXHJcblx0XHRcdHBvcHVwQ29udGFpbmVyOiBudWxsLFxyXG5cdFx0XHRhbGlnbm1lbnQ6ICdib3R0b20nLFxyXG5cdFx0XHRmaXhlZFdlZWtzOiBmYWxzZSxcclxuXHRcdFx0Zmlyc3REYXk6IG51bGwsXHJcblx0XHRcdGNhbGN1bGF0ZVdlZWs6IG51bGwsXHJcblx0XHRcdG1vbnRoc1RvU2hvdzogMSxcclxuXHRcdFx0bW9udGhzT2Zmc2V0OiAwLFxyXG5cdFx0XHRtb250aHNUb1N0ZXA6IDEsXHJcblx0XHRcdG1vbnRoc1RvSnVtcDogMTIsXHJcblx0XHRcdHVzZU1vdXNlV2hlZWw6IHRydWUsXHJcblx0XHRcdGNoYW5nZU1vbnRoOiB0cnVlLFxyXG5cdFx0XHR5ZWFyUmFuZ2U6ICdjLTEwOmMrMTAnLFxyXG5cdFx0XHRzaG93T3RoZXJNb250aHM6IGZhbHNlLFxyXG5cdFx0XHRzZWxlY3RPdGhlck1vbnRoczogZmFsc2UsXHJcblx0XHRcdGRlZmF1bHREYXRlOiBudWxsLFxyXG5cdFx0XHRzZWxlY3REZWZhdWx0RGF0ZTogZmFsc2UsXHJcblx0XHRcdG1pbkRhdGU6IG51bGwsXHJcblx0XHRcdG1heERhdGU6IG51bGwsXHJcblx0XHRcdGRhdGVGb3JtYXQ6IG51bGwsXHJcblx0XHRcdGF1dG9TaXplOiBmYWxzZSxcclxuXHRcdFx0cmFuZ2VTZWxlY3Q6IGZhbHNlLFxyXG5cdFx0XHRyYW5nZVNlcGFyYXRvcjogJyAtICcsXHJcblx0XHRcdG11bHRpU2VsZWN0OiAwLFxyXG5cdFx0XHRtdWx0aVNlcGFyYXRvcjogJywnLFxyXG5cdFx0XHRvbkRhdGU6IG51bGwsXHJcblx0XHRcdG9uU2hvdzogbnVsbCxcclxuXHRcdFx0b25DaGFuZ2VNb250aFllYXI6IG51bGwsXHJcblx0XHRcdG9uU2VsZWN0OiBudWxsLFxyXG5cdFx0XHRvbkNsb3NlOiBudWxsLFxyXG5cdFx0XHRhbHRGaWVsZDogbnVsbCxcclxuXHRcdFx0YWx0Rm9ybWF0OiBudWxsLFxyXG5cdFx0XHRjb25zdHJhaW5JbnB1dDogdHJ1ZSxcclxuXHRcdFx0Y29tbWFuZHNBc0RhdGVGb3JtYXQ6IGZhbHNlLFxyXG5cdFx0XHRjb21tYW5kczoge30gLy8gdGhpcy5jb21tYW5kc1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogTG9jYWxpc2F0aW9ucyBmb3IgdGhlIHBsdWdpbi5cclxuXHRcdFx0RW50cmllcyBhcmUgb2JqZWN0cyBpbmRleGVkIGJ5IHRoZSBsYW5ndWFnZSBjb2RlICgnJyBiZWluZyB0aGUgZGVmYXVsdCBVUy9FbmdsaXNoKS5cclxuXHRcdFx0RWFjaCBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlcy5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJvcGVydHkgW3JlbmRlcmVyPXRoaXMuZGVmYXVsdFJlbmRlcmVyXSB7c3RyaW5nfSBUaGUgcmVuZGVyaW5nIHRlbXBsYXRlcy5cclxuXHRcdFx0QHByb3BlcnR5IFtwcmV2VGV4dD0nJmx0O1ByZXYnXSB7c3RyaW5nfSBUZXh0IGZvciB0aGUgcHJldmlvdXMgbW9udGggY29tbWFuZC5cclxuXHRcdFx0QHByb3BlcnR5IFtwcmV2U3RhdHVzPSdTaG93IHRoZSBwcmV2aW91cyBtb250aCddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IGZvciB0aGUgcHJldmlvdXMgbW9udGggY29tbWFuZC5cclxuXHRcdFx0QHByb3BlcnR5IFtwcmV2SnVtcFRleHQ9JyZsdDsmbHQ7J10ge3N0cmluZ30gVGV4dCBmb3IgdGhlIHByZXZpb3VzIHllYXIgY29tbWFuZC5cclxuXHRcdFx0QHByb3BlcnR5IFtwcmV2SnVtcFN0YXR1cz0nU2hvdyB0aGUgcHJldmlvdXMgeWVhciddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IGZvciB0aGUgcHJldmlvdXMgeWVhciBjb21tYW5kLlxyXG5cdFx0XHRAcHJvcGVydHkgW25leHRUZXh0PSdOZXh0Jmd0OyddIHtzdHJpbmd9IFRleHQgZm9yIHRoZSBuZXh0IG1vbnRoIGNvbW1hbmQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbbmV4dFN0YXR1cz0nU2hvdyB0aGUgbmV4dCBtb250aCddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IGZvciB0aGUgbmV4dCBtb250aCBjb21tYW5kLlxyXG5cdFx0XHRAcHJvcGVydHkgW25leHRKdW1wVGV4dD0nJmd0OyZndDsnXSB7c3RyaW5nfSBUZXh0IGZvciB0aGUgbmV4dCB5ZWFyIGNvbW1hbmQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbbmV4dEp1bXBTdGF0dXM9J1Nob3cgdGhlIG5leHQgeWVhciddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IGZvciB0aGUgbmV4dCB5ZWFyIGNvbW1hbmQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbY3VycmVudFRleHQ9J0N1cnJlbnQnXSB7c3RyaW5nfSBUZXh0IGZvciB0aGUgY3VycmVudCBtb250aCBjb21tYW5kLlxyXG5cdFx0XHRAcHJvcGVydHkgW2N1cnJlbnRTdGF0dXM9J1Nob3cgdGhlIGN1cnJlbnQgbW9udGgnXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBmb3IgdGhlIGN1cnJlbnQgbW9udGggY29tbWFuZC5cclxuXHRcdFx0QHByb3BlcnR5IFt0b2RheVRleHQ9J1RvZGF5J10ge3N0cmluZ30gVGV4dCBmb3IgdGhlIHRvZGF5J3MgbW9udGggY29tbWFuZC5cclxuXHRcdFx0QHByb3BlcnR5IFt0b2RheVN0YXR1cz0nU2hvdyB0b2RheVxcJ3MgbW9udGgnXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBmb3IgdGhlIHRvZGF5J3MgbW9udGggY29tbWFuZC5cclxuXHRcdFx0QHByb3BlcnR5IFtjbGVhclRleHQ9J0NsZWFyJ10ge3N0cmluZ30gVGV4dCBmb3IgdGhlIGNsZWFyIGNvbW1hbmQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbY2xlYXJTdGF0dXM9J0NsZWFyIGFsbCB0aGUgZGF0ZXMnXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBmb3IgdGhlIGNsZWFyIGNvbW1hbmQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbY2xvc2VUZXh0PSdDbG9zZSddIHtzdHJpbmd9IFRleHQgZm9yIHRoZSBjbG9zZSBjb21tYW5kLlxyXG5cdFx0XHRAcHJvcGVydHkgW2Nsb3NlU3RhdHVzPSdDbG9zZSB0aGUgZGF0ZXBpY2tlciddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IGZvciB0aGUgY2xvc2UgY29tbWFuZC5cclxuXHRcdFx0QHByb3BlcnR5IFt5ZWFyU3RhdHVzPSdDaGFuZ2UgdGhlIHllYXInXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBmb3IgeWVhciBzZWxlY3Rpb24uXHJcblx0XHRcdEBwcm9wZXJ0eSBbZWFybGllclRleHQ9JyYjMTYwOyYjMTYwO+KWsiddIHtzdHJpbmd9IFRleHQgZm9yIGVhcmxpZXIgeWVhcnMuXHJcblx0XHRcdEBwcm9wZXJ0eSBbbGF0ZXJUZXh0PScmIzE2MDsmIzE2MDvilrwnXSB7c3RyaW5nfSBUZXh0IGZvciBsYXRlciB5ZWFycy5cclxuXHRcdFx0QHByb3BlcnR5IFttb250aFN0YXR1cz0nQ2hhbmdlIHRoZSBtb250aCddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IGZvciBtb250aCBzZWxlY3Rpb24uXHJcblx0XHRcdEBwcm9wZXJ0eSBbd2Vla1RleHQ9J1drJ10ge3N0cmluZ30gVGV4dCBmb3Igd2VlayBvZiB0aGUgeWVhciBjb2x1bW4gaGVhZGVyLlxyXG5cdFx0XHRAcHJvcGVydHkgW3dlZWtTdGF0dXM9J1dlZWsgb2YgdGhlIHllYXInXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBmb3Igd2VlayBvZiB0aGUgeWVhciBjb2x1bW4gaGVhZGVyLlxyXG5cdFx0XHRAcHJvcGVydHkgW2RheVN0YXR1cz0nU2VsZWN0IERELCYjMTYwO00mIzE2MDtkLCYjMTYwO3l5eXknXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBmb3Igc2VsZWN0YWJsZSBkYXlzLlxyXG5cdFx0XHRAcHJvcGVydHkgW2RlZmF1bHRTdGF0dXM9J1NlbGVjdCBhIGRhdGUnXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBzaG93biBieSBkZWZhdWx0LlxyXG5cdFx0XHRAcHJvcGVydHkgW2lzUlRMPWZhbHNlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgbGFuZ3VhZ2UgaXMgcmlnaHQtdG8tbGVmdC4gKi9cclxuXHRcdHJlZ2lvbmFsT3B0aW9uczogeyAvLyBBdmFpbGFibGUgcmVnaW9uYWwgc2V0dGluZ3MsIGluZGV4ZWQgYnkgbGFuZ3VhZ2UvY291bnRyeSBjb2RlXHJcblx0XHRcdCcnOiB7IC8vIERlZmF1bHQgcmVnaW9uYWwgc2V0dGluZ3MgLSBFbmdsaXNoL1VTXHJcblx0XHRcdFx0cmVuZGVyZXI6IHt9LCAvLyB0aGlzLmRlZmF1bHRSZW5kZXJlclxyXG5cdFx0XHRcdHByZXZUZXh0OiAnJmx0O1ByZXYnLFxyXG5cdFx0XHRcdHByZXZTdGF0dXM6ICdTaG93IHRoZSBwcmV2aW91cyBtb250aCcsXHJcblx0XHRcdFx0cHJldkp1bXBUZXh0OiAnJmx0OyZsdDsnLFxyXG5cdFx0XHRcdHByZXZKdW1wU3RhdHVzOiAnU2hvdyB0aGUgcHJldmlvdXMgeWVhcicsXHJcblx0XHRcdFx0bmV4dFRleHQ6ICdOZXh0Jmd0OycsXHJcblx0XHRcdFx0bmV4dFN0YXR1czogJ1Nob3cgdGhlIG5leHQgbW9udGgnLFxyXG5cdFx0XHRcdG5leHRKdW1wVGV4dDogJyZndDsmZ3Q7JyxcclxuXHRcdFx0XHRuZXh0SnVtcFN0YXR1czogJ1Nob3cgdGhlIG5leHQgeWVhcicsXHJcblx0XHRcdFx0Y3VycmVudFRleHQ6ICdDdXJyZW50JyxcclxuXHRcdFx0XHRjdXJyZW50U3RhdHVzOiAnU2hvdyB0aGUgY3VycmVudCBtb250aCcsXHJcblx0XHRcdFx0dG9kYXlUZXh0OiAnVG9kYXknLFxyXG5cdFx0XHRcdHRvZGF5U3RhdHVzOiAnU2hvdyB0b2RheVxcJ3MgbW9udGgnLFxyXG5cdFx0XHRcdGNsZWFyVGV4dDogJ0NsZWFyJyxcclxuXHRcdFx0XHRjbGVhclN0YXR1czogJ0NsZWFyIGFsbCB0aGUgZGF0ZXMnLFxyXG5cdFx0XHRcdGNsb3NlVGV4dDogJ0Nsb3NlJyxcclxuXHRcdFx0XHRjbG9zZVN0YXR1czogJ0Nsb3NlIHRoZSBkYXRlcGlja2VyJyxcclxuXHRcdFx0XHR5ZWFyU3RhdHVzOiAnQ2hhbmdlIHRoZSB5ZWFyJyxcclxuXHRcdFx0XHRlYXJsaWVyVGV4dDogJyYjMTYwOyYjMTYwO+KWsicsXHJcblx0XHRcdFx0bGF0ZXJUZXh0OiAnJiMxNjA7JiMxNjA74pa8JyxcclxuXHRcdFx0XHRtb250aFN0YXR1czogJ0NoYW5nZSB0aGUgbW9udGgnLFxyXG5cdFx0XHRcdHdlZWtUZXh0OiAnV2snLFxyXG5cdFx0XHRcdHdlZWtTdGF0dXM6ICdXZWVrIG9mIHRoZSB5ZWFyJyxcclxuXHRcdFx0XHRkYXlTdGF0dXM6ICdTZWxlY3QgREQsIE0gZCwgeXl5eScsXHJcblx0XHRcdFx0ZGVmYXVsdFN0YXR1czogJ1NlbGVjdCBhIGRhdGUnLFxyXG5cdFx0XHRcdGlzUlRMOiBmYWxzZVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvKiogTmFtZXMgb2YgZ2V0dGVyIG1ldGhvZHMgLSB0aG9zZSB0aGF0IGNhbid0IGJlIGNoYWluZWQuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXIgKi9cclxuXHRcdF9nZXR0ZXJzOiBbJ2dldERhdGUnLCAnaXNEaXNhYmxlZCcsICdpc1NlbGVjdGFibGUnLCAncmV0cmlldmVEYXRlJ10sXHJcblxyXG5cdFx0X2Rpc2FibGVkOiBbXSxcclxuXHRcdFxyXG5cdFx0X3BvcHVwQ2xhc3M6ICdjYWxlbmRhcnMtcG9wdXAnLCAvLyBNYXJrZXIgZm9yIHBvcHVwIGRpdmlzaW9uXHJcblx0XHRfdHJpZ2dlckNsYXNzOiAnY2FsZW5kYXJzLXRyaWdnZXInLCAvLyBNYXJrZXIgZm9yIHRyaWdnZXIgZWxlbWVudFxyXG5cdFx0X2Rpc2FibGVDbGFzczogJ2NhbGVuZGFycy1kaXNhYmxlJywgLy8gTWFya2VyIGZvciBkaXNhYmxlZCBlbGVtZW50XHJcblx0XHRfbW9udGhZZWFyQ2xhc3M6ICdjYWxlbmRhcnMtbW9udGgteWVhcicsIC8vIE1hcmtlciBmb3IgbW9udGgveWVhciBpbnB1dHNcclxuXHRcdF9jdXJNb250aENsYXNzOiAnY2FsZW5kYXJzLW1vbnRoLScsIC8vIE1hcmtlciBmb3IgY3VycmVudCBtb250aC95ZWFyXHJcblx0XHRfYW55WWVhckNsYXNzOiAnY2FsZW5kYXJzLWFueS15ZWFyJywgLy8gTWFya2VyIGZvciB5ZWFyIGRpcmVjdCBpbnB1dFxyXG5cdFx0X2N1ckRvV0NsYXNzOiAnY2FsZW5kYXJzLWRvdy0nLCAvLyBNYXJrZXIgZm9yIGRheSBvZiB3ZWVrXHJcblxyXG5cdFx0X2luaXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR0aGlzLmRlZmF1bHRPcHRpb25zLmNvbW1hbmRzID0gdGhpcy5jb21tYW5kcztcclxuXHRcdFx0dGhpcy5yZWdpb25hbE9wdGlvbnNbJyddLnJlbmRlcmVyID0gdGhpcy5kZWZhdWx0UmVuZGVyZXI7XHJcblx0XHRcdHRoaXMuX3N1cGVyKCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdF9pbnN0U2V0dGluZ3M6IGZ1bmN0aW9uKGVsZW0sIG9wdGlvbnMpIHtcclxuXHRcdFx0cmV0dXJuIHtzZWxlY3RlZERhdGVzOiBbXSwgZHJhd0RhdGU6IG51bGwsIHBpY2tpbmdSYW5nZTogZmFsc2UsXHJcblx0XHRcdFx0aW5saW5lOiAoJC5pbkFycmF5KGVsZW1bMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgWydkaXYnLCAnc3BhbiddKSA+IC0xKSxcclxuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKG5hbWUpIHsgLy8gR2V0IGEgc2V0dGluZyB2YWx1ZSwgY29tcHV0aW5nIGlmIG5lY2Vzc2FyeVxyXG5cdFx0XHRcdFx0aWYgKCQuaW5BcnJheShuYW1lLCBbJ2RlZmF1bHREYXRlJywgJ21pbkRhdGUnLCAnbWF4RGF0ZSddKSA+IC0xKSB7IC8vIERlY29kZSBkYXRlIHNldHRpbmdzXHJcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY2FsZW5kYXIuZGV0ZXJtaW5lRGF0ZSh0aGlzLm9wdGlvbnNbbmFtZV0sIG51bGwsXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5zZWxlY3RlZERhdGVzWzBdLCB0aGlzLmdldCgnZGF0ZUZvcm1hdCcpLCB0aGlzLmdldENvbmZpZygpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChuYW1lID09PSAnZGF0ZUZvcm1hdCcpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5kYXRlRm9ybWF0IHx8IHRoaXMub3B0aW9ucy5jYWxlbmRhci5sb2NhbC5kYXRlRm9ybWF0O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uc1tuYW1lXTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdGN1ck1pbkRhdGU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuICh0aGlzLnBpY2tpbmdSYW5nZSA/IHRoaXMuc2VsZWN0ZWREYXRlc1swXSA6IHRoaXMuZ2V0KCdtaW5EYXRlJykpO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0Z2V0Q29uZmlnOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHJldHVybiB7ZGF5TmFtZXNTaG9ydDogdGhpcy5vcHRpb25zLmRheU5hbWVzU2hvcnQsIGRheU5hbWVzOiB0aGlzLm9wdGlvbnMuZGF5TmFtZXMsXHJcblx0XHRcdFx0XHRcdG1vbnRoTmFtZXNTaG9ydDogdGhpcy5vcHRpb25zLm1vbnRoTmFtZXNTaG9ydCwgbW9udGhOYW1lczogdGhpcy5vcHRpb25zLm1vbnRoTmFtZXMsXHJcblx0XHRcdFx0XHRcdGNhbGN1bGF0ZVdlZWs6IHRoaXMub3B0aW9ucy5jYWxjdWxhdGVXZWVrLCBzaG9ydFllYXJDdXRvZmY6IHRoaXMub3B0aW9ucy5zaG9ydFllYXJDdXRvZmZ9O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHRcdH0sXHJcblxyXG5cdFx0X3Bvc3RBdHRhY2g6IGZ1bmN0aW9uKGVsZW0sIGluc3QpIHtcclxuXHRcdFx0aWYgKGluc3QuaW5saW5lKSB7XHJcblx0XHRcdFx0aW5zdC5kcmF3RGF0ZSA9IHBsdWdpbi5fY2hlY2tNaW5NYXgoKGluc3Quc2VsZWN0ZWREYXRlc1swXSB8fFxyXG5cdFx0XHRcdFx0aW5zdC5nZXQoJ2RlZmF1bHREYXRlJykgfHwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCkpLm5ld0RhdGUoKSwgaW5zdCk7XHJcblx0XHRcdFx0aW5zdC5wcmV2RGF0ZSA9IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpO1xyXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZShlbGVtWzBdKTtcclxuXHRcdFx0XHRpZiAoJC5mbi5tb3VzZXdoZWVsKSB7XHJcblx0XHRcdFx0XHRlbGVtLm1vdXNld2hlZWwodGhpcy5fZG9Nb3VzZVdoZWVsKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5fYXR0YWNobWVudHMoZWxlbSwgaW5zdCk7XHJcblx0XHRcdFx0ZWxlbS5vbigna2V5ZG93bi4nICsgaW5zdC5uYW1lLCB0aGlzLl9rZXlEb3duKS5vbigna2V5cHJlc3MuJyArIGluc3QubmFtZSwgdGhpcy5fa2V5UHJlc3MpLlxyXG5cdFx0XHRcdFx0b24oJ2tleXVwLicgKyBpbnN0Lm5hbWUsIHRoaXMuX2tleVVwKTtcclxuXHRcdFx0XHRpZiAoZWxlbS5hdHRyKCdkaXNhYmxlZCcpKSB7XHJcblx0XHRcdFx0XHR0aGlzLmRpc2FibGUoZWxlbVswXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdF9vcHRpb25zQ2hhbmdlZDogZnVuY3Rpb24oZWxlbSwgaW5zdCwgb3B0aW9ucykge1xyXG5cdFx0XHRpZiAob3B0aW9ucy5jYWxlbmRhciAmJiBvcHRpb25zLmNhbGVuZGFyICE9PSBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIpIHtcclxuXHRcdFx0XHR2YXIgZGlzY2FyZERhdGUgPSBmdW5jdGlvbihuYW1lKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gKHR5cGVvZiBpbnN0Lm9wdGlvbnNbbmFtZV0gPT09ICdvYmplY3QnID8gbnVsbCA6IGluc3Qub3B0aW9uc1tuYW1lXSk7XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHRvcHRpb25zID0gJC5leHRlbmQoe2RlZmF1bHREYXRlOiBkaXNjYXJkRGF0ZSgnZGVmYXVsdERhdGUnKSxcclxuXHRcdFx0XHRcdG1pbkRhdGU6IGRpc2NhcmREYXRlKCdtaW5EYXRlJyksIG1heERhdGU6IGRpc2NhcmREYXRlKCdtYXhEYXRlJyl9LCBvcHRpb25zKTtcclxuXHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF0ZXMgPSBbXTtcclxuXHRcdFx0XHRpbnN0LmRyYXdEYXRlID0gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgZGF0ZXMgPSBpbnN0LnNlbGVjdGVkRGF0ZXM7XHJcblx0XHRcdCQuZXh0ZW5kKGluc3Qub3B0aW9ucywgb3B0aW9ucyk7XHJcblx0XHRcdHRoaXMuc2V0RGF0ZShlbGVtWzBdLCBkYXRlcywgbnVsbCwgZmFsc2UsIHRydWUpO1xyXG5cdFx0XHRpbnN0LnBpY2tpbmdSYW5nZSA9IGZhbHNlO1xyXG5cdFx0XHR2YXIgY2FsZW5kYXIgPSBpbnN0Lm9wdGlvbnMuY2FsZW5kYXI7XHJcblx0XHRcdHZhciBkZWZhdWx0RGF0ZSA9IGluc3QuZ2V0KCdkZWZhdWx0RGF0ZScpO1xyXG5cdFx0XHRpbnN0LmRyYXdEYXRlID0gdGhpcy5fY2hlY2tNaW5NYXgoKGRlZmF1bHREYXRlID8gZGVmYXVsdERhdGUgOiBpbnN0LmRyYXdEYXRlKSB8fFxyXG5cdFx0XHRcdGRlZmF1bHREYXRlIHx8IGNhbGVuZGFyLnRvZGF5KCksIGluc3QpLm5ld0RhdGUoKTtcclxuXHRcdFx0aWYgKCFpbnN0LmlubGluZSkge1xyXG5cdFx0XHRcdHRoaXMuX2F0dGFjaG1lbnRzKGVsZW0sIGluc3QpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChpbnN0LmlubGluZSB8fCBpbnN0LmRpdikge1xyXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZShlbGVtWzBdKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQXR0YWNoIGV2ZW50cyBhbmQgdHJpZ2dlciwgaWYgbmVjZXNzYXJ5LlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtqUXVlcnl9IFRoZSBjb250cm9sIHRvIGFmZmVjdC5cclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuICovXHJcblx0XHRfYXR0YWNobWVudHM6IGZ1bmN0aW9uKGVsZW0sIGluc3QpIHtcclxuXHRcdFx0ZWxlbS5vZmYoJ2ZvY3VzLicgKyBpbnN0Lm5hbWUpO1xyXG5cdFx0XHRpZiAoaW5zdC5vcHRpb25zLnNob3dPbkZvY3VzKSB7XHJcblx0XHRcdFx0ZWxlbS5vbignZm9jdXMuJyArIGluc3QubmFtZSwgdGhpcy5zaG93KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoaW5zdC50cmlnZ2VyKSB7XHJcblx0XHRcdFx0aW5zdC50cmlnZ2VyLnJlbW92ZSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciB0cmlnZ2VyID0gaW5zdC5vcHRpb25zLnNob3dUcmlnZ2VyO1xyXG5cdFx0XHRpbnN0LnRyaWdnZXIgPSAoIXRyaWdnZXIgPyAkKFtdKSA6XHJcblx0XHRcdFx0JCh0cmlnZ2VyKS5jbG9uZSgpLnJlbW92ZUF0dHIoJ2lkJykuYWRkQ2xhc3ModGhpcy5fdHJpZ2dlckNsYXNzKVxyXG5cdFx0XHRcdFx0W2luc3Qub3B0aW9ucy5pc1JUTCA/ICdpbnNlcnRCZWZvcmUnIDogJ2luc2VydEFmdGVyJ10oZWxlbSkuXHJcblx0XHRcdFx0XHRjbGljayhmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0aWYgKCFwbHVnaW4uaXNEaXNhYmxlZChlbGVtWzBdKSkge1xyXG5cdFx0XHRcdFx0XHRcdHBsdWdpbltwbHVnaW4uY3VySW5zdCA9PT0gaW5zdCA/ICdoaWRlJyA6ICdzaG93J10oZWxlbVswXSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pKTtcclxuXHRcdFx0dGhpcy5fYXV0b1NpemUoZWxlbSwgaW5zdCk7XHJcblx0XHRcdHZhciBkYXRlcyA9IHRoaXMuX2V4dHJhY3REYXRlcyhpbnN0LCBlbGVtLnZhbCgpKTtcclxuXHRcdFx0aWYgKGRhdGVzKSB7XHJcblx0XHRcdFx0dGhpcy5zZXREYXRlKGVsZW1bMF0sIGRhdGVzLCBudWxsLCB0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgZGVmYXVsdERhdGUgPSBpbnN0LmdldCgnZGVmYXVsdERhdGUnKTtcclxuXHRcdFx0aWYgKGluc3Qub3B0aW9ucy5zZWxlY3REZWZhdWx0RGF0ZSAmJiBkZWZhdWx0RGF0ZSAmJiBpbnN0LnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0dGhpcy5zZXREYXRlKGVsZW1bMF0sIChkZWZhdWx0RGF0ZSB8fCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKSkubmV3RGF0ZSgpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQXBwbHkgdGhlIG1heGltdW0gbGVuZ3RoIGZvciB0aGUgZGF0ZSBmb3JtYXQuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGVsZW0ge2pRdWVyeX0gVGhlIGNvbnRyb2wgdG8gYWZmZWN0LlxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy4gKi9cclxuXHRcdF9hdXRvU2l6ZTogZnVuY3Rpb24oZWxlbSwgaW5zdCkge1xyXG5cdFx0XHRpZiAoaW5zdC5vcHRpb25zLmF1dG9TaXplICYmICFpbnN0LmlubGluZSkge1xyXG5cdFx0XHRcdHZhciBjYWxlbmRhciA9IGluc3Qub3B0aW9ucy5jYWxlbmRhcjtcclxuXHRcdFx0XHR2YXIgZGF0ZSA9IGNhbGVuZGFyLm5ld0RhdGUoMjAwOSwgMTAsIDIwKTsgLy8gRW5zdXJlIGRvdWJsZSBkaWdpdHNcclxuXHRcdFx0XHR2YXIgZGF0ZUZvcm1hdCA9IGluc3QuZ2V0KCdkYXRlRm9ybWF0Jyk7XHJcblx0XHRcdFx0aWYgKGRhdGVGb3JtYXQubWF0Y2goL1tETV0vKSkge1xyXG5cdFx0XHRcdFx0dmFyIGZpbmRNYXggPSBmdW5jdGlvbihuYW1lcykge1xyXG5cdFx0XHRcdFx0XHR2YXIgbWF4ID0gMDtcclxuXHRcdFx0XHRcdFx0dmFyIG1heEkgPSAwO1xyXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKG5hbWVzW2ldLmxlbmd0aCA+IG1heCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0bWF4ID0gbmFtZXNbaV0ubGVuZ3RoO1xyXG5cdFx0XHRcdFx0XHRcdFx0bWF4SSA9IGk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHJldHVybiBtYXhJO1xyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdGRhdGUubW9udGgoZmluZE1heChjYWxlbmRhci5sb2NhbFtkYXRlRm9ybWF0Lm1hdGNoKC9NTS8pID8gLy8gTG9uZ2VzdCBtb250aFxyXG5cdFx0XHRcdFx0XHQnbW9udGhOYW1lcycgOiAnbW9udGhOYW1lc1Nob3J0J10pICsgMSk7XHJcblx0XHRcdFx0XHRkYXRlLmRheShmaW5kTWF4KGNhbGVuZGFyLmxvY2FsW2RhdGVGb3JtYXQubWF0Y2goL0RELykgPyAvLyBMb25nZXN0IGRheVxyXG5cdFx0XHRcdFx0XHQnZGF5TmFtZXMnIDogJ2RheU5hbWVzU2hvcnQnXSkgKyAyMCAtIGRhdGUuZGF5T2ZXZWVrKCkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpbnN0LmVsZW0uYXR0cignc2l6ZScsIGRhdGUuZm9ybWF0RGF0ZShkYXRlRm9ybWF0KS5sZW5ndGgpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdF9wcmVEZXN0cm95OiBmdW5jdGlvbihlbGVtLCBpbnN0KSB7XHJcblx0XHRcdGlmIChpbnN0LnRyaWdnZXIpIHtcclxuXHRcdFx0XHRpbnN0LnRyaWdnZXIucmVtb3ZlKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxlbS5lbXB0eSgpLm9mZignLicgKyBpbnN0Lm5hbWUpO1xyXG5cdFx0XHRpZiAoaW5zdC5pbmxpbmUgJiYgJC5mbi5tb3VzZXdoZWVsKSB7XHJcblx0XHRcdFx0ZWxlbS51bm1vdXNld2hlZWwoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIWluc3QuaW5saW5lICYmIGluc3Qub3B0aW9ucy5hdXRvU2l6ZSkge1xyXG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cignc2l6ZScpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBBcHBseSBtdWx0aXBsZSBldmVudCBmdW5jdGlvbnMuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHBhcmFtIGZucyB7ZnVuY3Rpb259IFRoZSBmdW5jdGlvbnMgdG8gYXBwbHkuXHJcblx0XHRcdEBleGFtcGxlIG9uU2hvdzogbXVsdGlwbGVFdmVudHMoZm4xLCBmbjIsIC4uLikgKi9cclxuXHRcdG11bHRpcGxlRXZlbnRzOiBmdW5jdGlvbihmbnMpIHtcclxuXHRcdFx0dmFyIGZ1bmNzID0gYXJndW1lbnRzO1xyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oYXJncykge1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdGZ1bmNzW2ldLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogRW5hYmxlIHRoZSBjb250cm9sLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBhZmZlY3QuXHJcblx0XHRcdEBleGFtcGxlICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdlbmFibGUnKSAqL1xyXG5cdFx0ZW5hYmxlOiBmdW5jdGlvbihlbGVtKSB7XHJcblx0XHRcdGVsZW0gPSAkKGVsZW0pO1xyXG5cdFx0XHRpZiAoIWVsZW0uaGFzQ2xhc3ModGhpcy5fZ2V0TWFya2VyKCkpKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0aWYgKGluc3QuaW5saW5lKSB7XHJcblx0XHRcdFx0ZWxlbS5jaGlsZHJlbignLicgKyB0aGlzLl9kaXNhYmxlQ2xhc3MpLnJlbW92ZSgpLmVuZCgpLlxyXG5cdFx0XHRcdFx0ZmluZCgnYnV0dG9uLHNlbGVjdCcpLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpLmVuZCgpLlxyXG5cdFx0XHRcdFx0ZmluZCgnYScpLmF0dHIoJ2hyZWYnLCAnamF2YXNjcmlwdDp2b2lkKDApJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0ZWxlbS5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcclxuXHRcdFx0XHRpbnN0LnRyaWdnZXIuZmlsdGVyKCdidXR0b24uJyArIHRoaXMuX3RyaWdnZXJDbGFzcykucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSkuZW5kKCkuXHJcblx0XHRcdFx0XHRmaWx0ZXIoJ2ltZy4nICsgdGhpcy5fdHJpZ2dlckNsYXNzKS5jc3Moe29wYWNpdHk6ICcxLjAnLCBjdXJzb3I6ICcnfSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fZGlzYWJsZWQgPSAkLm1hcCh0aGlzLl9kaXNhYmxlZCxcclxuXHRcdFx0XHRmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gKHZhbHVlID09PSBlbGVtWzBdID8gbnVsbCA6IHZhbHVlKTsgfSk7IC8vIERlbGV0ZSBlbnRyeVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogRGlzYWJsZSB0aGUgY29udHJvbC5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gYWZmZWN0LlxyXG5cdFx0XHRAZXhhbXBsZSAkKHNlbGVjdG9yKS5kYXRlcGljaygnZGlzYWJsZScpICovXHJcblx0XHRkaXNhYmxlOiBmdW5jdGlvbihlbGVtKSB7XHJcblx0XHRcdGVsZW0gPSAkKGVsZW0pO1xyXG5cdFx0XHRpZiAoIWVsZW0uaGFzQ2xhc3ModGhpcy5fZ2V0TWFya2VyKCkpKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0aWYgKGluc3QuaW5saW5lKSB7XHJcblx0XHRcdFx0dmFyIGlubGluZSA9IGVsZW0uY2hpbGRyZW4oJzpsYXN0Jyk7XHJcblx0XHRcdFx0dmFyIG9mZnNldCA9IGlubGluZS5vZmZzZXQoKTtcclxuXHRcdFx0XHR2YXIgcmVsT2Zmc2V0ID0ge2xlZnQ6IDAsIHRvcDogMH07XHJcblx0XHRcdFx0aW5saW5lLnBhcmVudHMoKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0aWYgKCQodGhpcykuY3NzKCdwb3NpdGlvbicpID09PSAncmVsYXRpdmUnKSB7XHJcblx0XHRcdFx0XHRcdHJlbE9mZnNldCA9ICQodGhpcykub2Zmc2V0KCk7XHJcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHR2YXIgekluZGV4ID0gZWxlbS5jc3MoJ3pJbmRleCcpO1xyXG5cdFx0XHRcdHpJbmRleCA9ICh6SW5kZXggPT09ICdhdXRvJyA/IDAgOiBwYXJzZUludCh6SW5kZXgsIDEwKSkgKyAxO1xyXG5cdFx0XHRcdGVsZW0ucHJlcGVuZCgnPGRpdiBjbGFzcz1cIicgKyB0aGlzLl9kaXNhYmxlQ2xhc3MgKyAnXCIgc3R5bGU9XCInICtcclxuXHRcdFx0XHRcdCd3aWR0aDogJyArIGlubGluZS5vdXRlcldpZHRoKCkgKyAncHg7IGhlaWdodDogJyArIGlubGluZS5vdXRlckhlaWdodCgpICtcclxuXHRcdFx0XHRcdCdweDsgbGVmdDogJyArIChvZmZzZXQubGVmdCAtIHJlbE9mZnNldC5sZWZ0KSArICdweDsgdG9wOiAnICtcclxuXHRcdFx0XHRcdChvZmZzZXQudG9wIC0gcmVsT2Zmc2V0LnRvcCkgKyAncHg7IHotaW5kZXg6ICcgKyB6SW5kZXggKyAnXCI+PC9kaXY+JykuXHJcblx0XHRcdFx0XHRmaW5kKCdidXR0b24sc2VsZWN0JykucHJvcCgnZGlzYWJsZWQnLCB0cnVlKS5lbmQoKS5cclxuXHRcdFx0XHRcdGZpbmQoJ2EnKS5yZW1vdmVBdHRyKCdocmVmJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0ZWxlbS5wcm9wKCdkaXNhYmxlZCcsIHRydWUpO1xyXG5cdFx0XHRcdGluc3QudHJpZ2dlci5maWx0ZXIoJ2J1dHRvbi4nICsgdGhpcy5fdHJpZ2dlckNsYXNzKS5wcm9wKCdkaXNhYmxlZCcsIHRydWUpLmVuZCgpLlxyXG5cdFx0XHRcdFx0ZmlsdGVyKCdpbWcuJyArIHRoaXMuX3RyaWdnZXJDbGFzcykuY3NzKHtvcGFjaXR5OiAnMC41JywgY3Vyc29yOiAnZGVmYXVsdCd9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLl9kaXNhYmxlZCA9ICQubWFwKHRoaXMuX2Rpc2FibGVkLFxyXG5cdFx0XHRcdGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiAodmFsdWUgPT09IGVsZW1bMF0gPyBudWxsIDogdmFsdWUpOyB9KTsgLy8gRGVsZXRlIGVudHJ5XHJcblx0XHRcdHRoaXMuX2Rpc2FibGVkLnB1c2goZWxlbVswXSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBJcyB0aGUgZmlyc3QgZmllbGQgaW4gYSBqUXVlcnkgY29sbGVjdGlvbiBkaXNhYmxlZCBhcyBhIGRhdGVwaWNrZXI/XHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGV4YW1pbmUuXHJcblx0XHRcdEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGRpc2FibGVkLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgZW5hYmxlZC5cclxuXHRcdFx0QGV4YW1wbGUgaWYgKCQoc2VsZWN0b3IpLmRhdGVwaWNrKCdpc0Rpc2FibGVkJykpIHsuLi59ICovXHJcblx0XHRpc0Rpc2FibGVkOiBmdW5jdGlvbihlbGVtKSB7XHJcblx0XHRcdHJldHVybiAoZWxlbSAmJiAkLmluQXJyYXkoZWxlbSwgdGhpcy5fZGlzYWJsZWQpID4gLTEpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogU2hvdyBhIHBvcHVwIGRhdGVwaWNrZXIuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHBhcmFtIGVsZW0ge0V2ZW50fEVsZW1lbnR9IGEgZm9jdXMgZXZlbnQgb3IgdGhlIGNvbnRyb2wgdG8gdXNlLlxyXG5cdFx0XHRAZXhhbXBsZSAkKHNlbGVjdG9yKS5kYXRlcGljaygnc2hvdycpICovXHJcblx0XHRzaG93OiBmdW5jdGlvbihlbGVtKSB7XHJcblx0XHRcdGVsZW0gPSAkKGVsZW0udGFyZ2V0IHx8IGVsZW0pO1xyXG5cdFx0XHR2YXIgaW5zdCA9IHBsdWdpbi5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0aWYgKHBsdWdpbi5jdXJJbnN0ID09PSBpbnN0KSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChwbHVnaW4uY3VySW5zdCkge1xyXG5cdFx0XHRcdHBsdWdpbi5oaWRlKHBsdWdpbi5jdXJJbnN0LCB0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSkge1xyXG5cdFx0XHRcdC8vIFJldHJpZXZlIGV4aXN0aW5nIGRhdGUocylcclxuXHRcdFx0XHRpbnN0Lmxhc3RWYWwgPSBudWxsO1xyXG5cdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlcyA9IHBsdWdpbi5fZXh0cmFjdERhdGVzKGluc3QsIGVsZW0udmFsKCkpO1xyXG5cdFx0XHRcdGluc3QucGlja2luZ1JhbmdlID0gZmFsc2U7XHJcblx0XHRcdFx0aW5zdC5kcmF3RGF0ZSA9IHBsdWdpbi5fY2hlY2tNaW5NYXgoKGluc3Quc2VsZWN0ZWREYXRlc1swXSB8fFxyXG5cdFx0XHRcdFx0aW5zdC5nZXQoJ2RlZmF1bHREYXRlJykgfHwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCkpLm5ld0RhdGUoKSwgaW5zdCk7XHJcblx0XHRcdFx0aW5zdC5wcmV2RGF0ZSA9IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpO1xyXG5cdFx0XHRcdHBsdWdpbi5jdXJJbnN0ID0gaW5zdDtcclxuXHRcdFx0XHQvLyBHZW5lcmF0ZSBjb250ZW50XHJcblx0XHRcdFx0cGx1Z2luLl91cGRhdGUoZWxlbVswXSwgdHJ1ZSk7XHJcblx0XHRcdFx0Ly8gQWRqdXN0IHBvc2l0aW9uIGJlZm9yZSBzaG93aW5nXHJcblx0XHRcdFx0dmFyIG9mZnNldCA9IHBsdWdpbi5fY2hlY2tPZmZzZXQoaW5zdCk7XHJcblx0XHRcdFx0aW5zdC5kaXYuY3NzKHtsZWZ0OiBvZmZzZXQubGVmdCwgdG9wOiBvZmZzZXQudG9wfSk7XHJcblx0XHRcdFx0Ly8gQW5kIGRpc3BsYXlcclxuXHRcdFx0XHR2YXIgc2hvd0FuaW0gPSBpbnN0Lm9wdGlvbnMuc2hvd0FuaW07XHJcblx0XHRcdFx0dmFyIHNob3dTcGVlZCA9IGluc3Qub3B0aW9ucy5zaG93U3BlZWQ7XHJcblx0XHRcdFx0c2hvd1NwZWVkID0gKHNob3dTcGVlZCA9PT0gJ25vcm1hbCcgJiYgJC51aSAmJlxyXG5cdFx0XHRcdFx0cGFyc2VJbnQoJC51aS52ZXJzaW9uLnN1YnN0cmluZygyKSkgPj0gOCA/ICdfZGVmYXVsdCcgOiBzaG93U3BlZWQpO1xyXG5cdFx0XHRcdGlmICgkLmVmZmVjdHMgJiYgKCQuZWZmZWN0c1tzaG93QW5pbV0gfHwgKCQuZWZmZWN0cy5lZmZlY3QgJiYgJC5lZmZlY3RzLmVmZmVjdFtzaG93QW5pbV0pKSkge1xyXG5cdFx0XHRcdFx0dmFyIGRhdGEgPSBpbnN0LmRpdi5kYXRhKCk7IC8vIFVwZGF0ZSBvbGQgZWZmZWN0cyBkYXRhXHJcblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xyXG5cdFx0XHRcdFx0XHRpZiAoa2V5Lm1hdGNoKC9eZWNcXC5zdG9yYWdlXFwuLykpIHtcclxuXHRcdFx0XHRcdFx0XHRkYXRhW2tleV0gPSBpbnN0Ll9tYWluRGl2LmNzcyhrZXkucmVwbGFjZSgvZWNcXC5zdG9yYWdlXFwuLywgJycpKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aW5zdC5kaXYuZGF0YShkYXRhKS5zaG93KHNob3dBbmltLCBpbnN0Lm9wdGlvbnMuc2hvd09wdGlvbnMsIHNob3dTcGVlZCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0aW5zdC5kaXZbc2hvd0FuaW0gfHwgJ3Nob3cnXShzaG93QW5pbSA/IHNob3dTcGVlZCA6IDApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogRXh0cmFjdCBwb3NzaWJsZSBkYXRlcyBmcm9tIGEgc3RyaW5nLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxyXG5cdFx0XHRAcGFyYW0gdGV4dCB7c3RyaW5nfSBUaGUgdGV4dCB0byBleHRyYWN0IGZyb20uXHJcblx0XHRcdEByZXR1cm4ge0NEYXRlW119IFRoZSBleHRyYWN0ZWQgZGF0ZXMuICovXHJcblx0XHRfZXh0cmFjdERhdGVzOiBmdW5jdGlvbihpbnN0LCBkYXRlc1RleHQpIHtcclxuXHRcdFx0aWYgKGRhdGVzVGV4dCA9PT0gaW5zdC5sYXN0VmFsKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdGluc3QubGFzdFZhbCA9IGRhdGVzVGV4dDtcclxuXHRcdFx0ZGF0ZXNUZXh0ID0gZGF0ZXNUZXh0LnNwbGl0KGluc3Qub3B0aW9ucy5tdWx0aVNlbGVjdCA/IGluc3Qub3B0aW9ucy5tdWx0aVNlcGFyYXRvciA6XHJcblx0XHRcdFx0KGluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCA/IGluc3Qub3B0aW9ucy5yYW5nZVNlcGFyYXRvciA6ICdcXHgwMCcpKTtcclxuXHRcdFx0dmFyIGRhdGVzID0gW107XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0ZXNUZXh0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdHZhciBkYXRlID0gaW5zdC5vcHRpb25zLmNhbGVuZGFyLnBhcnNlRGF0ZShpbnN0LmdldCgnZGF0ZUZvcm1hdCcpLCBkYXRlc1RleHRbaV0pO1xyXG5cdFx0XHRcdFx0aWYgKGRhdGUpIHtcclxuXHRcdFx0XHRcdFx0dmFyIGZvdW5kID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZGF0ZXMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoZGF0ZXNbal0uY29tcGFyZVRvKGRhdGUpID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYgKCFmb3VuZCkge1xyXG5cdFx0XHRcdFx0XHRcdGRhdGVzLnB1c2goZGF0ZSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRcdC8vIElnbm9yZVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRkYXRlcy5zcGxpY2UoaW5zdC5vcHRpb25zLm11bHRpU2VsZWN0IHx8IChpbnN0Lm9wdGlvbnMucmFuZ2VTZWxlY3QgPyAyIDogMSksIGRhdGVzLmxlbmd0aCk7XHJcblx0XHRcdGlmIChpbnN0Lm9wdGlvbnMucmFuZ2VTZWxlY3QgJiYgZGF0ZXMubGVuZ3RoID09PSAxKSB7XHJcblx0XHRcdFx0ZGF0ZXNbMV0gPSBkYXRlc1swXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZGF0ZXM7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBVcGRhdGUgdGhlIGRhdGVwaWNrZXIgZGlzcGxheS5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RXZlbnR8RWxlbWVudH0gYSBmb2N1cyBldmVudCBvciB0aGUgY29udHJvbCB0byB1c2UuXHJcblx0XHRcdEBwYXJhbSBoaWRkZW4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIGluaXRpYWxseSBoaWRlIHRoZSBkYXRlcGlja2VyLiAqL1xyXG5cdFx0X3VwZGF0ZTogZnVuY3Rpb24oZWxlbSwgaGlkZGVuKSB7XHJcblx0XHRcdGVsZW0gPSAkKGVsZW0udGFyZ2V0IHx8IGVsZW0pO1xyXG5cdFx0XHR2YXIgaW5zdCA9IHBsdWdpbi5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0aWYgKCEkLmlzRW1wdHlPYmplY3QoaW5zdCkpIHtcclxuXHRcdFx0XHRpZiAoaW5zdC5pbmxpbmUgfHwgcGx1Z2luLmN1ckluc3QgPT09IGluc3QpIHtcclxuXHRcdFx0XHRcdGlmICgkLmlzRnVuY3Rpb24oaW5zdC5vcHRpb25zLm9uQ2hhbmdlTW9udGhZZWFyKSAmJiAoIWluc3QucHJldkRhdGUgfHxcclxuXHRcdFx0XHRcdFx0XHRpbnN0LnByZXZEYXRlLnllYXIoKSAhPT0gaW5zdC5kcmF3RGF0ZS55ZWFyKCkgfHxcclxuXHRcdFx0XHRcdFx0XHRpbnN0LnByZXZEYXRlLm1vbnRoKCkgIT09IGluc3QuZHJhd0RhdGUubW9udGgoKSkpIHtcclxuXHRcdFx0XHRcdFx0aW5zdC5vcHRpb25zLm9uQ2hhbmdlTW9udGhZZWFyLmFwcGx5KGVsZW1bMF0sXHJcblx0XHRcdFx0XHRcdFx0W2luc3QuZHJhd0RhdGUueWVhcigpLCBpbnN0LmRyYXdEYXRlLm1vbnRoKCldKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGluc3QuaW5saW5lKSB7XHJcblx0XHRcdFx0XHR2YXIgaW5kZXggPSAkKCdhLCA6aW5wdXQnLCBlbGVtKS5pbmRleCgkKCc6Zm9jdXMnLCBlbGVtKSk7XHJcblx0XHRcdFx0XHRlbGVtLmh0bWwodGhpcy5fZ2VuZXJhdGVDb250ZW50KGVsZW1bMF0sIGluc3QpKTtcclxuXHRcdFx0XHRcdHZhciBmb2N1cyA9IGVsZW0uZmluZCgnYSwgOmlucHV0Jyk7XHJcblx0XHRcdFx0XHRmb2N1cy5lcShNYXRoLm1heChNYXRoLm1pbihpbmRleCwgZm9jdXMubGVuZ3RoIC0gMSksIDApKS5mb2N1cygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIGlmIChwbHVnaW4uY3VySW5zdCA9PT0gaW5zdCkge1xyXG5cdFx0XHRcdFx0aWYgKCFpbnN0LmRpdikge1xyXG5cdFx0XHRcdFx0XHRpbnN0LmRpdiA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3ModGhpcy5fcG9wdXBDbGFzcykuXHJcblx0XHRcdFx0XHRcdFx0Y3NzKHtkaXNwbGF5OiAoaGlkZGVuID8gJ25vbmUnIDogJ3N0YXRpYycpLCBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuXHRcdFx0XHRcdFx0XHRcdGxlZnQ6IGVsZW0ub2Zmc2V0KCkubGVmdCwgdG9wOiBlbGVtLm9mZnNldCgpLnRvcCArIGVsZW0ub3V0ZXJIZWlnaHQoKX0pLlxyXG5cdFx0XHRcdFx0XHRcdGFwcGVuZFRvKCQoaW5zdC5vcHRpb25zLnBvcHVwQ29udGFpbmVyIHx8ICdib2R5JykpO1xyXG5cdFx0XHRcdFx0XHRpZiAoJC5mbi5tb3VzZXdoZWVsKSB7XHJcblx0XHRcdFx0XHRcdFx0aW5zdC5kaXYubW91c2V3aGVlbCh0aGlzLl9kb01vdXNlV2hlZWwpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpbnN0LmRpdi5odG1sKHRoaXMuX2dlbmVyYXRlQ29udGVudChlbGVtWzBdLCBpbnN0KSk7XHJcblx0XHRcdFx0XHRlbGVtLmZvY3VzKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBVcGRhdGUgdGhlIGlucHV0IGZpZWxkIGFuZCBhbnkgYWx0ZXJuYXRlIGZpZWxkIHdpdGggdGhlIGN1cnJlbnQgZGF0ZXMuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIHVzZS5cclxuXHRcdFx0QHBhcmFtIGtleVVwIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBjb21pbmcgZnJvbSA8Y29kZT5rZXlVcDwvY29kZT4gcHJvY2Vzc2luZyAoaW50ZXJuYWwpLiAqL1xyXG5cdFx0X3VwZGF0ZUlucHV0OiBmdW5jdGlvbihlbGVtLCBrZXlVcCkge1xyXG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XHJcblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KGluc3QpKSB7XHJcblx0XHRcdFx0dmFyIHZhbHVlID0gJyc7XHJcblx0XHRcdFx0dmFyIGFsdFZhbHVlID0gJyc7XHJcblx0XHRcdFx0dmFyIHNlcCA9IChpbnN0Lm9wdGlvbnMubXVsdGlTZWxlY3QgPyBpbnN0Lm9wdGlvbnMubXVsdGlTZXBhcmF0b3IgOlxyXG5cdFx0XHRcdFx0aW5zdC5vcHRpb25zLnJhbmdlU2VwYXJhdG9yKTtcclxuXHRcdFx0XHR2YXIgY2FsZW5kYXIgPSBpbnN0Lm9wdGlvbnMuY2FsZW5kYXI7XHJcblx0XHRcdFx0dmFyIGRhdGVGb3JtYXQgPSBpbnN0LmdldCgnZGF0ZUZvcm1hdCcpO1xyXG5cdFx0XHRcdHZhciBhbHRGb3JtYXQgPSBpbnN0Lm9wdGlvbnMuYWx0Rm9ybWF0IHx8IGRhdGVGb3JtYXQ7XHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0LnNlbGVjdGVkRGF0ZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHZhbHVlICs9IChrZXlVcCA/ICcnIDogKGkgPiAwID8gc2VwIDogJycpICtcclxuXHRcdFx0XHRcdFx0Y2FsZW5kYXIuZm9ybWF0RGF0ZShkYXRlRm9ybWF0LCBpbnN0LnNlbGVjdGVkRGF0ZXNbaV0pKTtcclxuXHRcdFx0XHRcdGFsdFZhbHVlICs9IChpID4gMCA/IHNlcCA6ICcnKSArXHJcblx0XHRcdFx0XHRcdGNhbGVuZGFyLmZvcm1hdERhdGUoYWx0Rm9ybWF0LCBpbnN0LnNlbGVjdGVkRGF0ZXNbaV0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoIWluc3QuaW5saW5lICYmICFrZXlVcCkge1xyXG5cdFx0XHRcdFx0JChlbGVtKS52YWwodmFsdWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQkKGluc3Qub3B0aW9ucy5hbHRGaWVsZCkudmFsKGFsdFZhbHVlKTtcclxuXHRcdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKGluc3Qub3B0aW9ucy5vblNlbGVjdCkgJiYgIWtleVVwICYmICFpbnN0LmluU2VsZWN0KSB7XHJcblx0XHRcdFx0XHRpbnN0LmluU2VsZWN0ID0gdHJ1ZTsgLy8gUHJldmVudCBlbmRsZXNzIGxvb3BzXHJcblx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMub25TZWxlY3QuYXBwbHkoZWxlbSwgW2luc3Quc2VsZWN0ZWREYXRlc10pO1xyXG5cdFx0XHRcdFx0aW5zdC5pblNlbGVjdCA9IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIHNpemUgb2YgbGVmdCBhbmQgdG9wIGJvcmRlcnMgZm9yIGFuIGVsZW1lbnQuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGVsZW0ge2pRdWVyeX0gVGhlIGVsZW1lbnQgb2YgaW50ZXJlc3QuXHJcblx0XHRcdEByZXR1cm4ge251bWJlcltdfSBUaGUgbGVmdCBhbmQgdG9wIGJvcmRlcnMuICovXHJcblx0XHRfZ2V0Qm9yZGVyczogZnVuY3Rpb24oZWxlbSkge1xyXG5cdFx0XHR2YXIgY29udmVydCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHRcdFx0cmV0dXJuIHt0aGluOiAxLCBtZWRpdW06IDMsIHRoaWNrOiA1fVt2YWx1ZV0gfHwgdmFsdWU7XHJcblx0XHRcdH07XHJcblx0XHRcdHJldHVybiBbcGFyc2VGbG9hdChjb252ZXJ0KGVsZW0uY3NzKCdib3JkZXItbGVmdC13aWR0aCcpKSksXHJcblx0XHRcdFx0cGFyc2VGbG9hdChjb252ZXJ0KGVsZW0uY3NzKCdib3JkZXItdG9wLXdpZHRoJykpKV07XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBDaGVjayBwb3NpdGlvbmluZyB0byByZW1haW4gb24gdGhlIHNjcmVlbi5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cclxuXHRcdFx0QHJldHVybiB7b2JqZWN0fSBUaGUgdXBkYXRlZCBvZmZzZXQgZm9yIHRoZSBkYXRlcGlja2VyLiAqL1xyXG5cdFx0X2NoZWNrT2Zmc2V0OiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdHZhciBiYXNlID0gKGluc3QuZWxlbS5pcygnOmhpZGRlbicpICYmIGluc3QudHJpZ2dlciA/IGluc3QudHJpZ2dlciA6IGluc3QuZWxlbSk7XHJcblx0XHRcdHZhciBvZmZzZXQgPSBiYXNlLm9mZnNldCgpO1xyXG5cdFx0XHR2YXIgYnJvd3NlcldpZHRoID0gJCh3aW5kb3cpLndpZHRoKCk7XHJcblx0XHRcdHZhciBicm93c2VySGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpO1xyXG5cdFx0XHRpZiAoYnJvd3NlcldpZHRoID09PSAwKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9mZnNldDtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgaXNGaXhlZCA9IGZhbHNlO1xyXG5cdFx0XHQkKGluc3QuZWxlbSkucGFyZW50cygpLmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0aXNGaXhlZCB8PSAkKHRoaXMpLmNzcygncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJztcclxuXHRcdFx0XHRyZXR1cm4gIWlzRml4ZWQ7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHR2YXIgc2Nyb2xsWCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdDtcclxuXHRcdFx0dmFyIHNjcm9sbFkgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xyXG5cdFx0XHR2YXIgYWJvdmUgPSBvZmZzZXQudG9wIC0gKGlzRml4ZWQgPyBzY3JvbGxZIDogMCkgLSBpbnN0LmRpdi5vdXRlckhlaWdodCgpO1xyXG5cdFx0XHR2YXIgYmVsb3cgPSBvZmZzZXQudG9wIC0gKGlzRml4ZWQgPyBzY3JvbGxZIDogMCkgKyBiYXNlLm91dGVySGVpZ2h0KCk7XHJcblx0XHRcdHZhciBhbGlnbkwgPSBvZmZzZXQubGVmdCAtIChpc0ZpeGVkID8gc2Nyb2xsWCA6IDApO1xyXG5cdFx0XHR2YXIgYWxpZ25SID0gb2Zmc2V0LmxlZnQgLSAoaXNGaXhlZCA/IHNjcm9sbFggOiAwKSArIGJhc2Uub3V0ZXJXaWR0aCgpIC0gaW5zdC5kaXYub3V0ZXJXaWR0aCgpO1xyXG5cdFx0XHR2YXIgdG9vV2lkZSA9IChvZmZzZXQubGVmdCAtIHNjcm9sbFggKyBpbnN0LmRpdi5vdXRlcldpZHRoKCkpID4gYnJvd3NlcldpZHRoO1xyXG5cdFx0XHR2YXIgdG9vSGlnaCA9IChvZmZzZXQudG9wIC0gc2Nyb2xsWSArIGluc3QuZWxlbS5vdXRlckhlaWdodCgpICtcclxuXHRcdFx0XHRpbnN0LmRpdi5vdXRlckhlaWdodCgpKSA+IGJyb3dzZXJIZWlnaHQ7XHJcblx0XHRcdGluc3QuZGl2LmNzcygncG9zaXRpb24nLCBpc0ZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZScpO1xyXG5cdFx0XHR2YXIgYWxpZ25tZW50ID0gaW5zdC5vcHRpb25zLmFsaWdubWVudDtcclxuXHRcdFx0aWYgKGFsaWdubWVudCA9PT0gJ3RvcExlZnQnKSB7XHJcblx0XHRcdFx0b2Zmc2V0ID0ge2xlZnQ6IGFsaWduTCwgdG9wOiBhYm92ZX07XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAoYWxpZ25tZW50ID09PSAndG9wUmlnaHQnKSB7XHJcblx0XHRcdFx0b2Zmc2V0ID0ge2xlZnQ6IGFsaWduUiwgdG9wOiBhYm92ZX07XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAoYWxpZ25tZW50ID09PSAnYm90dG9tTGVmdCcpIHtcclxuXHRcdFx0XHRvZmZzZXQgPSB7bGVmdDogYWxpZ25MLCB0b3A6IGJlbG93fTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmIChhbGlnbm1lbnQgPT09ICdib3R0b21SaWdodCcpIHtcclxuXHRcdFx0XHRvZmZzZXQgPSB7bGVmdDogYWxpZ25SLCB0b3A6IGJlbG93fTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmIChhbGlnbm1lbnQgPT09ICd0b3AnKSB7XHJcblx0XHRcdFx0b2Zmc2V0ID0ge2xlZnQ6IChpbnN0Lm9wdGlvbnMuaXNSVEwgfHwgdG9vV2lkZSA/IGFsaWduUiA6IGFsaWduTCksIHRvcDogYWJvdmV9O1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgeyAvLyBib3R0b21cclxuXHRcdFx0XHRvZmZzZXQgPSB7bGVmdDogKGluc3Qub3B0aW9ucy5pc1JUTCB8fCB0b29XaWRlID8gYWxpZ25SIDogYWxpZ25MKSxcclxuXHRcdFx0XHRcdHRvcDogKHRvb0hpZ2ggPyBhYm92ZSA6IGJlbG93KX07XHJcblx0XHRcdH1cclxuXHRcdFx0b2Zmc2V0LmxlZnQgPSBNYXRoLm1heCgoaXNGaXhlZCA/IDAgOiBzY3JvbGxYKSwgb2Zmc2V0LmxlZnQpO1xyXG5cdFx0XHRvZmZzZXQudG9wID0gTWF0aC5tYXgoKGlzRml4ZWQgPyAwIDogc2Nyb2xsWSksIG9mZnNldC50b3ApO1xyXG5cdFx0XHRyZXR1cm4gb2Zmc2V0O1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQ2xvc2UgZGF0ZSBwaWNrZXIgaWYgY2xpY2tlZCBlbHNld2hlcmUuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGV2ZW50IHtNb3VzZUV2ZW50fSBUaGUgbW91c2UgY2xpY2sgdG8gY2hlY2suICovXHJcblx0XHRfY2hlY2tFeHRlcm5hbENsaWNrOiBmdW5jdGlvbihldmVudCkge1xyXG5cdFx0XHRpZiAoIXBsdWdpbi5jdXJJbnN0KSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBlbGVtID0gJChldmVudC50YXJnZXQpO1xyXG5cdFx0XHRpZiAoZWxlbS5jbG9zZXN0KCcuJyArIHBsdWdpbi5fcG9wdXBDbGFzcyArICcsLicgKyBwbHVnaW4uX3RyaWdnZXJDbGFzcykubGVuZ3RoID09PSAwICYmXHJcblx0XHRcdFx0XHQhZWxlbS5oYXNDbGFzcyhwbHVnaW4uX2dldE1hcmtlcigpKSkge1xyXG5cdFx0XHRcdHBsdWdpbi5oaWRlKHBsdWdpbi5jdXJJbnN0KTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogSGlkZSBhIHBvcHVwIGRhdGVwaWNrZXIuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR8b2JqZWN0fSBUaGUgY29udHJvbCB0byB1c2Ugb3IgdGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEBwYXJhbSBpbW1lZGlhdGUge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIGNsb3NlIGltbWVkaWF0ZWx5IHdpdGhvdXQgYW5pbWF0aW9uIChpbnRlcm5hbCkuXHJcblx0XHRcdEBleGFtcGxlICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdoaWRlJykgKi9cclxuXHRcdGhpZGU6IGZ1bmN0aW9uKGVsZW0sIGltbWVkaWF0ZSkge1xyXG5cdFx0XHRpZiAoIWVsZW0pIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHRpZiAoJC5pc0VtcHR5T2JqZWN0KGluc3QpKSB7XHJcblx0XHRcdFx0aW5zdCA9IGVsZW07XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGluc3QgJiYgaW5zdCA9PT0gcGx1Z2luLmN1ckluc3QpIHtcclxuXHRcdFx0XHR2YXIgc2hvd0FuaW0gPSAoaW1tZWRpYXRlID8gJycgOiBpbnN0Lm9wdGlvbnMuc2hvd0FuaW0pO1xyXG5cdFx0XHRcdHZhciBzaG93U3BlZWQgPSBpbnN0Lm9wdGlvbnMuc2hvd1NwZWVkO1xyXG5cdFx0XHRcdHNob3dTcGVlZCA9IChzaG93U3BlZWQgPT09ICdub3JtYWwnICYmICQudWkgJiZcclxuXHRcdFx0XHRcdHBhcnNlSW50KCQudWkudmVyc2lvbi5zdWJzdHJpbmcoMikpID49IDggPyAnX2RlZmF1bHQnIDogc2hvd1NwZWVkKTtcclxuXHRcdFx0XHR2YXIgcG9zdFByb2Nlc3MgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGlmICghaW5zdC5kaXYpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aW5zdC5kaXYucmVtb3ZlKCk7XHJcblx0XHRcdFx0XHRpbnN0LmRpdiA9IG51bGw7XHJcblx0XHRcdFx0XHRwbHVnaW4uY3VySW5zdCA9IG51bGw7XHJcblx0XHRcdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKGluc3Qub3B0aW9ucy5vbkNsb3NlKSkge1xyXG5cdFx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMub25DbG9zZS5hcHBseShlbGVtLCBbaW5zdC5zZWxlY3RlZERhdGVzXSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHRpbnN0LmRpdi5zdG9wKCk7XHJcblx0XHRcdFx0aWYgKCQuZWZmZWN0cyAmJiAoJC5lZmZlY3RzW3Nob3dBbmltXSB8fCAoJC5lZmZlY3RzLmVmZmVjdCAmJiAkLmVmZmVjdHMuZWZmZWN0W3Nob3dBbmltXSkpKSB7XHJcblx0XHRcdFx0XHRpbnN0LmRpdi5oaWRlKHNob3dBbmltLCBpbnN0Lm9wdGlvbnMuc2hvd09wdGlvbnMsIHNob3dTcGVlZCwgcG9zdFByb2Nlc3MpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBoaWRlQW5pbSA9IChzaG93QW5pbSA9PT0gJ3NsaWRlRG93bicgPyAnc2xpZGVVcCcgOlxyXG5cdFx0XHRcdFx0XHQoc2hvd0FuaW0gPT09ICdmYWRlSW4nID8gJ2ZhZGVPdXQnIDogJ2hpZGUnKSk7XHJcblx0XHRcdFx0XHRpbnN0LmRpdltoaWRlQW5pbV0oKHNob3dBbmltID8gc2hvd1NwZWVkIDogJycpLCBwb3N0UHJvY2Vzcyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICghc2hvd0FuaW0pIHtcclxuXHRcdFx0XHRcdHBvc3RQcm9jZXNzKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBIYW5kbGUga2V5c3Ryb2tlcyBpbiB0aGUgZGF0ZXBpY2tlci5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gZXZlbnQge0tleUV2ZW50fSBUaGUga2V5c3Ryb2tlLlxyXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBub3QgaGFuZGxlZCwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIGhhbmRsZWQuICovXHJcblx0XHRfa2V5RG93bjogZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdFx0dmFyIGVsZW0gPSAoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLmVsZW0pIHx8IGV2ZW50LnRhcmdldDtcclxuXHRcdFx0dmFyIGluc3QgPSBwbHVnaW4uX2dldEluc3QoZWxlbSk7XHJcblx0XHRcdHZhciBoYW5kbGVkID0gZmFsc2U7XHJcblx0XHRcdGlmIChpbnN0LmlubGluZSB8fCBpbnN0LmRpdikge1xyXG5cdFx0XHRcdGlmIChldmVudC5rZXlDb2RlID09PSA5KSB7IC8vIFRhYiAtIGNsb3NlXHJcblx0XHRcdFx0XHRwbHVnaW4uaGlkZShlbGVtKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHsgLy8gRW50ZXIgLSBzZWxlY3RcclxuXHRcdFx0XHRcdHBsdWdpbi5zZWxlY3REYXRlKGVsZW0sXHJcblx0XHRcdFx0XHRcdCQoJ2EuJyArIGluc3Qub3B0aW9ucy5yZW5kZXJlci5oaWdobGlnaHRlZENsYXNzLCBpbnN0LmRpdilbMF0pO1xyXG5cdFx0XHRcdFx0aGFuZGxlZCA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgeyAvLyBDb21tYW5kIGtleXN0cm9rZXNcclxuXHRcdFx0XHRcdHZhciBjb21tYW5kcyA9IGluc3Qub3B0aW9ucy5jb21tYW5kcztcclxuXHRcdFx0XHRcdGZvciAodmFyIG5hbWUgaW4gY29tbWFuZHMpIHtcclxuXHRcdFx0XHRcdFx0dmFyIGNvbW1hbmQgPSBjb21tYW5kc1tuYW1lXTtcclxuXHRcdFx0XHRcdFx0aWYgKGNvbW1hbmQua2V5c3Ryb2tlLmtleUNvZGUgPT09IGV2ZW50LmtleUNvZGUgJiZcclxuXHRcdFx0XHRcdFx0XHRcdCEhY29tbWFuZC5rZXlzdHJva2UuY3RybEtleSA9PT0gISEoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSAmJlxyXG5cdFx0XHRcdFx0XHRcdFx0ISFjb21tYW5kLmtleXN0cm9rZS5hbHRLZXkgPT09IGV2ZW50LmFsdEtleSAmJlxyXG5cdFx0XHRcdFx0XHRcdFx0ISFjb21tYW5kLmtleXN0cm9rZS5zaGlmdEtleSA9PT0gZXZlbnQuc2hpZnRLZXkpIHtcclxuXHRcdFx0XHRcdFx0XHRwbHVnaW4ucGVyZm9ybUFjdGlvbihlbGVtLCBuYW1lKTtcclxuXHRcdFx0XHRcdFx0XHRoYW5kbGVkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHsgLy8gU2hvdyBvbiAnY3VycmVudCcga2V5c3Ryb2tlXHJcblx0XHRcdFx0dmFyIGNvbW1hbmQgPSBpbnN0Lm9wdGlvbnMuY29tbWFuZHMuY3VycmVudDtcclxuXHRcdFx0XHRpZiAoY29tbWFuZC5rZXlzdHJva2Uua2V5Q29kZSA9PT0gZXZlbnQua2V5Q29kZSAmJlxyXG5cdFx0XHRcdFx0XHQhIWNvbW1hbmQua2V5c3Ryb2tlLmN0cmxLZXkgPT09ICEhKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkgJiZcclxuXHRcdFx0XHRcdFx0ISFjb21tYW5kLmtleXN0cm9rZS5hbHRLZXkgPT09IGV2ZW50LmFsdEtleSAmJlxyXG5cdFx0XHRcdFx0XHQhIWNvbW1hbmQua2V5c3Ryb2tlLnNoaWZ0S2V5ID09PSBldmVudC5zaGlmdEtleSkge1xyXG5cdFx0XHRcdFx0cGx1Z2luLnNob3coZWxlbSk7XHJcblx0XHRcdFx0XHRoYW5kbGVkID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aW5zdC5jdHJsS2V5ID0gKChldmVudC5rZXlDb2RlIDwgNDggJiYgZXZlbnQua2V5Q29kZSAhPT0gMzIpIHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSk7XHJcblx0XHRcdGlmIChoYW5kbGVkKSB7XHJcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gIWhhbmRsZWQ7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBGaWx0ZXIga2V5c3Ryb2tlcyBpbiB0aGUgZGF0ZXBpY2tlci5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gZXZlbnQge0tleUV2ZW50fSBUaGUga2V5c3Ryb2tlLlxyXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBhbGxvd2VkLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90IGFsbG93ZWQuICovXHJcblx0XHRfa2V5UHJlc3M6IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRcdHZhciBpbnN0ID0gcGx1Z2luLl9nZXRJbnN0KChldmVudC5kYXRhICYmIGV2ZW50LmRhdGEuZWxlbSkgfHwgZXZlbnQudGFyZ2V0KTtcclxuXHRcdFx0aWYgKCEkLmlzRW1wdHlPYmplY3QoaW5zdCkgJiYgaW5zdC5vcHRpb25zLmNvbnN0cmFpbklucHV0KSB7XHJcblx0XHRcdFx0dmFyIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5rZXlDb2RlIHx8IGV2ZW50LmNoYXJDb2RlKTtcclxuXHRcdFx0XHR2YXIgYWxsb3dlZENoYXJzID0gcGx1Z2luLl9hbGxvd2VkQ2hhcnMoaW5zdCk7XHJcblx0XHRcdFx0cmV0dXJuIChldmVudC5tZXRhS2V5IHx8IGluc3QuY3RybEtleSB8fCBjaCA8ICcgJyB8fFxyXG5cdFx0XHRcdFx0IWFsbG93ZWRDaGFycyB8fCBhbGxvd2VkQ2hhcnMuaW5kZXhPZihjaCkgPiAtMSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBEZXRlcm1pbmUgdGhlIHNldCBvZiBjaGFyYWN0ZXJzIGFsbG93ZWQgYnkgdGhlIGRhdGUgZm9ybWF0LlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxyXG5cdFx0XHRAcmV0dXJuIHtzdHJpbmd9IFRoZSBzZXQgb2YgYWxsb3dlZCBjaGFyYWN0ZXJzLCBvciA8Y29kZT5udWxsPC9jb2RlPiBpZiBhbnl0aGluZyBhbGxvd2VkLiAqL1xyXG5cdFx0X2FsbG93ZWRDaGFyczogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHR2YXIgYWxsb3dlZENoYXJzID0gKGluc3Qub3B0aW9ucy5tdWx0aVNlbGVjdCA/IGluc3Qub3B0aW9ucy5tdWx0aVNlcGFyYXRvciA6XHJcblx0XHRcdFx0KGluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCA/IGluc3Qub3B0aW9ucy5yYW5nZVNlcGFyYXRvciA6ICcnKSk7XHJcblx0XHRcdHZhciBsaXRlcmFsID0gZmFsc2U7XHJcblx0XHRcdHZhciBoYXNOdW0gPSBmYWxzZTtcclxuXHRcdFx0dmFyIGRhdGVGb3JtYXQgPSBpbnN0LmdldCgnZGF0ZUZvcm1hdCcpO1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGVGb3JtYXQubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgY2ggPSBkYXRlRm9ybWF0LmNoYXJBdChpKTtcclxuXHRcdFx0XHRpZiAobGl0ZXJhbCkge1xyXG5cdFx0XHRcdFx0aWYgKGNoID09PSBcIidcIiAmJiBkYXRlRm9ybWF0LmNoYXJBdChpICsgMSkgIT09IFwiJ1wiKSB7XHJcblx0XHRcdFx0XHRcdGxpdGVyYWwgPSBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRhbGxvd2VkQ2hhcnMgKz0gY2g7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0c3dpdGNoIChjaCkge1xyXG5cdFx0XHRcdFx0XHRjYXNlICdkJzogY2FzZSAnbSc6IGNhc2UgJ28nOiBjYXNlICd3JzpcclxuXHRcdFx0XHRcdFx0XHRhbGxvd2VkQ2hhcnMgKz0gKGhhc051bSA/ICcnIDogJzAxMjM0NTY3ODknKTsgaGFzTnVtID0gdHJ1ZTsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ3knOiBjYXNlICdAJzogY2FzZSAnISc6XHJcblx0XHRcdFx0XHRcdFx0YWxsb3dlZENoYXJzICs9IChoYXNOdW0gPyAnJyA6ICcwMTIzNDU2Nzg5JykgKyAnLSc7IGhhc051bSA9IHRydWU7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdKJzpcclxuXHRcdFx0XHRcdFx0XHRhbGxvd2VkQ2hhcnMgKz0gKGhhc051bSA/ICcnIDogJzAxMjM0NTY3ODknKSArICctLic7IGhhc051bSA9IHRydWU7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdEJzogY2FzZSAnTSc6IGNhc2UgJ1knOlxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiBudWxsOyAvLyBBY2NlcHQgYW55dGhpbmdcclxuXHRcdFx0XHRcdFx0Y2FzZSBcIidcIjpcclxuXHRcdFx0XHRcdFx0XHRpZiAoZGF0ZUZvcm1hdC5jaGFyQXQoaSArIDEpID09PSBcIidcIikge1xyXG5cdFx0XHRcdFx0XHRcdFx0YWxsb3dlZENoYXJzICs9IFwiJ1wiO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdGxpdGVyYWwgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdFx0XHRhbGxvd2VkQ2hhcnMgKz0gY2g7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBhbGxvd2VkQ2hhcnM7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBTeW5jaHJvbmlzZSBkYXRlcGlja2VyIHdpdGggdGhlIGZpZWxkLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBldmVudCB7S2V5RXZlbnR9IFRoZSBrZXlzdHJva2UuXHJcblx0XHRcdEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGFsbG93ZWQsIDxjb2RlPmZhbHNlPC9jb2RlPiBpZiBub3QgYWxsb3dlZC4gKi9cclxuXHRcdF9rZXlVcDogZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdFx0dmFyIGVsZW0gPSAoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLmVsZW0pIHx8IGV2ZW50LnRhcmdldDtcclxuXHRcdFx0dmFyIGluc3QgPSBwbHVnaW4uX2dldEluc3QoZWxlbSk7XHJcblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KGluc3QpICYmICFpbnN0LmN0cmxLZXkgJiYgaW5zdC5sYXN0VmFsICE9PSBpbnN0LmVsZW0udmFsKCkpIHtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0dmFyIGRhdGVzID0gcGx1Z2luLl9leHRyYWN0RGF0ZXMoaW5zdCwgaW5zdC5lbGVtLnZhbCgpKTtcclxuXHRcdFx0XHRcdGlmIChkYXRlcy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0XHRcdHBsdWdpbi5zZXREYXRlKGVsZW0sIGRhdGVzLCBudWxsLCB0cnVlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y2F0Y2ggKGV2ZW50KSB7XHJcblx0XHRcdFx0XHQvLyBJZ25vcmVcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBJbmNyZW1lbnQvZGVjcmVtZW50IG1vbnRoL3llYXIgb24gbW91c2Ugd2hlZWwgYWN0aXZpdHkuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGV2ZW50IHtldmVudH0gVGhlIG1vdXNlIHdoZWVsIGV2ZW50LlxyXG5cdFx0XHRAcGFyYW0gZGVsdGEge251bWJlcn0gVGhlIGFtb3VudCBvZiBjaGFuZ2UuICovXHJcblx0XHRfZG9Nb3VzZVdoZWVsOiBmdW5jdGlvbihldmVudCwgZGVsdGEpIHtcclxuXHRcdFx0dmFyIGVsZW0gPSAocGx1Z2luLmN1ckluc3QgJiYgcGx1Z2luLmN1ckluc3QuZWxlbVswXSkgfHxcclxuXHRcdFx0XHQkKGV2ZW50LnRhcmdldCkuY2xvc2VzdCgnLicgKyBwbHVnaW4uX2dldE1hcmtlcigpKVswXTtcclxuXHRcdFx0aWYgKHBsdWdpbi5pc0Rpc2FibGVkKGVsZW0pKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBpbnN0ID0gcGx1Z2luLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHRpZiAoaW5zdC5vcHRpb25zLnVzZU1vdXNlV2hlZWwpIHtcclxuXHRcdFx0XHRkZWx0YSA9IChkZWx0YSA8IDAgPyAtMSA6ICsxKTtcclxuXHRcdFx0XHRwbHVnaW4uY2hhbmdlTW9udGgoZWxlbSwgLWluc3Qub3B0aW9uc1tldmVudC5jdHJsS2V5ID8gJ21vbnRoc1RvSnVtcCcgOiAnbW9udGhzVG9TdGVwJ10gKiBkZWx0YSk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIENsZWFyIGFuIGlucHV0IGFuZCBjbG9zZSBhIHBvcHVwIGRhdGVwaWNrZXIuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIHVzZS5cclxuXHRcdFx0QGV4YW1wbGUgJChzZWxlY3RvcikuZGF0ZXBpY2soJ2NsZWFyJykgKi9cclxuXHRcdGNsZWFyOiBmdW5jdGlvbihlbGVtKSB7XHJcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0aWYgKCEkLmlzRW1wdHlPYmplY3QoaW5zdCkpIHtcclxuXHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF0ZXMgPSBbXTtcclxuXHRcdFx0XHR0aGlzLmhpZGUoZWxlbSk7XHJcblx0XHRcdFx0dmFyIGRlZmF1bHREYXRlID0gaW5zdC5nZXQoJ2RlZmF1bHREYXRlJyk7XHJcblx0XHRcdFx0aWYgKGluc3Qub3B0aW9ucy5zZWxlY3REZWZhdWx0RGF0ZSAmJiBkZWZhdWx0RGF0ZSkge1xyXG5cdFx0XHRcdFx0dGhpcy5zZXREYXRlKGVsZW0sIChkZWZhdWx0RGF0ZSB8fCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKSkubmV3RGF0ZSgpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHR0aGlzLl91cGRhdGVJbnB1dChlbGVtKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBzZWxlY3RlZCBkYXRlKHMpIGZvciBhIGRhdGVwaWNrZXIuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGV4YW1pbmUuXHJcblx0XHRcdEByZXR1cm4ge0NEYXRlW119IFRoZSBzZWxlY3RlZCBkYXRlKHMpLlxyXG5cdFx0XHRAZXhhbXBsZSB2YXIgZGF0ZXMgPSAkKHNlbGVjdG9yKS5kYXRlcGljaygnZ2V0RGF0ZScpICovXHJcblx0XHRnZXREYXRlOiBmdW5jdGlvbihlbGVtKSB7XHJcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0cmV0dXJuICghJC5pc0VtcHR5T2JqZWN0KGluc3QpID8gaW5zdC5zZWxlY3RlZERhdGVzIDogW10pO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogU2V0IHRoZSBzZWxlY3RlZCBkYXRlKHMpIGZvciBhIGRhdGVwaWNrZXIuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IHRoZSBjb250cm9sIHRvIGV4YW1pbmUuXHJcblx0XHRcdEBwYXJhbSBkYXRlcyB7Q0RhdGV8bnVtYmVyfHN0cmluZ3xhcnJheX0gdGhlIHNlbGVjdGVkIGRhdGUocykuXHJcblx0XHRcdEBwYXJhbSBbZW5kRGF0ZV0ge0NEYXRlfG51bWJlcnxzdHJpbmd9IHRoZSBlbmRpbmcgZGF0ZSBmb3IgYSByYW5nZS5cclxuXHRcdFx0QHBhcmFtIFtrZXlVcF0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGNvbWluZyBmcm9tIDxjb2RlPmtleVVwPC9jb2RlPiBwcm9jZXNzaW5nIChpbnRlcm5hbCkuXHJcblx0XHRcdEBwYXJhbSBbc2V0T3B0XSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgY29taW5nIGZyb20gb3B0aW9uIHByb2Nlc3NpbmcgKGludGVybmFsKS5cclxuXHRcdFx0QGV4YW1wbGUgJChzZWxlY3RvcikuZGF0ZXBpY2soJ3NldERhdGUnLCBuZXcgRGF0ZSgyMDE0LCAxMi0xLCAyNSkpXHJcbiAkKHNlbGVjdG9yKS5kYXRlcGljaygnc2V0RGF0ZScsICcxMi8yNS8yMDE0JywgJzAxLzAxLzIwMTUnKVxyXG4gJChzZWxlY3RvcikuZGF0ZXBpY2soJ3NldERhdGUnLCBbZGF0ZTEsIGRhdGUyLCBkYXRlM10pICovXHJcblx0XHRzZXREYXRlOiBmdW5jdGlvbihlbGVtLCBkYXRlcywgZW5kRGF0ZSwga2V5VXAsIHNldE9wdCkge1xyXG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XHJcblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KGluc3QpKSB7XHJcblx0XHRcdFx0aWYgKCEkLmlzQXJyYXkoZGF0ZXMpKSB7XHJcblx0XHRcdFx0XHRkYXRlcyA9IFtkYXRlc107XHJcblx0XHRcdFx0XHRpZiAoZW5kRGF0ZSkge1xyXG5cdFx0XHRcdFx0XHRkYXRlcy5wdXNoKGVuZERhdGUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgbWluRGF0ZSA9IGluc3QuZ2V0KCdtaW5EYXRlJyk7XHJcblx0XHRcdFx0dmFyIG1heERhdGUgPSBpbnN0LmdldCgnbWF4RGF0ZScpO1xyXG5cdFx0XHRcdHZhciBjdXJEYXRlID0gaW5zdC5zZWxlY3RlZERhdGVzWzBdO1xyXG5cdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlcyA9IFtdO1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0ZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHZhciBkYXRlID0gaW5zdC5vcHRpb25zLmNhbGVuZGFyLmRldGVybWluZURhdGUoXHJcblx0XHRcdFx0XHRcdGRhdGVzW2ldLCBudWxsLCBjdXJEYXRlLCBpbnN0LmdldCgnZGF0ZUZvcm1hdCcpLCBpbnN0LmdldENvbmZpZygpKTtcclxuXHRcdFx0XHRcdGlmIChkYXRlKSB7XHJcblx0XHRcdFx0XHRcdGlmICgoIW1pbkRhdGUgfHwgZGF0ZS5jb21wYXJlVG8obWluRGF0ZSkgIT09IC0xKSAmJlxyXG5cdFx0XHRcdFx0XHRcdFx0KCFtYXhEYXRlIHx8IGRhdGUuY29tcGFyZVRvKG1heERhdGUpICE9PSArMSkpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgZm91bmQgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGluc3Quc2VsZWN0ZWREYXRlcy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGluc3Quc2VsZWN0ZWREYXRlc1tqXS5jb21wYXJlVG8oZGF0ZSkgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0Zm91bmQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0aWYgKCFmb3VuZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0aW5zdC5zZWxlY3RlZERhdGVzLnB1c2goZGF0ZSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlcy5zcGxpY2UoaW5zdC5vcHRpb25zLm11bHRpU2VsZWN0IHx8XHJcblx0XHRcdFx0XHQoaW5zdC5vcHRpb25zLnJhbmdlU2VsZWN0ID8gMiA6IDEpLCBpbnN0LnNlbGVjdGVkRGF0ZXMubGVuZ3RoKTtcclxuXHRcdFx0XHRpZiAoaW5zdC5vcHRpb25zLnJhbmdlU2VsZWN0KSB7XHJcblx0XHRcdFx0XHRzd2l0Y2ggKGluc3Quc2VsZWN0ZWREYXRlcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdFx0Y2FzZSAxOiBpbnN0LnNlbGVjdGVkRGF0ZXNbMV0gPSBpbnN0LnNlbGVjdGVkRGF0ZXNbMF07IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlIDI6IGluc3Quc2VsZWN0ZWREYXRlc1sxXSA9XHJcblx0XHRcdFx0XHRcdFx0KGluc3Quc2VsZWN0ZWREYXRlc1swXS5jb21wYXJlVG8oaW5zdC5zZWxlY3RlZERhdGVzWzFdKSA9PT0gKzEgP1xyXG5cdFx0XHRcdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlc1swXSA6IGluc3Quc2VsZWN0ZWREYXRlc1sxXSk7IGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aW5zdC5waWNraW5nUmFuZ2UgPSBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aW5zdC5wcmV2RGF0ZSA9IChpbnN0LmRyYXdEYXRlID8gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkgOiBudWxsKTtcclxuXHRcdFx0XHRpbnN0LmRyYXdEYXRlID0gdGhpcy5fY2hlY2tNaW5NYXgoKGluc3Quc2VsZWN0ZWREYXRlc1swXSB8fFxyXG5cdFx0XHRcdFx0aW5zdC5nZXQoJ2RlZmF1bHREYXRlJykgfHwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCkpLm5ld0RhdGUoKSwgaW5zdCk7XHJcblx0XHRcdFx0aWYgKCFzZXRPcHQpIHtcclxuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZShlbGVtKTtcclxuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZUlucHV0KGVsZW0sIGtleVVwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIERldGVybWluZSB3aGV0aGVyIGEgZGF0ZSBpcyBzZWxlY3RhYmxlIGZvciB0aGlzIGRhdGVwaWNrZXIuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGNoZWNrLlxyXG5cdFx0XHRAcGFyYW0gZGF0ZSB7Q0RhdGV8c3RyaW5nfG51bWJlcn0gVGhlIGRhdGUgdG8gY2hlY2suXHJcblx0XHRcdEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIHNlbGVjdGFibGUsIDxjb2RlPmZhbHNlPC9jb2RlPiBpZiBub3QuXHJcblx0XHRcdEBleGFtcGxlIHZhciBzZWxlY3RhYmxlID0gJChzZWxlY3RvcikuZGF0ZXBpY2soJ2lzU2VsZWN0YWJsZScsIGRhdGUpICovXHJcblx0XHRpc1NlbGVjdGFibGU6IGZ1bmN0aW9uKGVsZW0sIGRhdGUpIHtcclxuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHRpZiAoJC5pc0VtcHR5T2JqZWN0KGluc3QpKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRhdGUgPSBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIuZGV0ZXJtaW5lRGF0ZShkYXRlLFxyXG5cdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlc1swXSB8fCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKSwgbnVsbCxcclxuXHRcdFx0XHRpbnN0Lm9wdGlvbnMuZGF0ZUZvcm1hdCwgaW5zdC5nZXRDb25maWcoKSk7XHJcblx0XHRcdHJldHVybiB0aGlzLl9pc1NlbGVjdGFibGUoZWxlbSwgZGF0ZSwgaW5zdC5vcHRpb25zLm9uRGF0ZSxcclxuXHRcdFx0XHRpbnN0LmdldCgnbWluRGF0ZScpLCBpbnN0LmdldCgnbWF4RGF0ZScpKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEludGVybmFsbHkgZGV0ZXJtaW5lIHdoZXRoZXIgYSBkYXRlIGlzIHNlbGVjdGFibGUgZm9yIHRoaXMgZGF0ZXBpY2tlci5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gdGhlIGNvbnRyb2wgdG8gY2hlY2suXHJcblx0XHRcdEBwYXJhbSBkYXRlIHtDRGF0ZX0gVGhlIGRhdGUgdG8gY2hlY2suXHJcblx0XHRcdEBwYXJhbSBvbkRhdGUge2Z1bmN0aW9ufGJvb2xlYW59IEFueSA8Y29kZT5vbkRhdGU8L2NvZGU+IGNhbGxiYWNrIG9yIDxjb2RlPmNhbGxiYWNrLnNlbGVjdGFibGU8L2NvZGU+LlxyXG5cdFx0XHRAcGFyYW0gbWluRGF0ZSB7Q0RhdGV9IFRoZSBtaW5pbXVtIGFsbG93ZWQgZGF0ZS5cclxuXHRcdFx0QHBhcmFtIG1heERhdGUge0NEYXRlfSBUaGUgbWF4aW11bSBhbGxvd2VkIGRhdGUuXHJcblx0XHRcdEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIHNlbGVjdGFibGUsIDxjb2RlPmZhbHNlPC9jb2RlPiBpZiBub3QuICovXHJcblx0XHRfaXNTZWxlY3RhYmxlOiBmdW5jdGlvbihlbGVtLCBkYXRlLCBvbkRhdGUsIG1pbkRhdGUsIG1heERhdGUpIHtcclxuXHRcdFx0dmFyIGRhdGVJbmZvID0gKHR5cGVvZiBvbkRhdGUgPT09ICdib29sZWFuJyA/IHtzZWxlY3RhYmxlOiBvbkRhdGV9IDpcclxuXHRcdFx0XHQoISQuaXNGdW5jdGlvbihvbkRhdGUpID8ge30gOiBvbkRhdGUuYXBwbHkoZWxlbSwgW2RhdGUsIHRydWVdKSkpO1xyXG5cdFx0XHRyZXR1cm4gKGRhdGVJbmZvLnNlbGVjdGFibGUgIT09IGZhbHNlKSAmJlxyXG5cdFx0XHRcdCghbWluRGF0ZSB8fCBkYXRlLnRvSkQoKSA+PSBtaW5EYXRlLnRvSkQoKSkgJiYgKCFtYXhEYXRlIHx8IGRhdGUudG9KRCgpIDw9IG1heERhdGUudG9KRCgpKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFBlcmZvcm0gYSBuYW1lZCBhY3Rpb24gZm9yIGEgZGF0ZXBpY2tlci5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7ZWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gYWZmZWN0LlxyXG5cdFx0XHRAcGFyYW0gYWN0aW9uIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBhY3Rpb24uICovXHJcblx0XHRwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbihlbGVtLCBhY3Rpb24pIHtcclxuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSAmJiAhdGhpcy5pc0Rpc2FibGVkKGVsZW0pKSB7XHJcblx0XHRcdFx0dmFyIGNvbW1hbmRzID0gaW5zdC5vcHRpb25zLmNvbW1hbmRzO1xyXG5cdFx0XHRcdGlmIChjb21tYW5kc1thY3Rpb25dICYmIGNvbW1hbmRzW2FjdGlvbl0uZW5hYmxlZC5hcHBseShlbGVtLCBbaW5zdF0pKSB7XHJcblx0XHRcdFx0XHRjb21tYW5kc1thY3Rpb25dLmFjdGlvbi5hcHBseShlbGVtLCBbaW5zdF0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogU2V0IHRoZSBjdXJyZW50bHkgc2hvd24gbW9udGgsIGRlZmF1bHRpbmcgdG8gdG9kYXkncy5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gYWZmZWN0LlxyXG5cdFx0XHRAcGFyYW0gW3llYXJdIHtudW1iZXJ9IFRoZSB5ZWFyIHRvIHNob3cuXHJcblx0XHRcdEBwYXJhbSBbbW9udGhdIHtudW1iZXJ9IFRoZSBtb250aCB0byBzaG93ICgxLTEyKS5cclxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgdG8gc2hvdy5cclxuXHRcdFx0QGV4YW1wbGUgJChzZWxlY3RvcikuZGF0ZXBpY2soJ3Nob3dNb250aCcsIDIwMTQsIDEyLCAyNSkgKi9cclxuXHRcdHNob3dNb250aDogZnVuY3Rpb24oZWxlbSwgeWVhciwgbW9udGgsIGRheSkge1xyXG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XHJcblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KGluc3QpICYmIChkYXkgIT0gbnVsbCB8fFxyXG5cdFx0XHRcdFx0KGluc3QuZHJhd0RhdGUueWVhcigpICE9PSB5ZWFyIHx8IGluc3QuZHJhd0RhdGUubW9udGgoKSAhPT0gbW9udGgpKSkge1xyXG5cdFx0XHRcdGluc3QucHJldkRhdGUgPSBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKTtcclxuXHRcdFx0XHR2YXIgY2FsZW5kYXIgPSBpbnN0Lm9wdGlvbnMuY2FsZW5kYXI7XHJcblx0XHRcdFx0dmFyIHNob3cgPSB0aGlzLl9jaGVja01pbk1heCgoeWVhciAhPSBudWxsID9cclxuXHRcdFx0XHRcdGNhbGVuZGFyLm5ld0RhdGUoeWVhciwgbW9udGgsIDEpIDogY2FsZW5kYXIudG9kYXkoKSksIGluc3QpO1xyXG5cdFx0XHRcdGluc3QuZHJhd0RhdGUuZGF0ZShzaG93LnllYXIoKSwgc2hvdy5tb250aCgpLCBcclxuXHRcdFx0XHRcdChkYXkgIT0gbnVsbCA/IGRheSA6IE1hdGgubWluKGluc3QuZHJhd0RhdGUuZGF5KCksXHJcblx0XHRcdFx0XHRjYWxlbmRhci5kYXlzSW5Nb250aChzaG93LnllYXIoKSwgc2hvdy5tb250aCgpKSkpKTtcclxuXHRcdFx0XHR0aGlzLl91cGRhdGUoZWxlbSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEFkanVzdCB0aGUgY3VycmVudGx5IHNob3duIG1vbnRoLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBhZmZlY3QuXHJcblx0XHRcdEBwYXJhbSBvZmZzZXQge251bWJlcn0gVGhlIG51bWJlciBvZiBtb250aHMgdG8gY2hhbmdlIGJ5LlxyXG5cdFx0XHRAZXhhbXBsZSAkKHNlbGVjdG9yKS5kYXRlcGljaygnY2hhbmdlTW9udGgnLCAyKSovXHJcblx0XHRjaGFuZ2VNb250aDogZnVuY3Rpb24oZWxlbSwgb2Zmc2V0KSB7XHJcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0aWYgKCEkLmlzRW1wdHlPYmplY3QoaW5zdCkpIHtcclxuXHRcdFx0XHR2YXIgZGF0ZSA9IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLmFkZChvZmZzZXQsICdtJyk7XHJcblx0XHRcdFx0dGhpcy5zaG93TW9udGgoZWxlbSwgZGF0ZS55ZWFyKCksIGRhdGUubW9udGgoKSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEFkanVzdCB0aGUgY3VycmVudGx5IHNob3duIGRheS5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gYWZmZWN0LlxyXG5cdFx0XHRAcGFyYW0gb2Zmc2V0IHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZGF5cyB0byBjaGFuZ2UgYnkuXHJcblx0XHRcdEBleGFtcGxlICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdjaGFuZ2VEYXknLCA3KSovXHJcblx0XHRjaGFuZ2VEYXk6IGZ1bmN0aW9uKGVsZW0sIG9mZnNldCkge1xyXG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XHJcblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KGluc3QpKSB7XHJcblx0XHRcdFx0dmFyIGRhdGUgPSBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5hZGQob2Zmc2V0LCAnZCcpO1xyXG5cdFx0XHRcdHRoaXMuc2hvd01vbnRoKGVsZW0sIGRhdGUueWVhcigpLCBkYXRlLm1vbnRoKCksIGRhdGUuZGF5KCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXN0cmljdCBhIGRhdGUgdG8gdGhlIG1pbmltdW0vbWF4aW11bSBzcGVjaWZpZWQuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGRhdGUge0NEYXRlfSBUaGUgZGF0ZSB0byBjaGVjay5cclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuICovXHJcblx0XHRfY2hlY2tNaW5NYXg6IGZ1bmN0aW9uKGRhdGUsIGluc3QpIHtcclxuXHRcdFx0dmFyIG1pbkRhdGUgPSBpbnN0LmdldCgnbWluRGF0ZScpO1xyXG5cdFx0XHR2YXIgbWF4RGF0ZSA9IGluc3QuZ2V0KCdtYXhEYXRlJyk7XHJcblx0XHRcdGRhdGUgPSAobWluRGF0ZSAmJiBkYXRlLmNvbXBhcmVUbyhtaW5EYXRlKSA9PT0gLTEgPyBtaW5EYXRlLm5ld0RhdGUoKSA6IGRhdGUpO1xyXG5cdFx0XHRkYXRlID0gKG1heERhdGUgJiYgZGF0ZS5jb21wYXJlVG8obWF4RGF0ZSkgPT09ICsxID8gbWF4RGF0ZS5uZXdEYXRlKCkgOiBkYXRlKTtcclxuXHRcdFx0cmV0dXJuIGRhdGU7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgZGF0ZSBhc3NvY2lhdGVkIHdpdGggYW4gZW50cnkgaW4gdGhlIGRhdGVwaWNrZXIuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGV4YW1pbmUuXHJcblx0XHRcdEBwYXJhbSB0YXJnZXQge0VsZW1lbnR9IFRoZSBzZWxlY3RlZCBkYXRlcGlja2VyIGVsZW1lbnQuXHJcblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgY29ycmVzcG9uZGluZyBkYXRlLCBvciA8Y29kZT5udWxsPC9jb2RlPi5cdFx0XHRcclxuXHRcdFx0QGV4YW1wbGUgdmFyIGRhdGUgPSAkKHNlbGVjdG9yKS5kYXRlcGljaygncmV0cmlldmVEYXRlJywgJCgnZGl2LmRhdGVwaWNrLXBvcHVwIGE6Y29udGFpbnMoMTApJylbMF0pICovXHJcblx0XHRyZXRyaWV2ZURhdGU6IGZ1bmN0aW9uKGVsZW0sIHRhcmdldCkge1xyXG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XHJcblx0XHRcdHJldHVybiAoJC5pc0VtcHR5T2JqZWN0KGluc3QpID8gbnVsbCA6IGluc3Qub3B0aW9ucy5jYWxlbmRhci5mcm9tSkQoXHJcblx0XHRcdFx0cGFyc2VGbG9hdCh0YXJnZXQuY2xhc3NOYW1lLnJlcGxhY2UoL14uKmpkKFxcZCtcXC41KS4qJC8sICckMScpKSkpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogU2VsZWN0IGEgZGF0ZSBmb3IgdGhpcyBkYXRlcGlja2VyLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBleGFtaW5lLlxyXG5cdFx0XHRAcGFyYW0gdGFyZ2V0IHtFbGVtZW50fSBUaGUgc2VsZWN0ZWQgZGF0ZXBpY2tlciBlbGVtZW50LlxyXG5cdFx0XHRAZXhhbXBsZSAkKHNlbGVjdG9yKS5kYXRlcGljaygnc2VsZWN0RGF0ZScsICQoJ2Rpdi5kYXRlcGljay1wb3B1cCBhOmNvbnRhaW5zKDEwKScpWzBdKSAqL1xyXG5cdFx0c2VsZWN0RGF0ZTogZnVuY3Rpb24oZWxlbSwgdGFyZ2V0KSB7XHJcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0aWYgKCEkLmlzRW1wdHlPYmplY3QoaW5zdCkgJiYgIXRoaXMuaXNEaXNhYmxlZChlbGVtKSkge1xyXG5cdFx0XHRcdHZhciBkYXRlID0gdGhpcy5yZXRyaWV2ZURhdGUoZWxlbSwgdGFyZ2V0KTtcclxuXHRcdFx0XHRpZiAoaW5zdC5vcHRpb25zLm11bHRpU2VsZWN0KSB7XHJcblx0XHRcdFx0XHR2YXIgZm91bmQgPSBmYWxzZTtcclxuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdC5zZWxlY3RlZERhdGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdGlmIChkYXRlLmNvbXBhcmVUbyhpbnN0LnNlbGVjdGVkRGF0ZXNbaV0pID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0aW5zdC5zZWxlY3RlZERhdGVzLnNwbGljZShpLCAxKTtcclxuXHRcdFx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICghZm91bmQgJiYgaW5zdC5zZWxlY3RlZERhdGVzLmxlbmd0aCA8IGluc3Qub3B0aW9ucy5tdWx0aVNlbGVjdCkge1xyXG5cdFx0XHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF0ZXMucHVzaChkYXRlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZiAoaW5zdC5vcHRpb25zLnJhbmdlU2VsZWN0KSB7XHJcblx0XHRcdFx0XHRpZiAoaW5zdC5waWNraW5nUmFuZ2UpIHtcclxuXHRcdFx0XHRcdFx0aW5zdC5zZWxlY3RlZERhdGVzWzFdID0gZGF0ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF0ZXMgPSBbZGF0ZSwgZGF0ZV07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpbnN0LnBpY2tpbmdSYW5nZSA9ICFpbnN0LnBpY2tpbmdSYW5nZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF0ZXMgPSBbZGF0ZV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGluc3QucHJldkRhdGUgPSBpbnN0LmRyYXdEYXRlID0gZGF0ZS5uZXdEYXRlKCk7XHJcblx0XHRcdFx0dGhpcy5fdXBkYXRlSW5wdXQoZWxlbSk7XHJcblx0XHRcdFx0aWYgKGluc3QuaW5saW5lIHx8IGluc3QucGlja2luZ1JhbmdlIHx8IGluc3Quc2VsZWN0ZWREYXRlcy5sZW5ndGggPFxyXG5cdFx0XHRcdFx0XHQoaW5zdC5vcHRpb25zLm11bHRpU2VsZWN0IHx8IChpbnN0Lm9wdGlvbnMucmFuZ2VTZWxlY3QgPyAyIDogMSkpKSB7XHJcblx0XHRcdFx0XHR0aGlzLl91cGRhdGUoZWxlbSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5oaWRlKGVsZW0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogR2VuZXJhdGUgdGhlIGRhdGVwaWNrZXIgY29udGVudCBmb3IgdGhpcyBjb250cm9sLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBhZmZlY3QuXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxyXG5cdFx0XHRAcmV0dXJuIHtqUXVlcnl9IFRoZSBkYXRlcGlja2VyIGNvbnRlbnQgKi9cclxuXHRcdF9nZW5lcmF0ZUNvbnRlbnQ6IGZ1bmN0aW9uKGVsZW0sIGluc3QpIHtcclxuXHRcdFx0dmFyIG1vbnRoc1RvU2hvdyA9IGluc3Qub3B0aW9ucy5tb250aHNUb1Nob3c7XHJcblx0XHRcdG1vbnRoc1RvU2hvdyA9ICgkLmlzQXJyYXkobW9udGhzVG9TaG93KSA/IG1vbnRoc1RvU2hvdyA6IFsxLCBtb250aHNUb1Nob3ddKTtcclxuXHRcdFx0aW5zdC5kcmF3RGF0ZSA9IHRoaXMuX2NoZWNrTWluTWF4KFxyXG5cdFx0XHRcdGluc3QuZHJhd0RhdGUgfHwgaW5zdC5nZXQoJ2RlZmF1bHREYXRlJykgfHwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCksIGluc3QpO1xyXG5cdFx0XHR2YXIgZHJhd0RhdGUgPSBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5hZGQoLWluc3Qub3B0aW9ucy5tb250aHNPZmZzZXQsICdtJyk7XHJcblx0XHRcdC8vIEdlbmVyYXRlIG1vbnRoc1xyXG5cdFx0XHR2YXIgbW9udGhSb3dzID0gJyc7XHJcblx0XHRcdGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vbnRoc1RvU2hvd1swXTsgcm93KyspIHtcclxuXHRcdFx0XHR2YXIgbW9udGhzID0gJyc7XHJcblx0XHRcdFx0Zm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9udGhzVG9TaG93WzFdOyBjb2wrKykge1xyXG5cdFx0XHRcdFx0bW9udGhzICs9IHRoaXMuX2dlbmVyYXRlTW9udGgoZWxlbSwgaW5zdCwgZHJhd0RhdGUueWVhcigpLFxyXG5cdFx0XHRcdFx0XHRkcmF3RGF0ZS5tb250aCgpLCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIsIGluc3Qub3B0aW9ucy5yZW5kZXJlciwgKHJvdyA9PT0gMCAmJiBjb2wgPT09IDApKTtcclxuXHRcdFx0XHRcdGRyYXdEYXRlLmFkZCgxLCAnbScpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRtb250aFJvd3MgKz0gdGhpcy5fcHJlcGFyZShpbnN0Lm9wdGlvbnMucmVuZGVyZXIubW9udGhSb3csIGluc3QpLnJlcGxhY2UoL1xce21vbnRoc1xcfS8sIG1vbnRocyk7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIHBpY2tlciA9IHRoaXMuX3ByZXBhcmUoaW5zdC5vcHRpb25zLnJlbmRlcmVyLnBpY2tlciwgaW5zdCkucmVwbGFjZSgvXFx7bW9udGhzXFx9LywgbW9udGhSb3dzKS5cclxuXHRcdFx0XHRyZXBsYWNlKC9cXHt3ZWVrSGVhZGVyXFx9L2csIHRoaXMuX2dlbmVyYXRlRGF5SGVhZGVycyhpbnN0LCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIsIGluc3Qub3B0aW9ucy5yZW5kZXJlcikpO1xyXG5cdFx0XHQvLyBBZGQgY29tbWFuZHNcclxuXHRcdFx0dmFyIGFkZENvbW1hbmQgPSBmdW5jdGlvbih0eXBlLCBvcGVuLCBjbG9zZSwgbmFtZSwgY2xhc3Nlcykge1xyXG5cdFx0XHRcdGlmIChwaWNrZXIuaW5kZXhPZigneycgKyB0eXBlICsgJzonICsgbmFtZSArICd9JykgPT09IC0xKSB7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhciBjb21tYW5kID0gaW5zdC5vcHRpb25zLmNvbW1hbmRzW25hbWVdO1xyXG5cdFx0XHRcdHZhciBkYXRlID0gKGluc3Qub3B0aW9ucy5jb21tYW5kc0FzRGF0ZUZvcm1hdCA/IGNvbW1hbmQuZGF0ZS5hcHBseShlbGVtLCBbaW5zdF0pIDogbnVsbCk7XHJcblx0XHRcdFx0cGlja2VyID0gcGlja2VyLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXHsnICsgdHlwZSArICc6JyArIG5hbWUgKyAnXFxcXH0nLCAnZycpLFxyXG5cdFx0XHRcdFx0JzwnICsgb3BlbiArIChjb21tYW5kLnN0YXR1cyA/ICcgdGl0bGU9XCInICsgaW5zdC5vcHRpb25zW2NvbW1hbmQuc3RhdHVzXSArICdcIicgOiAnJykgK1xyXG5cdFx0XHRcdFx0JyBjbGFzcz1cIicgKyBpbnN0Lm9wdGlvbnMucmVuZGVyZXIuY29tbWFuZENsYXNzICsgJyAnICtcclxuXHRcdFx0XHRcdGluc3Qub3B0aW9ucy5yZW5kZXJlci5jb21tYW5kQ2xhc3MgKyAnLScgKyBuYW1lICsgJyAnICsgY2xhc3NlcyArXHJcblx0XHRcdFx0XHQoY29tbWFuZC5lbmFibGVkKGluc3QpID8gJycgOiAnICcgKyBpbnN0Lm9wdGlvbnMucmVuZGVyZXIuZGlzYWJsZWRDbGFzcykgKyAnXCI+JyArXHJcblx0XHRcdFx0XHQoZGF0ZSA/IGRhdGUuZm9ybWF0RGF0ZShpbnN0Lm9wdGlvbnNbY29tbWFuZC50ZXh0XSkgOlxyXG5cdFx0XHRcdFx0aW5zdC5vcHRpb25zW2NvbW1hbmQudGV4dF0pICsgJzwvJyArIGNsb3NlICsgJz4nKTtcclxuXHRcdFx0fTtcclxuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBpbnN0Lm9wdGlvbnMuY29tbWFuZHMpIHtcclxuXHRcdFx0XHRhZGRDb21tYW5kKCdidXR0b24nLCAnYnV0dG9uIHR5cGU9XCJidXR0b25cIicsICdidXR0b24nLCBuYW1lLFxyXG5cdFx0XHRcdFx0aW5zdC5vcHRpb25zLnJlbmRlcmVyLmNvbW1hbmRCdXR0b25DbGFzcyk7XHJcblx0XHRcdFx0YWRkQ29tbWFuZCgnbGluaycsICdhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIicsICdhJywgbmFtZSxcclxuXHRcdFx0XHRcdGluc3Qub3B0aW9ucy5yZW5kZXJlci5jb21tYW5kTGlua0NsYXNzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRwaWNrZXIgPSAkKHBpY2tlcik7XHJcblx0XHRcdGlmIChtb250aHNUb1Nob3dbMV0gPiAxKSB7XHJcblx0XHRcdFx0dmFyIGNvdW50ID0gMDtcclxuXHRcdFx0XHQkKGluc3Qub3B0aW9ucy5yZW5kZXJlci5tb250aFNlbGVjdG9yLCBwaWNrZXIpLmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHR2YXIgbnRoID0gKytjb3VudCAlIG1vbnRoc1RvU2hvd1sxXTtcclxuXHRcdFx0XHRcdCQodGhpcykuYWRkQ2xhc3MobnRoID09PSAxID8gJ2ZpcnN0JyA6IChudGggPT09IDAgPyAnbGFzdCcgOiAnJykpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIEFkZCBkYXRlcGlja2VyIGJlaGF2aW91clxyXG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblx0XHRcdGZ1bmN0aW9uIHJlbW92ZUhpZ2hsaWdodCgpIHtcclxuXHRcdFx0XHQoaW5zdC5pbmxpbmUgPyAkKHRoaXMpLmNsb3Nlc3QoJy4nICsgc2VsZi5fZ2V0TWFya2VyKCkpIDogaW5zdC5kaXYpLlxyXG5cdFx0XHRcdFx0ZmluZChpbnN0Lm9wdGlvbnMucmVuZGVyZXIuZGF5U2VsZWN0b3IgKyAnIGEnKS5cclxuXHRcdFx0XHRcdHJlbW92ZUNsYXNzKGluc3Qub3B0aW9ucy5yZW5kZXJlci5oaWdobGlnaHRlZENsYXNzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRwaWNrZXIuZmluZChpbnN0Lm9wdGlvbnMucmVuZGVyZXIuZGF5U2VsZWN0b3IgKyAnIGEnKS5ob3ZlcihcclxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRyZW1vdmVIaWdobGlnaHQuYXBwbHkodGhpcyk7XHJcblx0XHRcdFx0XHRcdCQodGhpcykuYWRkQ2xhc3MoaW5zdC5vcHRpb25zLnJlbmRlcmVyLmhpZ2hsaWdodGVkQ2xhc3MpO1xyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdHJlbW92ZUhpZ2hsaWdodCkuXHJcblx0XHRcdFx0Y2xpY2soZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRzZWxmLnNlbGVjdERhdGUoZWxlbSwgdGhpcyk7XHJcblx0XHRcdFx0fSkuZW5kKCkuXHJcblx0XHRcdFx0ZmluZCgnc2VsZWN0LicgKyB0aGlzLl9tb250aFllYXJDbGFzcyArICc6bm90KC4nICsgdGhpcy5fYW55WWVhckNsYXNzICsgJyknKS5cclxuXHRcdFx0XHRjaGFuZ2UoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHR2YXIgbW9udGhZZWFyID0gJCh0aGlzKS52YWwoKS5zcGxpdCgnLycpO1xyXG5cdFx0XHRcdFx0c2VsZi5zaG93TW9udGgoZWxlbSwgcGFyc2VJbnQobW9udGhZZWFyWzFdLCAxMCksIHBhcnNlSW50KG1vbnRoWWVhclswXSwgMTApKTtcclxuXHRcdFx0XHR9KS5lbmQoKS5cclxuXHRcdFx0XHRmaW5kKCdzZWxlY3QuJyArIHRoaXMuX2FueVllYXJDbGFzcykuY2xpY2soZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHQkKHRoaXMpLmNzcygndmlzaWJpbGl0eScsICdoaWRkZW4nKS5cclxuXHRcdFx0XHRcdFx0bmV4dCgnaW5wdXQnKS5jc3Moe2xlZnQ6IHRoaXMub2Zmc2V0TGVmdCwgdG9wOiB0aGlzLm9mZnNldFRvcCxcclxuXHRcdFx0XHRcdFx0d2lkdGg6IHRoaXMub2Zmc2V0V2lkdGgsIGhlaWdodDogdGhpcy5vZmZzZXRIZWlnaHR9KS5zaG93KCkuZm9jdXMoKTtcclxuXHRcdFx0XHR9KS5lbmQoKS5cclxuXHRcdFx0XHRmaW5kKCdpbnB1dC4nICsgc2VsZi5fbW9udGhZZWFyQ2xhc3MpLmNoYW5nZShmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdHZhciB5ZWFyID0gcGFyc2VJbnQoJCh0aGlzKS52YWwoKSwgMTApO1xyXG5cdFx0XHRcdFx0XHR5ZWFyID0gKGlzTmFOKHllYXIpID8gaW5zdC5kcmF3RGF0ZS55ZWFyKCkgOiB5ZWFyKTtcclxuXHRcdFx0XHRcdFx0c2VsZi5zaG93TW9udGgoZWxlbSwgeWVhciwgaW5zdC5kcmF3RGF0ZS5tb250aCgpLCBpbnN0LmRyYXdEYXRlLmRheSgpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRcdGFsZXJ0KGUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pLmtleWRvd24oZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdFx0XHRcdGlmIChldmVudC5rZXlDb2RlID09PSAxMykgeyAvLyBFbnRlclxyXG5cdFx0XHRcdFx0XHQkKGV2ZW50LmVsZW0pLmNoYW5nZSgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMjcpIHsgLy8gRXNjYXBlXHJcblx0XHRcdFx0XHRcdCQoZXZlbnQuZWxlbSkuaGlkZSgpLnByZXYoJ3NlbGVjdCcpLmNzcygndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XHJcblx0XHRcdFx0XHRcdGluc3QuZWxlbS5mb2N1cygpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHQvLyBBZGQga2V5Ym9hcmQgaGFuZGxpbmdcclxuXHRcdFx0dmFyIGRhdGEgPSB7ZWxlbTogaW5zdC5lbGVtWzBdfTtcclxuXHRcdFx0cGlja2VyLmtleWRvd24oZGF0YSwgdGhpcy5fa2V5RG93bikua2V5cHJlc3MoZGF0YSwgdGhpcy5fa2V5UHJlc3MpLmtleXVwKGRhdGEsIHRoaXMuX2tleVVwKTtcclxuXHRcdFx0Ly8gQWRkIGNvbW1hbmQgYmVoYXZpb3VyXHJcblx0XHRcdHBpY2tlci5maW5kKCcuJyArIGluc3Qub3B0aW9ucy5yZW5kZXJlci5jb21tYW5kQ2xhc3MpLmNsaWNrKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0aWYgKCEkKHRoaXMpLmhhc0NsYXNzKGluc3Qub3B0aW9ucy5yZW5kZXJlci5kaXNhYmxlZENsYXNzKSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgYWN0aW9uID0gdGhpcy5jbGFzc05hbWUucmVwbGFjZShcclxuXHRcdFx0XHRcdFx0XHRuZXcgUmVnRXhwKCdeLionICsgaW5zdC5vcHRpb25zLnJlbmRlcmVyLmNvbW1hbmRDbGFzcyArICctKFteIF0rKS4qJCcpLCAnJDEnKTtcclxuXHRcdFx0XHRcdFx0cGx1Z2luLnBlcmZvcm1BY3Rpb24oZWxlbSwgYWN0aW9uKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0Ly8gQWRkIGNsYXNzZXNcclxuXHRcdFx0aWYgKGluc3Qub3B0aW9ucy5pc1JUTCkge1xyXG5cdFx0XHRcdHBpY2tlci5hZGRDbGFzcyhpbnN0Lm9wdGlvbnMucmVuZGVyZXIucnRsQ2xhc3MpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChtb250aHNUb1Nob3dbMF0gKiBtb250aHNUb1Nob3dbMV0gPiAxKSB7XHJcblx0XHRcdFx0cGlja2VyLmFkZENsYXNzKGluc3Qub3B0aW9ucy5yZW5kZXJlci5tdWx0aUNsYXNzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoaW5zdC5vcHRpb25zLnBpY2tlckNsYXNzKSB7XHJcblx0XHRcdFx0cGlja2VyLmFkZENsYXNzKGluc3Qub3B0aW9ucy5waWNrZXJDbGFzcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gUmVzaXplXHJcblx0XHRcdCQoJ2JvZHknKS5hcHBlbmQocGlja2VyKTtcclxuXHRcdFx0dmFyIHdpZHRoID0gMDtcclxuXHRcdFx0cGlja2VyLmZpbmQoaW5zdC5vcHRpb25zLnJlbmRlcmVyLm1vbnRoU2VsZWN0b3IpLmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0d2lkdGggKz0gJCh0aGlzKS5vdXRlcldpZHRoKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRwaWNrZXIud2lkdGgod2lkdGggLyBtb250aHNUb1Nob3dbMF0pO1xyXG5cdFx0XHQvLyBQcmUtc2hvdyBjdXN0b21pc2F0aW9uXHJcblx0XHRcdGlmICgkLmlzRnVuY3Rpb24oaW5zdC5vcHRpb25zLm9uU2hvdykpIHtcclxuXHRcdFx0XHRpbnN0Lm9wdGlvbnMub25TaG93LmFwcGx5KGVsZW0sIFtwaWNrZXIsIGluc3Qub3B0aW9ucy5jYWxlbmRhciwgaW5zdF0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBwaWNrZXI7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBHZW5lcmF0ZSB0aGUgY29udGVudCBmb3IgYSBzaW5nbGUgbW9udGguXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGFmZmVjdC5cclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtudW1iZXJ9IFRoZSB5ZWFyIHRvIGdlbmVyYXRlLlxyXG5cdFx0XHRAcGFyYW0gbW9udGgge251bWJlcn0gVGhlIG1vbnRoIHRvIGdlbmVyYXRlLlxyXG5cdFx0XHRAcGFyYW0gY2FsZW5kYXIge0Jhc2VDYWxlbmRhcn0gVGhlIGN1cnJlbnQgY2FsZW5kYXIuXHJcblx0XHRcdEBwYXJhbSByZW5kZXJlciB7b2JqZWN0fSBUaGUgcmVuZGVyaW5nIHRlbXBsYXRlcy5cclxuXHRcdFx0QHBhcmFtIGZpcnN0IHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBmaXJzdCBvZiBtdWx0aXBsZSBtb250aHMuXHJcblx0XHRcdEByZXR1cm4ge3N0cmluZ30gVGhlIG1vbnRoIGNvbnRlbnQuICovXHJcblx0XHRfZ2VuZXJhdGVNb250aDogZnVuY3Rpb24oZWxlbSwgaW5zdCwgeWVhciwgbW9udGgsIGNhbGVuZGFyLCByZW5kZXJlciwgZmlyc3QpIHtcclxuXHRcdFx0dmFyIGRheXNJbk1vbnRoID0gY2FsZW5kYXIuZGF5c0luTW9udGgoeWVhciwgbW9udGgpO1xyXG5cdFx0XHR2YXIgbW9udGhzVG9TaG93ID0gaW5zdC5vcHRpb25zLm1vbnRoc1RvU2hvdztcclxuXHRcdFx0bW9udGhzVG9TaG93ID0gKCQuaXNBcnJheShtb250aHNUb1Nob3cpID8gbW9udGhzVG9TaG93IDogWzEsIG1vbnRoc1RvU2hvd10pO1xyXG5cdFx0XHR2YXIgZml4ZWRXZWVrcyA9IGluc3Qub3B0aW9ucy5maXhlZFdlZWtzIHx8IChtb250aHNUb1Nob3dbMF0gKiBtb250aHNUb1Nob3dbMV0gPiAxKTtcclxuXHRcdFx0dmFyIGZpcnN0RGF5ID0gaW5zdC5vcHRpb25zLmZpcnN0RGF5O1xyXG5cdFx0XHRmaXJzdERheSA9IChmaXJzdERheSA9PSBudWxsID8gY2FsZW5kYXIubG9jYWwuZmlyc3REYXkgOiBmaXJzdERheSk7XHJcblx0XHRcdHZhciBsZWFkRGF5cyA9IChjYWxlbmRhci5kYXlPZldlZWsoeWVhciwgbW9udGgsIGNhbGVuZGFyLm1pbkRheSkgLVxyXG5cdFx0XHRcdGZpcnN0RGF5ICsgY2FsZW5kYXIuZGF5c0luV2VlaygpKSAlIGNhbGVuZGFyLmRheXNJbldlZWsoKTtcclxuXHRcdFx0dmFyIG51bVdlZWtzID0gKGZpeGVkV2Vla3MgPyA2IDogTWF0aC5jZWlsKChsZWFkRGF5cyArIGRheXNJbk1vbnRoKSAvIGNhbGVuZGFyLmRheXNJbldlZWsoKSkpO1xyXG5cdFx0XHR2YXIgc2VsZWN0T3RoZXJNb250aHMgPSBpbnN0Lm9wdGlvbnMuc2VsZWN0T3RoZXJNb250aHMgJiYgaW5zdC5vcHRpb25zLnNob3dPdGhlck1vbnRocztcclxuXHRcdFx0dmFyIG1pbkRhdGUgPSAoaW5zdC5waWNraW5nUmFuZ2UgPyBpbnN0LnNlbGVjdGVkRGF0ZXNbMF0gOiBpbnN0LmdldCgnbWluRGF0ZScpKTtcclxuXHRcdFx0dmFyIG1heERhdGUgPSBpbnN0LmdldCgnbWF4RGF0ZScpO1xyXG5cdFx0XHR2YXIgc2hvd1dlZWtzID0gcmVuZGVyZXIud2Vlay5pbmRleE9mKCd7d2Vla09mWWVhcn0nKSA+IC0xO1xyXG5cdFx0XHR2YXIgdG9kYXkgPSBjYWxlbmRhci50b2RheSgpO1xyXG5cdFx0XHR2YXIgZHJhd0RhdGUgPSBjYWxlbmRhci5uZXdEYXRlKHllYXIsIG1vbnRoLCBjYWxlbmRhci5taW5EYXkpO1xyXG5cdFx0XHRkcmF3RGF0ZS5hZGQoLWxlYWREYXlzIC0gKGZpeGVkV2Vla3MgJiZcclxuXHRcdFx0XHQoZHJhd0RhdGUuZGF5T2ZXZWVrKCkgPT09IGZpcnN0RGF5IHx8IGRyYXdEYXRlLmRheXNJbk1vbnRoKCkgPCBjYWxlbmRhci5kYXlzSW5XZWVrKCkpP1xyXG5cdFx0XHRcdGNhbGVuZGFyLmRheXNJbldlZWsoKSA6IDApLCAnZCcpO1xyXG5cdFx0XHR2YXIgamQgPSBkcmF3RGF0ZS50b0pEKCk7XHJcblx0XHRcdC8vIEdlbmVyYXRlIHdlZWtzXHJcblx0XHRcdHZhciB3ZWVrcyA9ICcnO1xyXG5cdFx0XHRmb3IgKHZhciB3ZWVrID0gMDsgd2VlayA8IG51bVdlZWtzOyB3ZWVrKyspIHtcclxuXHRcdFx0XHR2YXIgd2Vla09mWWVhciA9ICghc2hvd1dlZWtzID8gJycgOiAnPHNwYW4gY2xhc3M9XCJqZCcgKyBqZCArICdcIj4nICtcclxuXHRcdFx0XHRcdCgkLmlzRnVuY3Rpb24oaW5zdC5vcHRpb25zLmNhbGN1bGF0ZVdlZWspID9cclxuXHRcdFx0XHRcdGluc3Qub3B0aW9ucy5jYWxjdWxhdGVXZWVrKGRyYXdEYXRlKSA6IGRyYXdEYXRlLndlZWtPZlllYXIoKSkgKyAnPC9zcGFuPicpO1xyXG5cdFx0XHRcdHZhciBkYXlzID0gJyc7XHJcblx0XHRcdFx0Zm9yICh2YXIgZGF5ID0gMDsgZGF5IDwgY2FsZW5kYXIuZGF5c0luV2VlaygpOyBkYXkrKykge1xyXG5cdFx0XHRcdFx0dmFyIHNlbGVjdGVkID0gZmFsc2U7XHJcblx0XHRcdFx0XHRpZiAoaW5zdC5vcHRpb25zLnJhbmdlU2VsZWN0ICYmIGluc3Quc2VsZWN0ZWREYXRlcy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0XHRcdHNlbGVjdGVkID0gKGRyYXdEYXRlLmNvbXBhcmVUbyhpbnN0LnNlbGVjdGVkRGF0ZXNbMF0pICE9PSAtMSAmJlxyXG5cdFx0XHRcdFx0XHRcdGRyYXdEYXRlLmNvbXBhcmVUbyhpbnN0LnNlbGVjdGVkRGF0ZXNbMV0pICE9PSArMSlcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGluc3Quc2VsZWN0ZWREYXRlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChpbnN0LnNlbGVjdGVkRGF0ZXNbaV0uY29tcGFyZVRvKGRyYXdEYXRlKSA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0c2VsZWN0ZWQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR2YXIgZGF0ZUluZm8gPSAoISQuaXNGdW5jdGlvbihpbnN0Lm9wdGlvbnMub25EYXRlKSA/IHt9IDpcclxuXHRcdFx0XHRcdFx0aW5zdC5vcHRpb25zLm9uRGF0ZS5hcHBseShlbGVtLCBbZHJhd0RhdGUsIGRyYXdEYXRlLm1vbnRoKCkgPT09IG1vbnRoXSkpO1xyXG5cdFx0XHRcdFx0dmFyIHNlbGVjdGFibGUgPSAoc2VsZWN0T3RoZXJNb250aHMgfHwgZHJhd0RhdGUubW9udGgoKSA9PT0gbW9udGgpICYmXHJcblx0XHRcdFx0XHRcdHRoaXMuX2lzU2VsZWN0YWJsZShlbGVtLCBkcmF3RGF0ZSwgZGF0ZUluZm8uc2VsZWN0YWJsZSwgbWluRGF0ZSwgbWF4RGF0ZSk7XHJcblx0XHRcdFx0XHRkYXlzICs9IHRoaXMuX3ByZXBhcmUocmVuZGVyZXIuZGF5LCBpbnN0KS5yZXBsYWNlKC9cXHtkYXlcXH0vZyxcclxuXHRcdFx0XHRcdFx0KHNlbGVjdGFibGUgPyAnPGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKVwiJyA6ICc8c3BhbicpICtcclxuXHRcdFx0XHRcdFx0JyBjbGFzcz1cImpkJyArIGpkICsgJyAnICsgKGRhdGVJbmZvLmRhdGVDbGFzcyB8fCAnJykgK1xyXG5cdFx0XHRcdFx0XHQoc2VsZWN0ZWQgJiYgKHNlbGVjdE90aGVyTW9udGhzIHx8IGRyYXdEYXRlLm1vbnRoKCkgPT09IG1vbnRoKSA/XHJcblx0XHRcdFx0XHRcdCcgJyArIHJlbmRlcmVyLnNlbGVjdGVkQ2xhc3MgOiAnJykgK1xyXG5cdFx0XHRcdFx0XHQoc2VsZWN0YWJsZSA/ICcgJyArIHJlbmRlcmVyLmRlZmF1bHRDbGFzcyA6ICcnKSArXHJcblx0XHRcdFx0XHRcdChkcmF3RGF0ZS53ZWVrRGF5KCkgPyAnJyA6ICcgJyArIHJlbmRlcmVyLndlZWtlbmRDbGFzcykgK1xyXG5cdFx0XHRcdFx0XHQoZHJhd0RhdGUubW9udGgoKSA9PT0gbW9udGggPyAnJyA6ICcgJyArIHJlbmRlcmVyLm90aGVyTW9udGhDbGFzcykgK1xyXG5cdFx0XHRcdFx0XHQoZHJhd0RhdGUuY29tcGFyZVRvKHRvZGF5KSA9PT0gMCAmJiBkcmF3RGF0ZS5tb250aCgpID09PSBtb250aCA/XHJcblx0XHRcdFx0XHRcdCcgJyArIHJlbmRlcmVyLnRvZGF5Q2xhc3MgOiAnJykgK1xyXG5cdFx0XHRcdFx0XHQoZHJhd0RhdGUuY29tcGFyZVRvKGluc3QuZHJhd0RhdGUpID09PSAwICYmIGRyYXdEYXRlLm1vbnRoKCkgPT09IG1vbnRoID9cclxuXHRcdFx0XHRcdFx0JyAnICsgcmVuZGVyZXIuaGlnaGxpZ2h0ZWRDbGFzcyA6ICcnKSArICdcIicgK1xyXG5cdFx0XHRcdFx0XHQoZGF0ZUluZm8udGl0bGUgfHwgKGluc3Qub3B0aW9ucy5kYXlTdGF0dXMgJiYgc2VsZWN0YWJsZSkgPyAnIHRpdGxlPVwiJyArXHJcblx0XHRcdFx0XHRcdChkYXRlSW5mby50aXRsZSB8fCBkcmF3RGF0ZS5mb3JtYXREYXRlKGluc3Qub3B0aW9ucy5kYXlTdGF0dXMpKSArICdcIicgOiAnJykgKyAnPicgK1xyXG5cdFx0XHRcdFx0XHQoaW5zdC5vcHRpb25zLnNob3dPdGhlck1vbnRocyB8fCBkcmF3RGF0ZS5tb250aCgpID09PSBtb250aCA/XHJcblx0XHRcdFx0XHRcdGRhdGVJbmZvLmNvbnRlbnQgfHwgZHJhd0RhdGUuZGF5KCkgOiAnJiMxNjA7JykgK1xyXG5cdFx0XHRcdFx0XHQoc2VsZWN0YWJsZSA/ICc8L2E+JyA6ICc8L3NwYW4+JykpO1xyXG5cdFx0XHRcdFx0ZHJhd0RhdGUuYWRkKDEsICdkJyk7XHJcblx0XHRcdFx0XHRqZCsrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR3ZWVrcyArPSB0aGlzLl9wcmVwYXJlKHJlbmRlcmVyLndlZWssIGluc3QpLnJlcGxhY2UoL1xce2RheXNcXH0vZywgZGF5cykuXHJcblx0XHRcdFx0XHRyZXBsYWNlKC9cXHt3ZWVrT2ZZZWFyXFx9L2csIHdlZWtPZlllYXIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBtb250aEhlYWRlciA9IHRoaXMuX3ByZXBhcmUocmVuZGVyZXIubW9udGgsIGluc3QpLm1hdGNoKC9cXHttb250aEhlYWRlcig6W15cXH1dKyk/XFx9Lyk7XHJcblx0XHRcdG1vbnRoSGVhZGVyID0gKG1vbnRoSGVhZGVyWzBdLmxlbmd0aCA8PSAxMyA/ICdNTSB5eXl5JyA6XHJcblx0XHRcdFx0bW9udGhIZWFkZXJbMF0uc3Vic3RyaW5nKDEzLCBtb250aEhlYWRlclswXS5sZW5ndGggLSAxKSk7XHJcblx0XHRcdG1vbnRoSGVhZGVyID0gKGZpcnN0ID8gdGhpcy5fZ2VuZXJhdGVNb250aFNlbGVjdGlvbihcclxuXHRcdFx0XHRpbnN0LCB5ZWFyLCBtb250aCwgbWluRGF0ZSwgbWF4RGF0ZSwgbW9udGhIZWFkZXIsIGNhbGVuZGFyLCByZW5kZXJlcikgOlxyXG5cdFx0XHRcdGNhbGVuZGFyLmZvcm1hdERhdGUobW9udGhIZWFkZXIsIGNhbGVuZGFyLm5ld0RhdGUoeWVhciwgbW9udGgsIGNhbGVuZGFyLm1pbkRheSkpKTtcclxuXHRcdFx0dmFyIHdlZWtIZWFkZXIgPSB0aGlzLl9wcmVwYXJlKHJlbmRlcmVyLndlZWtIZWFkZXIsIGluc3QpLlxyXG5cdFx0XHRcdHJlcGxhY2UoL1xce2RheXNcXH0vZywgdGhpcy5fZ2VuZXJhdGVEYXlIZWFkZXJzKGluc3QsIGNhbGVuZGFyLCByZW5kZXJlcikpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fcHJlcGFyZShyZW5kZXJlci5tb250aCwgaW5zdCkucmVwbGFjZSgvXFx7bW9udGhIZWFkZXIoOlteXFx9XSspP1xcfS9nLCBtb250aEhlYWRlcikuXHJcblx0XHRcdFx0cmVwbGFjZSgvXFx7d2Vla0hlYWRlclxcfS9nLCB3ZWVrSGVhZGVyKS5yZXBsYWNlKC9cXHt3ZWVrc1xcfS9nLCB3ZWVrcyk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBHZW5lcmF0ZSB0aGUgSFRNTCBmb3IgdGhlIGRheSBoZWFkZXJzLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxyXG5cdFx0XHRAcGFyYW0gY2FsZW5kYXIge0Jhc2VDYWxlbmRhcn0gVGhlIGN1cnJlbnQgY2FsZW5kYXIuXHJcblx0XHRcdEBwYXJhbSByZW5kZXJlciB7b2JqZWN0fSBUaGUgcmVuZGVyaW5nIHRlbXBsYXRlcy5cclxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBBIHdlZWsncyB3b3J0aCBvZiBkYXkgaGVhZGVycy4gKi9cclxuXHRcdF9nZW5lcmF0ZURheUhlYWRlcnM6IGZ1bmN0aW9uKGluc3QsIGNhbGVuZGFyLCByZW5kZXJlcikge1xyXG5cdFx0XHR2YXIgZmlyc3REYXkgPSBpbnN0Lm9wdGlvbnMuZmlyc3REYXk7XHJcblx0XHRcdGZpcnN0RGF5ID0gKGZpcnN0RGF5ID09IG51bGwgPyBjYWxlbmRhci5sb2NhbC5maXJzdERheSA6IGZpcnN0RGF5KTtcclxuXHRcdFx0dmFyIGhlYWRlciA9ICcnO1xyXG5cdFx0XHRmb3IgKHZhciBkYXkgPSAwOyBkYXkgPCBjYWxlbmRhci5kYXlzSW5XZWVrKCk7IGRheSsrKSB7XHJcblx0XHRcdFx0dmFyIGRvdyA9IChkYXkgKyBmaXJzdERheSkgJSBjYWxlbmRhci5kYXlzSW5XZWVrKCk7XHJcblx0XHRcdFx0aGVhZGVyICs9IHRoaXMuX3ByZXBhcmUocmVuZGVyZXIuZGF5SGVhZGVyLCBpbnN0KS5yZXBsYWNlKC9cXHtkYXlcXH0vZyxcclxuXHRcdFx0XHRcdCc8c3BhbiBjbGFzcz1cIicgKyB0aGlzLl9jdXJEb1dDbGFzcyArIGRvdyArICdcIiB0aXRsZT1cIicgK1xyXG5cdFx0XHRcdFx0Y2FsZW5kYXIubG9jYWwuZGF5TmFtZXNbZG93XSArICdcIj4nICsgY2FsZW5kYXIubG9jYWwuZGF5TmFtZXNNaW5bZG93XSArICc8L3NwYW4+Jyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGhlYWRlcjtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEdlbmVyYXRlIHNlbGVjdGlvbiBjb250cm9scyBmb3IgbW9udGguXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtudW1iZXJ9IFRoZSB5ZWFyIHRvIGdlbmVyYXRlLlxyXG5cdFx0XHRAcGFyYW0gbW9udGgge251bWJlcn0gVGhlIG1vbnRoIHRvIGdlbmVyYXRlLlxyXG5cdFx0XHRAcGFyYW0gbWluRGF0ZSB7Q0RhdGV9IFRoZSBtaW5pbXVtIGRhdGUgYWxsb3dlZC5cclxuXHRcdFx0QHBhcmFtIG1heERhdGUge0NEYXRlfSBUaGUgbWF4aW11bSBkYXRlIGFsbG93ZWQuXHJcblx0XHRcdEBwYXJhbSBtb250aEhlYWRlciB7c3RyaW5nfSBUaGUgbW9udGgveWVhciBmb3JtYXQuXHJcblx0XHRcdEBwYXJhbSBjYWxlbmRhciB7QmFzZUNhbGVuZGFyfSBUaGUgY3VycmVudCBjYWxlbmRhci5cclxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGUgbW9udGggc2VsZWN0aW9uIGNvbnRlbnQuICovXHJcblx0XHRfZ2VuZXJhdGVNb250aFNlbGVjdGlvbjogZnVuY3Rpb24oaW5zdCwgeWVhciwgbW9udGgsIG1pbkRhdGUsIG1heERhdGUsIG1vbnRoSGVhZGVyLCBjYWxlbmRhcikge1xyXG5cdFx0XHRpZiAoIWluc3Qub3B0aW9ucy5jaGFuZ2VNb250aCkge1xyXG5cdFx0XHRcdHJldHVybiBjYWxlbmRhci5mb3JtYXREYXRlKG1vbnRoSGVhZGVyLCBjYWxlbmRhci5uZXdEYXRlKHllYXIsIG1vbnRoLCAxKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gTW9udGhzXHJcblx0XHRcdHZhciBtb250aE5hbWVzID0gY2FsZW5kYXIubG9jYWxbXHJcblx0XHRcdFx0J21vbnRoTmFtZXMnICsgKG1vbnRoSGVhZGVyLm1hdGNoKC9tbS9pKSA/ICcnIDogJ1Nob3J0JyldO1xyXG5cdFx0XHR2YXIgaHRtbCA9IG1vbnRoSGVhZGVyLnJlcGxhY2UoL20rL2ksICdcXFxceDJFJykucmVwbGFjZSgveSsvaSwgJ1xcXFx4MkYnKTtcclxuXHRcdFx0dmFyIHNlbGVjdG9yID0gJzxzZWxlY3QgY2xhc3M9XCInICsgdGhpcy5fbW9udGhZZWFyQ2xhc3MgK1xyXG5cdFx0XHRcdCdcIiB0aXRsZT1cIicgKyBpbnN0Lm9wdGlvbnMubW9udGhTdGF0dXMgKyAnXCI+JztcclxuXHRcdFx0dmFyIG1heE1vbnRoID0gY2FsZW5kYXIubW9udGhzSW5ZZWFyKHllYXIpICsgY2FsZW5kYXIubWluTW9udGg7XHJcblx0XHRcdGZvciAodmFyIG0gPSBjYWxlbmRhci5taW5Nb250aDsgbSA8IG1heE1vbnRoOyBtKyspIHtcclxuXHRcdFx0XHRpZiAoKCFtaW5EYXRlIHx8IGNhbGVuZGFyLm5ld0RhdGUoeWVhciwgbSxcclxuXHRcdFx0XHRcdFx0Y2FsZW5kYXIuZGF5c0luTW9udGgoeWVhciwgbSkgLSAxICsgY2FsZW5kYXIubWluRGF5KS5cclxuXHRcdFx0XHRcdFx0Y29tcGFyZVRvKG1pbkRhdGUpICE9PSAtMSkgJiZcclxuXHRcdFx0XHRcdFx0KCFtYXhEYXRlIHx8IGNhbGVuZGFyLm5ld0RhdGUoeWVhciwgbSwgY2FsZW5kYXIubWluRGF5KS5cclxuXHRcdFx0XHRcdFx0Y29tcGFyZVRvKG1heERhdGUpICE9PSArMSkpIHtcclxuXHRcdFx0XHRcdHNlbGVjdG9yICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArIG0gKyAnLycgKyB5ZWFyICsgJ1wiJyArXHJcblx0XHRcdFx0XHRcdChtb250aCA9PT0gbSA/ICcgc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiJyA6ICcnKSArICc+JyArXHJcblx0XHRcdFx0XHRcdG1vbnRoTmFtZXNbbSAtIGNhbGVuZGFyLm1pbk1vbnRoXSArICc8L29wdGlvbj4nO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRzZWxlY3RvciArPSAnPC9zZWxlY3Q+JztcclxuXHRcdFx0aHRtbCA9IGh0bWwucmVwbGFjZSgvXFxcXHgyRS8sIHNlbGVjdG9yKTtcclxuXHRcdFx0Ly8gWWVhcnNcclxuXHRcdFx0dmFyIHllYXJSYW5nZSA9IGluc3Qub3B0aW9ucy55ZWFyUmFuZ2U7XHJcblx0XHRcdGlmICh5ZWFyUmFuZ2UgPT09ICdhbnknKSB7XHJcblx0XHRcdFx0c2VsZWN0b3IgPSAnPHNlbGVjdCBjbGFzcz1cIicgKyB0aGlzLl9tb250aFllYXJDbGFzcyArICcgJyArIHRoaXMuX2FueVllYXJDbGFzcyArXHJcblx0XHRcdFx0XHQnXCIgdGl0bGU9XCInICsgaW5zdC5vcHRpb25zLnllYXJTdGF0dXMgKyAnXCI+JyArXHJcblx0XHRcdFx0XHQnPG9wdGlvbj4nICsgeWVhciArICc8L29wdGlvbj48L3NlbGVjdD4nICtcclxuXHRcdFx0XHRcdCc8aW5wdXQgY2xhc3M9XCInICsgdGhpcy5fbW9udGhZZWFyQ2xhc3MgKyAnICcgKyB0aGlzLl9jdXJNb250aENsYXNzICtcclxuXHRcdFx0XHRcdG1vbnRoICsgJ1wiIHZhbHVlPVwiJyArIHllYXIgKyAnXCI+JztcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHR5ZWFyUmFuZ2UgPSB5ZWFyUmFuZ2Uuc3BsaXQoJzonKTtcclxuXHRcdFx0XHR2YXIgdG9kYXlZZWFyID0gY2FsZW5kYXIudG9kYXkoKS55ZWFyKCk7XHJcblx0XHRcdFx0dmFyIHN0YXJ0ID0gKHllYXJSYW5nZVswXS5tYXRjaCgnY1srLV0uKicpID8geWVhciArIHBhcnNlSW50KHllYXJSYW5nZVswXS5zdWJzdHJpbmcoMSksIDEwKSA6XHJcblx0XHRcdFx0XHQoKHllYXJSYW5nZVswXS5tYXRjaCgnWystXS4qJykgPyB0b2RheVllYXIgOiAwKSArIHBhcnNlSW50KHllYXJSYW5nZVswXSwgMTApKSk7XHJcblx0XHRcdFx0dmFyIGVuZCA9ICh5ZWFyUmFuZ2VbMV0ubWF0Y2goJ2NbKy1dLionKSA/IHllYXIgKyBwYXJzZUludCh5ZWFyUmFuZ2VbMV0uc3Vic3RyaW5nKDEpLCAxMCkgOlxyXG5cdFx0XHRcdFx0KCh5ZWFyUmFuZ2VbMV0ubWF0Y2goJ1srLV0uKicpID8gdG9kYXlZZWFyIDogMCkgKyBwYXJzZUludCh5ZWFyUmFuZ2VbMV0sIDEwKSkpO1xyXG5cdFx0XHRcdHNlbGVjdG9yID0gJzxzZWxlY3QgY2xhc3M9XCInICsgdGhpcy5fbW9udGhZZWFyQ2xhc3MgK1xyXG5cdFx0XHRcdFx0J1wiIHRpdGxlPVwiJyArIGluc3Qub3B0aW9ucy55ZWFyU3RhdHVzICsgJ1wiPic7XHJcblx0XHRcdFx0c3RhcnQgPSBjYWxlbmRhci5uZXdEYXRlKHN0YXJ0ICsgMSwgY2FsZW5kYXIuZmlyc3RNb250aCwgY2FsZW5kYXIubWluRGF5KS5hZGQoLTEsICdkJyk7XHJcblx0XHRcdFx0ZW5kID0gY2FsZW5kYXIubmV3RGF0ZShlbmQsIGNhbGVuZGFyLmZpcnN0TW9udGgsIGNhbGVuZGFyLm1pbkRheSk7XHJcblx0XHRcdFx0dmFyIGFkZFllYXIgPSBmdW5jdGlvbih5LCB5RGlzcGxheSkge1xyXG5cdFx0XHRcdFx0aWYgKHkgIT09IDAgfHwgY2FsZW5kYXIuaGFzWWVhclplcm8pIHtcclxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgKz0gJzxvcHRpb24gdmFsdWU9XCInICtcclxuXHRcdFx0XHRcdFx0XHRNYXRoLm1pbihtb250aCwgY2FsZW5kYXIubW9udGhzSW5ZZWFyKHkpIC0gMSArIGNhbGVuZGFyLm1pbk1vbnRoKSArXHJcblx0XHRcdFx0XHRcdFx0Jy8nICsgeSArICdcIicgKyAoeWVhciA9PT0geSA/ICcgc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiJyA6ICcnKSArICc+JyArXHJcblx0XHRcdFx0XHRcdFx0KHlEaXNwbGF5IHx8IHkpICsgJzwvb3B0aW9uPic7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHRpZiAoc3RhcnQudG9KRCgpIDwgZW5kLnRvSkQoKSkge1xyXG5cdFx0XHRcdFx0c3RhcnQgPSAobWluRGF0ZSAmJiBtaW5EYXRlLmNvbXBhcmVUbyhzdGFydCkgPT09ICsxID8gbWluRGF0ZSA6IHN0YXJ0KS55ZWFyKCk7XHJcblx0XHRcdFx0XHRlbmQgPSAobWF4RGF0ZSAmJiBtYXhEYXRlLmNvbXBhcmVUbyhlbmQpID09PSAtMSA/IG1heERhdGUgOiBlbmQpLnllYXIoKTtcclxuXHRcdFx0XHRcdHZhciBlYXJsaWVyTGF0ZXIgPSBNYXRoLmZsb29yKChlbmQgLSBzdGFydCkgLyAyKTtcclxuXHRcdFx0XHRcdGlmICghbWluRGF0ZSB8fCBtaW5EYXRlLnllYXIoKSA8IHN0YXJ0KSB7XHJcblx0XHRcdFx0XHRcdGFkZFllYXIoc3RhcnQgLSBlYXJsaWVyTGF0ZXIsIGluc3Qub3B0aW9ucy5lYXJsaWVyVGV4dCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRmb3IgKHZhciB5ID0gc3RhcnQ7IHkgPD0gZW5kOyB5KyspIHtcclxuXHRcdFx0XHRcdFx0YWRkWWVhcih5KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICghbWF4RGF0ZSB8fCBtYXhEYXRlLnllYXIoKSA+IGVuZCkge1xyXG5cdFx0XHRcdFx0XHRhZGRZZWFyKGVuZCArIGVhcmxpZXJMYXRlciwgaW5zdC5vcHRpb25zLmxhdGVyVGV4dCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0c3RhcnQgPSAobWF4RGF0ZSAmJiBtYXhEYXRlLmNvbXBhcmVUbyhzdGFydCkgPT09IC0xID8gbWF4RGF0ZSA6IHN0YXJ0KS55ZWFyKCk7XHJcblx0XHRcdFx0XHRlbmQgPSAobWluRGF0ZSAmJiBtaW5EYXRlLmNvbXBhcmVUbyhlbmQpID09PSArMSA/IG1pbkRhdGUgOiBlbmQpLnllYXIoKTtcclxuXHRcdFx0XHRcdHZhciBlYXJsaWVyTGF0ZXIgPSBNYXRoLmZsb29yKChzdGFydCAtIGVuZCkgLyAyKTtcclxuXHRcdFx0XHRcdGlmICghbWF4RGF0ZSB8fCBtYXhEYXRlLnllYXIoKSA+IHN0YXJ0KSB7XHJcblx0XHRcdFx0XHRcdGFkZFllYXIoc3RhcnQgKyBlYXJsaWVyTGF0ZXIsIGluc3Qub3B0aW9ucy5lYXJsaWVyVGV4dCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRmb3IgKHZhciB5ID0gc3RhcnQ7IHkgPj0gZW5kOyB5LS0pIHtcclxuXHRcdFx0XHRcdFx0YWRkWWVhcih5KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICghbWluRGF0ZSB8fCBtaW5EYXRlLnllYXIoKSA8IGVuZCkge1xyXG5cdFx0XHRcdFx0XHRhZGRZZWFyKGVuZCAtIGVhcmxpZXJMYXRlciwgaW5zdC5vcHRpb25zLmxhdGVyVGV4dCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHNlbGVjdG9yICs9ICc8L3NlbGVjdD4nO1xyXG5cdFx0XHR9XHJcblx0XHRcdGh0bWwgPSBodG1sLnJlcGxhY2UoL1xcXFx4MkYvLCBzZWxlY3Rvcik7XHJcblx0XHRcdHJldHVybiBodG1sO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUHJlcGFyZSBhIHJlbmRlciB0ZW1wbGF0ZSBmb3IgdXNlLlxyXG5cdFx0XHRFeGNsdWRlIHBvcHVwL2lubGluZSBzZWN0aW9ucyB0aGF0IGFyZSBub3QgYXBwbGljYWJsZS5cclxuXHRcdFx0TG9jYWxpc2UgdGV4dCBvZiB0aGUgZm9ybToge2wxMG46bmFtZX0uXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIHRleHQge3N0cmluZ30gVGhlIHRleHQgdG8gbG9jYWxpc2UuXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxyXG5cdFx0XHRAcmV0dXJuIHtzdHJpbmd9IFRoZSBsb2NhbGlzZWQgdGV4dC4gKi9cclxuXHRcdF9wcmVwYXJlOiBmdW5jdGlvbih0ZXh0LCBpbnN0KSB7XHJcblx0XHRcdHZhciByZXBsYWNlU2VjdGlvbiA9IGZ1bmN0aW9uKHR5cGUsIHJldGFpbikge1xyXG5cdFx0XHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdFx0XHR2YXIgc3RhcnQgPSB0ZXh0LmluZGV4T2YoJ3snICsgdHlwZSArICc6c3RhcnR9Jyk7XHJcblx0XHRcdFx0XHRpZiAoc3RhcnQgPT09IC0xKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHZhciBlbmQgPSB0ZXh0LnN1YnN0cmluZyhzdGFydCkuaW5kZXhPZigneycgKyB0eXBlICsgJzplbmR9Jyk7XHJcblx0XHRcdFx0XHRpZiAoZW5kID4gLTEpIHtcclxuXHRcdFx0XHRcdFx0dGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0KSArXHJcblx0XHRcdFx0XHRcdFx0KHJldGFpbiA/IHRleHQuc3Vic3RyKHN0YXJ0ICsgdHlwZS5sZW5ndGggKyA4LCBlbmQgLSB0eXBlLmxlbmd0aCAtIDgpIDogJycpICtcclxuXHRcdFx0XHRcdFx0XHR0ZXh0LnN1YnN0cmluZyhzdGFydCArIGVuZCArIHR5cGUubGVuZ3RoICsgNik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0XHRyZXBsYWNlU2VjdGlvbignaW5saW5lJywgaW5zdC5pbmxpbmUpO1xyXG5cdFx0XHRyZXBsYWNlU2VjdGlvbigncG9wdXAnLCAhaW5zdC5pbmxpbmUpO1xyXG5cdFx0XHR2YXIgcGF0dGVybiA9IC9cXHtsMTBuOihbXlxcfV0rKVxcfS87XHJcblx0XHRcdHZhciBtYXRjaGVzID0gbnVsbDtcclxuXHRcdFx0d2hpbGUgKG1hdGNoZXMgPSBwYXR0ZXJuLmV4ZWModGV4dCkpIHtcclxuXHRcdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKG1hdGNoZXNbMF0sIGluc3Qub3B0aW9uc1ttYXRjaGVzWzFdXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRleHQ7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdHZhciBwbHVnaW4gPSAkLmNhbGVuZGFyc1BpY2tlcjsgLy8gU2luZ2xldG9uIGluc3RhbmNlXHJcblxyXG5cdCQoZnVuY3Rpb24oKSB7XHJcblx0XHQkKGRvY3VtZW50KS5vbignbW91c2Vkb3duLicgKyBwbHVnaW5OYW1lLCBwbHVnaW4uX2NoZWNrRXh0ZXJuYWxDbGljaykuXHJcblx0XHRcdG9uKCdyZXNpemUuJyArIHBsdWdpbk5hbWUsIGZ1bmN0aW9uKCkgeyBwbHVnaW4uaGlkZShwbHVnaW4uY3VySW5zdCk7IH0pO1xyXG5cdH0pO1xyXG5cclxufSkoalF1ZXJ5KTtcclxuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
