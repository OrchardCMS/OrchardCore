/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/* http://keith-wood.name/calendars.html
   Calendars date picker for jQuery v2.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

	var pluginName = 'calendarsPicker';


	/** Create the calendars datepicker plugin.
		<p>Sets an input field to popup a calendar for date entry,
			or a <code>div</code> or <code>span</code> to show an inline calendar.</p>
		<p>Expects HTML like:</p>
		<pre>&lt;input type="text"> or &lt;div>&lt;/div></pre>
		<p>Provide inline configuration like:</p>
		<pre>&lt;input type="text" data-calendarsPicker="name: 'value'"/></pre>
	 	@class CalendarsPicker
		@augments JQPlugin
		@example $(selector).calendarsPicker()
 $(selector).calendarsPicker({minDate: 0, maxDate: '+1m +1w'}) */
	$.JQPlugin.createPlugin({
	
		/** The name of the plugin.
			@memberof CalendarsPicker */
		name: pluginName,
		
		/** Default template for generating a datepicker.
			Insert anywhere:
			<ul>
			<li>'{l10n:name}' to insert localised value for name,</li>
			<li>'{link:name}' to insert a link trigger for command name,</li>
			<li>'{button:name}' to insert a button trigger for command name,</li>
			<li>'{popup:start}...{popup:end}' to mark a section for inclusion in a popup datepicker only,</li>
			<li>'{inline:start}...{inline:end}' to mark a section for inclusion in an inline datepicker only.</li>
			</ul>
			@memberof CalendarsPicker
			@property picker {string} Overall structure: '{months}' to insert calendar months.
			@property monthRow {string} One row of months: '{months}' to insert calendar months.
			@property month {string} A single month: '{monthHeader<em>:dateFormat</em>}' to insert the month header -
						<em>dateFormat</em> is optional and defaults to 'MM yyyy',
						'{weekHeader}' to insert a week header, '{weeks}' to insert the month's weeks.
			@property weekHeader {string} A week header: '{days}' to insert individual day names.
			@property dayHeader {string} Individual day header: '{day}' to insert day name.
			@property week {string} One week of the month: '{days}' to insert the week's days,
						'{weekOfYear}' to insert week of year.
			@property day {string} An individual day: '{day}' to insert day value.
			@property monthSelector {string} jQuery selector, relative to picker, for a single month.
			@property daySelector {string} jQuery selector, relative to picker, for individual days.
			@property rtlClass {string} Class for right-to-left (RTL) languages.
			@property multiClass {string} Class for multi-month datepickers.
			@property defaultClass {string} Class for selectable dates.
			@property selectedClass {string} Class for currently selected dates.
			@property highlightedClass {string} Class for highlighted dates.
			@property todayClass {string} Class for today.
			@property otherMonthClass {string} Class for days from other months.
			@property weekendClass {string} Class for days on weekends.
			@property commandClass {string} Class prefix for commands.
			@property commandButtonClass {string} Extra class(es) for commands that are buttons.
			@property commandLinkClass {string} Extra class(es) for commands that are links.
			@property disabledClass {string} Class for disabled commands. */
		defaultRenderer: {
			picker: '<div class="calendars">' +
			'<div class="calendars-nav">{link:prev}{link:today}{link:next}</div>{months}' +
			'{popup:start}<div class="calendars-ctrl">{link:clear}{link:close}</div>{popup:end}' +
			'<div class="calendars-clear-fix"></div></div>',
			monthRow: '<div class="calendars-month-row">{months}</div>',
			month: '<div class="calendars-month"><div class="calendars-month-header">{monthHeader}</div>' +
			'<table><thead>{weekHeader}</thead><tbody>{weeks}</tbody></table></div>',
			weekHeader: '<tr>{days}</tr>',
			dayHeader: '<th>{day}</th>',
			week: '<tr>{days}</tr>',
			day: '<td>{day}</td>',
			monthSelector: '.calendars-month',
			daySelector: 'td',
			rtlClass: 'calendars-rtl',
			multiClass: 'calendars-multi',
			defaultClass: '',
			selectedClass: 'calendars-selected',
			highlightedClass: 'calendars-highlight',
			todayClass: 'calendars-today',
			otherMonthClass: 'calendars-other-month',
			weekendClass: 'calendars-weekend',
			commandClass: 'calendars-cmd',
			commandButtonClass: '',
			commandLinkClass: '',
			disabledClass: 'calendars-disabled'
		},
	
		/** Command actions that may be added to a layout by name.
			<ul>
			<li>prev - Show the previous month (based on <code>monthsToStep</code> option) - <em>PageUp</em></li>
			<li>prevJump - Show the previous year (based on <code>monthsToJump</code> option) - <em>Ctrl+PageUp</em></li>
			<li>next - Show the next month (based on <code>monthsToStep</code> option) - <em>PageDown</em></li>
			<li>nextJump - Show the next year (based on <code>monthsToJump</code> option) - <em>Ctrl+PageDown</em></li>
			<li>current - Show the currently selected month or today's if none selected - <em>Ctrl+Home</em></li>
			<li>today - Show today's month - <em>Ctrl+Home</em></li>
			<li>clear - Erase the date and close the datepicker popup - <em>Ctrl+End</em></li>
			<li>close - Close the datepicker popup - <em>Esc</em></li>
			<li>prevWeek - Move the cursor to the previous week - <em>Ctrl+Up</em></li>
			<li>prevDay - Move the cursor to the previous day - <em>Ctrl+Left</em></li>
			<li>nextDay - Move the cursor to the next day - <em>Ctrl+Right</em></li>
			<li>nextWeek - Move the cursor to the next week - <em>Ctrl+Down</em></li>
			</ul>
			The command name is the key name and is used to add the command to a layout
			with '{button:name}' or '{link:name}'. Each has the following attributes.
			@memberof CalendarsPicker
			@property text {string} The field in the regional settings for the displayed text.
			@property status {string} The field in the regional settings for the status text.
			@property keystroke {object} The keystroke to trigger the action, with attributes:
				<code>keyCode</code> {number} the code for the keystroke,
				<code>ctrlKey</code> {boolean} <code>true</code> if <em>Ctrl</em> is required,
				<code>altKey</code> {boolean} <code>true</code> if <em>Alt</em> is required,
				<code>shiftKey</code> {boolean} <code>true</code> if <em>Shift</em> is required.
			@property enabled {CalendarsPickerCommandEnabled} The function that indicates the command is enabled.
			@property date {CalendarsPickerCommandDate} The function to get the date associated with this action.
			@property action {CalendarsPickerCommandAction} The function that implements the action. */
		commands: {
			prev: {text: 'prevText', status: 'prevStatus', // Previous month
				keystroke: {keyCode: 33}, // Page up
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					return (!minDate || inst.drawDate.newDate().
						add(1 - inst.options.monthsToStep - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay).add(-1, 'd').compareTo(minDate) !== -1); },
				date: function(inst) {
					return inst.drawDate.newDate().
						add(-inst.options.monthsToStep - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay); },
				action: function(inst) {
					plugin.changeMonth(this, -inst.options.monthsToStep); }
			},
			prevJump: {text: 'prevJumpText', status: 'prevJumpStatus', // Previous year
				keystroke: {keyCode: 33, ctrlKey: true}, // Ctrl + Page up
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					return (!minDate || inst.drawDate.newDate().
						add(1 - inst.options.monthsToJump - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay).add(-1, 'd').compareTo(minDate) !== -1); },
				date: function(inst) {
					return inst.drawDate.newDate().
						add(-inst.options.monthsToJump - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay); },
				action: function(inst) {
					plugin.changeMonth(this, -inst.options.monthsToJump); }
			},
			next: {text: 'nextText', status: 'nextStatus', // Next month
				keystroke: {keyCode: 34}, // Page down
				enabled: function(inst) {
					var maxDate = inst.get('maxDate');
					return (!maxDate || inst.drawDate.newDate().
						add(inst.options.monthsToStep - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay).compareTo(maxDate) !== +1); },
				date: function(inst) {
					return inst.drawDate.newDate().
						add(inst.options.monthsToStep - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay); },
				action: function(inst) {
					plugin.changeMonth(this, inst.options.monthsToStep); }
			},
			nextJump: {text: 'nextJumpText', status: 'nextJumpStatus', // Next year
				keystroke: {keyCode: 34, ctrlKey: true}, // Ctrl + Page down
				enabled: function(inst) {
					var maxDate = inst.get('maxDate');
					return (!maxDate || inst.drawDate.newDate().
						add(inst.options.monthsToJump - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay).compareTo(maxDate) !== +1);	},
				date: function(inst) {
					return inst.drawDate.newDate().
						add(inst.options.monthsToJump - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay); },
				action: function(inst) {
					plugin.changeMonth(this, inst.options.monthsToJump); }
			},
			current: {text: 'currentText', status: 'currentStatus', // Current month
				keystroke: {keyCode: 36, ctrlKey: true}, // Ctrl + Home
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					var maxDate = inst.get('maxDate');
					var curDate = inst.selectedDates[0] || inst.options.calendar.today();
					return (!minDate || curDate.compareTo(minDate) !== -1) &&
						(!maxDate || curDate.compareTo(maxDate) !== +1); },
				date: function(inst) {
					return inst.selectedDates[0] || inst.options.calendar.today(); },
				action: function(inst) {
					var curDate = inst.selectedDates[0] || inst.options.calendar.today();
					plugin.showMonth(this, curDate.year(), curDate.month()); }
			},
			today: {text: 'todayText', status: 'todayStatus', // Today's month
				keystroke: {keyCode: 36, ctrlKey: true}, // Ctrl + Home
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					var maxDate = inst.get('maxDate');
					return (!minDate || inst.options.calendar.today().compareTo(minDate) !== -1) &&
						(!maxDate || inst.options.calendar.today().compareTo(maxDate) !== +1); },
				date: function(inst) { return inst.options.calendar.today(); },
				action: function(inst) { plugin.showMonth(this); }
			},
			clear: {text: 'clearText', status: 'clearStatus', // Clear the datepicker
				keystroke: {keyCode: 35, ctrlKey: true}, // Ctrl + End
				enabled: function(inst) { return true; },
				date: function(inst) { return null; },
				action: function(inst) { plugin.clear(this); }
			},
			close: {text: 'closeText', status: 'closeStatus', // Close the datepicker
				keystroke: {keyCode: 27}, // Escape
				enabled: function(inst) { return true; },
				date: function(inst) { return null; },
				action: function(inst) { plugin.hide(this); }
			},
			prevWeek: {text: 'prevWeekText', status: 'prevWeekStatus', // Previous week
				keystroke: {keyCode: 38, ctrlKey: true}, // Ctrl + Up
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					return (!minDate || inst.drawDate.newDate().
						add(-inst.options.calendar.daysInWeek(), 'd').compareTo(minDate) !== -1); },
				date: function(inst) { return inst.drawDate.newDate().
					add(-inst.options.calendar.daysInWeek(), 'd'); },
				action: function(inst) { plugin.changeDay(this, -inst.options.calendar.daysInWeek()); }
			},
			prevDay: {text: 'prevDayText', status: 'prevDayStatus', // Previous day
				keystroke: {keyCode: 37, ctrlKey: true}, // Ctrl + Left
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					return (!minDate || inst.drawDate.newDate().add(-1, 'd').
						compareTo(minDate) !== -1); },
				date: function(inst) { return inst.drawDate.newDate().add(-1, 'd'); },
				action: function(inst) { plugin.changeDay(this, -1); }
			},
			nextDay: {text: 'nextDayText', status: 'nextDayStatus', // Next day
				keystroke: {keyCode: 39, ctrlKey: true}, // Ctrl + Right
				enabled: function(inst) {
					var maxDate = inst.get('maxDate');
					return (!maxDate || inst.drawDate.newDate().add(1, 'd').
						compareTo(maxDate) !== +1); },
				date: function(inst) { return inst.drawDate.newDate().add(1, 'd'); },
				action: function(inst) { plugin.changeDay(this, 1); }
			},
			nextWeek: {text: 'nextWeekText', status: 'nextWeekStatus', // Next week
				keystroke: {keyCode: 40, ctrlKey: true}, // Ctrl + Down
				enabled: function(inst) {
					var maxDate = inst.get('maxDate');
					return (!maxDate || inst.drawDate.newDate().
						add(inst.options.calendar.daysInWeek(), 'd').compareTo(maxDate) !== +1); },
				date: function(inst) { return inst.drawDate.newDate().
					add(inst.options.calendar.daysInWeek(), 'd'); },
				action: function(inst) { plugin.changeDay(this, inst.options.calendar.daysInWeek()); }
			}
		},

		/** Determine whether a command is enabled.
			@callback CalendarsPickerCommandEnabled
			@param inst {object} The current instance settings.
			@return {boolean} <code>true</code> if this command is enabled, <code>false</code> if not.
			@example enabled: function(inst) {
	return !!inst.curMinDate();
 } */

		/** Calculate the representative date for a command.
			@callback CalendarsPickerCommandDate
			@param inst {object} The current instance settings.
			@return {CDate} A date appropriate for this command.
			@example date: function(inst) {
	return inst.curMinDate();
 } */

		/** Perform the action for a command.
			@callback CalendarsPickerCommandAction
			@param inst {object} The current instance settings.
			@example date: function(inst) {
	$.datepick.setDate(inst.elem, inst.curMinDate());
 } */

		/** Calculate the week of the year for a date.
			@callback CalendarsPickerCalculateWeek
			@param date {CDate} The date to evaluate.
			@return {number} The week of the year.
			@example calculateWeek: function(date) {
	var startYear = $.calendars.newDate(date.year(), 1, 1);
	return Math.floor((date.dayOfYear() - startYear.dayOfYear()) / 7) + 1;
 } */

		/** Provide information about an individual date shown in the calendar.
			@callback CalendarsPickerOnDate
			@param date {CDate} The date to evaluate.
			@return {object} Information about that date, with the properties above.
			@property selectable {boolean} <code>true</code> if this date can be selected.
			@property dateClass {string} Class(es) to be applied to the date.
			@property content {string} The date cell content.
			@property tooltip {string} A popup tooltip for the date.
			@example onDate: function(date) {
	return {selectable: date.day() > 0 && date.day() &lt; 5,
		dateClass: date.day() === 4 ? 'last-day' : ''};
 } */

		/** Update the datepicker display.
			@callback CalendarsPickerOnShow
			@param picker {jQuery} The datepicker <code>div</code> to be shown.
			@param inst {object} The current instance settings.
			@example onShow: function(picker, inst) {
	picker.append('&lt;button type="button">Hi&lt;/button>').
		find('button:last').click(function() {
			alert('Hi!');
		});
 } */

		/** React to navigating through the months/years.
			@callback CalendarsPickerOnChangeMonthYear
			@param year {number} The new year.
			@param month {number} The new month (1 to 12).
			@example onChangeMonthYear: function(year, month) {
	alert('Now in ' + month + '/' + year);
 } */
			
		/** Datepicker on select callback.
			Triggered when a date is selected.
			@callback CalendarsPickerOnSelect
			@param dates {CDate[]} The selected date(s).
			@example onSelect: function(dates) {
 	alert('Selected ' + dates);
 } */
			
		/** Datepicker on close callback.
			Triggered when a popup calendar is closed.
			@callback CalendarsPickerOnClose
			@param dates {CDate[]} The selected date(s).
			@example onClose: function(dates) {
 	alert('Selected ' + dates);
 } */
		
		/** Default settings for the plugin.
			@memberof CalendarsPicker
			@property [calendar=$.calendars.instance()] {Calendar} The calendar for this datepicker.
			@property [pickerClass=''] {string} CSS class to add to this instance of the datepicker.
			@property [showOnFocus=true] {boolean} <code>true</code> for popup on focus, <code>false</code> for not.
			@property [showTrigger=null] {string|Element|jQuery} Element to be cloned for a trigger, <code>null</code> for none.
			@property [showAnim='show'] {string} Name of jQuery animation for popup, '' for no animation.
			@property [showOptions=null] {object} Options for enhanced animations.
			@property [showSpeed='normal'] {string} Duration of display/closure.
			@property [popupContainer=null] {string|Element|jQuery} The element to which a popup calendar is added, <code>null</code> for body.
			@property [alignment='bottom'] {string} Alignment of popup - with nominated corner of input:
						'top' or 'bottom' aligns depending on language direction,
						'topLeft', 'topRight', 'bottomLeft', 'bottomRight'.
			@property [fixedWeeks=false] {boolean} <code>true</code> to always show 6 weeks, <code>false</code> to only show as many as are needed.
			@property [firstDay=null] {number} First day of the week, 0 = Sunday, 1 = Monday, etc., <code>null</code> for <code>calendar</code> default.
			@property [calculateWeek=null] {CalendarsPickerCalculateWeek} Calculate week of the year from a date, <code>null</code> for <code>calendar</code> default.
			@property [monthsToShow=1] {number|number[]} How many months to show, cols or [rows, cols].
			@property [monthsOffset=0] {number} How many months to offset the primary month by;
						may be a function that takes the date and returns the offset.
			@property [monthsToStep=1] {number} How many months to move when prev/next clicked.
			@property [monthsToJump=12] {number} How many months to move when large prev/next clicked.
			@property [useMouseWheel=true] {boolean} <code>true</code> to use mousewheel if available, <code>false</code> to never use it.
			@property [changeMonth=true] {boolean} <code>true</code> to change month/year via drop-down, <code>false</code> for navigation only.
			@property [yearRange='c-10:c+10'] {string} Range of years to show in drop-down: 'any' for direct text entry
						or 'start:end', where start/end are '+-nn' for relative to today
						or 'c+-nn' for relative to the currently selected date
						or 'nnnn' for an absolute year.
			@property [showOtherMonths=false] {boolean} <code>true</code> to show dates from other months, <code>false</code> to not show them.
			@property [selectOtherMonths=false] {boolean} <code>true</code> to allow selection of dates from other months too.
			@property [defaultDate=null] {string|number|CDate} Date to show if no other selected.
			@property [selectDefaultDate=false] {boolean} <code>true</code> to pre-select the default date if no other is chosen.
			@property [minDate=null] {string|number|CDate} The minimum selectable date.
			@property [maxDate=null] {string|number|CDate} The maximum selectable date.
			@property [dateFormat='mm/dd/yyyy'] {string} Format for dates.
			@property [autoSize=false] {boolean} <code>true</code> to size the input field according to the date format.
			@property [rangeSelect=false] {boolean} Allows for selecting a date range on one date picker.
			@property [rangeSeparator=' - '] {string} Text between two dates in a range.
			@property [multiSelect=0] {number} Maximum number of selectable dates, zero for single select.
			@property [multiSeparator=','] {string} Text between multiple dates.
			@property [onDate=null] {CalendarsPickerOnDate} Callback as a date is added to the datepicker.
			@property [onShow=null] {CalendarsPickerOnShow} Callback just before a datepicker is shown.
			@property [onChangeMonthYear=null] {CalendarsPickerOnChangeMonthYear} Callback when a new month/year is selected.
			@property [onSelect=null] {CalendarsPickerOnSelect} Callback when a date is selected.
			@property [onClose=null] {CalendarsPickerOnClose} Callback when a datepicker is closed.
			@property [altField=null] {string|Element|jQuery} Alternate field to update in synch with the datepicker.
			@property [altFormat=null] {string} Date format for alternate field, defaults to <code>dateFormat</code>.
			@property [constrainInput=true] {boolean} <code>true</code> to constrain typed input to <code>dateFormat</code> allowed characters.
			@property [commandsAsDateFormat=false] {boolean} <code>true</code> to apply
						<code><a href="#formatDate">formatDate</a></code> to the command texts.
			@property [commands=this.commands] {object} Command actions that may be added to a layout by name. */
		defaultOptions: {
			calendar: $.calendars.instance(),
			pickerClass: '',
			showOnFocus: true,
			showTrigger: null,
			showAnim: 'show',
			showOptions: {},
			showSpeed: 'normal',
			popupContainer: null,
			alignment: 'bottom',
			fixedWeeks: false,
			firstDay: null,
			calculateWeek: null,
			monthsToShow: 1,
			monthsOffset: 0,
			monthsToStep: 1,
			monthsToJump: 12,
			useMouseWheel: true,
			changeMonth: true,
			yearRange: 'c-10:c+10',
			showOtherMonths: false,
			selectOtherMonths: false,
			defaultDate: null,
			selectDefaultDate: false,
			minDate: null,
			maxDate: null,
			dateFormat: null,
			autoSize: false,
			rangeSelect: false,
			rangeSeparator: ' - ',
			multiSelect: 0,
			multiSeparator: ',',
			onDate: null,
			onShow: null,
			onChangeMonthYear: null,
			onSelect: null,
			onClose: null,
			altField: null,
			altFormat: null,
			constrainInput: true,
			commandsAsDateFormat: false,
			commands: {} // this.commands
		},

		/** Localisations for the plugin.
			Entries are objects indexed by the language code ('' being the default US/English).
			Each object has the following attributes.
			@memberof CalendarsPicker
			@property [renderer=this.defaultRenderer] {string} The rendering templates.
			@property [prevText='&lt;Prev'] {string} Text for the previous month command.
			@property [prevStatus='Show the previous month'] {string} Status text for the previous month command.
			@property [prevJumpText='&lt;&lt;'] {string} Text for the previous year command.
			@property [prevJumpStatus='Show the previous year'] {string} Status text for the previous year command.
			@property [nextText='Next&gt;'] {string} Text for the next month command.
			@property [nextStatus='Show the next month'] {string} Status text for the next month command.
			@property [nextJumpText='&gt;&gt;'] {string} Text for the next year command.
			@property [nextJumpStatus='Show the next year'] {string} Status text for the next year command.
			@property [currentText='Current'] {string} Text for the current month command.
			@property [currentStatus='Show the current month'] {string} Status text for the current month command.
			@property [todayText='Today'] {string} Text for the today's month command.
			@property [todayStatus='Show today\'s month'] {string} Status text for the today's month command.
			@property [clearText='Clear'] {string} Text for the clear command.
			@property [clearStatus='Clear all the dates'] {string} Status text for the clear command.
			@property [closeText='Close'] {string} Text for the close command.
			@property [closeStatus='Close the datepicker'] {string} Status text for the close command.
			@property [yearStatus='Change the year'] {string} Status text for year selection.
			@property [earlierText='&#160;&#160;▲'] {string} Text for earlier years.
			@property [laterText='&#160;&#160;▼'] {string} Text for later years.
			@property [monthStatus='Change the month'] {string} Status text for month selection.
			@property [weekText='Wk'] {string} Text for week of the year column header.
			@property [weekStatus='Week of the year'] {string} Status text for week of the year column header.
			@property [dayStatus='Select DD,&#160;M&#160;d,&#160;yyyy'] {string} Status text for selectable days.
			@property [defaultStatus='Select a date'] {string} Status text shown by default.
			@property [isRTL=false] {boolean} <code>true</code> if language is right-to-left. */
		regionalOptions: { // Available regional settings, indexed by language/country code
			'': { // Default regional settings - English/US
				renderer: {}, // this.defaultRenderer
				prevText: '&lt;Prev',
				prevStatus: 'Show the previous month',
				prevJumpText: '&lt;&lt;',
				prevJumpStatus: 'Show the previous year',
				nextText: 'Next&gt;',
				nextStatus: 'Show the next month',
				nextJumpText: '&gt;&gt;',
				nextJumpStatus: 'Show the next year',
				currentText: 'Current',
				currentStatus: 'Show the current month',
				todayText: 'Today',
				todayStatus: 'Show today\'s month',
				clearText: 'Clear',
				clearStatus: 'Clear all the dates',
				closeText: 'Close',
				closeStatus: 'Close the datepicker',
				yearStatus: 'Change the year',
				earlierText: '&#160;&#160;▲',
				laterText: '&#160;&#160;▼',
				monthStatus: 'Change the month',
				weekText: 'Wk',
				weekStatus: 'Week of the year',
				dayStatus: 'Select DD, M d, yyyy',
				defaultStatus: 'Select a date',
				isRTL: false
			}
		},
		
		/** Names of getter methods - those that can't be chained.
			@memberof CalendarsPicker */
		_getters: ['getDate', 'isDisabled', 'isSelectable', 'retrieveDate'],

		_disabled: [],
		
		_popupClass: 'calendars-popup', // Marker for popup division
		_triggerClass: 'calendars-trigger', // Marker for trigger element
		_disableClass: 'calendars-disable', // Marker for disabled element
		_monthYearClass: 'calendars-month-year', // Marker for month/year inputs
		_curMonthClass: 'calendars-month-', // Marker for current month/year
		_anyYearClass: 'calendars-any-year', // Marker for year direct input
		_curDoWClass: 'calendars-dow-', // Marker for day of week

		_init: function() {
			this.defaultOptions.commands = this.commands;
			this.regionalOptions[''].renderer = this.defaultRenderer;
			this._super();
		},

		_instSettings: function(elem, options) {
			return {selectedDates: [], drawDate: null, pickingRange: false,
				inline: ($.inArray(elem[0].nodeName.toLowerCase(), ['div', 'span']) > -1),
				get: function(name) { // Get a setting value, computing if necessary
					if ($.inArray(name, ['defaultDate', 'minDate', 'maxDate']) > -1) { // Decode date settings
						return this.options.calendar.determineDate(this.options[name], null,
							this.selectedDates[0], this.get('dateFormat'), this.getConfig());
					}
					if (name === 'dateFormat') {
						return this.options.dateFormat || this.options.calendar.local.dateFormat;
					}
					return this.options[name];
				},
				curMinDate: function() {
					return (this.pickingRange ? this.selectedDates[0] : this.get('minDate'));
				},
				getConfig: function() {
					return {dayNamesShort: this.options.dayNamesShort, dayNames: this.options.dayNames,
						monthNamesShort: this.options.monthNamesShort, monthNames: this.options.monthNames,
						calculateWeek: this.options.calculateWeek, shortYearCutoff: this.options.shortYearCutoff};
				}
			};
		},

		_postAttach: function(elem, inst) {
			if (inst.inline) {
				inst.drawDate = plugin._checkMinMax((inst.selectedDates[0] ||
					inst.get('defaultDate') || inst.options.calendar.today()).newDate(), inst);
				inst.prevDate = inst.drawDate.newDate();
				this._update(elem[0]);
				if ($.fn.mousewheel) {
					elem.mousewheel(this._doMouseWheel);
				}
			}
			else {
				this._attachments(elem, inst);
				elem.on('keydown.' + inst.name, this._keyDown).on('keypress.' + inst.name, this._keyPress).
					on('keyup.' + inst.name, this._keyUp);
				if (elem.attr('disabled')) {
					this.disable(elem[0]);
				}
			}
		},

		_optionsChanged: function(elem, inst, options) {
			if (options.calendar && options.calendar !== inst.options.calendar) {
				var discardDate = function(name) {
					return (typeof inst.options[name] === 'object' ? null : inst.options[name]);
				};
				options = $.extend({defaultDate: discardDate('defaultDate'),
					minDate: discardDate('minDate'), maxDate: discardDate('maxDate')}, options);
				inst.selectedDates = [];
				inst.drawDate = null;
			}
			var dates = inst.selectedDates;
			$.extend(inst.options, options);
			this.setDate(elem[0], dates, null, false, true);
			inst.pickingRange = false;
			var calendar = inst.options.calendar;
			var defaultDate = inst.get('defaultDate');
			inst.drawDate = this._checkMinMax((defaultDate ? defaultDate : inst.drawDate) ||
				defaultDate || calendar.today(), inst).newDate();
			if (!inst.inline) {
				this._attachments(elem, inst);
			}
			if (inst.inline || inst.div) {
				this._update(elem[0]);
			}
		},

		/** Attach events and trigger, if necessary.
			@memberof CalendarsPicker
			@private
			@param elem {jQuery} The control to affect.
			@param inst {object} The current instance settings. */
		_attachments: function(elem, inst) {
			elem.off('focus.' + inst.name);
			if (inst.options.showOnFocus) {
				elem.on('focus.' + inst.name, this.show);
			}
			if (inst.trigger) {
				inst.trigger.remove();
			}
			var trigger = inst.options.showTrigger;
			inst.trigger = (!trigger ? $([]) :
				$(trigger).clone().removeAttr('id').addClass(this._triggerClass)
					[inst.options.isRTL ? 'insertBefore' : 'insertAfter'](elem).
					click(function() {
						if (!plugin.isDisabled(elem[0])) {
							plugin[plugin.curInst === inst ? 'hide' : 'show'](elem[0]);
						}
					}));
			this._autoSize(elem, inst);
			var dates = this._extractDates(inst, elem.val());
			if (dates) {
				this.setDate(elem[0], dates, null, true);
			}
			var defaultDate = inst.get('defaultDate');
			if (inst.options.selectDefaultDate && defaultDate && inst.selectedDates.length === 0) {
				this.setDate(elem[0], (defaultDate || inst.options.calendar.today()).newDate());
			}
		},

		/** Apply the maximum length for the date format.
			@memberof CalendarsPicker
			@private
			@param elem {jQuery} The control to affect.
			@param inst {object} The current instance settings. */
		_autoSize: function(elem, inst) {
			if (inst.options.autoSize && !inst.inline) {
				var calendar = inst.options.calendar;
				var date = calendar.newDate(2009, 10, 20); // Ensure double digits
				var dateFormat = inst.get('dateFormat');
				if (dateFormat.match(/[DM]/)) {
					var findMax = function(names) {
						var max = 0;
						var maxI = 0;
						for (var i = 0; i < names.length; i++) {
							if (names[i].length > max) {
								max = names[i].length;
								maxI = i;
							}
						}
						return maxI;
					};
					date.month(findMax(calendar.local[dateFormat.match(/MM/) ? // Longest month
						'monthNames' : 'monthNamesShort']) + 1);
					date.day(findMax(calendar.local[dateFormat.match(/DD/) ? // Longest day
						'dayNames' : 'dayNamesShort']) + 20 - date.dayOfWeek());
				}
				inst.elem.attr('size', date.formatDate(dateFormat).length);
			}
		},

		_preDestroy: function(elem, inst) {
			if (inst.trigger) {
				inst.trigger.remove();
			}
			elem.empty().off('.' + inst.name);
			if (inst.inline && $.fn.mousewheel) {
				elem.unmousewheel();
			}
			if (!inst.inline && inst.options.autoSize) {
				elem.removeAttr('size');
			}
		},

		/** Apply multiple event functions.
			@memberof CalendarsPicker
			@param fns {function} The functions to apply.
			@example onShow: multipleEvents(fn1, fn2, ...) */
		multipleEvents: function(fns) {
			var funcs = arguments;
			return function(args) {
				for (var i = 0; i < funcs.length; i++) {
					funcs[i].apply(this, arguments);
				}
			};
		},

		/** Enable the control.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@example $(selector).datepick('enable') */
		enable: function(elem) {
			elem = $(elem);
			if (!elem.hasClass(this._getMarker())) {
				return;
			}
			var inst = this._getInst(elem);
			if (inst.inline) {
				elem.children('.' + this._disableClass).remove().end().
					find('button,select').prop('disabled', false).end().
					find('a').attr('href', 'javascript:void(0)');
			}
			else {
				elem.prop('disabled', false);
				inst.trigger.filter('button.' + this._triggerClass).prop('disabled', false).end().
					filter('img.' + this._triggerClass).css({opacity: '1.0', cursor: ''});
			}
			this._disabled = $.map(this._disabled,
				function(value) { return (value === elem[0] ? null : value); }); // Delete entry
		},

		/** Disable the control.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@example $(selector).datepick('disable') */
		disable: function(elem) {
			elem = $(elem);
			if (!elem.hasClass(this._getMarker())) {
				return;
			}
			var inst = this._getInst(elem);
			if (inst.inline) {
				var inline = elem.children(':last');
				var offset = inline.offset();
				var relOffset = {left: 0, top: 0};
				inline.parents().each(function() {
					if ($(this).css('position') === 'relative') {
						relOffset = $(this).offset();
						return false;
					}
				});
				var zIndex = elem.css('zIndex');
				zIndex = (zIndex === 'auto' ? 0 : parseInt(zIndex, 10)) + 1;
				elem.prepend('<div class="' + this._disableClass + '" style="' +
					'width: ' + inline.outerWidth() + 'px; height: ' + inline.outerHeight() +
					'px; left: ' + (offset.left - relOffset.left) + 'px; top: ' +
					(offset.top - relOffset.top) + 'px; z-index: ' + zIndex + '"></div>').
					find('button,select').prop('disabled', true).end().
					find('a').removeAttr('href');
			}
			else {
				elem.prop('disabled', true);
				inst.trigger.filter('button.' + this._triggerClass).prop('disabled', true).end().
					filter('img.' + this._triggerClass).css({opacity: '0.5', cursor: 'default'});
			}
			this._disabled = $.map(this._disabled,
				function(value) { return (value === elem[0] ? null : value); }); // Delete entry
			this._disabled.push(elem[0]);
		},

		/** Is the first field in a jQuery collection disabled as a datepicker?
			@memberof CalendarsPicker
			@param elem {Element} The control to examine.
			@return {boolean} <code>true</code> if disabled, <code>false</code> if enabled.
			@example if ($(selector).datepick('isDisabled')) {...} */
		isDisabled: function(elem) {
			return (elem && $.inArray(elem, this._disabled) > -1);
		},

		/** Show a popup datepicker.
			@memberof CalendarsPicker
			@param elem {Event|Element} a focus event or the control to use.
			@example $(selector).datepick('show') */
		show: function(elem) {
			elem = $(elem.target || elem);
			var inst = plugin._getInst(elem);
			if (plugin.curInst === inst) {
				return;
			}
			if (plugin.curInst) {
				plugin.hide(plugin.curInst, true);
			}
			if (!$.isEmptyObject(inst)) {
				// Retrieve existing date(s)
				inst.lastVal = null;
				inst.selectedDates = plugin._extractDates(inst, elem.val());
				inst.pickingRange = false;
				inst.drawDate = plugin._checkMinMax((inst.selectedDates[0] ||
					inst.get('defaultDate') || inst.options.calendar.today()).newDate(), inst);
				inst.prevDate = inst.drawDate.newDate();
				plugin.curInst = inst;
				// Generate content
				plugin._update(elem[0], true);
				// Adjust position before showing
				var offset = plugin._checkOffset(inst);
				inst.div.css({left: offset.left, top: offset.top});
				// And display
				var showAnim = inst.options.showAnim;
				var showSpeed = inst.options.showSpeed;
				showSpeed = (showSpeed === 'normal' && $.ui &&
					parseInt($.ui.version.substring(2)) >= 8 ? '_default' : showSpeed);
				if ($.effects && ($.effects[showAnim] || ($.effects.effect && $.effects.effect[showAnim]))) {
					var data = inst.div.data(); // Update old effects data
					for (var key in data) {
						if (key.match(/^ec\.storage\./)) {
							data[key] = inst._mainDiv.css(key.replace(/ec\.storage\./, ''));
						}
					}
					inst.div.data(data).show(showAnim, inst.options.showOptions, showSpeed);
				}
				else {
					inst.div[showAnim || 'show'](showAnim ? showSpeed : 0);
				}
			}
		},

		/** Extract possible dates from a string.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@param text {string} The text to extract from.
			@return {CDate[]} The extracted dates. */
		_extractDates: function(inst, datesText) {
			if (datesText === inst.lastVal) {
				return;
			}
			inst.lastVal = datesText;
			datesText = datesText.split(inst.options.multiSelect ? inst.options.multiSeparator :
				(inst.options.rangeSelect ? inst.options.rangeSeparator : '\x00'));
			var dates = [];
			for (var i = 0; i < datesText.length; i++) {
				try {
					var date = inst.options.calendar.parseDate(inst.get('dateFormat'), datesText[i]);
					if (date) {
						var found = false;
						for (var j = 0; j < dates.length; j++) {
							if (dates[j].compareTo(date) === 0) {
								found = true;
								break;
							}
						}
						if (!found) {
							dates.push(date);
						}
					}
				}
				catch (e) {
					// Ignore
				}
			}
			dates.splice(inst.options.multiSelect || (inst.options.rangeSelect ? 2 : 1), dates.length);
			if (inst.options.rangeSelect && dates.length === 1) {
				dates[1] = dates[0];
			}
			return dates;
		},

		/** Update the datepicker display.
			@memberof CalendarsPicker
			@private
			@param elem {Event|Element} a focus event or the control to use.
			@param hidden {boolean} <code>true</code> to initially hide the datepicker. */
		_update: function(elem, hidden) {
			elem = $(elem.target || elem);
			var inst = plugin._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				if (inst.inline || plugin.curInst === inst) {
					if ($.isFunction(inst.options.onChangeMonthYear) && (!inst.prevDate ||
							inst.prevDate.year() !== inst.drawDate.year() ||
							inst.prevDate.month() !== inst.drawDate.month())) {
						inst.options.onChangeMonthYear.apply(elem[0],
							[inst.drawDate.year(), inst.drawDate.month()]);
					}
				}
				if (inst.inline) {
					var index = $('a, :input', elem).index($(':focus', elem));
					elem.html(this._generateContent(elem[0], inst));
					var focus = elem.find('a, :input');
					focus.eq(Math.max(Math.min(index, focus.length - 1), 0)).focus();
				}
				else if (plugin.curInst === inst) {
					if (!inst.div) {
						inst.div = $('<div></div>').addClass(this._popupClass).
							css({display: (hidden ? 'none' : 'static'), position: 'absolute',
								left: elem.offset().left, top: elem.offset().top + elem.outerHeight()}).
							appendTo($(inst.options.popupContainer || 'body'));
						if ($.fn.mousewheel) {
							inst.div.mousewheel(this._doMouseWheel);
						}
					}
					inst.div.html(this._generateContent(elem[0], inst));
					elem.focus();
				}
			}
		},

		/** Update the input field and any alternate field with the current dates.
			@memberof CalendarsPicker
			@private
			@param elem {Element} The control to use.
			@param keyUp {boolean} <code>true</code> if coming from <code>keyUp</code> processing (internal). */
		_updateInput: function(elem, keyUp) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				var value = '';
				var altValue = '';
				var sep = (inst.options.multiSelect ? inst.options.multiSeparator :
					inst.options.rangeSeparator);
				var calendar = inst.options.calendar;
				var dateFormat = inst.get('dateFormat');
				var altFormat = inst.options.altFormat || dateFormat;
				for (var i = 0; i < inst.selectedDates.length; i++) {
					value += (keyUp ? '' : (i > 0 ? sep : '') +
						calendar.formatDate(dateFormat, inst.selectedDates[i]));
					altValue += (i > 0 ? sep : '') +
						calendar.formatDate(altFormat, inst.selectedDates[i]);
				}
				if (!inst.inline && !keyUp) {
					$(elem).val(value);
				}
				$(inst.options.altField).val(altValue);
				if ($.isFunction(inst.options.onSelect) && !keyUp && !inst.inSelect) {
					inst.inSelect = true; // Prevent endless loops
					inst.options.onSelect.apply(elem, [inst.selectedDates]);
					inst.inSelect = false;
				}
			}
		},

		/** Retrieve the size of left and top borders for an element.
			@memberof CalendarsPicker
			@private
			@param elem {jQuery} The element of interest.
			@return {number[]} The left and top borders. */
		_getBorders: function(elem) {
			var convert = function(value) {
				return {thin: 1, medium: 3, thick: 5}[value] || value;
			};
			return [parseFloat(convert(elem.css('border-left-width'))),
				parseFloat(convert(elem.css('border-top-width')))];
		},

		/** Check positioning to remain on the screen.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@return {object} The updated offset for the datepicker. */
		_checkOffset: function(inst) {
			var base = (inst.elem.is(':hidden') && inst.trigger ? inst.trigger : inst.elem);
			var offset = base.offset();
			var browserWidth = $(window).width();
			var browserHeight = $(window).height();
			if (browserWidth === 0) {
				return offset;
			}
			var isFixed = false;
			$(inst.elem).parents().each(function() {
				isFixed |= $(this).css('position') === 'fixed';
				return !isFixed;
			});
			var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			var above = offset.top - (isFixed ? scrollY : 0) - inst.div.outerHeight();
			var below = offset.top - (isFixed ? scrollY : 0) + base.outerHeight();
			var alignL = offset.left - (isFixed ? scrollX : 0);
			var alignR = offset.left - (isFixed ? scrollX : 0) + base.outerWidth() - inst.div.outerWidth();
			var tooWide = (offset.left - scrollX + inst.div.outerWidth()) > browserWidth;
			var tooHigh = (offset.top - scrollY + inst.elem.outerHeight() +
				inst.div.outerHeight()) > browserHeight;
			inst.div.css('position', isFixed ? 'fixed' : 'absolute');
			var alignment = inst.options.alignment;
			if (alignment === 'topLeft') {
				offset = {left: alignL, top: above};
			}
			else if (alignment === 'topRight') {
				offset = {left: alignR, top: above};
			}
			else if (alignment === 'bottomLeft') {
				offset = {left: alignL, top: below};
			}
			else if (alignment === 'bottomRight') {
				offset = {left: alignR, top: below};
			}
			else if (alignment === 'top') {
				offset = {left: (inst.options.isRTL || tooWide ? alignR : alignL), top: above};
			}
			else { // bottom
				offset = {left: (inst.options.isRTL || tooWide ? alignR : alignL),
					top: (tooHigh ? above : below)};
			}
			offset.left = Math.max((isFixed ? 0 : scrollX), offset.left);
			offset.top = Math.max((isFixed ? 0 : scrollY), offset.top);
			return offset;
		},

		/** Close date picker if clicked elsewhere.
			@memberof CalendarsPicker
			@private
			@param event {MouseEvent} The mouse click to check. */
		_checkExternalClick: function(event) {
			if (!plugin.curInst) {
				return;
			}
			var elem = $(event.target);
			if (elem.closest('.' + plugin._popupClass + ',.' + plugin._triggerClass).length === 0 &&
					!elem.hasClass(plugin._getMarker())) {
				plugin.hide(plugin.curInst);
			}
		},

		/** Hide a popup datepicker.
			@memberof CalendarsPicker
			@param elem {Element|object} The control to use or the current instance settings.
			@param immediate {boolean} <code>true</code> to close immediately without animation (internal).
			@example $(selector).datepick('hide') */
		hide: function(elem, immediate) {
			if (!elem) {
				return;
			}
			var inst = this._getInst(elem);
			if ($.isEmptyObject(inst)) {
				inst = elem;
			}
			if (inst && inst === plugin.curInst) {
				var showAnim = (immediate ? '' : inst.options.showAnim);
				var showSpeed = inst.options.showSpeed;
				showSpeed = (showSpeed === 'normal' && $.ui &&
					parseInt($.ui.version.substring(2)) >= 8 ? '_default' : showSpeed);
				var postProcess = function() {
					if (!inst.div) {
						return;
					}
					inst.div.remove();
					inst.div = null;
					plugin.curInst = null;
					if ($.isFunction(inst.options.onClose)) {
						inst.options.onClose.apply(elem, [inst.selectedDates]);
					}
				};
				inst.div.stop();
				if ($.effects && ($.effects[showAnim] || ($.effects.effect && $.effects.effect[showAnim]))) {
					inst.div.hide(showAnim, inst.options.showOptions, showSpeed, postProcess);
				}
				else {
					var hideAnim = (showAnim === 'slideDown' ? 'slideUp' :
						(showAnim === 'fadeIn' ? 'fadeOut' : 'hide'));
					inst.div[hideAnim]((showAnim ? showSpeed : ''), postProcess);
				}
				if (!showAnim) {
					postProcess();
				}
			}
		},

		/** Handle keystrokes in the datepicker.
			@memberof CalendarsPicker
			@private
			@param event {KeyEvent} The keystroke.
			@return {boolean} <code>true</code> if not handled, <code>false</code> if handled. */
		_keyDown: function(event) {
			var elem = (event.data && event.data.elem) || event.target;
			var inst = plugin._getInst(elem);
			var handled = false;
			if (inst.inline || inst.div) {
				if (event.keyCode === 9) { // Tab - close
					plugin.hide(elem);
				}
				else if (event.keyCode === 13) { // Enter - select
					plugin.selectDate(elem,
						$('a.' + inst.options.renderer.highlightedClass, inst.div)[0]);
					handled = true;
				}
				else { // Command keystrokes
					var commands = inst.options.commands;
					for (var name in commands) {
						var command = commands[name];
						if (command.keystroke.keyCode === event.keyCode &&
								!!command.keystroke.ctrlKey === !!(event.ctrlKey || event.metaKey) &&
								!!command.keystroke.altKey === event.altKey &&
								!!command.keystroke.shiftKey === event.shiftKey) {
							plugin.performAction(elem, name);
							handled = true;
							break;
						}
					}
				}
			}
			else { // Show on 'current' keystroke
				var command = inst.options.commands.current;
				if (command.keystroke.keyCode === event.keyCode &&
						!!command.keystroke.ctrlKey === !!(event.ctrlKey || event.metaKey) &&
						!!command.keystroke.altKey === event.altKey &&
						!!command.keystroke.shiftKey === event.shiftKey) {
					plugin.show(elem);
					handled = true;
				}
			}
			inst.ctrlKey = ((event.keyCode < 48 && event.keyCode !== 32) || event.ctrlKey || event.metaKey);
			if (handled) {
				event.preventDefault();
				event.stopPropagation();
			}
			return !handled;
		},

		/** Filter keystrokes in the datepicker.
			@memberof CalendarsPicker
			@private
			@param event {KeyEvent} The keystroke.
			@return {boolean} <code>true</code> if allowed, <code>false</code> if not allowed. */
		_keyPress: function(event) {
			var inst = plugin._getInst((event.data && event.data.elem) || event.target);
			if (!$.isEmptyObject(inst) && inst.options.constrainInput) {
				var ch = String.fromCharCode(event.keyCode || event.charCode);
				var allowedChars = plugin._allowedChars(inst);
				return (event.metaKey || inst.ctrlKey || ch < ' ' ||
					!allowedChars || allowedChars.indexOf(ch) > -1);
			}
			return true;
		},

		/** Determine the set of characters allowed by the date format.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@return {string} The set of allowed characters, or <code>null</code> if anything allowed. */
		_allowedChars: function(inst) {
			var allowedChars = (inst.options.multiSelect ? inst.options.multiSeparator :
				(inst.options.rangeSelect ? inst.options.rangeSeparator : ''));
			var literal = false;
			var hasNum = false;
			var dateFormat = inst.get('dateFormat');
			for (var i = 0; i < dateFormat.length; i++) {
				var ch = dateFormat.charAt(i);
				if (literal) {
					if (ch === "'" && dateFormat.charAt(i + 1) !== "'") {
						literal = false;
					}
					else {
						allowedChars += ch;
					}
				}
				else {
					switch (ch) {
						case 'd': case 'm': case 'o': case 'w':
							allowedChars += (hasNum ? '' : '0123456789'); hasNum = true; break;
						case 'y': case '@': case '!':
							allowedChars += (hasNum ? '' : '0123456789') + '-'; hasNum = true; break;
						case 'J':
							allowedChars += (hasNum ? '' : '0123456789') + '-.'; hasNum = true; break;
						case 'D': case 'M': case 'Y':
							return null; // Accept anything
						case "'":
							if (dateFormat.charAt(i + 1) === "'") {
								allowedChars += "'";
							}
							else {
								literal = true;
							}
							break;
						default:
							allowedChars += ch;
					}
				}
			}
			return allowedChars;
		},

		/** Synchronise datepicker with the field.
			@memberof CalendarsPicker
			@private
			@param event {KeyEvent} The keystroke.
			@return {boolean} <code>true</code> if allowed, <code>false</code> if not allowed. */
		_keyUp: function(event) {
			var elem = (event.data && event.data.elem) || event.target;
			var inst = plugin._getInst(elem);
			if (!$.isEmptyObject(inst) && !inst.ctrlKey && inst.lastVal !== inst.elem.val()) {
				try {
					var dates = plugin._extractDates(inst, inst.elem.val());
					if (dates.length > 0) {
						plugin.setDate(elem, dates, null, true);
					}
				}
				catch (event) {
					// Ignore
				}
			}
			return true;
		},

		/** Increment/decrement month/year on mouse wheel activity.
			@memberof CalendarsPicker
			@private
			@param event {event} The mouse wheel event.
			@param delta {number} The amount of change. */
		_doMouseWheel: function(event, delta) {
			var elem = (plugin.curInst && plugin.curInst.elem[0]) ||
				$(event.target).closest('.' + plugin._getMarker())[0];
			if (plugin.isDisabled(elem)) {
				return;
			}
			var inst = plugin._getInst(elem);
			if (inst.options.useMouseWheel) {
				delta = (delta < 0 ? -1 : +1);
				plugin.changeMonth(elem, -inst.options[event.ctrlKey ? 'monthsToJump' : 'monthsToStep'] * delta);
			}
			event.preventDefault();
		},

		/** Clear an input and close a popup datepicker.
			@memberof CalendarsPicker
			@param elem {Element} The control to use.
			@example $(selector).datepick('clear') */
		clear: function(elem) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				inst.selectedDates = [];
				this.hide(elem);
				var defaultDate = inst.get('defaultDate');
				if (inst.options.selectDefaultDate && defaultDate) {
					this.setDate(elem, (defaultDate || inst.options.calendar.today()).newDate());
				}
				else {
					this._updateInput(elem);
				}
			}
		},

		/** Retrieve the selected date(s) for a datepicker.
			@memberof CalendarsPicker
			@param elem {Element} The control to examine.
			@return {CDate[]} The selected date(s).
			@example var dates = $(selector).datepick('getDate') */
		getDate: function(elem) {
			var inst = this._getInst(elem);
			return (!$.isEmptyObject(inst) ? inst.selectedDates : []);
		},

		/** Set the selected date(s) for a datepicker.
			@memberof CalendarsPicker
			@param elem {Element} the control to examine.
			@param dates {CDate|number|string|array} the selected date(s).
			@param [endDate] {CDate|number|string} the ending date for a range.
			@param [keyUp] {boolean} <code>true</code> if coming from <code>keyUp</code> processing (internal).
			@param [setOpt] {boolean} <code>true</code> if coming from option processing (internal).
			@example $(selector).datepick('setDate', new Date(2014, 12-1, 25))
 $(selector).datepick('setDate', '12/25/2014', '01/01/2015')
 $(selector).datepick('setDate', [date1, date2, date3]) */
		setDate: function(elem, dates, endDate, keyUp, setOpt) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				if (!$.isArray(dates)) {
					dates = [dates];
					if (endDate) {
						dates.push(endDate);
					}
				}
				var minDate = inst.get('minDate');
				var maxDate = inst.get('maxDate');
				var curDate = inst.selectedDates[0];
				inst.selectedDates = [];
				for (var i = 0; i < dates.length; i++) {
					var date = inst.options.calendar.determineDate(
						dates[i], null, curDate, inst.get('dateFormat'), inst.getConfig());
					if (date) {
						if ((!minDate || date.compareTo(minDate) !== -1) &&
								(!maxDate || date.compareTo(maxDate) !== +1)) {
							var found = false;
							for (var j = 0; j < inst.selectedDates.length; j++) {
								if (inst.selectedDates[j].compareTo(date) === 0) {
									found = true;
									break;
								}
							}
							if (!found) {
								inst.selectedDates.push(date);
							}
						}
					}
				}
				inst.selectedDates.splice(inst.options.multiSelect ||
					(inst.options.rangeSelect ? 2 : 1), inst.selectedDates.length);
				if (inst.options.rangeSelect) {
					switch (inst.selectedDates.length) {
						case 1: inst.selectedDates[1] = inst.selectedDates[0]; break;
						case 2: inst.selectedDates[1] =
							(inst.selectedDates[0].compareTo(inst.selectedDates[1]) === +1 ?
							inst.selectedDates[0] : inst.selectedDates[1]); break;
					}
					inst.pickingRange = false;
				}
				inst.prevDate = (inst.drawDate ? inst.drawDate.newDate() : null);
				inst.drawDate = this._checkMinMax((inst.selectedDates[0] ||
					inst.get('defaultDate') || inst.options.calendar.today()).newDate(), inst);
				if (!setOpt) {
					this._update(elem);
					this._updateInput(elem, keyUp);
				}
			}
		},

		/** Determine whether a date is selectable for this datepicker.
			@memberof CalendarsPicker
			@private
			@param elem {Element} The control to check.
			@param date {CDate|string|number} The date to check.
			@return {boolean} <code>true</code> if selectable, <code>false</code> if not.
			@example var selectable = $(selector).datepick('isSelectable', date) */
		isSelectable: function(elem, date) {
			var inst = this._getInst(elem);
			if ($.isEmptyObject(inst)) {
				return false;
			}
			date = inst.options.calendar.determineDate(date,
				inst.selectedDates[0] || inst.options.calendar.today(), null,
				inst.options.dateFormat, inst.getConfig());
			return this._isSelectable(elem, date, inst.options.onDate,
				inst.get('minDate'), inst.get('maxDate'));
		},

		/** Internally determine whether a date is selectable for this datepicker.
			@memberof CalendarsPicker
			@private
			@param elem {Element} the control to check.
			@param date {CDate} The date to check.
			@param onDate {function|boolean} Any <code>onDate</code> callback or <code>callback.selectable</code>.
			@param minDate {CDate} The minimum allowed date.
			@param maxDate {CDate} The maximum allowed date.
			@return {boolean} <code>true</code> if selectable, <code>false</code> if not. */
		_isSelectable: function(elem, date, onDate, minDate, maxDate) {
			var dateInfo = (typeof onDate === 'boolean' ? {selectable: onDate} :
				(!$.isFunction(onDate) ? {} : onDate.apply(elem, [date, true])));
			return (dateInfo.selectable !== false) &&
				(!minDate || date.toJD() >= minDate.toJD()) && (!maxDate || date.toJD() <= maxDate.toJD());
		},

		/** Perform a named action for a datepicker.
			@memberof CalendarsPicker
			@param elem {element} The control to affect.
			@param action {string} The name of the action. */
		performAction: function(elem, action) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst) && !this.isDisabled(elem)) {
				var commands = inst.options.commands;
				if (commands[action] && commands[action].enabled.apply(elem, [inst])) {
					commands[action].action.apply(elem, [inst]);
				}
			}
		},

		/** Set the currently shown month, defaulting to today's.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@param [year] {number} The year to show.
			@param [month] {number} The month to show (1-12).
			@param [day] {number} The day to show.
			@example $(selector).datepick('showMonth', 2014, 12, 25) */
		showMonth: function(elem, year, month, day) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst) && (day != null ||
					(inst.drawDate.year() !== year || inst.drawDate.month() !== month))) {
				inst.prevDate = inst.drawDate.newDate();
				var calendar = inst.options.calendar;
				var show = this._checkMinMax((year != null ?
					calendar.newDate(year, month, 1) : calendar.today()), inst);
				inst.drawDate.date(show.year(), show.month(), 
					(day != null ? day : Math.min(inst.drawDate.day(),
					calendar.daysInMonth(show.year(), show.month()))));
				this._update(elem);
			}
		},

		/** Adjust the currently shown month.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@param offset {number} The number of months to change by.
			@example $(selector).datepick('changeMonth', 2)*/
		changeMonth: function(elem, offset) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				var date = inst.drawDate.newDate().add(offset, 'm');
				this.showMonth(elem, date.year(), date.month());
			}
		},

		/** Adjust the currently shown day.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@param offset {number} The number of days to change by.
			@example $(selector).datepick('changeDay', 7)*/
		changeDay: function(elem, offset) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				var date = inst.drawDate.newDate().add(offset, 'd');
				this.showMonth(elem, date.year(), date.month(), date.day());
			}
		},

		/** Restrict a date to the minimum/maximum specified.
			@memberof CalendarsPicker
			@private
			@param date {CDate} The date to check.
			@param inst {object} The current instance settings. */
		_checkMinMax: function(date, inst) {
			var minDate = inst.get('minDate');
			var maxDate = inst.get('maxDate');
			date = (minDate && date.compareTo(minDate) === -1 ? minDate.newDate() : date);
			date = (maxDate && date.compareTo(maxDate) === +1 ? maxDate.newDate() : date);
			return date;
		},

		/** Retrieve the date associated with an entry in the datepicker.
			@memberof CalendarsPicker
			@param elem {Element} The control to examine.
			@param target {Element} The selected datepicker element.
			@return {CDate} The corresponding date, or <code>null</code>.			
			@example var date = $(selector).datepick('retrieveDate', $('div.datepick-popup a:contains(10)')[0]) */
		retrieveDate: function(elem, target) {
			var inst = this._getInst(elem);
			return ($.isEmptyObject(inst) ? null : inst.options.calendar.fromJD(
				parseFloat(target.className.replace(/^.*jd(\d+\.5).*$/, '$1'))));
		},

		/** Select a date for this datepicker.
			@memberof CalendarsPicker
			@param elem {Element} The control to examine.
			@param target {Element} The selected datepicker element.
			@example $(selector).datepick('selectDate', $('div.datepick-popup a:contains(10)')[0]) */
		selectDate: function(elem, target) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst) && !this.isDisabled(elem)) {
				var date = this.retrieveDate(elem, target);
				if (inst.options.multiSelect) {
					var found = false;
					for (var i = 0; i < inst.selectedDates.length; i++) {
						if (date.compareTo(inst.selectedDates[i]) === 0) {
							inst.selectedDates.splice(i, 1);
							found = true;
							break;
						}
					}
					if (!found && inst.selectedDates.length < inst.options.multiSelect) {
						inst.selectedDates.push(date);
					}
				}
				else if (inst.options.rangeSelect) {
					if (inst.pickingRange) {
						inst.selectedDates[1] = date;
					}
					else {
						inst.selectedDates = [date, date];
					}
					inst.pickingRange = !inst.pickingRange;
				}
				else {
					inst.selectedDates = [date];
				}
				inst.prevDate = inst.drawDate = date.newDate();
				this._updateInput(elem);
				if (inst.inline || inst.pickingRange || inst.selectedDates.length <
						(inst.options.multiSelect || (inst.options.rangeSelect ? 2 : 1))) {
					this._update(elem);
				}
				else {
					this.hide(elem);
				}
			}
		},

		/** Generate the datepicker content for this control.
			@memberof CalendarsPicker
			@private
			@param elem {Element} The control to affect.
			@param inst {object} The current instance settings.
			@return {jQuery} The datepicker content */
		_generateContent: function(elem, inst) {
			var monthsToShow = inst.options.monthsToShow;
			monthsToShow = ($.isArray(monthsToShow) ? monthsToShow : [1, monthsToShow]);
			inst.drawDate = this._checkMinMax(
				inst.drawDate || inst.get('defaultDate') || inst.options.calendar.today(), inst);
			var drawDate = inst.drawDate.newDate().add(-inst.options.monthsOffset, 'm');
			// Generate months
			var monthRows = '';
			for (var row = 0; row < monthsToShow[0]; row++) {
				var months = '';
				for (var col = 0; col < monthsToShow[1]; col++) {
					months += this._generateMonth(elem, inst, drawDate.year(),
						drawDate.month(), inst.options.calendar, inst.options.renderer, (row === 0 && col === 0));
					drawDate.add(1, 'm');
				}
				monthRows += this._prepare(inst.options.renderer.monthRow, inst).replace(/\{months\}/, months);
			}
			var picker = this._prepare(inst.options.renderer.picker, inst).replace(/\{months\}/, monthRows).
				replace(/\{weekHeader\}/g, this._generateDayHeaders(inst, inst.options.calendar, inst.options.renderer));
			// Add commands
			var addCommand = function(type, open, close, name, classes) {
				if (picker.indexOf('{' + type + ':' + name + '}') === -1) {
					return;
				}
				var command = inst.options.commands[name];
				var date = (inst.options.commandsAsDateFormat ? command.date.apply(elem, [inst]) : null);
				picker = picker.replace(new RegExp('\\{' + type + ':' + name + '\\}', 'g'),
					'<' + open + (command.status ? ' title="' + inst.options[command.status] + '"' : '') +
					' class="' + inst.options.renderer.commandClass + ' ' +
					inst.options.renderer.commandClass + '-' + name + ' ' + classes +
					(command.enabled(inst) ? '' : ' ' + inst.options.renderer.disabledClass) + '">' +
					(date ? date.formatDate(inst.options[command.text]) :
					inst.options[command.text]) + '</' + close + '>');
			};
			for (var name in inst.options.commands) {
				addCommand('button', 'button type="button"', 'button', name,
					inst.options.renderer.commandButtonClass);
				addCommand('link', 'a href="javascript:void(0)"', 'a', name,
					inst.options.renderer.commandLinkClass);
			}
			picker = $(picker);
			if (monthsToShow[1] > 1) {
				var count = 0;
				$(inst.options.renderer.monthSelector, picker).each(function() {
					var nth = ++count % monthsToShow[1];
					$(this).addClass(nth === 1 ? 'first' : (nth === 0 ? 'last' : ''));
				});
			}
			// Add datepicker behaviour
			var self = this;
			function removeHighlight() {
				(inst.inline ? $(this).closest('.' + self._getMarker()) : inst.div).
					find(inst.options.renderer.daySelector + ' a').
					removeClass(inst.options.renderer.highlightedClass);
			}
			picker.find(inst.options.renderer.daySelector + ' a').hover(
					function() {
						removeHighlight.apply(this);
						$(this).addClass(inst.options.renderer.highlightedClass);
					},
					removeHighlight).
				click(function() {
					self.selectDate(elem, this);
				}).end().
				find('select.' + this._monthYearClass + ':not(.' + this._anyYearClass + ')').
				change(function() {
					var monthYear = $(this).val().split('/');
					self.showMonth(elem, parseInt(monthYear[1], 10), parseInt(monthYear[0], 10));
				}).end().
				find('select.' + this._anyYearClass).click(function() {
					$(this).css('visibility', 'hidden').
						next('input').css({left: this.offsetLeft, top: this.offsetTop,
						width: this.offsetWidth, height: this.offsetHeight}).show().focus();
				}).end().
				find('input.' + self._monthYearClass).change(function() {
					try {
						var year = parseInt($(this).val(), 10);
						year = (isNaN(year) ? inst.drawDate.year() : year);
						self.showMonth(elem, year, inst.drawDate.month(), inst.drawDate.day());
					}
					catch (e) {
						alert(e);
					}
				}).keydown(function(event) {
					if (event.keyCode === 13) { // Enter
						$(event.elem).change();
					}
					else if (event.keyCode === 27) { // Escape
						$(event.elem).hide().prev('select').css('visibility', 'visible');
						inst.elem.focus();
					}
				});
			// Add keyboard handling
			var data = {elem: inst.elem[0]};
			picker.keydown(data, this._keyDown).keypress(data, this._keyPress).keyup(data, this._keyUp);
			// Add command behaviour
			picker.find('.' + inst.options.renderer.commandClass).click(function() {
					if (!$(this).hasClass(inst.options.renderer.disabledClass)) {
						var action = this.className.replace(
							new RegExp('^.*' + inst.options.renderer.commandClass + '-([^ ]+).*$'), '$1');
						plugin.performAction(elem, action);
					}
				});
			// Add classes
			if (inst.options.isRTL) {
				picker.addClass(inst.options.renderer.rtlClass);
			}
			if (monthsToShow[0] * monthsToShow[1] > 1) {
				picker.addClass(inst.options.renderer.multiClass);
			}
			if (inst.options.pickerClass) {
				picker.addClass(inst.options.pickerClass);
			}
			// Resize
			$('body').append(picker);
			var width = 0;
			picker.find(inst.options.renderer.monthSelector).each(function() {
				width += $(this).outerWidth();
			});
			picker.width(width / monthsToShow[0]);
			// Pre-show customisation
			if ($.isFunction(inst.options.onShow)) {
				inst.options.onShow.apply(elem, [picker, inst.options.calendar, inst]);
			}
			return picker;
		},

		/** Generate the content for a single month.
			@memberof CalendarsPicker
			@private
			@param elem {Element} The control to affect.
			@param inst {object} The current instance settings.
			@param year {number} The year to generate.
			@param month {number} The month to generate.
			@param calendar {BaseCalendar} The current calendar.
			@param renderer {object} The rendering templates.
			@param first {boolean} <code>true</code> if first of multiple months.
			@return {string} The month content. */
		_generateMonth: function(elem, inst, year, month, calendar, renderer, first) {
			var daysInMonth = calendar.daysInMonth(year, month);
			var monthsToShow = inst.options.monthsToShow;
			monthsToShow = ($.isArray(monthsToShow) ? monthsToShow : [1, monthsToShow]);
			var fixedWeeks = inst.options.fixedWeeks || (monthsToShow[0] * monthsToShow[1] > 1);
			var firstDay = inst.options.firstDay;
			firstDay = (firstDay == null ? calendar.local.firstDay : firstDay);
			var leadDays = (calendar.dayOfWeek(year, month, calendar.minDay) -
				firstDay + calendar.daysInWeek()) % calendar.daysInWeek();
			var numWeeks = (fixedWeeks ? 6 : Math.ceil((leadDays + daysInMonth) / calendar.daysInWeek()));
			var selectOtherMonths = inst.options.selectOtherMonths && inst.options.showOtherMonths;
			var minDate = (inst.pickingRange ? inst.selectedDates[0] : inst.get('minDate'));
			var maxDate = inst.get('maxDate');
			var showWeeks = renderer.week.indexOf('{weekOfYear}') > -1;
			var today = calendar.today();
			var drawDate = calendar.newDate(year, month, calendar.minDay);
			drawDate.add(-leadDays - (fixedWeeks &&
				(drawDate.dayOfWeek() === firstDay || drawDate.daysInMonth() < calendar.daysInWeek())?
				calendar.daysInWeek() : 0), 'd');
			var jd = drawDate.toJD();
			// Generate weeks
			var weeks = '';
			for (var week = 0; week < numWeeks; week++) {
				var weekOfYear = (!showWeeks ? '' : '<span class="jd' + jd + '">' +
					($.isFunction(inst.options.calculateWeek) ?
					inst.options.calculateWeek(drawDate) : drawDate.weekOfYear()) + '</span>');
				var days = '';
				for (var day = 0; day < calendar.daysInWeek(); day++) {
					var selected = false;
					if (inst.options.rangeSelect && inst.selectedDates.length > 0) {
						selected = (drawDate.compareTo(inst.selectedDates[0]) !== -1 &&
							drawDate.compareTo(inst.selectedDates[1]) !== +1)
					}
					else {
						for (var i = 0; i < inst.selectedDates.length; i++) {
							if (inst.selectedDates[i].compareTo(drawDate) === 0) {
								selected = true;
								break;
							}
						}
					}
					var dateInfo = (!$.isFunction(inst.options.onDate) ? {} :
						inst.options.onDate.apply(elem, [drawDate, drawDate.month() === month]));
					var selectable = (selectOtherMonths || drawDate.month() === month) &&
						this._isSelectable(elem, drawDate, dateInfo.selectable, minDate, maxDate);
					days += this._prepare(renderer.day, inst).replace(/\{day\}/g,
						(selectable ? '<a href="javascript:void(0)"' : '<span') +
						' class="jd' + jd + ' ' + (dateInfo.dateClass || '') +
						(selected && (selectOtherMonths || drawDate.month() === month) ?
						' ' + renderer.selectedClass : '') +
						(selectable ? ' ' + renderer.defaultClass : '') +
						(drawDate.weekDay() ? '' : ' ' + renderer.weekendClass) +
						(drawDate.month() === month ? '' : ' ' + renderer.otherMonthClass) +
						(drawDate.compareTo(today) === 0 && drawDate.month() === month ?
						' ' + renderer.todayClass : '') +
						(drawDate.compareTo(inst.drawDate) === 0 && drawDate.month() === month ?
						' ' + renderer.highlightedClass : '') + '"' +
						(dateInfo.title || (inst.options.dayStatus && selectable) ? ' title="' +
						(dateInfo.title || drawDate.formatDate(inst.options.dayStatus)) + '"' : '') + '>' +
						(inst.options.showOtherMonths || drawDate.month() === month ?
						dateInfo.content || drawDate.day() : '&#160;') +
						(selectable ? '</a>' : '</span>'));
					drawDate.add(1, 'd');
					jd++;
				}
				weeks += this._prepare(renderer.week, inst).replace(/\{days\}/g, days).
					replace(/\{weekOfYear\}/g, weekOfYear);
			}
			var monthHeader = this._prepare(renderer.month, inst).match(/\{monthHeader(:[^\}]+)?\}/);
			monthHeader = (monthHeader[0].length <= 13 ? 'MM yyyy' :
				monthHeader[0].substring(13, monthHeader[0].length - 1));
			monthHeader = (first ? this._generateMonthSelection(
				inst, year, month, minDate, maxDate, monthHeader, calendar, renderer) :
				calendar.formatDate(monthHeader, calendar.newDate(year, month, calendar.minDay)));
			var weekHeader = this._prepare(renderer.weekHeader, inst).
				replace(/\{days\}/g, this._generateDayHeaders(inst, calendar, renderer));
			return this._prepare(renderer.month, inst).replace(/\{monthHeader(:[^\}]+)?\}/g, monthHeader).
				replace(/\{weekHeader\}/g, weekHeader).replace(/\{weeks\}/g, weeks);
		},

		/** Generate the HTML for the day headers.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@param calendar {BaseCalendar} The current calendar.
			@param renderer {object} The rendering templates.
			@return {string} A week's worth of day headers. */
		_generateDayHeaders: function(inst, calendar, renderer) {
			var firstDay = inst.options.firstDay;
			firstDay = (firstDay == null ? calendar.local.firstDay : firstDay);
			var header = '';
			for (var day = 0; day < calendar.daysInWeek(); day++) {
				var dow = (day + firstDay) % calendar.daysInWeek();
				header += this._prepare(renderer.dayHeader, inst).replace(/\{day\}/g,
					'<span class="' + this._curDoWClass + dow + '" title="' +
					calendar.local.dayNames[dow] + '">' + calendar.local.dayNamesMin[dow] + '</span>');
			}
			return header;
		},

		/** Generate selection controls for month.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@param year {number} The year to generate.
			@param month {number} The month to generate.
			@param minDate {CDate} The minimum date allowed.
			@param maxDate {CDate} The maximum date allowed.
			@param monthHeader {string} The month/year format.
			@param calendar {BaseCalendar} The current calendar.
			@return {string} The month selection content. */
		_generateMonthSelection: function(inst, year, month, minDate, maxDate, monthHeader, calendar) {
			if (!inst.options.changeMonth) {
				return calendar.formatDate(monthHeader, calendar.newDate(year, month, 1));
			}
			// Months
			var monthNames = calendar.local[
				'monthNames' + (monthHeader.match(/mm/i) ? '' : 'Short')];
			var html = monthHeader.replace(/m+/i, '\\x2E').replace(/y+/i, '\\x2F');
			var selector = '<select class="' + this._monthYearClass +
				'" title="' + inst.options.monthStatus + '">';
			var maxMonth = calendar.monthsInYear(year) + calendar.minMonth;
			for (var m = calendar.minMonth; m < maxMonth; m++) {
				if ((!minDate || calendar.newDate(year, m,
						calendar.daysInMonth(year, m) - 1 + calendar.minDay).
						compareTo(minDate) !== -1) &&
						(!maxDate || calendar.newDate(year, m, calendar.minDay).
						compareTo(maxDate) !== +1)) {
					selector += '<option value="' + m + '/' + year + '"' +
						(month === m ? ' selected="selected"' : '') + '>' +
						monthNames[m - calendar.minMonth] + '</option>';
				}
			}
			selector += '</select>';
			html = html.replace(/\\x2E/, selector);
			// Years
			var yearRange = inst.options.yearRange;
			if (yearRange === 'any') {
				selector = '<select class="' + this._monthYearClass + ' ' + this._anyYearClass +
					'" title="' + inst.options.yearStatus + '">' +
					'<option>' + year + '</option></select>' +
					'<input class="' + this._monthYearClass + ' ' + this._curMonthClass +
					month + '" value="' + year + '">';
			}
			else {
				yearRange = yearRange.split(':');
				var todayYear = calendar.today().year();
				var start = (yearRange[0].match('c[+-].*') ? year + parseInt(yearRange[0].substring(1), 10) :
					((yearRange[0].match('[+-].*') ? todayYear : 0) + parseInt(yearRange[0], 10)));
				var end = (yearRange[1].match('c[+-].*') ? year + parseInt(yearRange[1].substring(1), 10) :
					((yearRange[1].match('[+-].*') ? todayYear : 0) + parseInt(yearRange[1], 10)));
				selector = '<select class="' + this._monthYearClass +
					'" title="' + inst.options.yearStatus + '">';
				start = calendar.newDate(start + 1, calendar.firstMonth, calendar.minDay).add(-1, 'd');
				end = calendar.newDate(end, calendar.firstMonth, calendar.minDay);
				var addYear = function(y, yDisplay) {
					if (y !== 0 || calendar.hasYearZero) {
						selector += '<option value="' +
							Math.min(month, calendar.monthsInYear(y) - 1 + calendar.minMonth) +
							'/' + y + '"' + (year === y ? ' selected="selected"' : '') + '>' +
							(yDisplay || y) + '</option>';
					}
				};
				if (start.toJD() < end.toJD()) {
					start = (minDate && minDate.compareTo(start) === +1 ? minDate : start).year();
					end = (maxDate && maxDate.compareTo(end) === -1 ? maxDate : end).year();
					var earlierLater = Math.floor((end - start) / 2);
					if (!minDate || minDate.year() < start) {
						addYear(start - earlierLater, inst.options.earlierText);
					}
					for (var y = start; y <= end; y++) {
						addYear(y);
					}
					if (!maxDate || maxDate.year() > end) {
						addYear(end + earlierLater, inst.options.laterText);
					}
				}
				else {
					start = (maxDate && maxDate.compareTo(start) === -1 ? maxDate : start).year();
					end = (minDate && minDate.compareTo(end) === +1 ? minDate : end).year();
					var earlierLater = Math.floor((start - end) / 2);
					if (!maxDate || maxDate.year() > start) {
						addYear(start + earlierLater, inst.options.earlierText);
					}
					for (var y = start; y >= end; y--) {
						addYear(y);
					}
					if (!minDate || minDate.year() < end) {
						addYear(end - earlierLater, inst.options.laterText);
					}
				}
				selector += '</select>';
			}
			html = html.replace(/\\x2F/, selector);
			return html;
		},

		/** Prepare a render template for use.
			Exclude popup/inline sections that are not applicable.
			Localise text of the form: {l10n:name}.
			@memberof CalendarsPicker
			@private
			@param text {string} The text to localise.
			@param inst {object} The current instance settings.
			@return {string} The localised text. */
		_prepare: function(text, inst) {
			var replaceSection = function(type, retain) {
				while (true) {
					var start = text.indexOf('{' + type + ':start}');
					if (start === -1) {
						return;
					}
					var end = text.substring(start).indexOf('{' + type + ':end}');
					if (end > -1) {
						text = text.substring(0, start) +
							(retain ? text.substr(start + type.length + 8, end - type.length - 8) : '') +
							text.substring(start + end + type.length + 6);
					}
				}
			};
			replaceSection('inline', inst.inline);
			replaceSection('popup', !inst.inline);
			var pattern = /\{l10n:([^\}]+)\}/;
			var matches = null;
			while (matches = pattern.exec(text)) {
				text = text.replace(matches[0], inst.options[matches[1]]);
			}
			return text;
		}
	});

	var plugin = $.calendarsPicker; // Singleton instance

	$(function() {
		$(document).on('mousedown.' + pluginName, plugin._checkExternalClick).
			on('resize.' + pluginName, function() { plugin.hide(plugin.curInst); });
	});

})(jQuery);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5jYWxlbmRhcnMucGlja2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxBQUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImpxdWVyeS5jYWxlbmRhcnMucGlja2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogaHR0cDovL2tlaXRoLXdvb2QubmFtZS9jYWxlbmRhcnMuaHRtbFxyXG4gICBDYWxlbmRhcnMgZGF0ZSBwaWNrZXIgZm9yIGpRdWVyeSB2Mi4wLjEuXHJcbiAgIFdyaXR0ZW4gYnkgS2VpdGggV29vZCAoa2J3b29ke2F0fWlpbmV0LmNvbS5hdSkgQXVndXN0IDIwMDkuXHJcbiAgIEF2YWlsYWJsZSB1bmRlciB0aGUgTUlUIChodHRwOi8va2VpdGgtd29vZC5uYW1lL2xpY2VuY2UuaHRtbCkgbGljZW5zZS4gXHJcbiAgIFBsZWFzZSBhdHRyaWJ1dGUgdGhlIGF1dGhvciBpZiB5b3UgdXNlIGl0LiAqL1xyXG5cclxuKGZ1bmN0aW9uKCQpIHsgLy8gSGlkZSBzY29wZSwgbm8gJCBjb25mbGljdFxyXG5cclxuXHR2YXIgcGx1Z2luTmFtZSA9ICdjYWxlbmRhcnNQaWNrZXInO1xyXG5cclxuXHJcblx0LyoqIENyZWF0ZSB0aGUgY2FsZW5kYXJzIGRhdGVwaWNrZXIgcGx1Z2luLlxyXG5cdFx0PHA+U2V0cyBhbiBpbnB1dCBmaWVsZCB0byBwb3B1cCBhIGNhbGVuZGFyIGZvciBkYXRlIGVudHJ5LFxyXG5cdFx0XHRvciBhIDxjb2RlPmRpdjwvY29kZT4gb3IgPGNvZGU+c3BhbjwvY29kZT4gdG8gc2hvdyBhbiBpbmxpbmUgY2FsZW5kYXIuPC9wPlxyXG5cdFx0PHA+RXhwZWN0cyBIVE1MIGxpa2U6PC9wPlxyXG5cdFx0PHByZT4mbHQ7aW5wdXQgdHlwZT1cInRleHRcIj4gb3IgJmx0O2Rpdj4mbHQ7L2Rpdj48L3ByZT5cclxuXHRcdDxwPlByb3ZpZGUgaW5saW5lIGNvbmZpZ3VyYXRpb24gbGlrZTo8L3A+XHJcblx0XHQ8cHJlPiZsdDtpbnB1dCB0eXBlPVwidGV4dFwiIGRhdGEtY2FsZW5kYXJzUGlja2VyPVwibmFtZTogJ3ZhbHVlJ1wiLz48L3ByZT5cclxuXHQgXHRAY2xhc3MgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRAYXVnbWVudHMgSlFQbHVnaW5cclxuXHRcdEBleGFtcGxlICQoc2VsZWN0b3IpLmNhbGVuZGFyc1BpY2tlcigpXHJcbiAkKHNlbGVjdG9yKS5jYWxlbmRhcnNQaWNrZXIoe21pbkRhdGU6IDAsIG1heERhdGU6ICcrMW0gKzF3J30pICovXHJcblx0JC5KUVBsdWdpbi5jcmVhdGVQbHVnaW4oe1xyXG5cdFxyXG5cdFx0LyoqIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4uXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXIgKi9cclxuXHRcdG5hbWU6IHBsdWdpbk5hbWUsXHJcblx0XHRcclxuXHRcdC8qKiBEZWZhdWx0IHRlbXBsYXRlIGZvciBnZW5lcmF0aW5nIGEgZGF0ZXBpY2tlci5cclxuXHRcdFx0SW5zZXJ0IGFueXdoZXJlOlxyXG5cdFx0XHQ8dWw+XHJcblx0XHRcdDxsaT4ne2wxMG46bmFtZX0nIHRvIGluc2VydCBsb2NhbGlzZWQgdmFsdWUgZm9yIG5hbWUsPC9saT5cclxuXHRcdFx0PGxpPid7bGluazpuYW1lfScgdG8gaW5zZXJ0IGEgbGluayB0cmlnZ2VyIGZvciBjb21tYW5kIG5hbWUsPC9saT5cclxuXHRcdFx0PGxpPid7YnV0dG9uOm5hbWV9JyB0byBpbnNlcnQgYSBidXR0b24gdHJpZ2dlciBmb3IgY29tbWFuZCBuYW1lLDwvbGk+XHJcblx0XHRcdDxsaT4ne3BvcHVwOnN0YXJ0fS4uLntwb3B1cDplbmR9JyB0byBtYXJrIGEgc2VjdGlvbiBmb3IgaW5jbHVzaW9uIGluIGEgcG9wdXAgZGF0ZXBpY2tlciBvbmx5LDwvbGk+XHJcblx0XHRcdDxsaT4ne2lubGluZTpzdGFydH0uLi57aW5saW5lOmVuZH0nIHRvIG1hcmsgYSBzZWN0aW9uIGZvciBpbmNsdXNpb24gaW4gYW4gaW5saW5lIGRhdGVwaWNrZXIgb25seS48L2xpPlxyXG5cdFx0XHQ8L3VsPlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcm9wZXJ0eSBwaWNrZXIge3N0cmluZ30gT3ZlcmFsbCBzdHJ1Y3R1cmU6ICd7bW9udGhzfScgdG8gaW5zZXJ0IGNhbGVuZGFyIG1vbnRocy5cclxuXHRcdFx0QHByb3BlcnR5IG1vbnRoUm93IHtzdHJpbmd9IE9uZSByb3cgb2YgbW9udGhzOiAne21vbnRoc30nIHRvIGluc2VydCBjYWxlbmRhciBtb250aHMuXHJcblx0XHRcdEBwcm9wZXJ0eSBtb250aCB7c3RyaW5nfSBBIHNpbmdsZSBtb250aDogJ3ttb250aEhlYWRlcjxlbT46ZGF0ZUZvcm1hdDwvZW0+fScgdG8gaW5zZXJ0IHRoZSBtb250aCBoZWFkZXIgLVxyXG5cdFx0XHRcdFx0XHQ8ZW0+ZGF0ZUZvcm1hdDwvZW0+IGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byAnTU0geXl5eScsXHJcblx0XHRcdFx0XHRcdCd7d2Vla0hlYWRlcn0nIHRvIGluc2VydCBhIHdlZWsgaGVhZGVyLCAne3dlZWtzfScgdG8gaW5zZXJ0IHRoZSBtb250aCdzIHdlZWtzLlxyXG5cdFx0XHRAcHJvcGVydHkgd2Vla0hlYWRlciB7c3RyaW5nfSBBIHdlZWsgaGVhZGVyOiAne2RheXN9JyB0byBpbnNlcnQgaW5kaXZpZHVhbCBkYXkgbmFtZXMuXHJcblx0XHRcdEBwcm9wZXJ0eSBkYXlIZWFkZXIge3N0cmluZ30gSW5kaXZpZHVhbCBkYXkgaGVhZGVyOiAne2RheX0nIHRvIGluc2VydCBkYXkgbmFtZS5cclxuXHRcdFx0QHByb3BlcnR5IHdlZWsge3N0cmluZ30gT25lIHdlZWsgb2YgdGhlIG1vbnRoOiAne2RheXN9JyB0byBpbnNlcnQgdGhlIHdlZWsncyBkYXlzLFxyXG5cdFx0XHRcdFx0XHQne3dlZWtPZlllYXJ9JyB0byBpbnNlcnQgd2VlayBvZiB5ZWFyLlxyXG5cdFx0XHRAcHJvcGVydHkgZGF5IHtzdHJpbmd9IEFuIGluZGl2aWR1YWwgZGF5OiAne2RheX0nIHRvIGluc2VydCBkYXkgdmFsdWUuXHJcblx0XHRcdEBwcm9wZXJ0eSBtb250aFNlbGVjdG9yIHtzdHJpbmd9IGpRdWVyeSBzZWxlY3RvciwgcmVsYXRpdmUgdG8gcGlja2VyLCBmb3IgYSBzaW5nbGUgbW9udGguXHJcblx0XHRcdEBwcm9wZXJ0eSBkYXlTZWxlY3RvciB7c3RyaW5nfSBqUXVlcnkgc2VsZWN0b3IsIHJlbGF0aXZlIHRvIHBpY2tlciwgZm9yIGluZGl2aWR1YWwgZGF5cy5cclxuXHRcdFx0QHByb3BlcnR5IHJ0bENsYXNzIHtzdHJpbmd9IENsYXNzIGZvciByaWdodC10by1sZWZ0IChSVEwpIGxhbmd1YWdlcy5cclxuXHRcdFx0QHByb3BlcnR5IG11bHRpQ2xhc3Mge3N0cmluZ30gQ2xhc3MgZm9yIG11bHRpLW1vbnRoIGRhdGVwaWNrZXJzLlxyXG5cdFx0XHRAcHJvcGVydHkgZGVmYXVsdENsYXNzIHtzdHJpbmd9IENsYXNzIGZvciBzZWxlY3RhYmxlIGRhdGVzLlxyXG5cdFx0XHRAcHJvcGVydHkgc2VsZWN0ZWRDbGFzcyB7c3RyaW5nfSBDbGFzcyBmb3IgY3VycmVudGx5IHNlbGVjdGVkIGRhdGVzLlxyXG5cdFx0XHRAcHJvcGVydHkgaGlnaGxpZ2h0ZWRDbGFzcyB7c3RyaW5nfSBDbGFzcyBmb3IgaGlnaGxpZ2h0ZWQgZGF0ZXMuXHJcblx0XHRcdEBwcm9wZXJ0eSB0b2RheUNsYXNzIHtzdHJpbmd9IENsYXNzIGZvciB0b2RheS5cclxuXHRcdFx0QHByb3BlcnR5IG90aGVyTW9udGhDbGFzcyB7c3RyaW5nfSBDbGFzcyBmb3IgZGF5cyBmcm9tIG90aGVyIG1vbnRocy5cclxuXHRcdFx0QHByb3BlcnR5IHdlZWtlbmRDbGFzcyB7c3RyaW5nfSBDbGFzcyBmb3IgZGF5cyBvbiB3ZWVrZW5kcy5cclxuXHRcdFx0QHByb3BlcnR5IGNvbW1hbmRDbGFzcyB7c3RyaW5nfSBDbGFzcyBwcmVmaXggZm9yIGNvbW1hbmRzLlxyXG5cdFx0XHRAcHJvcGVydHkgY29tbWFuZEJ1dHRvbkNsYXNzIHtzdHJpbmd9IEV4dHJhIGNsYXNzKGVzKSBmb3IgY29tbWFuZHMgdGhhdCBhcmUgYnV0dG9ucy5cclxuXHRcdFx0QHByb3BlcnR5IGNvbW1hbmRMaW5rQ2xhc3Mge3N0cmluZ30gRXh0cmEgY2xhc3MoZXMpIGZvciBjb21tYW5kcyB0aGF0IGFyZSBsaW5rcy5cclxuXHRcdFx0QHByb3BlcnR5IGRpc2FibGVkQ2xhc3Mge3N0cmluZ30gQ2xhc3MgZm9yIGRpc2FibGVkIGNvbW1hbmRzLiAqL1xyXG5cdFx0ZGVmYXVsdFJlbmRlcmVyOiB7XHJcblx0XHRcdHBpY2tlcjogJzxkaXYgY2xhc3M9XCJjYWxlbmRhcnNcIj4nICtcclxuXHRcdFx0JzxkaXYgY2xhc3M9XCJjYWxlbmRhcnMtbmF2XCI+e2xpbms6cHJldn17bGluazp0b2RheX17bGluazpuZXh0fTwvZGl2Pnttb250aHN9JyArXHJcblx0XHRcdCd7cG9wdXA6c3RhcnR9PGRpdiBjbGFzcz1cImNhbGVuZGFycy1jdHJsXCI+e2xpbms6Y2xlYXJ9e2xpbms6Y2xvc2V9PC9kaXY+e3BvcHVwOmVuZH0nICtcclxuXHRcdFx0JzxkaXYgY2xhc3M9XCJjYWxlbmRhcnMtY2xlYXItZml4XCI+PC9kaXY+PC9kaXY+JyxcclxuXHRcdFx0bW9udGhSb3c6ICc8ZGl2IGNsYXNzPVwiY2FsZW5kYXJzLW1vbnRoLXJvd1wiPnttb250aHN9PC9kaXY+JyxcclxuXHRcdFx0bW9udGg6ICc8ZGl2IGNsYXNzPVwiY2FsZW5kYXJzLW1vbnRoXCI+PGRpdiBjbGFzcz1cImNhbGVuZGFycy1tb250aC1oZWFkZXJcIj57bW9udGhIZWFkZXJ9PC9kaXY+JyArXHJcblx0XHRcdCc8dGFibGU+PHRoZWFkPnt3ZWVrSGVhZGVyfTwvdGhlYWQ+PHRib2R5Pnt3ZWVrc308L3Rib2R5PjwvdGFibGU+PC9kaXY+JyxcclxuXHRcdFx0d2Vla0hlYWRlcjogJzx0cj57ZGF5c308L3RyPicsXHJcblx0XHRcdGRheUhlYWRlcjogJzx0aD57ZGF5fTwvdGg+JyxcclxuXHRcdFx0d2VlazogJzx0cj57ZGF5c308L3RyPicsXHJcblx0XHRcdGRheTogJzx0ZD57ZGF5fTwvdGQ+JyxcclxuXHRcdFx0bW9udGhTZWxlY3RvcjogJy5jYWxlbmRhcnMtbW9udGgnLFxyXG5cdFx0XHRkYXlTZWxlY3RvcjogJ3RkJyxcclxuXHRcdFx0cnRsQ2xhc3M6ICdjYWxlbmRhcnMtcnRsJyxcclxuXHRcdFx0bXVsdGlDbGFzczogJ2NhbGVuZGFycy1tdWx0aScsXHJcblx0XHRcdGRlZmF1bHRDbGFzczogJycsXHJcblx0XHRcdHNlbGVjdGVkQ2xhc3M6ICdjYWxlbmRhcnMtc2VsZWN0ZWQnLFxyXG5cdFx0XHRoaWdobGlnaHRlZENsYXNzOiAnY2FsZW5kYXJzLWhpZ2hsaWdodCcsXHJcblx0XHRcdHRvZGF5Q2xhc3M6ICdjYWxlbmRhcnMtdG9kYXknLFxyXG5cdFx0XHRvdGhlck1vbnRoQ2xhc3M6ICdjYWxlbmRhcnMtb3RoZXItbW9udGgnLFxyXG5cdFx0XHR3ZWVrZW5kQ2xhc3M6ICdjYWxlbmRhcnMtd2Vla2VuZCcsXHJcblx0XHRcdGNvbW1hbmRDbGFzczogJ2NhbGVuZGFycy1jbWQnLFxyXG5cdFx0XHRjb21tYW5kQnV0dG9uQ2xhc3M6ICcnLFxyXG5cdFx0XHRjb21tYW5kTGlua0NsYXNzOiAnJyxcclxuXHRcdFx0ZGlzYWJsZWRDbGFzczogJ2NhbGVuZGFycy1kaXNhYmxlZCdcclxuXHRcdH0sXHJcblx0XHJcblx0XHQvKiogQ29tbWFuZCBhY3Rpb25zIHRoYXQgbWF5IGJlIGFkZGVkIHRvIGEgbGF5b3V0IGJ5IG5hbWUuXHJcblx0XHRcdDx1bD5cclxuXHRcdFx0PGxpPnByZXYgLSBTaG93IHRoZSBwcmV2aW91cyBtb250aCAoYmFzZWQgb24gPGNvZGU+bW9udGhzVG9TdGVwPC9jb2RlPiBvcHRpb24pIC0gPGVtPlBhZ2VVcDwvZW0+PC9saT5cclxuXHRcdFx0PGxpPnByZXZKdW1wIC0gU2hvdyB0aGUgcHJldmlvdXMgeWVhciAoYmFzZWQgb24gPGNvZGU+bW9udGhzVG9KdW1wPC9jb2RlPiBvcHRpb24pIC0gPGVtPkN0cmwrUGFnZVVwPC9lbT48L2xpPlxyXG5cdFx0XHQ8bGk+bmV4dCAtIFNob3cgdGhlIG5leHQgbW9udGggKGJhc2VkIG9uIDxjb2RlPm1vbnRoc1RvU3RlcDwvY29kZT4gb3B0aW9uKSAtIDxlbT5QYWdlRG93bjwvZW0+PC9saT5cclxuXHRcdFx0PGxpPm5leHRKdW1wIC0gU2hvdyB0aGUgbmV4dCB5ZWFyIChiYXNlZCBvbiA8Y29kZT5tb250aHNUb0p1bXA8L2NvZGU+IG9wdGlvbikgLSA8ZW0+Q3RybCtQYWdlRG93bjwvZW0+PC9saT5cclxuXHRcdFx0PGxpPmN1cnJlbnQgLSBTaG93IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbW9udGggb3IgdG9kYXkncyBpZiBub25lIHNlbGVjdGVkIC0gPGVtPkN0cmwrSG9tZTwvZW0+PC9saT5cclxuXHRcdFx0PGxpPnRvZGF5IC0gU2hvdyB0b2RheSdzIG1vbnRoIC0gPGVtPkN0cmwrSG9tZTwvZW0+PC9saT5cclxuXHRcdFx0PGxpPmNsZWFyIC0gRXJhc2UgdGhlIGRhdGUgYW5kIGNsb3NlIHRoZSBkYXRlcGlja2VyIHBvcHVwIC0gPGVtPkN0cmwrRW5kPC9lbT48L2xpPlxyXG5cdFx0XHQ8bGk+Y2xvc2UgLSBDbG9zZSB0aGUgZGF0ZXBpY2tlciBwb3B1cCAtIDxlbT5Fc2M8L2VtPjwvbGk+XHJcblx0XHRcdDxsaT5wcmV2V2VlayAtIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgcHJldmlvdXMgd2VlayAtIDxlbT5DdHJsK1VwPC9lbT48L2xpPlxyXG5cdFx0XHQ8bGk+cHJldkRheSAtIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgcHJldmlvdXMgZGF5IC0gPGVtPkN0cmwrTGVmdDwvZW0+PC9saT5cclxuXHRcdFx0PGxpPm5leHREYXkgLSBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIG5leHQgZGF5IC0gPGVtPkN0cmwrUmlnaHQ8L2VtPjwvbGk+XHJcblx0XHRcdDxsaT5uZXh0V2VlayAtIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgbmV4dCB3ZWVrIC0gPGVtPkN0cmwrRG93bjwvZW0+PC9saT5cclxuXHRcdFx0PC91bD5cclxuXHRcdFx0VGhlIGNvbW1hbmQgbmFtZSBpcyB0aGUga2V5IG5hbWUgYW5kIGlzIHVzZWQgdG8gYWRkIHRoZSBjb21tYW5kIHRvIGEgbGF5b3V0XHJcblx0XHRcdHdpdGggJ3tidXR0b246bmFtZX0nIG9yICd7bGluazpuYW1lfScuIEVhY2ggaGFzIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlcy5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJvcGVydHkgdGV4dCB7c3RyaW5nfSBUaGUgZmllbGQgaW4gdGhlIHJlZ2lvbmFsIHNldHRpbmdzIGZvciB0aGUgZGlzcGxheWVkIHRleHQuXHJcblx0XHRcdEBwcm9wZXJ0eSBzdGF0dXMge3N0cmluZ30gVGhlIGZpZWxkIGluIHRoZSByZWdpb25hbCBzZXR0aW5ncyBmb3IgdGhlIHN0YXR1cyB0ZXh0LlxyXG5cdFx0XHRAcHJvcGVydHkga2V5c3Ryb2tlIHtvYmplY3R9IFRoZSBrZXlzdHJva2UgdG8gdHJpZ2dlciB0aGUgYWN0aW9uLCB3aXRoIGF0dHJpYnV0ZXM6XHJcblx0XHRcdFx0PGNvZGU+a2V5Q29kZTwvY29kZT4ge251bWJlcn0gdGhlIGNvZGUgZm9yIHRoZSBrZXlzdHJva2UsXHJcblx0XHRcdFx0PGNvZGU+Y3RybEtleTwvY29kZT4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIDxlbT5DdHJsPC9lbT4gaXMgcmVxdWlyZWQsXHJcblx0XHRcdFx0PGNvZGU+YWx0S2V5PC9jb2RlPiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgPGVtPkFsdDwvZW0+IGlzIHJlcXVpcmVkLFxyXG5cdFx0XHRcdDxjb2RlPnNoaWZ0S2V5PC9jb2RlPiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgPGVtPlNoaWZ0PC9lbT4gaXMgcmVxdWlyZWQuXHJcblx0XHRcdEBwcm9wZXJ0eSBlbmFibGVkIHtDYWxlbmRhcnNQaWNrZXJDb21tYW5kRW5hYmxlZH0gVGhlIGZ1bmN0aW9uIHRoYXQgaW5kaWNhdGVzIHRoZSBjb21tYW5kIGlzIGVuYWJsZWQuXHJcblx0XHRcdEBwcm9wZXJ0eSBkYXRlIHtDYWxlbmRhcnNQaWNrZXJDb21tYW5kRGF0ZX0gVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgZGF0ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBhY3Rpb24uXHJcblx0XHRcdEBwcm9wZXJ0eSBhY3Rpb24ge0NhbGVuZGFyc1BpY2tlckNvbW1hbmRBY3Rpb259IFRoZSBmdW5jdGlvbiB0aGF0IGltcGxlbWVudHMgdGhlIGFjdGlvbi4gKi9cclxuXHRcdGNvbW1hbmRzOiB7XHJcblx0XHRcdHByZXY6IHt0ZXh0OiAncHJldlRleHQnLCBzdGF0dXM6ICdwcmV2U3RhdHVzJywgLy8gUHJldmlvdXMgbW9udGhcclxuXHRcdFx0XHRrZXlzdHJva2U6IHtrZXlDb2RlOiAzM30sIC8vIFBhZ2UgdXBcclxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdFx0XHR2YXIgbWluRGF0ZSA9IGluc3QuY3VyTWluRGF0ZSgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuICghbWluRGF0ZSB8fCBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5cclxuXHRcdFx0XHRcdFx0YWRkKDEgLSBpbnN0Lm9wdGlvbnMubW9udGhzVG9TdGVwIC0gaW5zdC5vcHRpb25zLm1vbnRoc09mZnNldCwgJ20nKS5cclxuXHRcdFx0XHRcdFx0ZGF5KGluc3Qub3B0aW9ucy5jYWxlbmRhci5taW5EYXkpLmFkZCgtMSwgJ2QnKS5jb21wYXJlVG8obWluRGF0ZSkgIT09IC0xKTsgfSxcclxuXHRcdFx0XHRkYXRlOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuXHJcblx0XHRcdFx0XHRcdGFkZCgtaW5zdC5vcHRpb25zLm1vbnRoc1RvU3RlcCAtIGluc3Qub3B0aW9ucy5tb250aHNPZmZzZXQsICdtJykuXHJcblx0XHRcdFx0XHRcdGRheShpbnN0Lm9wdGlvbnMuY2FsZW5kYXIubWluRGF5KTsgfSxcclxuXHRcdFx0XHRhY3Rpb246IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0XHRcdHBsdWdpbi5jaGFuZ2VNb250aCh0aGlzLCAtaW5zdC5vcHRpb25zLm1vbnRoc1RvU3RlcCk7IH1cclxuXHRcdFx0fSxcclxuXHRcdFx0cHJldkp1bXA6IHt0ZXh0OiAncHJldkp1bXBUZXh0Jywgc3RhdHVzOiAncHJldkp1bXBTdGF0dXMnLCAvLyBQcmV2aW91cyB5ZWFyXHJcblx0XHRcdFx0a2V5c3Ryb2tlOiB7a2V5Q29kZTogMzMsIGN0cmxLZXk6IHRydWV9LCAvLyBDdHJsICsgUGFnZSB1cFxyXG5cdFx0XHRcdGVuYWJsZWQ6IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0XHRcdHZhciBtaW5EYXRlID0gaW5zdC5jdXJNaW5EYXRlKCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gKCFtaW5EYXRlIHx8IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxyXG5cdFx0XHRcdFx0XHRhZGQoMSAtIGluc3Qub3B0aW9ucy5tb250aHNUb0p1bXAgLSBpbnN0Lm9wdGlvbnMubW9udGhzT2Zmc2V0LCAnbScpLlxyXG5cdFx0XHRcdFx0XHRkYXkoaW5zdC5vcHRpb25zLmNhbGVuZGFyLm1pbkRheSkuYWRkKC0xLCAnZCcpLmNvbXBhcmVUbyhtaW5EYXRlKSAhPT0gLTEpOyB9LFxyXG5cdFx0XHRcdGRhdGU6IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0XHRcdHJldHVybiBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5cclxuXHRcdFx0XHRcdFx0YWRkKC1pbnN0Lm9wdGlvbnMubW9udGhzVG9KdW1wIC0gaW5zdC5vcHRpb25zLm1vbnRoc09mZnNldCwgJ20nKS5cclxuXHRcdFx0XHRcdFx0ZGF5KGluc3Qub3B0aW9ucy5jYWxlbmRhci5taW5EYXkpOyB9LFxyXG5cdFx0XHRcdGFjdGlvbjogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHRcdFx0cGx1Z2luLmNoYW5nZU1vbnRoKHRoaXMsIC1pbnN0Lm9wdGlvbnMubW9udGhzVG9KdW1wKTsgfVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRuZXh0OiB7dGV4dDogJ25leHRUZXh0Jywgc3RhdHVzOiAnbmV4dFN0YXR1cycsIC8vIE5leHQgbW9udGhcclxuXHRcdFx0XHRrZXlzdHJva2U6IHtrZXlDb2RlOiAzNH0sIC8vIFBhZ2UgZG93blxyXG5cdFx0XHRcdGVuYWJsZWQ6IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0XHRcdHZhciBtYXhEYXRlID0gaW5zdC5nZXQoJ21heERhdGUnKTtcclxuXHRcdFx0XHRcdHJldHVybiAoIW1heERhdGUgfHwgaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuXHJcblx0XHRcdFx0XHRcdGFkZChpbnN0Lm9wdGlvbnMubW9udGhzVG9TdGVwIC0gaW5zdC5vcHRpb25zLm1vbnRoc09mZnNldCwgJ20nKS5cclxuXHRcdFx0XHRcdFx0ZGF5KGluc3Qub3B0aW9ucy5jYWxlbmRhci5taW5EYXkpLmNvbXBhcmVUbyhtYXhEYXRlKSAhPT0gKzEpOyB9LFxyXG5cdFx0XHRcdGRhdGU6IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0XHRcdHJldHVybiBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5cclxuXHRcdFx0XHRcdFx0YWRkKGluc3Qub3B0aW9ucy5tb250aHNUb1N0ZXAgLSBpbnN0Lm9wdGlvbnMubW9udGhzT2Zmc2V0LCAnbScpLlxyXG5cdFx0XHRcdFx0XHRkYXkoaW5zdC5vcHRpb25zLmNhbGVuZGFyLm1pbkRheSk7IH0sXHJcblx0XHRcdFx0YWN0aW9uOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdFx0XHRwbHVnaW4uY2hhbmdlTW9udGgodGhpcywgaW5zdC5vcHRpb25zLm1vbnRoc1RvU3RlcCk7IH1cclxuXHRcdFx0fSxcclxuXHRcdFx0bmV4dEp1bXA6IHt0ZXh0OiAnbmV4dEp1bXBUZXh0Jywgc3RhdHVzOiAnbmV4dEp1bXBTdGF0dXMnLCAvLyBOZXh0IHllYXJcclxuXHRcdFx0XHRrZXlzdHJva2U6IHtrZXlDb2RlOiAzNCwgY3RybEtleTogdHJ1ZX0sIC8vIEN0cmwgKyBQYWdlIGRvd25cclxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdFx0XHR2YXIgbWF4RGF0ZSA9IGluc3QuZ2V0KCdtYXhEYXRlJyk7XHJcblx0XHRcdFx0XHRyZXR1cm4gKCFtYXhEYXRlIHx8IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxyXG5cdFx0XHRcdFx0XHRhZGQoaW5zdC5vcHRpb25zLm1vbnRoc1RvSnVtcCAtIGluc3Qub3B0aW9ucy5tb250aHNPZmZzZXQsICdtJykuXHJcblx0XHRcdFx0XHRcdGRheShpbnN0Lm9wdGlvbnMuY2FsZW5kYXIubWluRGF5KS5jb21wYXJlVG8obWF4RGF0ZSkgIT09ICsxKTtcdH0sXHJcblx0XHRcdFx0ZGF0ZTogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxyXG5cdFx0XHRcdFx0XHRhZGQoaW5zdC5vcHRpb25zLm1vbnRoc1RvSnVtcCAtIGluc3Qub3B0aW9ucy5tb250aHNPZmZzZXQsICdtJykuXHJcblx0XHRcdFx0XHRcdGRheShpbnN0Lm9wdGlvbnMuY2FsZW5kYXIubWluRGF5KTsgfSxcclxuXHRcdFx0XHRhY3Rpb246IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0XHRcdHBsdWdpbi5jaGFuZ2VNb250aCh0aGlzLCBpbnN0Lm9wdGlvbnMubW9udGhzVG9KdW1wKTsgfVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRjdXJyZW50OiB7dGV4dDogJ2N1cnJlbnRUZXh0Jywgc3RhdHVzOiAnY3VycmVudFN0YXR1cycsIC8vIEN1cnJlbnQgbW9udGhcclxuXHRcdFx0XHRrZXlzdHJva2U6IHtrZXlDb2RlOiAzNiwgY3RybEtleTogdHJ1ZX0sIC8vIEN0cmwgKyBIb21lXHJcblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHRcdFx0dmFyIG1pbkRhdGUgPSBpbnN0LmN1ck1pbkRhdGUoKTtcclxuXHRcdFx0XHRcdHZhciBtYXhEYXRlID0gaW5zdC5nZXQoJ21heERhdGUnKTtcclxuXHRcdFx0XHRcdHZhciBjdXJEYXRlID0gaW5zdC5zZWxlY3RlZERhdGVzWzBdIHx8IGluc3Qub3B0aW9ucy5jYWxlbmRhci50b2RheSgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuICghbWluRGF0ZSB8fCBjdXJEYXRlLmNvbXBhcmVUbyhtaW5EYXRlKSAhPT0gLTEpICYmXHJcblx0XHRcdFx0XHRcdCghbWF4RGF0ZSB8fCBjdXJEYXRlLmNvbXBhcmVUbyhtYXhEYXRlKSAhPT0gKzEpOyB9LFxyXG5cdFx0XHRcdGRhdGU6IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0XHRcdHJldHVybiBpbnN0LnNlbGVjdGVkRGF0ZXNbMF0gfHwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCk7IH0sXHJcblx0XHRcdFx0YWN0aW9uOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdFx0XHR2YXIgY3VyRGF0ZSA9IGluc3Quc2VsZWN0ZWREYXRlc1swXSB8fCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKTtcclxuXHRcdFx0XHRcdHBsdWdpbi5zaG93TW9udGgodGhpcywgY3VyRGF0ZS55ZWFyKCksIGN1ckRhdGUubW9udGgoKSk7IH1cclxuXHRcdFx0fSxcclxuXHRcdFx0dG9kYXk6IHt0ZXh0OiAndG9kYXlUZXh0Jywgc3RhdHVzOiAndG9kYXlTdGF0dXMnLCAvLyBUb2RheSdzIG1vbnRoXHJcblx0XHRcdFx0a2V5c3Ryb2tlOiB7a2V5Q29kZTogMzYsIGN0cmxLZXk6IHRydWV9LCAvLyBDdHJsICsgSG9tZVxyXG5cdFx0XHRcdGVuYWJsZWQ6IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0XHRcdHZhciBtaW5EYXRlID0gaW5zdC5jdXJNaW5EYXRlKCk7XHJcblx0XHRcdFx0XHR2YXIgbWF4RGF0ZSA9IGluc3QuZ2V0KCdtYXhEYXRlJyk7XHJcblx0XHRcdFx0XHRyZXR1cm4gKCFtaW5EYXRlIHx8IGluc3Qub3B0aW9ucy5jYWxlbmRhci50b2RheSgpLmNvbXBhcmVUbyhtaW5EYXRlKSAhPT0gLTEpICYmXHJcblx0XHRcdFx0XHRcdCghbWF4RGF0ZSB8fCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKS5jb21wYXJlVG8obWF4RGF0ZSkgIT09ICsxKTsgfSxcclxuXHRcdFx0XHRkYXRlOiBmdW5jdGlvbihpbnN0KSB7IHJldHVybiBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKTsgfSxcclxuXHRcdFx0XHRhY3Rpb246IGZ1bmN0aW9uKGluc3QpIHsgcGx1Z2luLnNob3dNb250aCh0aGlzKTsgfVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRjbGVhcjoge3RleHQ6ICdjbGVhclRleHQnLCBzdGF0dXM6ICdjbGVhclN0YXR1cycsIC8vIENsZWFyIHRoZSBkYXRlcGlja2VyXHJcblx0XHRcdFx0a2V5c3Ryb2tlOiB7a2V5Q29kZTogMzUsIGN0cmxLZXk6IHRydWV9LCAvLyBDdHJsICsgRW5kXHJcblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkgeyByZXR1cm4gdHJ1ZTsgfSxcclxuXHRcdFx0XHRkYXRlOiBmdW5jdGlvbihpbnN0KSB7IHJldHVybiBudWxsOyB9LFxyXG5cdFx0XHRcdGFjdGlvbjogZnVuY3Rpb24oaW5zdCkgeyBwbHVnaW4uY2xlYXIodGhpcyk7IH1cclxuXHRcdFx0fSxcclxuXHRcdFx0Y2xvc2U6IHt0ZXh0OiAnY2xvc2VUZXh0Jywgc3RhdHVzOiAnY2xvc2VTdGF0dXMnLCAvLyBDbG9zZSB0aGUgZGF0ZXBpY2tlclxyXG5cdFx0XHRcdGtleXN0cm9rZToge2tleUNvZGU6IDI3fSwgLy8gRXNjYXBlXHJcblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkgeyByZXR1cm4gdHJ1ZTsgfSxcclxuXHRcdFx0XHRkYXRlOiBmdW5jdGlvbihpbnN0KSB7IHJldHVybiBudWxsOyB9LFxyXG5cdFx0XHRcdGFjdGlvbjogZnVuY3Rpb24oaW5zdCkgeyBwbHVnaW4uaGlkZSh0aGlzKTsgfVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRwcmV2V2Vlazoge3RleHQ6ICdwcmV2V2Vla1RleHQnLCBzdGF0dXM6ICdwcmV2V2Vla1N0YXR1cycsIC8vIFByZXZpb3VzIHdlZWtcclxuXHRcdFx0XHRrZXlzdHJva2U6IHtrZXlDb2RlOiAzOCwgY3RybEtleTogdHJ1ZX0sIC8vIEN0cmwgKyBVcFxyXG5cdFx0XHRcdGVuYWJsZWQ6IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0XHRcdHZhciBtaW5EYXRlID0gaW5zdC5jdXJNaW5EYXRlKCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gKCFtaW5EYXRlIHx8IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxyXG5cdFx0XHRcdFx0XHRhZGQoLWluc3Qub3B0aW9ucy5jYWxlbmRhci5kYXlzSW5XZWVrKCksICdkJykuY29tcGFyZVRvKG1pbkRhdGUpICE9PSAtMSk7IH0sXHJcblx0XHRcdFx0ZGF0ZTogZnVuY3Rpb24oaW5zdCkgeyByZXR1cm4gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuXHJcblx0XHRcdFx0XHRhZGQoLWluc3Qub3B0aW9ucy5jYWxlbmRhci5kYXlzSW5XZWVrKCksICdkJyk7IH0sXHJcblx0XHRcdFx0YWN0aW9uOiBmdW5jdGlvbihpbnN0KSB7IHBsdWdpbi5jaGFuZ2VEYXkodGhpcywgLWluc3Qub3B0aW9ucy5jYWxlbmRhci5kYXlzSW5XZWVrKCkpOyB9XHJcblx0XHRcdH0sXHJcblx0XHRcdHByZXZEYXk6IHt0ZXh0OiAncHJldkRheVRleHQnLCBzdGF0dXM6ICdwcmV2RGF5U3RhdHVzJywgLy8gUHJldmlvdXMgZGF5XHJcblx0XHRcdFx0a2V5c3Ryb2tlOiB7a2V5Q29kZTogMzcsIGN0cmxLZXk6IHRydWV9LCAvLyBDdHJsICsgTGVmdFxyXG5cdFx0XHRcdGVuYWJsZWQ6IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0XHRcdHZhciBtaW5EYXRlID0gaW5zdC5jdXJNaW5EYXRlKCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gKCFtaW5EYXRlIHx8IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLmFkZCgtMSwgJ2QnKS5cclxuXHRcdFx0XHRcdFx0Y29tcGFyZVRvKG1pbkRhdGUpICE9PSAtMSk7IH0sXHJcblx0XHRcdFx0ZGF0ZTogZnVuY3Rpb24oaW5zdCkgeyByZXR1cm4gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuYWRkKC0xLCAnZCcpOyB9LFxyXG5cdFx0XHRcdGFjdGlvbjogZnVuY3Rpb24oaW5zdCkgeyBwbHVnaW4uY2hhbmdlRGF5KHRoaXMsIC0xKTsgfVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRuZXh0RGF5OiB7dGV4dDogJ25leHREYXlUZXh0Jywgc3RhdHVzOiAnbmV4dERheVN0YXR1cycsIC8vIE5leHQgZGF5XHJcblx0XHRcdFx0a2V5c3Ryb2tlOiB7a2V5Q29kZTogMzksIGN0cmxLZXk6IHRydWV9LCAvLyBDdHJsICsgUmlnaHRcclxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdFx0XHR2YXIgbWF4RGF0ZSA9IGluc3QuZ2V0KCdtYXhEYXRlJyk7XHJcblx0XHRcdFx0XHRyZXR1cm4gKCFtYXhEYXRlIHx8IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLmFkZCgxLCAnZCcpLlxyXG5cdFx0XHRcdFx0XHRjb21wYXJlVG8obWF4RGF0ZSkgIT09ICsxKTsgfSxcclxuXHRcdFx0XHRkYXRlOiBmdW5jdGlvbihpbnN0KSB7IHJldHVybiBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5hZGQoMSwgJ2QnKTsgfSxcclxuXHRcdFx0XHRhY3Rpb246IGZ1bmN0aW9uKGluc3QpIHsgcGx1Z2luLmNoYW5nZURheSh0aGlzLCAxKTsgfVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRuZXh0V2Vlazoge3RleHQ6ICduZXh0V2Vla1RleHQnLCBzdGF0dXM6ICduZXh0V2Vla1N0YXR1cycsIC8vIE5leHQgd2Vla1xyXG5cdFx0XHRcdGtleXN0cm9rZToge2tleUNvZGU6IDQwLCBjdHJsS2V5OiB0cnVlfSwgLy8gQ3RybCArIERvd25cclxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdFx0XHR2YXIgbWF4RGF0ZSA9IGluc3QuZ2V0KCdtYXhEYXRlJyk7XHJcblx0XHRcdFx0XHRyZXR1cm4gKCFtYXhEYXRlIHx8IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxyXG5cdFx0XHRcdFx0XHRhZGQoaW5zdC5vcHRpb25zLmNhbGVuZGFyLmRheXNJbldlZWsoKSwgJ2QnKS5jb21wYXJlVG8obWF4RGF0ZSkgIT09ICsxKTsgfSxcclxuXHRcdFx0XHRkYXRlOiBmdW5jdGlvbihpbnN0KSB7IHJldHVybiBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5cclxuXHRcdFx0XHRcdGFkZChpbnN0Lm9wdGlvbnMuY2FsZW5kYXIuZGF5c0luV2VlaygpLCAnZCcpOyB9LFxyXG5cdFx0XHRcdGFjdGlvbjogZnVuY3Rpb24oaW5zdCkgeyBwbHVnaW4uY2hhbmdlRGF5KHRoaXMsIGluc3Qub3B0aW9ucy5jYWxlbmRhci5kYXlzSW5XZWVrKCkpOyB9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIERldGVybWluZSB3aGV0aGVyIGEgY29tbWFuZCBpcyBlbmFibGVkLlxyXG5cdFx0XHRAY2FsbGJhY2sgQ2FsZW5kYXJzUGlja2VyQ29tbWFuZEVuYWJsZWRcclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoaXMgY29tbWFuZCBpcyBlbmFibGVkLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90LlxyXG5cdFx0XHRAZXhhbXBsZSBlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0cmV0dXJuICEhaW5zdC5jdXJNaW5EYXRlKCk7XHJcbiB9ICovXHJcblxyXG5cdFx0LyoqIENhbGN1bGF0ZSB0aGUgcmVwcmVzZW50YXRpdmUgZGF0ZSBmb3IgYSBjb21tYW5kLlxyXG5cdFx0XHRAY2FsbGJhY2sgQ2FsZW5kYXJzUGlja2VyQ29tbWFuZERhdGVcclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEByZXR1cm4ge0NEYXRlfSBBIGRhdGUgYXBwcm9wcmlhdGUgZm9yIHRoaXMgY29tbWFuZC5cclxuXHRcdFx0QGV4YW1wbGUgZGF0ZTogZnVuY3Rpb24oaW5zdCkge1xyXG5cdHJldHVybiBpbnN0LmN1ck1pbkRhdGUoKTtcclxuIH0gKi9cclxuXHJcblx0XHQvKiogUGVyZm9ybSB0aGUgYWN0aW9uIGZvciBhIGNvbW1hbmQuXHJcblx0XHRcdEBjYWxsYmFjayBDYWxlbmRhcnNQaWNrZXJDb21tYW5kQWN0aW9uXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxyXG5cdFx0XHRAZXhhbXBsZSBkYXRlOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0JC5kYXRlcGljay5zZXREYXRlKGluc3QuZWxlbSwgaW5zdC5jdXJNaW5EYXRlKCkpO1xyXG4gfSAqL1xyXG5cclxuXHRcdC8qKiBDYWxjdWxhdGUgdGhlIHdlZWsgb2YgdGhlIHllYXIgZm9yIGEgZGF0ZS5cclxuXHRcdFx0QGNhbGxiYWNrIENhbGVuZGFyc1BpY2tlckNhbGN1bGF0ZVdlZWtcclxuXHRcdFx0QHBhcmFtIGRhdGUge0NEYXRlfSBUaGUgZGF0ZSB0byBldmFsdWF0ZS5cclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgd2VlayBvZiB0aGUgeWVhci5cclxuXHRcdFx0QGV4YW1wbGUgY2FsY3VsYXRlV2VlazogZnVuY3Rpb24oZGF0ZSkge1xyXG5cdHZhciBzdGFydFllYXIgPSAkLmNhbGVuZGFycy5uZXdEYXRlKGRhdGUueWVhcigpLCAxLCAxKTtcclxuXHRyZXR1cm4gTWF0aC5mbG9vcigoZGF0ZS5kYXlPZlllYXIoKSAtIHN0YXJ0WWVhci5kYXlPZlllYXIoKSkgLyA3KSArIDE7XHJcbiB9ICovXHJcblxyXG5cdFx0LyoqIFByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgYW4gaW5kaXZpZHVhbCBkYXRlIHNob3duIGluIHRoZSBjYWxlbmRhci5cclxuXHRcdFx0QGNhbGxiYWNrIENhbGVuZGFyc1BpY2tlck9uRGF0ZVxyXG5cdFx0XHRAcGFyYW0gZGF0ZSB7Q0RhdGV9IFRoZSBkYXRlIHRvIGV2YWx1YXRlLlxyXG5cdFx0XHRAcmV0dXJuIHtvYmplY3R9IEluZm9ybWF0aW9uIGFib3V0IHRoYXQgZGF0ZSwgd2l0aCB0aGUgcHJvcGVydGllcyBhYm92ZS5cclxuXHRcdFx0QHByb3BlcnR5IHNlbGVjdGFibGUge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoaXMgZGF0ZSBjYW4gYmUgc2VsZWN0ZWQuXHJcblx0XHRcdEBwcm9wZXJ0eSBkYXRlQ2xhc3Mge3N0cmluZ30gQ2xhc3MoZXMpIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGRhdGUuXHJcblx0XHRcdEBwcm9wZXJ0eSBjb250ZW50IHtzdHJpbmd9IFRoZSBkYXRlIGNlbGwgY29udGVudC5cclxuXHRcdFx0QHByb3BlcnR5IHRvb2x0aXAge3N0cmluZ30gQSBwb3B1cCB0b29sdGlwIGZvciB0aGUgZGF0ZS5cclxuXHRcdFx0QGV4YW1wbGUgb25EYXRlOiBmdW5jdGlvbihkYXRlKSB7XHJcblx0cmV0dXJuIHtzZWxlY3RhYmxlOiBkYXRlLmRheSgpID4gMCAmJiBkYXRlLmRheSgpICZsdDsgNSxcclxuXHRcdGRhdGVDbGFzczogZGF0ZS5kYXkoKSA9PT0gNCA/ICdsYXN0LWRheScgOiAnJ307XHJcbiB9ICovXHJcblxyXG5cdFx0LyoqIFVwZGF0ZSB0aGUgZGF0ZXBpY2tlciBkaXNwbGF5LlxyXG5cdFx0XHRAY2FsbGJhY2sgQ2FsZW5kYXJzUGlja2VyT25TaG93XHJcblx0XHRcdEBwYXJhbSBwaWNrZXIge2pRdWVyeX0gVGhlIGRhdGVwaWNrZXIgPGNvZGU+ZGl2PC9jb2RlPiB0byBiZSBzaG93bi5cclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEBleGFtcGxlIG9uU2hvdzogZnVuY3Rpb24ocGlja2VyLCBpbnN0KSB7XHJcblx0cGlja2VyLmFwcGVuZCgnJmx0O2J1dHRvbiB0eXBlPVwiYnV0dG9uXCI+SGkmbHQ7L2J1dHRvbj4nKS5cclxuXHRcdGZpbmQoJ2J1dHRvbjpsYXN0JykuY2xpY2soZnVuY3Rpb24oKSB7XHJcblx0XHRcdGFsZXJ0KCdIaSEnKTtcclxuXHRcdH0pO1xyXG4gfSAqL1xyXG5cclxuXHRcdC8qKiBSZWFjdCB0byBuYXZpZ2F0aW5nIHRocm91Z2ggdGhlIG1vbnRocy95ZWFycy5cclxuXHRcdFx0QGNhbGxiYWNrIENhbGVuZGFyc1BpY2tlck9uQ2hhbmdlTW9udGhZZWFyXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtudW1iZXJ9IFRoZSBuZXcgeWVhci5cclxuXHRcdFx0QHBhcmFtIG1vbnRoIHtudW1iZXJ9IFRoZSBuZXcgbW9udGggKDEgdG8gMTIpLlxyXG5cdFx0XHRAZXhhbXBsZSBvbkNoYW5nZU1vbnRoWWVhcjogZnVuY3Rpb24oeWVhciwgbW9udGgpIHtcclxuXHRhbGVydCgnTm93IGluICcgKyBtb250aCArICcvJyArIHllYXIpO1xyXG4gfSAqL1xyXG5cdFx0XHRcclxuXHRcdC8qKiBEYXRlcGlja2VyIG9uIHNlbGVjdCBjYWxsYmFjay5cclxuXHRcdFx0VHJpZ2dlcmVkIHdoZW4gYSBkYXRlIGlzIHNlbGVjdGVkLlxyXG5cdFx0XHRAY2FsbGJhY2sgQ2FsZW5kYXJzUGlja2VyT25TZWxlY3RcclxuXHRcdFx0QHBhcmFtIGRhdGVzIHtDRGF0ZVtdfSBUaGUgc2VsZWN0ZWQgZGF0ZShzKS5cclxuXHRcdFx0QGV4YW1wbGUgb25TZWxlY3Q6IGZ1bmN0aW9uKGRhdGVzKSB7XHJcbiBcdGFsZXJ0KCdTZWxlY3RlZCAnICsgZGF0ZXMpO1xyXG4gfSAqL1xyXG5cdFx0XHRcclxuXHRcdC8qKiBEYXRlcGlja2VyIG9uIGNsb3NlIGNhbGxiYWNrLlxyXG5cdFx0XHRUcmlnZ2VyZWQgd2hlbiBhIHBvcHVwIGNhbGVuZGFyIGlzIGNsb3NlZC5cclxuXHRcdFx0QGNhbGxiYWNrIENhbGVuZGFyc1BpY2tlck9uQ2xvc2VcclxuXHRcdFx0QHBhcmFtIGRhdGVzIHtDRGF0ZVtdfSBUaGUgc2VsZWN0ZWQgZGF0ZShzKS5cclxuXHRcdFx0QGV4YW1wbGUgb25DbG9zZTogZnVuY3Rpb24oZGF0ZXMpIHtcclxuIFx0YWxlcnQoJ1NlbGVjdGVkICcgKyBkYXRlcyk7XHJcbiB9ICovXHJcblx0XHRcclxuXHRcdC8qKiBEZWZhdWx0IHNldHRpbmdzIGZvciB0aGUgcGx1Z2luLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcm9wZXJ0eSBbY2FsZW5kYXI9JC5jYWxlbmRhcnMuaW5zdGFuY2UoKV0ge0NhbGVuZGFyfSBUaGUgY2FsZW5kYXIgZm9yIHRoaXMgZGF0ZXBpY2tlci5cclxuXHRcdFx0QHByb3BlcnR5IFtwaWNrZXJDbGFzcz0nJ10ge3N0cmluZ30gQ1NTIGNsYXNzIHRvIGFkZCB0byB0aGlzIGluc3RhbmNlIG9mIHRoZSBkYXRlcGlja2VyLlxyXG5cdFx0XHRAcHJvcGVydHkgW3Nob3dPbkZvY3VzPXRydWVdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBmb3IgcG9wdXAgb24gZm9jdXMsIDxjb2RlPmZhbHNlPC9jb2RlPiBmb3Igbm90LlxyXG5cdFx0XHRAcHJvcGVydHkgW3Nob3dUcmlnZ2VyPW51bGxdIHtzdHJpbmd8RWxlbWVudHxqUXVlcnl9IEVsZW1lbnQgdG8gYmUgY2xvbmVkIGZvciBhIHRyaWdnZXIsIDxjb2RlPm51bGw8L2NvZGU+IGZvciBub25lLlxyXG5cdFx0XHRAcHJvcGVydHkgW3Nob3dBbmltPSdzaG93J10ge3N0cmluZ30gTmFtZSBvZiBqUXVlcnkgYW5pbWF0aW9uIGZvciBwb3B1cCwgJycgZm9yIG5vIGFuaW1hdGlvbi5cclxuXHRcdFx0QHByb3BlcnR5IFtzaG93T3B0aW9ucz1udWxsXSB7b2JqZWN0fSBPcHRpb25zIGZvciBlbmhhbmNlZCBhbmltYXRpb25zLlxyXG5cdFx0XHRAcHJvcGVydHkgW3Nob3dTcGVlZD0nbm9ybWFsJ10ge3N0cmluZ30gRHVyYXRpb24gb2YgZGlzcGxheS9jbG9zdXJlLlxyXG5cdFx0XHRAcHJvcGVydHkgW3BvcHVwQ29udGFpbmVyPW51bGxdIHtzdHJpbmd8RWxlbWVudHxqUXVlcnl9IFRoZSBlbGVtZW50IHRvIHdoaWNoIGEgcG9wdXAgY2FsZW5kYXIgaXMgYWRkZWQsIDxjb2RlPm51bGw8L2NvZGU+IGZvciBib2R5LlxyXG5cdFx0XHRAcHJvcGVydHkgW2FsaWdubWVudD0nYm90dG9tJ10ge3N0cmluZ30gQWxpZ25tZW50IG9mIHBvcHVwIC0gd2l0aCBub21pbmF0ZWQgY29ybmVyIG9mIGlucHV0OlxyXG5cdFx0XHRcdFx0XHQndG9wJyBvciAnYm90dG9tJyBhbGlnbnMgZGVwZW5kaW5nIG9uIGxhbmd1YWdlIGRpcmVjdGlvbixcclxuXHRcdFx0XHRcdFx0J3RvcExlZnQnLCAndG9wUmlnaHQnLCAnYm90dG9tTGVmdCcsICdib3R0b21SaWdodCcuXHJcblx0XHRcdEBwcm9wZXJ0eSBbZml4ZWRXZWVrcz1mYWxzZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIGFsd2F5cyBzaG93IDYgd2Vla3MsIDxjb2RlPmZhbHNlPC9jb2RlPiB0byBvbmx5IHNob3cgYXMgbWFueSBhcyBhcmUgbmVlZGVkLlxyXG5cdFx0XHRAcHJvcGVydHkgW2ZpcnN0RGF5PW51bGxdIHtudW1iZXJ9IEZpcnN0IGRheSBvZiB0aGUgd2VlaywgMCA9IFN1bmRheSwgMSA9IE1vbmRheSwgZXRjLiwgPGNvZGU+bnVsbDwvY29kZT4gZm9yIDxjb2RlPmNhbGVuZGFyPC9jb2RlPiBkZWZhdWx0LlxyXG5cdFx0XHRAcHJvcGVydHkgW2NhbGN1bGF0ZVdlZWs9bnVsbF0ge0NhbGVuZGFyc1BpY2tlckNhbGN1bGF0ZVdlZWt9IENhbGN1bGF0ZSB3ZWVrIG9mIHRoZSB5ZWFyIGZyb20gYSBkYXRlLCA8Y29kZT5udWxsPC9jb2RlPiBmb3IgPGNvZGU+Y2FsZW5kYXI8L2NvZGU+IGRlZmF1bHQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbbW9udGhzVG9TaG93PTFdIHtudW1iZXJ8bnVtYmVyW119IEhvdyBtYW55IG1vbnRocyB0byBzaG93LCBjb2xzIG9yIFtyb3dzLCBjb2xzXS5cclxuXHRcdFx0QHByb3BlcnR5IFttb250aHNPZmZzZXQ9MF0ge251bWJlcn0gSG93IG1hbnkgbW9udGhzIHRvIG9mZnNldCB0aGUgcHJpbWFyeSBtb250aCBieTtcclxuXHRcdFx0XHRcdFx0bWF5IGJlIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0aGUgZGF0ZSBhbmQgcmV0dXJucyB0aGUgb2Zmc2V0LlxyXG5cdFx0XHRAcHJvcGVydHkgW21vbnRoc1RvU3RlcD0xXSB7bnVtYmVyfSBIb3cgbWFueSBtb250aHMgdG8gbW92ZSB3aGVuIHByZXYvbmV4dCBjbGlja2VkLlxyXG5cdFx0XHRAcHJvcGVydHkgW21vbnRoc1RvSnVtcD0xMl0ge251bWJlcn0gSG93IG1hbnkgbW9udGhzIHRvIG1vdmUgd2hlbiBsYXJnZSBwcmV2L25leHQgY2xpY2tlZC5cclxuXHRcdFx0QHByb3BlcnR5IFt1c2VNb3VzZVdoZWVsPXRydWVdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiB0byB1c2UgbW91c2V3aGVlbCBpZiBhdmFpbGFibGUsIDxjb2RlPmZhbHNlPC9jb2RlPiB0byBuZXZlciB1c2UgaXQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbY2hhbmdlTW9udGg9dHJ1ZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIGNoYW5nZSBtb250aC95ZWFyIHZpYSBkcm9wLWRvd24sIDxjb2RlPmZhbHNlPC9jb2RlPiBmb3IgbmF2aWdhdGlvbiBvbmx5LlxyXG5cdFx0XHRAcHJvcGVydHkgW3llYXJSYW5nZT0nYy0xMDpjKzEwJ10ge3N0cmluZ30gUmFuZ2Ugb2YgeWVhcnMgdG8gc2hvdyBpbiBkcm9wLWRvd246ICdhbnknIGZvciBkaXJlY3QgdGV4dCBlbnRyeVxyXG5cdFx0XHRcdFx0XHRvciAnc3RhcnQ6ZW5kJywgd2hlcmUgc3RhcnQvZW5kIGFyZSAnKy1ubicgZm9yIHJlbGF0aXZlIHRvIHRvZGF5XHJcblx0XHRcdFx0XHRcdG9yICdjKy1ubicgZm9yIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZGF0ZVxyXG5cdFx0XHRcdFx0XHRvciAnbm5ubicgZm9yIGFuIGFic29sdXRlIHllYXIuXHJcblx0XHRcdEBwcm9wZXJ0eSBbc2hvd090aGVyTW9udGhzPWZhbHNlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gc2hvdyBkYXRlcyBmcm9tIG90aGVyIG1vbnRocywgPGNvZGU+ZmFsc2U8L2NvZGU+IHRvIG5vdCBzaG93IHRoZW0uXHJcblx0XHRcdEBwcm9wZXJ0eSBbc2VsZWN0T3RoZXJNb250aHM9ZmFsc2VdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiB0byBhbGxvdyBzZWxlY3Rpb24gb2YgZGF0ZXMgZnJvbSBvdGhlciBtb250aHMgdG9vLlxyXG5cdFx0XHRAcHJvcGVydHkgW2RlZmF1bHREYXRlPW51bGxdIHtzdHJpbmd8bnVtYmVyfENEYXRlfSBEYXRlIHRvIHNob3cgaWYgbm8gb3RoZXIgc2VsZWN0ZWQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbc2VsZWN0RGVmYXVsdERhdGU9ZmFsc2VdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiB0byBwcmUtc2VsZWN0IHRoZSBkZWZhdWx0IGRhdGUgaWYgbm8gb3RoZXIgaXMgY2hvc2VuLlxyXG5cdFx0XHRAcHJvcGVydHkgW21pbkRhdGU9bnVsbF0ge3N0cmluZ3xudW1iZXJ8Q0RhdGV9IFRoZSBtaW5pbXVtIHNlbGVjdGFibGUgZGF0ZS5cclxuXHRcdFx0QHByb3BlcnR5IFttYXhEYXRlPW51bGxdIHtzdHJpbmd8bnVtYmVyfENEYXRlfSBUaGUgbWF4aW11bSBzZWxlY3RhYmxlIGRhdGUuXHJcblx0XHRcdEBwcm9wZXJ0eSBbZGF0ZUZvcm1hdD0nbW0vZGQveXl5eSddIHtzdHJpbmd9IEZvcm1hdCBmb3IgZGF0ZXMuXHJcblx0XHRcdEBwcm9wZXJ0eSBbYXV0b1NpemU9ZmFsc2VdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiB0byBzaXplIHRoZSBpbnB1dCBmaWVsZCBhY2NvcmRpbmcgdG8gdGhlIGRhdGUgZm9ybWF0LlxyXG5cdFx0XHRAcHJvcGVydHkgW3JhbmdlU2VsZWN0PWZhbHNlXSB7Ym9vbGVhbn0gQWxsb3dzIGZvciBzZWxlY3RpbmcgYSBkYXRlIHJhbmdlIG9uIG9uZSBkYXRlIHBpY2tlci5cclxuXHRcdFx0QHByb3BlcnR5IFtyYW5nZVNlcGFyYXRvcj0nIC0gJ10ge3N0cmluZ30gVGV4dCBiZXR3ZWVuIHR3byBkYXRlcyBpbiBhIHJhbmdlLlxyXG5cdFx0XHRAcHJvcGVydHkgW211bHRpU2VsZWN0PTBdIHtudW1iZXJ9IE1heGltdW0gbnVtYmVyIG9mIHNlbGVjdGFibGUgZGF0ZXMsIHplcm8gZm9yIHNpbmdsZSBzZWxlY3QuXHJcblx0XHRcdEBwcm9wZXJ0eSBbbXVsdGlTZXBhcmF0b3I9JywnXSB7c3RyaW5nfSBUZXh0IGJldHdlZW4gbXVsdGlwbGUgZGF0ZXMuXHJcblx0XHRcdEBwcm9wZXJ0eSBbb25EYXRlPW51bGxdIHtDYWxlbmRhcnNQaWNrZXJPbkRhdGV9IENhbGxiYWNrIGFzIGEgZGF0ZSBpcyBhZGRlZCB0byB0aGUgZGF0ZXBpY2tlci5cclxuXHRcdFx0QHByb3BlcnR5IFtvblNob3c9bnVsbF0ge0NhbGVuZGFyc1BpY2tlck9uU2hvd30gQ2FsbGJhY2sganVzdCBiZWZvcmUgYSBkYXRlcGlja2VyIGlzIHNob3duLlxyXG5cdFx0XHRAcHJvcGVydHkgW29uQ2hhbmdlTW9udGhZZWFyPW51bGxdIHtDYWxlbmRhcnNQaWNrZXJPbkNoYW5nZU1vbnRoWWVhcn0gQ2FsbGJhY2sgd2hlbiBhIG5ldyBtb250aC95ZWFyIGlzIHNlbGVjdGVkLlxyXG5cdFx0XHRAcHJvcGVydHkgW29uU2VsZWN0PW51bGxdIHtDYWxlbmRhcnNQaWNrZXJPblNlbGVjdH0gQ2FsbGJhY2sgd2hlbiBhIGRhdGUgaXMgc2VsZWN0ZWQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbb25DbG9zZT1udWxsXSB7Q2FsZW5kYXJzUGlja2VyT25DbG9zZX0gQ2FsbGJhY2sgd2hlbiBhIGRhdGVwaWNrZXIgaXMgY2xvc2VkLlxyXG5cdFx0XHRAcHJvcGVydHkgW2FsdEZpZWxkPW51bGxdIHtzdHJpbmd8RWxlbWVudHxqUXVlcnl9IEFsdGVybmF0ZSBmaWVsZCB0byB1cGRhdGUgaW4gc3luY2ggd2l0aCB0aGUgZGF0ZXBpY2tlci5cclxuXHRcdFx0QHByb3BlcnR5IFthbHRGb3JtYXQ9bnVsbF0ge3N0cmluZ30gRGF0ZSBmb3JtYXQgZm9yIGFsdGVybmF0ZSBmaWVsZCwgZGVmYXVsdHMgdG8gPGNvZGU+ZGF0ZUZvcm1hdDwvY29kZT4uXHJcblx0XHRcdEBwcm9wZXJ0eSBbY29uc3RyYWluSW5wdXQ9dHJ1ZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIGNvbnN0cmFpbiB0eXBlZCBpbnB1dCB0byA8Y29kZT5kYXRlRm9ybWF0PC9jb2RlPiBhbGxvd2VkIGNoYXJhY3RlcnMuXHJcblx0XHRcdEBwcm9wZXJ0eSBbY29tbWFuZHNBc0RhdGVGb3JtYXQ9ZmFsc2VdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiB0byBhcHBseVxyXG5cdFx0XHRcdFx0XHQ8Y29kZT48YSBocmVmPVwiI2Zvcm1hdERhdGVcIj5mb3JtYXREYXRlPC9hPjwvY29kZT4gdG8gdGhlIGNvbW1hbmQgdGV4dHMuXHJcblx0XHRcdEBwcm9wZXJ0eSBbY29tbWFuZHM9dGhpcy5jb21tYW5kc10ge29iamVjdH0gQ29tbWFuZCBhY3Rpb25zIHRoYXQgbWF5IGJlIGFkZGVkIHRvIGEgbGF5b3V0IGJ5IG5hbWUuICovXHJcblx0XHRkZWZhdWx0T3B0aW9uczoge1xyXG5cdFx0XHRjYWxlbmRhcjogJC5jYWxlbmRhcnMuaW5zdGFuY2UoKSxcclxuXHRcdFx0cGlja2VyQ2xhc3M6ICcnLFxyXG5cdFx0XHRzaG93T25Gb2N1czogdHJ1ZSxcclxuXHRcdFx0c2hvd1RyaWdnZXI6IG51bGwsXHJcblx0XHRcdHNob3dBbmltOiAnc2hvdycsXHJcblx0XHRcdHNob3dPcHRpb25zOiB7fSxcclxuXHRcdFx0c2hvd1NwZWVkOiAnbm9ybWFsJyxcclxuXHRcdFx0cG9wdXBDb250YWluZXI6IG51bGwsXHJcblx0XHRcdGFsaWdubWVudDogJ2JvdHRvbScsXHJcblx0XHRcdGZpeGVkV2Vla3M6IGZhbHNlLFxyXG5cdFx0XHRmaXJzdERheTogbnVsbCxcclxuXHRcdFx0Y2FsY3VsYXRlV2VlazogbnVsbCxcclxuXHRcdFx0bW9udGhzVG9TaG93OiAxLFxyXG5cdFx0XHRtb250aHNPZmZzZXQ6IDAsXHJcblx0XHRcdG1vbnRoc1RvU3RlcDogMSxcclxuXHRcdFx0bW9udGhzVG9KdW1wOiAxMixcclxuXHRcdFx0dXNlTW91c2VXaGVlbDogdHJ1ZSxcclxuXHRcdFx0Y2hhbmdlTW9udGg6IHRydWUsXHJcblx0XHRcdHllYXJSYW5nZTogJ2MtMTA6YysxMCcsXHJcblx0XHRcdHNob3dPdGhlck1vbnRoczogZmFsc2UsXHJcblx0XHRcdHNlbGVjdE90aGVyTW9udGhzOiBmYWxzZSxcclxuXHRcdFx0ZGVmYXVsdERhdGU6IG51bGwsXHJcblx0XHRcdHNlbGVjdERlZmF1bHREYXRlOiBmYWxzZSxcclxuXHRcdFx0bWluRGF0ZTogbnVsbCxcclxuXHRcdFx0bWF4RGF0ZTogbnVsbCxcclxuXHRcdFx0ZGF0ZUZvcm1hdDogbnVsbCxcclxuXHRcdFx0YXV0b1NpemU6IGZhbHNlLFxyXG5cdFx0XHRyYW5nZVNlbGVjdDogZmFsc2UsXHJcblx0XHRcdHJhbmdlU2VwYXJhdG9yOiAnIC0gJyxcclxuXHRcdFx0bXVsdGlTZWxlY3Q6IDAsXHJcblx0XHRcdG11bHRpU2VwYXJhdG9yOiAnLCcsXHJcblx0XHRcdG9uRGF0ZTogbnVsbCxcclxuXHRcdFx0b25TaG93OiBudWxsLFxyXG5cdFx0XHRvbkNoYW5nZU1vbnRoWWVhcjogbnVsbCxcclxuXHRcdFx0b25TZWxlY3Q6IG51bGwsXHJcblx0XHRcdG9uQ2xvc2U6IG51bGwsXHJcblx0XHRcdGFsdEZpZWxkOiBudWxsLFxyXG5cdFx0XHRhbHRGb3JtYXQ6IG51bGwsXHJcblx0XHRcdGNvbnN0cmFpbklucHV0OiB0cnVlLFxyXG5cdFx0XHRjb21tYW5kc0FzRGF0ZUZvcm1hdDogZmFsc2UsXHJcblx0XHRcdGNvbW1hbmRzOiB7fSAvLyB0aGlzLmNvbW1hbmRzXHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBMb2NhbGlzYXRpb25zIGZvciB0aGUgcGx1Z2luLlxyXG5cdFx0XHRFbnRyaWVzIGFyZSBvYmplY3RzIGluZGV4ZWQgYnkgdGhlIGxhbmd1YWdlIGNvZGUgKCcnIGJlaW5nIHRoZSBkZWZhdWx0IFVTL0VuZ2xpc2gpLlxyXG5cdFx0XHRFYWNoIG9iamVjdCBoYXMgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcm9wZXJ0eSBbcmVuZGVyZXI9dGhpcy5kZWZhdWx0UmVuZGVyZXJdIHtzdHJpbmd9IFRoZSByZW5kZXJpbmcgdGVtcGxhdGVzLlxyXG5cdFx0XHRAcHJvcGVydHkgW3ByZXZUZXh0PScmbHQ7UHJldiddIHtzdHJpbmd9IFRleHQgZm9yIHRoZSBwcmV2aW91cyBtb250aCBjb21tYW5kLlxyXG5cdFx0XHRAcHJvcGVydHkgW3ByZXZTdGF0dXM9J1Nob3cgdGhlIHByZXZpb3VzIG1vbnRoJ10ge3N0cmluZ30gU3RhdHVzIHRleHQgZm9yIHRoZSBwcmV2aW91cyBtb250aCBjb21tYW5kLlxyXG5cdFx0XHRAcHJvcGVydHkgW3ByZXZKdW1wVGV4dD0nJmx0OyZsdDsnXSB7c3RyaW5nfSBUZXh0IGZvciB0aGUgcHJldmlvdXMgeWVhciBjb21tYW5kLlxyXG5cdFx0XHRAcHJvcGVydHkgW3ByZXZKdW1wU3RhdHVzPSdTaG93IHRoZSBwcmV2aW91cyB5ZWFyJ10ge3N0cmluZ30gU3RhdHVzIHRleHQgZm9yIHRoZSBwcmV2aW91cyB5ZWFyIGNvbW1hbmQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbbmV4dFRleHQ9J05leHQmZ3Q7J10ge3N0cmluZ30gVGV4dCBmb3IgdGhlIG5leHQgbW9udGggY29tbWFuZC5cclxuXHRcdFx0QHByb3BlcnR5IFtuZXh0U3RhdHVzPSdTaG93IHRoZSBuZXh0IG1vbnRoJ10ge3N0cmluZ30gU3RhdHVzIHRleHQgZm9yIHRoZSBuZXh0IG1vbnRoIGNvbW1hbmQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbbmV4dEp1bXBUZXh0PScmZ3Q7Jmd0OyddIHtzdHJpbmd9IFRleHQgZm9yIHRoZSBuZXh0IHllYXIgY29tbWFuZC5cclxuXHRcdFx0QHByb3BlcnR5IFtuZXh0SnVtcFN0YXR1cz0nU2hvdyB0aGUgbmV4dCB5ZWFyJ10ge3N0cmluZ30gU3RhdHVzIHRleHQgZm9yIHRoZSBuZXh0IHllYXIgY29tbWFuZC5cclxuXHRcdFx0QHByb3BlcnR5IFtjdXJyZW50VGV4dD0nQ3VycmVudCddIHtzdHJpbmd9IFRleHQgZm9yIHRoZSBjdXJyZW50IG1vbnRoIGNvbW1hbmQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbY3VycmVudFN0YXR1cz0nU2hvdyB0aGUgY3VycmVudCBtb250aCddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IGZvciB0aGUgY3VycmVudCBtb250aCBjb21tYW5kLlxyXG5cdFx0XHRAcHJvcGVydHkgW3RvZGF5VGV4dD0nVG9kYXknXSB7c3RyaW5nfSBUZXh0IGZvciB0aGUgdG9kYXkncyBtb250aCBjb21tYW5kLlxyXG5cdFx0XHRAcHJvcGVydHkgW3RvZGF5U3RhdHVzPSdTaG93IHRvZGF5XFwncyBtb250aCddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IGZvciB0aGUgdG9kYXkncyBtb250aCBjb21tYW5kLlxyXG5cdFx0XHRAcHJvcGVydHkgW2NsZWFyVGV4dD0nQ2xlYXInXSB7c3RyaW5nfSBUZXh0IGZvciB0aGUgY2xlYXIgY29tbWFuZC5cclxuXHRcdFx0QHByb3BlcnR5IFtjbGVhclN0YXR1cz0nQ2xlYXIgYWxsIHRoZSBkYXRlcyddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IGZvciB0aGUgY2xlYXIgY29tbWFuZC5cclxuXHRcdFx0QHByb3BlcnR5IFtjbG9zZVRleHQ9J0Nsb3NlJ10ge3N0cmluZ30gVGV4dCBmb3IgdGhlIGNsb3NlIGNvbW1hbmQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbY2xvc2VTdGF0dXM9J0Nsb3NlIHRoZSBkYXRlcGlja2VyJ10ge3N0cmluZ30gU3RhdHVzIHRleHQgZm9yIHRoZSBjbG9zZSBjb21tYW5kLlxyXG5cdFx0XHRAcHJvcGVydHkgW3llYXJTdGF0dXM9J0NoYW5nZSB0aGUgeWVhciddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IGZvciB5ZWFyIHNlbGVjdGlvbi5cclxuXHRcdFx0QHByb3BlcnR5IFtlYXJsaWVyVGV4dD0nJiMxNjA7JiMxNjA74payJ10ge3N0cmluZ30gVGV4dCBmb3IgZWFybGllciB5ZWFycy5cclxuXHRcdFx0QHByb3BlcnR5IFtsYXRlclRleHQ9JyYjMTYwOyYjMTYwO+KWvCddIHtzdHJpbmd9IFRleHQgZm9yIGxhdGVyIHllYXJzLlxyXG5cdFx0XHRAcHJvcGVydHkgW21vbnRoU3RhdHVzPSdDaGFuZ2UgdGhlIG1vbnRoJ10ge3N0cmluZ30gU3RhdHVzIHRleHQgZm9yIG1vbnRoIHNlbGVjdGlvbi5cclxuXHRcdFx0QHByb3BlcnR5IFt3ZWVrVGV4dD0nV2snXSB7c3RyaW5nfSBUZXh0IGZvciB3ZWVrIG9mIHRoZSB5ZWFyIGNvbHVtbiBoZWFkZXIuXHJcblx0XHRcdEBwcm9wZXJ0eSBbd2Vla1N0YXR1cz0nV2VlayBvZiB0aGUgeWVhciddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IGZvciB3ZWVrIG9mIHRoZSB5ZWFyIGNvbHVtbiBoZWFkZXIuXHJcblx0XHRcdEBwcm9wZXJ0eSBbZGF5U3RhdHVzPSdTZWxlY3QgREQsJiMxNjA7TSYjMTYwO2QsJiMxNjA7eXl5eSddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IGZvciBzZWxlY3RhYmxlIGRheXMuXHJcblx0XHRcdEBwcm9wZXJ0eSBbZGVmYXVsdFN0YXR1cz0nU2VsZWN0IGEgZGF0ZSddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IHNob3duIGJ5IGRlZmF1bHQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbaXNSVEw9ZmFsc2VdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBsYW5ndWFnZSBpcyByaWdodC10by1sZWZ0LiAqL1xyXG5cdFx0cmVnaW9uYWxPcHRpb25zOiB7IC8vIEF2YWlsYWJsZSByZWdpb25hbCBzZXR0aW5ncywgaW5kZXhlZCBieSBsYW5ndWFnZS9jb3VudHJ5IGNvZGVcclxuXHRcdFx0Jyc6IHsgLy8gRGVmYXVsdCByZWdpb25hbCBzZXR0aW5ncyAtIEVuZ2xpc2gvVVNcclxuXHRcdFx0XHRyZW5kZXJlcjoge30sIC8vIHRoaXMuZGVmYXVsdFJlbmRlcmVyXHJcblx0XHRcdFx0cHJldlRleHQ6ICcmbHQ7UHJldicsXHJcblx0XHRcdFx0cHJldlN0YXR1czogJ1Nob3cgdGhlIHByZXZpb3VzIG1vbnRoJyxcclxuXHRcdFx0XHRwcmV2SnVtcFRleHQ6ICcmbHQ7Jmx0OycsXHJcblx0XHRcdFx0cHJldkp1bXBTdGF0dXM6ICdTaG93IHRoZSBwcmV2aW91cyB5ZWFyJyxcclxuXHRcdFx0XHRuZXh0VGV4dDogJ05leHQmZ3Q7JyxcclxuXHRcdFx0XHRuZXh0U3RhdHVzOiAnU2hvdyB0aGUgbmV4dCBtb250aCcsXHJcblx0XHRcdFx0bmV4dEp1bXBUZXh0OiAnJmd0OyZndDsnLFxyXG5cdFx0XHRcdG5leHRKdW1wU3RhdHVzOiAnU2hvdyB0aGUgbmV4dCB5ZWFyJyxcclxuXHRcdFx0XHRjdXJyZW50VGV4dDogJ0N1cnJlbnQnLFxyXG5cdFx0XHRcdGN1cnJlbnRTdGF0dXM6ICdTaG93IHRoZSBjdXJyZW50IG1vbnRoJyxcclxuXHRcdFx0XHR0b2RheVRleHQ6ICdUb2RheScsXHJcblx0XHRcdFx0dG9kYXlTdGF0dXM6ICdTaG93IHRvZGF5XFwncyBtb250aCcsXHJcblx0XHRcdFx0Y2xlYXJUZXh0OiAnQ2xlYXInLFxyXG5cdFx0XHRcdGNsZWFyU3RhdHVzOiAnQ2xlYXIgYWxsIHRoZSBkYXRlcycsXHJcblx0XHRcdFx0Y2xvc2VUZXh0OiAnQ2xvc2UnLFxyXG5cdFx0XHRcdGNsb3NlU3RhdHVzOiAnQ2xvc2UgdGhlIGRhdGVwaWNrZXInLFxyXG5cdFx0XHRcdHllYXJTdGF0dXM6ICdDaGFuZ2UgdGhlIHllYXInLFxyXG5cdFx0XHRcdGVhcmxpZXJUZXh0OiAnJiMxNjA7JiMxNjA74payJyxcclxuXHRcdFx0XHRsYXRlclRleHQ6ICcmIzE2MDsmIzE2MDvilrwnLFxyXG5cdFx0XHRcdG1vbnRoU3RhdHVzOiAnQ2hhbmdlIHRoZSBtb250aCcsXHJcblx0XHRcdFx0d2Vla1RleHQ6ICdXaycsXHJcblx0XHRcdFx0d2Vla1N0YXR1czogJ1dlZWsgb2YgdGhlIHllYXInLFxyXG5cdFx0XHRcdGRheVN0YXR1czogJ1NlbGVjdCBERCwgTSBkLCB5eXl5JyxcclxuXHRcdFx0XHRkZWZhdWx0U3RhdHVzOiAnU2VsZWN0IGEgZGF0ZScsXHJcblx0XHRcdFx0aXNSVEw6IGZhbHNlXHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8qKiBOYW1lcyBvZiBnZXR0ZXIgbWV0aG9kcyAtIHRob3NlIHRoYXQgY2FuJ3QgYmUgY2hhaW5lZC5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlciAqL1xyXG5cdFx0X2dldHRlcnM6IFsnZ2V0RGF0ZScsICdpc0Rpc2FibGVkJywgJ2lzU2VsZWN0YWJsZScsICdyZXRyaWV2ZURhdGUnXSxcclxuXHJcblx0XHRfZGlzYWJsZWQ6IFtdLFxyXG5cdFx0XHJcblx0XHRfcG9wdXBDbGFzczogJ2NhbGVuZGFycy1wb3B1cCcsIC8vIE1hcmtlciBmb3IgcG9wdXAgZGl2aXNpb25cclxuXHRcdF90cmlnZ2VyQ2xhc3M6ICdjYWxlbmRhcnMtdHJpZ2dlcicsIC8vIE1hcmtlciBmb3IgdHJpZ2dlciBlbGVtZW50XHJcblx0XHRfZGlzYWJsZUNsYXNzOiAnY2FsZW5kYXJzLWRpc2FibGUnLCAvLyBNYXJrZXIgZm9yIGRpc2FibGVkIGVsZW1lbnRcclxuXHRcdF9tb250aFllYXJDbGFzczogJ2NhbGVuZGFycy1tb250aC15ZWFyJywgLy8gTWFya2VyIGZvciBtb250aC95ZWFyIGlucHV0c1xyXG5cdFx0X2N1ck1vbnRoQ2xhc3M6ICdjYWxlbmRhcnMtbW9udGgtJywgLy8gTWFya2VyIGZvciBjdXJyZW50IG1vbnRoL3llYXJcclxuXHRcdF9hbnlZZWFyQ2xhc3M6ICdjYWxlbmRhcnMtYW55LXllYXInLCAvLyBNYXJrZXIgZm9yIHllYXIgZGlyZWN0IGlucHV0XHJcblx0XHRfY3VyRG9XQ2xhc3M6ICdjYWxlbmRhcnMtZG93LScsIC8vIE1hcmtlciBmb3IgZGF5IG9mIHdlZWtcclxuXHJcblx0XHRfaW5pdDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHRoaXMuZGVmYXVsdE9wdGlvbnMuY29tbWFuZHMgPSB0aGlzLmNvbW1hbmRzO1xyXG5cdFx0XHR0aGlzLnJlZ2lvbmFsT3B0aW9uc1snJ10ucmVuZGVyZXIgPSB0aGlzLmRlZmF1bHRSZW5kZXJlcjtcclxuXHRcdFx0dGhpcy5fc3VwZXIoKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0X2luc3RTZXR0aW5nczogZnVuY3Rpb24oZWxlbSwgb3B0aW9ucykge1xyXG5cdFx0XHRyZXR1cm4ge3NlbGVjdGVkRGF0ZXM6IFtdLCBkcmF3RGF0ZTogbnVsbCwgcGlja2luZ1JhbmdlOiBmYWxzZSxcclxuXHRcdFx0XHRpbmxpbmU6ICgkLmluQXJyYXkoZWxlbVswXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCBbJ2RpdicsICdzcGFuJ10pID4gLTEpLFxyXG5cdFx0XHRcdGdldDogZnVuY3Rpb24obmFtZSkgeyAvLyBHZXQgYSBzZXR0aW5nIHZhbHVlLCBjb21wdXRpbmcgaWYgbmVjZXNzYXJ5XHJcblx0XHRcdFx0XHRpZiAoJC5pbkFycmF5KG5hbWUsIFsnZGVmYXVsdERhdGUnLCAnbWluRGF0ZScsICdtYXhEYXRlJ10pID4gLTEpIHsgLy8gRGVjb2RlIGRhdGUgc2V0dGluZ3NcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jYWxlbmRhci5kZXRlcm1pbmVEYXRlKHRoaXMub3B0aW9uc1tuYW1lXSwgbnVsbCxcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnNlbGVjdGVkRGF0ZXNbMF0sIHRoaXMuZ2V0KCdkYXRlRm9ybWF0JyksIHRoaXMuZ2V0Q29uZmlnKCkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKG5hbWUgPT09ICdkYXRlRm9ybWF0Jykge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmRhdGVGb3JtYXQgfHwgdGhpcy5vcHRpb25zLmNhbGVuZGFyLmxvY2FsLmRhdGVGb3JtYXQ7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zW25hbWVdO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0Y3VyTWluRGF0ZTogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gKHRoaXMucGlja2luZ1JhbmdlID8gdGhpcy5zZWxlY3RlZERhdGVzWzBdIDogdGhpcy5nZXQoJ21pbkRhdGUnKSk7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRnZXRDb25maWc6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHtkYXlOYW1lc1Nob3J0OiB0aGlzLm9wdGlvbnMuZGF5TmFtZXNTaG9ydCwgZGF5TmFtZXM6IHRoaXMub3B0aW9ucy5kYXlOYW1lcyxcclxuXHRcdFx0XHRcdFx0bW9udGhOYW1lc1Nob3J0OiB0aGlzLm9wdGlvbnMubW9udGhOYW1lc1Nob3J0LCBtb250aE5hbWVzOiB0aGlzLm9wdGlvbnMubW9udGhOYW1lcyxcclxuXHRcdFx0XHRcdFx0Y2FsY3VsYXRlV2VlazogdGhpcy5vcHRpb25zLmNhbGN1bGF0ZVdlZWssIHNob3J0WWVhckN1dG9mZjogdGhpcy5vcHRpb25zLnNob3J0WWVhckN1dG9mZn07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0fSxcclxuXHJcblx0XHRfcG9zdEF0dGFjaDogZnVuY3Rpb24oZWxlbSwgaW5zdCkge1xyXG5cdFx0XHRpZiAoaW5zdC5pbmxpbmUpIHtcclxuXHRcdFx0XHRpbnN0LmRyYXdEYXRlID0gcGx1Z2luLl9jaGVja01pbk1heCgoaW5zdC5zZWxlY3RlZERhdGVzWzBdIHx8XHJcblx0XHRcdFx0XHRpbnN0LmdldCgnZGVmYXVsdERhdGUnKSB8fCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKSkubmV3RGF0ZSgpLCBpbnN0KTtcclxuXHRcdFx0XHRpbnN0LnByZXZEYXRlID0gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCk7XHJcblx0XHRcdFx0dGhpcy5fdXBkYXRlKGVsZW1bMF0pO1xyXG5cdFx0XHRcdGlmICgkLmZuLm1vdXNld2hlZWwpIHtcclxuXHRcdFx0XHRcdGVsZW0ubW91c2V3aGVlbCh0aGlzLl9kb01vdXNlV2hlZWwpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHR0aGlzLl9hdHRhY2htZW50cyhlbGVtLCBpbnN0KTtcclxuXHRcdFx0XHRlbGVtLm9uKCdrZXlkb3duLicgKyBpbnN0Lm5hbWUsIHRoaXMuX2tleURvd24pLm9uKCdrZXlwcmVzcy4nICsgaW5zdC5uYW1lLCB0aGlzLl9rZXlQcmVzcykuXHJcblx0XHRcdFx0XHRvbigna2V5dXAuJyArIGluc3QubmFtZSwgdGhpcy5fa2V5VXApO1xyXG5cdFx0XHRcdGlmIChlbGVtLmF0dHIoJ2Rpc2FibGVkJykpIHtcclxuXHRcdFx0XHRcdHRoaXMuZGlzYWJsZShlbGVtWzBdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0X29wdGlvbnNDaGFuZ2VkOiBmdW5jdGlvbihlbGVtLCBpbnN0LCBvcHRpb25zKSB7XHJcblx0XHRcdGlmIChvcHRpb25zLmNhbGVuZGFyICYmIG9wdGlvbnMuY2FsZW5kYXIgIT09IGluc3Qub3B0aW9ucy5jYWxlbmRhcikge1xyXG5cdFx0XHRcdHZhciBkaXNjYXJkRGF0ZSA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuXHRcdFx0XHRcdHJldHVybiAodHlwZW9mIGluc3Qub3B0aW9uc1tuYW1lXSA9PT0gJ29iamVjdCcgPyBudWxsIDogaW5zdC5vcHRpb25zW25hbWVdKTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdG9wdGlvbnMgPSAkLmV4dGVuZCh7ZGVmYXVsdERhdGU6IGRpc2NhcmREYXRlKCdkZWZhdWx0RGF0ZScpLFxyXG5cdFx0XHRcdFx0bWluRGF0ZTogZGlzY2FyZERhdGUoJ21pbkRhdGUnKSwgbWF4RGF0ZTogZGlzY2FyZERhdGUoJ21heERhdGUnKX0sIG9wdGlvbnMpO1xyXG5cdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlcyA9IFtdO1xyXG5cdFx0XHRcdGluc3QuZHJhd0RhdGUgPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBkYXRlcyA9IGluc3Quc2VsZWN0ZWREYXRlcztcclxuXHRcdFx0JC5leHRlbmQoaW5zdC5vcHRpb25zLCBvcHRpb25zKTtcclxuXHRcdFx0dGhpcy5zZXREYXRlKGVsZW1bMF0sIGRhdGVzLCBudWxsLCBmYWxzZSwgdHJ1ZSk7XHJcblx0XHRcdGluc3QucGlja2luZ1JhbmdlID0gZmFsc2U7XHJcblx0XHRcdHZhciBjYWxlbmRhciA9IGluc3Qub3B0aW9ucy5jYWxlbmRhcjtcclxuXHRcdFx0dmFyIGRlZmF1bHREYXRlID0gaW5zdC5nZXQoJ2RlZmF1bHREYXRlJyk7XHJcblx0XHRcdGluc3QuZHJhd0RhdGUgPSB0aGlzLl9jaGVja01pbk1heCgoZGVmYXVsdERhdGUgPyBkZWZhdWx0RGF0ZSA6IGluc3QuZHJhd0RhdGUpIHx8XHJcblx0XHRcdFx0ZGVmYXVsdERhdGUgfHwgY2FsZW5kYXIudG9kYXkoKSwgaW5zdCkubmV3RGF0ZSgpO1xyXG5cdFx0XHRpZiAoIWluc3QuaW5saW5lKSB7XHJcblx0XHRcdFx0dGhpcy5fYXR0YWNobWVudHMoZWxlbSwgaW5zdCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGluc3QuaW5saW5lIHx8IGluc3QuZGl2KSB7XHJcblx0XHRcdFx0dGhpcy5fdXBkYXRlKGVsZW1bMF0pO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBBdHRhY2ggZXZlbnRzIGFuZCB0cmlnZ2VyLCBpZiBuZWNlc3NhcnkuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGVsZW0ge2pRdWVyeX0gVGhlIGNvbnRyb2wgdG8gYWZmZWN0LlxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy4gKi9cclxuXHRcdF9hdHRhY2htZW50czogZnVuY3Rpb24oZWxlbSwgaW5zdCkge1xyXG5cdFx0XHRlbGVtLm9mZignZm9jdXMuJyArIGluc3QubmFtZSk7XHJcblx0XHRcdGlmIChpbnN0Lm9wdGlvbnMuc2hvd09uRm9jdXMpIHtcclxuXHRcdFx0XHRlbGVtLm9uKCdmb2N1cy4nICsgaW5zdC5uYW1lLCB0aGlzLnNob3cpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChpbnN0LnRyaWdnZXIpIHtcclxuXHRcdFx0XHRpbnN0LnRyaWdnZXIucmVtb3ZlKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIHRyaWdnZXIgPSBpbnN0Lm9wdGlvbnMuc2hvd1RyaWdnZXI7XHJcblx0XHRcdGluc3QudHJpZ2dlciA9ICghdHJpZ2dlciA/ICQoW10pIDpcclxuXHRcdFx0XHQkKHRyaWdnZXIpLmNsb25lKCkucmVtb3ZlQXR0cignaWQnKS5hZGRDbGFzcyh0aGlzLl90cmlnZ2VyQ2xhc3MpXHJcblx0XHRcdFx0XHRbaW5zdC5vcHRpb25zLmlzUlRMID8gJ2luc2VydEJlZm9yZScgOiAnaW5zZXJ0QWZ0ZXInXShlbGVtKS5cclxuXHRcdFx0XHRcdGNsaWNrKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRpZiAoIXBsdWdpbi5pc0Rpc2FibGVkKGVsZW1bMF0pKSB7XHJcblx0XHRcdFx0XHRcdFx0cGx1Z2luW3BsdWdpbi5jdXJJbnN0ID09PSBpbnN0ID8gJ2hpZGUnIDogJ3Nob3cnXShlbGVtWzBdKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSkpO1xyXG5cdFx0XHR0aGlzLl9hdXRvU2l6ZShlbGVtLCBpbnN0KTtcclxuXHRcdFx0dmFyIGRhdGVzID0gdGhpcy5fZXh0cmFjdERhdGVzKGluc3QsIGVsZW0udmFsKCkpO1xyXG5cdFx0XHRpZiAoZGF0ZXMpIHtcclxuXHRcdFx0XHR0aGlzLnNldERhdGUoZWxlbVswXSwgZGF0ZXMsIG51bGwsIHRydWUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBkZWZhdWx0RGF0ZSA9IGluc3QuZ2V0KCdkZWZhdWx0RGF0ZScpO1xyXG5cdFx0XHRpZiAoaW5zdC5vcHRpb25zLnNlbGVjdERlZmF1bHREYXRlICYmIGRlZmF1bHREYXRlICYmIGluc3Quc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0XHR0aGlzLnNldERhdGUoZWxlbVswXSwgKGRlZmF1bHREYXRlIHx8IGluc3Qub3B0aW9ucy5jYWxlbmRhci50b2RheSgpKS5uZXdEYXRlKCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBBcHBseSB0aGUgbWF4aW11bSBsZW5ndGggZm9yIHRoZSBkYXRlIGZvcm1hdC5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7alF1ZXJ5fSBUaGUgY29udHJvbCB0byBhZmZlY3QuXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLiAqL1xyXG5cdFx0X2F1dG9TaXplOiBmdW5jdGlvbihlbGVtLCBpbnN0KSB7XHJcblx0XHRcdGlmIChpbnN0Lm9wdGlvbnMuYXV0b1NpemUgJiYgIWluc3QuaW5saW5lKSB7XHJcblx0XHRcdFx0dmFyIGNhbGVuZGFyID0gaW5zdC5vcHRpb25zLmNhbGVuZGFyO1xyXG5cdFx0XHRcdHZhciBkYXRlID0gY2FsZW5kYXIubmV3RGF0ZSgyMDA5LCAxMCwgMjApOyAvLyBFbnN1cmUgZG91YmxlIGRpZ2l0c1xyXG5cdFx0XHRcdHZhciBkYXRlRm9ybWF0ID0gaW5zdC5nZXQoJ2RhdGVGb3JtYXQnKTtcclxuXHRcdFx0XHRpZiAoZGF0ZUZvcm1hdC5tYXRjaCgvW0RNXS8pKSB7XHJcblx0XHRcdFx0XHR2YXIgZmluZE1heCA9IGZ1bmN0aW9uKG5hbWVzKSB7XHJcblx0XHRcdFx0XHRcdHZhciBtYXggPSAwO1xyXG5cdFx0XHRcdFx0XHR2YXIgbWF4SSA9IDA7XHJcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAobmFtZXNbaV0ubGVuZ3RoID4gbWF4KSB7XHJcblx0XHRcdFx0XHRcdFx0XHRtYXggPSBuYW1lc1tpXS5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdFx0XHRtYXhJID0gaTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0cmV0dXJuIG1heEk7XHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0ZGF0ZS5tb250aChmaW5kTWF4KGNhbGVuZGFyLmxvY2FsW2RhdGVGb3JtYXQubWF0Y2goL01NLykgPyAvLyBMb25nZXN0IG1vbnRoXHJcblx0XHRcdFx0XHRcdCdtb250aE5hbWVzJyA6ICdtb250aE5hbWVzU2hvcnQnXSkgKyAxKTtcclxuXHRcdFx0XHRcdGRhdGUuZGF5KGZpbmRNYXgoY2FsZW5kYXIubG9jYWxbZGF0ZUZvcm1hdC5tYXRjaCgvREQvKSA/IC8vIExvbmdlc3QgZGF5XHJcblx0XHRcdFx0XHRcdCdkYXlOYW1lcycgOiAnZGF5TmFtZXNTaG9ydCddKSArIDIwIC0gZGF0ZS5kYXlPZldlZWsoKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGluc3QuZWxlbS5hdHRyKCdzaXplJywgZGF0ZS5mb3JtYXREYXRlKGRhdGVGb3JtYXQpLmxlbmd0aCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0X3ByZURlc3Ryb3k6IGZ1bmN0aW9uKGVsZW0sIGluc3QpIHtcclxuXHRcdFx0aWYgKGluc3QudHJpZ2dlcikge1xyXG5cdFx0XHRcdGluc3QudHJpZ2dlci5yZW1vdmUoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbGVtLmVtcHR5KCkub2ZmKCcuJyArIGluc3QubmFtZSk7XHJcblx0XHRcdGlmIChpbnN0LmlubGluZSAmJiAkLmZuLm1vdXNld2hlZWwpIHtcclxuXHRcdFx0XHRlbGVtLnVubW91c2V3aGVlbCgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghaW5zdC5pbmxpbmUgJiYgaW5zdC5vcHRpb25zLmF1dG9TaXplKSB7XHJcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyKCdzaXplJyk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEFwcGx5IG11bHRpcGxlIGV2ZW50IGZ1bmN0aW9ucy5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcGFyYW0gZm5zIHtmdW5jdGlvbn0gVGhlIGZ1bmN0aW9ucyB0byBhcHBseS5cclxuXHRcdFx0QGV4YW1wbGUgb25TaG93OiBtdWx0aXBsZUV2ZW50cyhmbjEsIGZuMiwgLi4uKSAqL1xyXG5cdFx0bXVsdGlwbGVFdmVudHM6IGZ1bmN0aW9uKGZucykge1xyXG5cdFx0XHR2YXIgZnVuY3MgPSBhcmd1bWVudHM7XHJcblx0XHRcdHJldHVybiBmdW5jdGlvbihhcmdzKSB7XHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0ZnVuY3NbaV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBFbmFibGUgdGhlIGNvbnRyb2wuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGFmZmVjdC5cclxuXHRcdFx0QGV4YW1wbGUgJChzZWxlY3RvcikuZGF0ZXBpY2soJ2VuYWJsZScpICovXHJcblx0XHRlbmFibGU6IGZ1bmN0aW9uKGVsZW0pIHtcclxuXHRcdFx0ZWxlbSA9ICQoZWxlbSk7XHJcblx0XHRcdGlmICghZWxlbS5oYXNDbGFzcyh0aGlzLl9nZXRNYXJrZXIoKSkpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHRpZiAoaW5zdC5pbmxpbmUpIHtcclxuXHRcdFx0XHRlbGVtLmNoaWxkcmVuKCcuJyArIHRoaXMuX2Rpc2FibGVDbGFzcykucmVtb3ZlKCkuZW5kKCkuXHJcblx0XHRcdFx0XHRmaW5kKCdidXR0b24sc2VsZWN0JykucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSkuZW5kKCkuXHJcblx0XHRcdFx0XHRmaW5kKCdhJykuYXR0cignaHJlZicsICdqYXZhc2NyaXB0OnZvaWQoMCknKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRlbGVtLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xyXG5cdFx0XHRcdGluc3QudHJpZ2dlci5maWx0ZXIoJ2J1dHRvbi4nICsgdGhpcy5fdHJpZ2dlckNsYXNzKS5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKS5lbmQoKS5cclxuXHRcdFx0XHRcdGZpbHRlcignaW1nLicgKyB0aGlzLl90cmlnZ2VyQ2xhc3MpLmNzcyh7b3BhY2l0eTogJzEuMCcsIGN1cnNvcjogJyd9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLl9kaXNhYmxlZCA9ICQubWFwKHRoaXMuX2Rpc2FibGVkLFxyXG5cdFx0XHRcdGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiAodmFsdWUgPT09IGVsZW1bMF0gPyBudWxsIDogdmFsdWUpOyB9KTsgLy8gRGVsZXRlIGVudHJ5XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBEaXNhYmxlIHRoZSBjb250cm9sLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBhZmZlY3QuXHJcblx0XHRcdEBleGFtcGxlICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdkaXNhYmxlJykgKi9cclxuXHRcdGRpc2FibGU6IGZ1bmN0aW9uKGVsZW0pIHtcclxuXHRcdFx0ZWxlbSA9ICQoZWxlbSk7XHJcblx0XHRcdGlmICghZWxlbS5oYXNDbGFzcyh0aGlzLl9nZXRNYXJrZXIoKSkpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHRpZiAoaW5zdC5pbmxpbmUpIHtcclxuXHRcdFx0XHR2YXIgaW5saW5lID0gZWxlbS5jaGlsZHJlbignOmxhc3QnKTtcclxuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gaW5saW5lLm9mZnNldCgpO1xyXG5cdFx0XHRcdHZhciByZWxPZmZzZXQgPSB7bGVmdDogMCwgdG9wOiAwfTtcclxuXHRcdFx0XHRpbmxpbmUucGFyZW50cygpLmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRpZiAoJCh0aGlzKS5jc3MoJ3Bvc2l0aW9uJykgPT09ICdyZWxhdGl2ZScpIHtcclxuXHRcdFx0XHRcdFx0cmVsT2Zmc2V0ID0gJCh0aGlzKS5vZmZzZXQoKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdHZhciB6SW5kZXggPSBlbGVtLmNzcygnekluZGV4Jyk7XHJcblx0XHRcdFx0ekluZGV4ID0gKHpJbmRleCA9PT0gJ2F1dG8nID8gMCA6IHBhcnNlSW50KHpJbmRleCwgMTApKSArIDE7XHJcblx0XHRcdFx0ZWxlbS5wcmVwZW5kKCc8ZGl2IGNsYXNzPVwiJyArIHRoaXMuX2Rpc2FibGVDbGFzcyArICdcIiBzdHlsZT1cIicgK1xyXG5cdFx0XHRcdFx0J3dpZHRoOiAnICsgaW5saW5lLm91dGVyV2lkdGgoKSArICdweDsgaGVpZ2h0OiAnICsgaW5saW5lLm91dGVySGVpZ2h0KCkgK1xyXG5cdFx0XHRcdFx0J3B4OyBsZWZ0OiAnICsgKG9mZnNldC5sZWZ0IC0gcmVsT2Zmc2V0LmxlZnQpICsgJ3B4OyB0b3A6ICcgK1xyXG5cdFx0XHRcdFx0KG9mZnNldC50b3AgLSByZWxPZmZzZXQudG9wKSArICdweDsgei1pbmRleDogJyArIHpJbmRleCArICdcIj48L2Rpdj4nKS5cclxuXHRcdFx0XHRcdGZpbmQoJ2J1dHRvbixzZWxlY3QnKS5wcm9wKCdkaXNhYmxlZCcsIHRydWUpLmVuZCgpLlxyXG5cdFx0XHRcdFx0ZmluZCgnYScpLnJlbW92ZUF0dHIoJ2hyZWYnKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRlbGVtLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XHJcblx0XHRcdFx0aW5zdC50cmlnZ2VyLmZpbHRlcignYnV0dG9uLicgKyB0aGlzLl90cmlnZ2VyQ2xhc3MpLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSkuZW5kKCkuXHJcblx0XHRcdFx0XHRmaWx0ZXIoJ2ltZy4nICsgdGhpcy5fdHJpZ2dlckNsYXNzKS5jc3Moe29wYWNpdHk6ICcwLjUnLCBjdXJzb3I6ICdkZWZhdWx0J30pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX2Rpc2FibGVkID0gJC5tYXAodGhpcy5fZGlzYWJsZWQsXHJcblx0XHRcdFx0ZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuICh2YWx1ZSA9PT0gZWxlbVswXSA/IG51bGwgOiB2YWx1ZSk7IH0pOyAvLyBEZWxldGUgZW50cnlcclxuXHRcdFx0dGhpcy5fZGlzYWJsZWQucHVzaChlbGVtWzBdKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIElzIHRoZSBmaXJzdCBmaWVsZCBpbiBhIGpRdWVyeSBjb2xsZWN0aW9uIGRpc2FibGVkIGFzIGEgZGF0ZXBpY2tlcj9cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gZXhhbWluZS5cclxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgZGlzYWJsZWQsIDxjb2RlPmZhbHNlPC9jb2RlPiBpZiBlbmFibGVkLlxyXG5cdFx0XHRAZXhhbXBsZSBpZiAoJChzZWxlY3RvcikuZGF0ZXBpY2soJ2lzRGlzYWJsZWQnKSkgey4uLn0gKi9cclxuXHRcdGlzRGlzYWJsZWQ6IGZ1bmN0aW9uKGVsZW0pIHtcclxuXHRcdFx0cmV0dXJuIChlbGVtICYmICQuaW5BcnJheShlbGVtLCB0aGlzLl9kaXNhYmxlZCkgPiAtMSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBTaG93IGEgcG9wdXAgZGF0ZXBpY2tlci5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RXZlbnR8RWxlbWVudH0gYSBmb2N1cyBldmVudCBvciB0aGUgY29udHJvbCB0byB1c2UuXHJcblx0XHRcdEBleGFtcGxlICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdzaG93JykgKi9cclxuXHRcdHNob3c6IGZ1bmN0aW9uKGVsZW0pIHtcclxuXHRcdFx0ZWxlbSA9ICQoZWxlbS50YXJnZXQgfHwgZWxlbSk7XHJcblx0XHRcdHZhciBpbnN0ID0gcGx1Z2luLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHRpZiAocGx1Z2luLmN1ckluc3QgPT09IGluc3QpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHBsdWdpbi5jdXJJbnN0KSB7XHJcblx0XHRcdFx0cGx1Z2luLmhpZGUocGx1Z2luLmN1ckluc3QsIHRydWUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KGluc3QpKSB7XHJcblx0XHRcdFx0Ly8gUmV0cmlldmUgZXhpc3RpbmcgZGF0ZShzKVxyXG5cdFx0XHRcdGluc3QubGFzdFZhbCA9IG51bGw7XHJcblx0XHRcdFx0aW5zdC5zZWxlY3RlZERhdGVzID0gcGx1Z2luLl9leHRyYWN0RGF0ZXMoaW5zdCwgZWxlbS52YWwoKSk7XHJcblx0XHRcdFx0aW5zdC5waWNraW5nUmFuZ2UgPSBmYWxzZTtcclxuXHRcdFx0XHRpbnN0LmRyYXdEYXRlID0gcGx1Z2luLl9jaGVja01pbk1heCgoaW5zdC5zZWxlY3RlZERhdGVzWzBdIHx8XHJcblx0XHRcdFx0XHRpbnN0LmdldCgnZGVmYXVsdERhdGUnKSB8fCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKSkubmV3RGF0ZSgpLCBpbnN0KTtcclxuXHRcdFx0XHRpbnN0LnByZXZEYXRlID0gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCk7XHJcblx0XHRcdFx0cGx1Z2luLmN1ckluc3QgPSBpbnN0O1xyXG5cdFx0XHRcdC8vIEdlbmVyYXRlIGNvbnRlbnRcclxuXHRcdFx0XHRwbHVnaW4uX3VwZGF0ZShlbGVtWzBdLCB0cnVlKTtcclxuXHRcdFx0XHQvLyBBZGp1c3QgcG9zaXRpb24gYmVmb3JlIHNob3dpbmdcclxuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gcGx1Z2luLl9jaGVja09mZnNldChpbnN0KTtcclxuXHRcdFx0XHRpbnN0LmRpdi5jc3Moe2xlZnQ6IG9mZnNldC5sZWZ0LCB0b3A6IG9mZnNldC50b3B9KTtcclxuXHRcdFx0XHQvLyBBbmQgZGlzcGxheVxyXG5cdFx0XHRcdHZhciBzaG93QW5pbSA9IGluc3Qub3B0aW9ucy5zaG93QW5pbTtcclxuXHRcdFx0XHR2YXIgc2hvd1NwZWVkID0gaW5zdC5vcHRpb25zLnNob3dTcGVlZDtcclxuXHRcdFx0XHRzaG93U3BlZWQgPSAoc2hvd1NwZWVkID09PSAnbm9ybWFsJyAmJiAkLnVpICYmXHJcblx0XHRcdFx0XHRwYXJzZUludCgkLnVpLnZlcnNpb24uc3Vic3RyaW5nKDIpKSA+PSA4ID8gJ19kZWZhdWx0JyA6IHNob3dTcGVlZCk7XHJcblx0XHRcdFx0aWYgKCQuZWZmZWN0cyAmJiAoJC5lZmZlY3RzW3Nob3dBbmltXSB8fCAoJC5lZmZlY3RzLmVmZmVjdCAmJiAkLmVmZmVjdHMuZWZmZWN0W3Nob3dBbmltXSkpKSB7XHJcblx0XHRcdFx0XHR2YXIgZGF0YSA9IGluc3QuZGl2LmRhdGEoKTsgLy8gVXBkYXRlIG9sZCBlZmZlY3RzIGRhdGFcclxuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBkYXRhKSB7XHJcblx0XHRcdFx0XHRcdGlmIChrZXkubWF0Y2goL15lY1xcLnN0b3JhZ2VcXC4vKSkge1xyXG5cdFx0XHRcdFx0XHRcdGRhdGFba2V5XSA9IGluc3QuX21haW5EaXYuY3NzKGtleS5yZXBsYWNlKC9lY1xcLnN0b3JhZ2VcXC4vLCAnJykpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpbnN0LmRpdi5kYXRhKGRhdGEpLnNob3coc2hvd0FuaW0sIGluc3Qub3B0aW9ucy5zaG93T3B0aW9ucywgc2hvd1NwZWVkKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRpbnN0LmRpdltzaG93QW5pbSB8fCAnc2hvdyddKHNob3dBbmltID8gc2hvd1NwZWVkIDogMCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBFeHRyYWN0IHBvc3NpYmxlIGRhdGVzIGZyb20gYSBzdHJpbmcuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEBwYXJhbSB0ZXh0IHtzdHJpbmd9IFRoZSB0ZXh0IHRvIGV4dHJhY3QgZnJvbS5cclxuXHRcdFx0QHJldHVybiB7Q0RhdGVbXX0gVGhlIGV4dHJhY3RlZCBkYXRlcy4gKi9cclxuXHRcdF9leHRyYWN0RGF0ZXM6IGZ1bmN0aW9uKGluc3QsIGRhdGVzVGV4dCkge1xyXG5cdFx0XHRpZiAoZGF0ZXNUZXh0ID09PSBpbnN0Lmxhc3RWYWwpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0aW5zdC5sYXN0VmFsID0gZGF0ZXNUZXh0O1xyXG5cdFx0XHRkYXRlc1RleHQgPSBkYXRlc1RleHQuc3BsaXQoaW5zdC5vcHRpb25zLm11bHRpU2VsZWN0ID8gaW5zdC5vcHRpb25zLm11bHRpU2VwYXJhdG9yIDpcclxuXHRcdFx0XHQoaW5zdC5vcHRpb25zLnJhbmdlU2VsZWN0ID8gaW5zdC5vcHRpb25zLnJhbmdlU2VwYXJhdG9yIDogJ1xceDAwJykpO1xyXG5cdFx0XHR2YXIgZGF0ZXMgPSBbXTtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRlc1RleHQubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0dmFyIGRhdGUgPSBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIucGFyc2VEYXRlKGluc3QuZ2V0KCdkYXRlRm9ybWF0JyksIGRhdGVzVGV4dFtpXSk7XHJcblx0XHRcdFx0XHRpZiAoZGF0ZSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgZm91bmQgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkYXRlcy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChkYXRlc1tqXS5jb21wYXJlVG8oZGF0ZSkgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0XHRcdGZvdW5kID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZiAoIWZvdW5kKSB7XHJcblx0XHRcdFx0XHRcdFx0ZGF0ZXMucHVzaChkYXRlKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjYXRjaCAoZSkge1xyXG5cdFx0XHRcdFx0Ly8gSWdub3JlXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGRhdGVzLnNwbGljZShpbnN0Lm9wdGlvbnMubXVsdGlTZWxlY3QgfHwgKGluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCA/IDIgOiAxKSwgZGF0ZXMubGVuZ3RoKTtcclxuXHRcdFx0aWYgKGluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCAmJiBkYXRlcy5sZW5ndGggPT09IDEpIHtcclxuXHRcdFx0XHRkYXRlc1sxXSA9IGRhdGVzWzBdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBkYXRlcztcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFVwZGF0ZSB0aGUgZGF0ZXBpY2tlciBkaXNwbGF5LlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFdmVudHxFbGVtZW50fSBhIGZvY3VzIGV2ZW50IG9yIHRoZSBjb250cm9sIHRvIHVzZS5cclxuXHRcdFx0QHBhcmFtIGhpZGRlbiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gaW5pdGlhbGx5IGhpZGUgdGhlIGRhdGVwaWNrZXIuICovXHJcblx0XHRfdXBkYXRlOiBmdW5jdGlvbihlbGVtLCBoaWRkZW4pIHtcclxuXHRcdFx0ZWxlbSA9ICQoZWxlbS50YXJnZXQgfHwgZWxlbSk7XHJcblx0XHRcdHZhciBpbnN0ID0gcGx1Z2luLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSkge1xyXG5cdFx0XHRcdGlmIChpbnN0LmlubGluZSB8fCBwbHVnaW4uY3VySW5zdCA9PT0gaW5zdCkge1xyXG5cdFx0XHRcdFx0aWYgKCQuaXNGdW5jdGlvbihpbnN0Lm9wdGlvbnMub25DaGFuZ2VNb250aFllYXIpICYmICghaW5zdC5wcmV2RGF0ZSB8fFxyXG5cdFx0XHRcdFx0XHRcdGluc3QucHJldkRhdGUueWVhcigpICE9PSBpbnN0LmRyYXdEYXRlLnllYXIoKSB8fFxyXG5cdFx0XHRcdFx0XHRcdGluc3QucHJldkRhdGUubW9udGgoKSAhPT0gaW5zdC5kcmF3RGF0ZS5tb250aCgpKSkge1xyXG5cdFx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMub25DaGFuZ2VNb250aFllYXIuYXBwbHkoZWxlbVswXSxcclxuXHRcdFx0XHRcdFx0XHRbaW5zdC5kcmF3RGF0ZS55ZWFyKCksIGluc3QuZHJhd0RhdGUubW9udGgoKV0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoaW5zdC5pbmxpbmUpIHtcclxuXHRcdFx0XHRcdHZhciBpbmRleCA9ICQoJ2EsIDppbnB1dCcsIGVsZW0pLmluZGV4KCQoJzpmb2N1cycsIGVsZW0pKTtcclxuXHRcdFx0XHRcdGVsZW0uaHRtbCh0aGlzLl9nZW5lcmF0ZUNvbnRlbnQoZWxlbVswXSwgaW5zdCkpO1xyXG5cdFx0XHRcdFx0dmFyIGZvY3VzID0gZWxlbS5maW5kKCdhLCA6aW5wdXQnKTtcclxuXHRcdFx0XHRcdGZvY3VzLmVxKE1hdGgubWF4KE1hdGgubWluKGluZGV4LCBmb2N1cy5sZW5ndGggLSAxKSwgMCkpLmZvY3VzKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKHBsdWdpbi5jdXJJbnN0ID09PSBpbnN0KSB7XHJcblx0XHRcdFx0XHRpZiAoIWluc3QuZGl2KSB7XHJcblx0XHRcdFx0XHRcdGluc3QuZGl2ID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcyh0aGlzLl9wb3B1cENsYXNzKS5cclxuXHRcdFx0XHRcdFx0XHRjc3Moe2Rpc3BsYXk6IChoaWRkZW4gPyAnbm9uZScgOiAnc3RhdGljJyksIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG5cdFx0XHRcdFx0XHRcdFx0bGVmdDogZWxlbS5vZmZzZXQoKS5sZWZ0LCB0b3A6IGVsZW0ub2Zmc2V0KCkudG9wICsgZWxlbS5vdXRlckhlaWdodCgpfSkuXHJcblx0XHRcdFx0XHRcdFx0YXBwZW5kVG8oJChpbnN0Lm9wdGlvbnMucG9wdXBDb250YWluZXIgfHwgJ2JvZHknKSk7XHJcblx0XHRcdFx0XHRcdGlmICgkLmZuLm1vdXNld2hlZWwpIHtcclxuXHRcdFx0XHRcdFx0XHRpbnN0LmRpdi5tb3VzZXdoZWVsKHRoaXMuX2RvTW91c2VXaGVlbCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGluc3QuZGl2Lmh0bWwodGhpcy5fZ2VuZXJhdGVDb250ZW50KGVsZW1bMF0sIGluc3QpKTtcclxuXHRcdFx0XHRcdGVsZW0uZm9jdXMoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFVwZGF0ZSB0aGUgaW5wdXQgZmllbGQgYW5kIGFueSBhbHRlcm5hdGUgZmllbGQgd2l0aCB0aGUgY3VycmVudCBkYXRlcy5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gdXNlLlxyXG5cdFx0XHRAcGFyYW0ga2V5VXAge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGNvbWluZyBmcm9tIDxjb2RlPmtleVVwPC9jb2RlPiBwcm9jZXNzaW5nIChpbnRlcm5hbCkuICovXHJcblx0XHRfdXBkYXRlSW5wdXQ6IGZ1bmN0aW9uKGVsZW0sIGtleVVwKSB7XHJcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0aWYgKCEkLmlzRW1wdHlPYmplY3QoaW5zdCkpIHtcclxuXHRcdFx0XHR2YXIgdmFsdWUgPSAnJztcclxuXHRcdFx0XHR2YXIgYWx0VmFsdWUgPSAnJztcclxuXHRcdFx0XHR2YXIgc2VwID0gKGluc3Qub3B0aW9ucy5tdWx0aVNlbGVjdCA/IGluc3Qub3B0aW9ucy5tdWx0aVNlcGFyYXRvciA6XHJcblx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMucmFuZ2VTZXBhcmF0b3IpO1xyXG5cdFx0XHRcdHZhciBjYWxlbmRhciA9IGluc3Qub3B0aW9ucy5jYWxlbmRhcjtcclxuXHRcdFx0XHR2YXIgZGF0ZUZvcm1hdCA9IGluc3QuZ2V0KCdkYXRlRm9ybWF0Jyk7XHJcblx0XHRcdFx0dmFyIGFsdEZvcm1hdCA9IGluc3Qub3B0aW9ucy5hbHRGb3JtYXQgfHwgZGF0ZUZvcm1hdDtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGluc3Quc2VsZWN0ZWREYXRlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dmFsdWUgKz0gKGtleVVwID8gJycgOiAoaSA+IDAgPyBzZXAgOiAnJykgK1xyXG5cdFx0XHRcdFx0XHRjYWxlbmRhci5mb3JtYXREYXRlKGRhdGVGb3JtYXQsIGluc3Quc2VsZWN0ZWREYXRlc1tpXSkpO1xyXG5cdFx0XHRcdFx0YWx0VmFsdWUgKz0gKGkgPiAwID8gc2VwIDogJycpICtcclxuXHRcdFx0XHRcdFx0Y2FsZW5kYXIuZm9ybWF0RGF0ZShhbHRGb3JtYXQsIGluc3Quc2VsZWN0ZWREYXRlc1tpXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICghaW5zdC5pbmxpbmUgJiYgIWtleVVwKSB7XHJcblx0XHRcdFx0XHQkKGVsZW0pLnZhbCh2YWx1ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdCQoaW5zdC5vcHRpb25zLmFsdEZpZWxkKS52YWwoYWx0VmFsdWUpO1xyXG5cdFx0XHRcdGlmICgkLmlzRnVuY3Rpb24oaW5zdC5vcHRpb25zLm9uU2VsZWN0KSAmJiAha2V5VXAgJiYgIWluc3QuaW5TZWxlY3QpIHtcclxuXHRcdFx0XHRcdGluc3QuaW5TZWxlY3QgPSB0cnVlOyAvLyBQcmV2ZW50IGVuZGxlc3MgbG9vcHNcclxuXHRcdFx0XHRcdGluc3Qub3B0aW9ucy5vblNlbGVjdC5hcHBseShlbGVtLCBbaW5zdC5zZWxlY3RlZERhdGVzXSk7XHJcblx0XHRcdFx0XHRpbnN0LmluU2VsZWN0ID0gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgc2l6ZSBvZiBsZWZ0IGFuZCB0b3AgYm9yZGVycyBmb3IgYW4gZWxlbWVudC5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7alF1ZXJ5fSBUaGUgZWxlbWVudCBvZiBpbnRlcmVzdC5cclxuXHRcdFx0QHJldHVybiB7bnVtYmVyW119IFRoZSBsZWZ0IGFuZCB0b3AgYm9yZGVycy4gKi9cclxuXHRcdF9nZXRCb3JkZXJzOiBmdW5jdGlvbihlbGVtKSB7XHJcblx0XHRcdHZhciBjb252ZXJ0ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdFx0XHRyZXR1cm4ge3RoaW46IDEsIG1lZGl1bTogMywgdGhpY2s6IDV9W3ZhbHVlXSB8fCB2YWx1ZTtcclxuXHRcdFx0fTtcclxuXHRcdFx0cmV0dXJuIFtwYXJzZUZsb2F0KGNvbnZlcnQoZWxlbS5jc3MoJ2JvcmRlci1sZWZ0LXdpZHRoJykpKSxcclxuXHRcdFx0XHRwYXJzZUZsb2F0KGNvbnZlcnQoZWxlbS5jc3MoJ2JvcmRlci10b3Atd2lkdGgnKSkpXTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIENoZWNrIHBvc2l0aW9uaW5nIHRvIHJlbWFpbiBvbiB0aGUgc2NyZWVuLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxyXG5cdFx0XHRAcmV0dXJuIHtvYmplY3R9IFRoZSB1cGRhdGVkIG9mZnNldCBmb3IgdGhlIGRhdGVwaWNrZXIuICovXHJcblx0XHRfY2hlY2tPZmZzZXQ6IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0dmFyIGJhc2UgPSAoaW5zdC5lbGVtLmlzKCc6aGlkZGVuJykgJiYgaW5zdC50cmlnZ2VyID8gaW5zdC50cmlnZ2VyIDogaW5zdC5lbGVtKTtcclxuXHRcdFx0dmFyIG9mZnNldCA9IGJhc2Uub2Zmc2V0KCk7XHJcblx0XHRcdHZhciBicm93c2VyV2lkdGggPSAkKHdpbmRvdykud2lkdGgoKTtcclxuXHRcdFx0dmFyIGJyb3dzZXJIZWlnaHQgPSAkKHdpbmRvdykuaGVpZ2h0KCk7XHJcblx0XHRcdGlmIChicm93c2VyV2lkdGggPT09IDApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2Zmc2V0O1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBpc0ZpeGVkID0gZmFsc2U7XHJcblx0XHRcdCQoaW5zdC5lbGVtKS5wYXJlbnRzKCkuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRpc0ZpeGVkIHw9ICQodGhpcykuY3NzKCdwb3NpdGlvbicpID09PSAnZml4ZWQnO1xyXG5cdFx0XHRcdHJldHVybiAhaXNGaXhlZDtcclxuXHRcdFx0fSk7XHJcblx0XHRcdHZhciBzY3JvbGxYID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0O1xyXG5cdFx0XHR2YXIgc2Nyb2xsWSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XHJcblx0XHRcdHZhciBhYm92ZSA9IG9mZnNldC50b3AgLSAoaXNGaXhlZCA/IHNjcm9sbFkgOiAwKSAtIGluc3QuZGl2Lm91dGVySGVpZ2h0KCk7XHJcblx0XHRcdHZhciBiZWxvdyA9IG9mZnNldC50b3AgLSAoaXNGaXhlZCA/IHNjcm9sbFkgOiAwKSArIGJhc2Uub3V0ZXJIZWlnaHQoKTtcclxuXHRcdFx0dmFyIGFsaWduTCA9IG9mZnNldC5sZWZ0IC0gKGlzRml4ZWQgPyBzY3JvbGxYIDogMCk7XHJcblx0XHRcdHZhciBhbGlnblIgPSBvZmZzZXQubGVmdCAtIChpc0ZpeGVkID8gc2Nyb2xsWCA6IDApICsgYmFzZS5vdXRlcldpZHRoKCkgLSBpbnN0LmRpdi5vdXRlcldpZHRoKCk7XHJcblx0XHRcdHZhciB0b29XaWRlID0gKG9mZnNldC5sZWZ0IC0gc2Nyb2xsWCArIGluc3QuZGl2Lm91dGVyV2lkdGgoKSkgPiBicm93c2VyV2lkdGg7XHJcblx0XHRcdHZhciB0b29IaWdoID0gKG9mZnNldC50b3AgLSBzY3JvbGxZICsgaW5zdC5lbGVtLm91dGVySGVpZ2h0KCkgK1xyXG5cdFx0XHRcdGluc3QuZGl2Lm91dGVySGVpZ2h0KCkpID4gYnJvd3NlckhlaWdodDtcclxuXHRcdFx0aW5zdC5kaXYuY3NzKCdwb3NpdGlvbicsIGlzRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJyk7XHJcblx0XHRcdHZhciBhbGlnbm1lbnQgPSBpbnN0Lm9wdGlvbnMuYWxpZ25tZW50O1xyXG5cdFx0XHRpZiAoYWxpZ25tZW50ID09PSAndG9wTGVmdCcpIHtcclxuXHRcdFx0XHRvZmZzZXQgPSB7bGVmdDogYWxpZ25MLCB0b3A6IGFib3ZlfTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmIChhbGlnbm1lbnQgPT09ICd0b3BSaWdodCcpIHtcclxuXHRcdFx0XHRvZmZzZXQgPSB7bGVmdDogYWxpZ25SLCB0b3A6IGFib3ZlfTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmIChhbGlnbm1lbnQgPT09ICdib3R0b21MZWZ0Jykge1xyXG5cdFx0XHRcdG9mZnNldCA9IHtsZWZ0OiBhbGlnbkwsIHRvcDogYmVsb3d9O1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKGFsaWdubWVudCA9PT0gJ2JvdHRvbVJpZ2h0Jykge1xyXG5cdFx0XHRcdG9mZnNldCA9IHtsZWZ0OiBhbGlnblIsIHRvcDogYmVsb3d9O1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKGFsaWdubWVudCA9PT0gJ3RvcCcpIHtcclxuXHRcdFx0XHRvZmZzZXQgPSB7bGVmdDogKGluc3Qub3B0aW9ucy5pc1JUTCB8fCB0b29XaWRlID8gYWxpZ25SIDogYWxpZ25MKSwgdG9wOiBhYm92ZX07XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7IC8vIGJvdHRvbVxyXG5cdFx0XHRcdG9mZnNldCA9IHtsZWZ0OiAoaW5zdC5vcHRpb25zLmlzUlRMIHx8IHRvb1dpZGUgPyBhbGlnblIgOiBhbGlnbkwpLFxyXG5cdFx0XHRcdFx0dG9wOiAodG9vSGlnaCA/IGFib3ZlIDogYmVsb3cpfTtcclxuXHRcdFx0fVxyXG5cdFx0XHRvZmZzZXQubGVmdCA9IE1hdGgubWF4KChpc0ZpeGVkID8gMCA6IHNjcm9sbFgpLCBvZmZzZXQubGVmdCk7XHJcblx0XHRcdG9mZnNldC50b3AgPSBNYXRoLm1heCgoaXNGaXhlZCA/IDAgOiBzY3JvbGxZKSwgb2Zmc2V0LnRvcCk7XHJcblx0XHRcdHJldHVybiBvZmZzZXQ7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBDbG9zZSBkYXRlIHBpY2tlciBpZiBjbGlja2VkIGVsc2V3aGVyZS5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gZXZlbnQge01vdXNlRXZlbnR9IFRoZSBtb3VzZSBjbGljayB0byBjaGVjay4gKi9cclxuXHRcdF9jaGVja0V4dGVybmFsQ2xpY2s6IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRcdGlmICghcGx1Z2luLmN1ckluc3QpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGVsZW0gPSAkKGV2ZW50LnRhcmdldCk7XHJcblx0XHRcdGlmIChlbGVtLmNsb3Nlc3QoJy4nICsgcGx1Z2luLl9wb3B1cENsYXNzICsgJywuJyArIHBsdWdpbi5fdHJpZ2dlckNsYXNzKS5sZW5ndGggPT09IDAgJiZcclxuXHRcdFx0XHRcdCFlbGVtLmhhc0NsYXNzKHBsdWdpbi5fZ2V0TWFya2VyKCkpKSB7XHJcblx0XHRcdFx0cGx1Z2luLmhpZGUocGx1Z2luLmN1ckluc3QpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBIaWRlIGEgcG9wdXAgZGF0ZXBpY2tlci5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudHxvYmplY3R9IFRoZSBjb250cm9sIHRvIHVzZSBvciB0aGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cclxuXHRcdFx0QHBhcmFtIGltbWVkaWF0ZSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gY2xvc2UgaW1tZWRpYXRlbHkgd2l0aG91dCBhbmltYXRpb24gKGludGVybmFsKS5cclxuXHRcdFx0QGV4YW1wbGUgJChzZWxlY3RvcikuZGF0ZXBpY2soJ2hpZGUnKSAqL1xyXG5cdFx0aGlkZTogZnVuY3Rpb24oZWxlbSwgaW1tZWRpYXRlKSB7XHJcblx0XHRcdGlmICghZWxlbSkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XHJcblx0XHRcdGlmICgkLmlzRW1wdHlPYmplY3QoaW5zdCkpIHtcclxuXHRcdFx0XHRpbnN0ID0gZWxlbTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoaW5zdCAmJiBpbnN0ID09PSBwbHVnaW4uY3VySW5zdCkge1xyXG5cdFx0XHRcdHZhciBzaG93QW5pbSA9IChpbW1lZGlhdGUgPyAnJyA6IGluc3Qub3B0aW9ucy5zaG93QW5pbSk7XHJcblx0XHRcdFx0dmFyIHNob3dTcGVlZCA9IGluc3Qub3B0aW9ucy5zaG93U3BlZWQ7XHJcblx0XHRcdFx0c2hvd1NwZWVkID0gKHNob3dTcGVlZCA9PT0gJ25vcm1hbCcgJiYgJC51aSAmJlxyXG5cdFx0XHRcdFx0cGFyc2VJbnQoJC51aS52ZXJzaW9uLnN1YnN0cmluZygyKSkgPj0gOCA/ICdfZGVmYXVsdCcgOiBzaG93U3BlZWQpO1xyXG5cdFx0XHRcdHZhciBwb3N0UHJvY2VzcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0aWYgKCFpbnN0LmRpdikge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpbnN0LmRpdi5yZW1vdmUoKTtcclxuXHRcdFx0XHRcdGluc3QuZGl2ID0gbnVsbDtcclxuXHRcdFx0XHRcdHBsdWdpbi5jdXJJbnN0ID0gbnVsbDtcclxuXHRcdFx0XHRcdGlmICgkLmlzRnVuY3Rpb24oaW5zdC5vcHRpb25zLm9uQ2xvc2UpKSB7XHJcblx0XHRcdFx0XHRcdGluc3Qub3B0aW9ucy5vbkNsb3NlLmFwcGx5KGVsZW0sIFtpbnN0LnNlbGVjdGVkRGF0ZXNdKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdGluc3QuZGl2LnN0b3AoKTtcclxuXHRcdFx0XHRpZiAoJC5lZmZlY3RzICYmICgkLmVmZmVjdHNbc2hvd0FuaW1dIHx8ICgkLmVmZmVjdHMuZWZmZWN0ICYmICQuZWZmZWN0cy5lZmZlY3Rbc2hvd0FuaW1dKSkpIHtcclxuXHRcdFx0XHRcdGluc3QuZGl2LmhpZGUoc2hvd0FuaW0sIGluc3Qub3B0aW9ucy5zaG93T3B0aW9ucywgc2hvd1NwZWVkLCBwb3N0UHJvY2Vzcyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIGhpZGVBbmltID0gKHNob3dBbmltID09PSAnc2xpZGVEb3duJyA/ICdzbGlkZVVwJyA6XHJcblx0XHRcdFx0XHRcdChzaG93QW5pbSA9PT0gJ2ZhZGVJbicgPyAnZmFkZU91dCcgOiAnaGlkZScpKTtcclxuXHRcdFx0XHRcdGluc3QuZGl2W2hpZGVBbmltXSgoc2hvd0FuaW0gPyBzaG93U3BlZWQgOiAnJyksIHBvc3RQcm9jZXNzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKCFzaG93QW5pbSkge1xyXG5cdFx0XHRcdFx0cG9zdFByb2Nlc3MoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEhhbmRsZSBrZXlzdHJva2VzIGluIHRoZSBkYXRlcGlja2VyLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBldmVudCB7S2V5RXZlbnR9IFRoZSBrZXlzdHJva2UuXHJcblx0XHRcdEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIG5vdCBoYW5kbGVkLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgaGFuZGxlZC4gKi9cclxuXHRcdF9rZXlEb3duOiBmdW5jdGlvbihldmVudCkge1xyXG5cdFx0XHR2YXIgZWxlbSA9IChldmVudC5kYXRhICYmIGV2ZW50LmRhdGEuZWxlbSkgfHwgZXZlbnQudGFyZ2V0O1xyXG5cdFx0XHR2YXIgaW5zdCA9IHBsdWdpbi5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0dmFyIGhhbmRsZWQgPSBmYWxzZTtcclxuXHRcdFx0aWYgKGluc3QuaW5saW5lIHx8IGluc3QuZGl2KSB7XHJcblx0XHRcdFx0aWYgKGV2ZW50LmtleUNvZGUgPT09IDkpIHsgLy8gVGFiIC0gY2xvc2VcclxuXHRcdFx0XHRcdHBsdWdpbi5oaWRlKGVsZW0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSAxMykgeyAvLyBFbnRlciAtIHNlbGVjdFxyXG5cdFx0XHRcdFx0cGx1Z2luLnNlbGVjdERhdGUoZWxlbSxcclxuXHRcdFx0XHRcdFx0JCgnYS4nICsgaW5zdC5vcHRpb25zLnJlbmRlcmVyLmhpZ2hsaWdodGVkQ2xhc3MsIGluc3QuZGl2KVswXSk7XHJcblx0XHRcdFx0XHRoYW5kbGVkID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7IC8vIENvbW1hbmQga2V5c3Ryb2tlc1xyXG5cdFx0XHRcdFx0dmFyIGNvbW1hbmRzID0gaW5zdC5vcHRpb25zLmNvbW1hbmRzO1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBjb21tYW5kcykge1xyXG5cdFx0XHRcdFx0XHR2YXIgY29tbWFuZCA9IGNvbW1hbmRzW25hbWVdO1xyXG5cdFx0XHRcdFx0XHRpZiAoY29tbWFuZC5rZXlzdHJva2Uua2V5Q29kZSA9PT0gZXZlbnQua2V5Q29kZSAmJlxyXG5cdFx0XHRcdFx0XHRcdFx0ISFjb21tYW5kLmtleXN0cm9rZS5jdHJsS2V5ID09PSAhIShldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpICYmXHJcblx0XHRcdFx0XHRcdFx0XHQhIWNvbW1hbmQua2V5c3Ryb2tlLmFsdEtleSA9PT0gZXZlbnQuYWx0S2V5ICYmXHJcblx0XHRcdFx0XHRcdFx0XHQhIWNvbW1hbmQua2V5c3Ryb2tlLnNoaWZ0S2V5ID09PSBldmVudC5zaGlmdEtleSkge1xyXG5cdFx0XHRcdFx0XHRcdHBsdWdpbi5wZXJmb3JtQWN0aW9uKGVsZW0sIG5hbWUpO1xyXG5cdFx0XHRcdFx0XHRcdGhhbmRsZWQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgeyAvLyBTaG93IG9uICdjdXJyZW50JyBrZXlzdHJva2VcclxuXHRcdFx0XHR2YXIgY29tbWFuZCA9IGluc3Qub3B0aW9ucy5jb21tYW5kcy5jdXJyZW50O1xyXG5cdFx0XHRcdGlmIChjb21tYW5kLmtleXN0cm9rZS5rZXlDb2RlID09PSBldmVudC5rZXlDb2RlICYmXHJcblx0XHRcdFx0XHRcdCEhY29tbWFuZC5rZXlzdHJva2UuY3RybEtleSA9PT0gISEoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSAmJlxyXG5cdFx0XHRcdFx0XHQhIWNvbW1hbmQua2V5c3Ryb2tlLmFsdEtleSA9PT0gZXZlbnQuYWx0S2V5ICYmXHJcblx0XHRcdFx0XHRcdCEhY29tbWFuZC5rZXlzdHJva2Uuc2hpZnRLZXkgPT09IGV2ZW50LnNoaWZ0S2V5KSB7XHJcblx0XHRcdFx0XHRwbHVnaW4uc2hvdyhlbGVtKTtcclxuXHRcdFx0XHRcdGhhbmRsZWQgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpbnN0LmN0cmxLZXkgPSAoKGV2ZW50LmtleUNvZGUgPCA0OCAmJiBldmVudC5rZXlDb2RlICE9PSAzMikgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KTtcclxuXHRcdFx0aWYgKGhhbmRsZWQpIHtcclxuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiAhaGFuZGxlZDtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEZpbHRlciBrZXlzdHJva2VzIGluIHRoZSBkYXRlcGlja2VyLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBldmVudCB7S2V5RXZlbnR9IFRoZSBrZXlzdHJva2UuXHJcblx0XHRcdEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGFsbG93ZWQsIDxjb2RlPmZhbHNlPC9jb2RlPiBpZiBub3QgYWxsb3dlZC4gKi9cclxuXHRcdF9rZXlQcmVzczogZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdFx0dmFyIGluc3QgPSBwbHVnaW4uX2dldEluc3QoKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5lbGVtKSB8fCBldmVudC50YXJnZXQpO1xyXG5cdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSAmJiBpbnN0Lm9wdGlvbnMuY29uc3RyYWluSW5wdXQpIHtcclxuXHRcdFx0XHR2YXIgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LmtleUNvZGUgfHwgZXZlbnQuY2hhckNvZGUpO1xyXG5cdFx0XHRcdHZhciBhbGxvd2VkQ2hhcnMgPSBwbHVnaW4uX2FsbG93ZWRDaGFycyhpbnN0KTtcclxuXHRcdFx0XHRyZXR1cm4gKGV2ZW50Lm1ldGFLZXkgfHwgaW5zdC5jdHJsS2V5IHx8IGNoIDwgJyAnIHx8XHJcblx0XHRcdFx0XHQhYWxsb3dlZENoYXJzIHx8IGFsbG93ZWRDaGFycy5pbmRleE9mKGNoKSA+IC0xKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIERldGVybWluZSB0aGUgc2V0IG9mIGNoYXJhY3RlcnMgYWxsb3dlZCBieSB0aGUgZGF0ZSBmb3JtYXQuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEByZXR1cm4ge3N0cmluZ30gVGhlIHNldCBvZiBhbGxvd2VkIGNoYXJhY3RlcnMsIG9yIDxjb2RlPm51bGw8L2NvZGU+IGlmIGFueXRoaW5nIGFsbG93ZWQuICovXHJcblx0XHRfYWxsb3dlZENoYXJzOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdHZhciBhbGxvd2VkQ2hhcnMgPSAoaW5zdC5vcHRpb25zLm11bHRpU2VsZWN0ID8gaW5zdC5vcHRpb25zLm11bHRpU2VwYXJhdG9yIDpcclxuXHRcdFx0XHQoaW5zdC5vcHRpb25zLnJhbmdlU2VsZWN0ID8gaW5zdC5vcHRpb25zLnJhbmdlU2VwYXJhdG9yIDogJycpKTtcclxuXHRcdFx0dmFyIGxpdGVyYWwgPSBmYWxzZTtcclxuXHRcdFx0dmFyIGhhc051bSA9IGZhbHNlO1xyXG5cdFx0XHR2YXIgZGF0ZUZvcm1hdCA9IGluc3QuZ2V0KCdkYXRlRm9ybWF0Jyk7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0ZUZvcm1hdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdHZhciBjaCA9IGRhdGVGb3JtYXQuY2hhckF0KGkpO1xyXG5cdFx0XHRcdGlmIChsaXRlcmFsKSB7XHJcblx0XHRcdFx0XHRpZiAoY2ggPT09IFwiJ1wiICYmIGRhdGVGb3JtYXQuY2hhckF0KGkgKyAxKSAhPT0gXCInXCIpIHtcclxuXHRcdFx0XHRcdFx0bGl0ZXJhbCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdGFsbG93ZWRDaGFycyArPSBjaDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRzd2l0Y2ggKGNoKSB7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ2QnOiBjYXNlICdtJzogY2FzZSAnbyc6IGNhc2UgJ3cnOlxyXG5cdFx0XHRcdFx0XHRcdGFsbG93ZWRDaGFycyArPSAoaGFzTnVtID8gJycgOiAnMDEyMzQ1Njc4OScpOyBoYXNOdW0gPSB0cnVlOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAneSc6IGNhc2UgJ0AnOiBjYXNlICchJzpcclxuXHRcdFx0XHRcdFx0XHRhbGxvd2VkQ2hhcnMgKz0gKGhhc051bSA/ICcnIDogJzAxMjM0NTY3ODknKSArICctJzsgaGFzTnVtID0gdHJ1ZTsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ0onOlxyXG5cdFx0XHRcdFx0XHRcdGFsbG93ZWRDaGFycyArPSAoaGFzTnVtID8gJycgOiAnMDEyMzQ1Njc4OScpICsgJy0uJzsgaGFzTnVtID0gdHJ1ZTsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ0QnOiBjYXNlICdNJzogY2FzZSAnWSc6XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7IC8vIEFjY2VwdCBhbnl0aGluZ1xyXG5cdFx0XHRcdFx0XHRjYXNlIFwiJ1wiOlxyXG5cdFx0XHRcdFx0XHRcdGlmIChkYXRlRm9ybWF0LmNoYXJBdChpICsgMSkgPT09IFwiJ1wiKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRhbGxvd2VkQ2hhcnMgKz0gXCInXCI7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0bGl0ZXJhbCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0XHRcdGFsbG93ZWRDaGFycyArPSBjaDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGFsbG93ZWRDaGFycztcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFN5bmNocm9uaXNlIGRhdGVwaWNrZXIgd2l0aCB0aGUgZmllbGQuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGV2ZW50IHtLZXlFdmVudH0gVGhlIGtleXN0cm9rZS5cclxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgYWxsb3dlZCwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdCBhbGxvd2VkLiAqL1xyXG5cdFx0X2tleVVwOiBmdW5jdGlvbihldmVudCkge1xyXG5cdFx0XHR2YXIgZWxlbSA9IChldmVudC5kYXRhICYmIGV2ZW50LmRhdGEuZWxlbSkgfHwgZXZlbnQudGFyZ2V0O1xyXG5cdFx0XHR2YXIgaW5zdCA9IHBsdWdpbi5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0aWYgKCEkLmlzRW1wdHlPYmplY3QoaW5zdCkgJiYgIWluc3QuY3RybEtleSAmJiBpbnN0Lmxhc3RWYWwgIT09IGluc3QuZWxlbS52YWwoKSkge1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHR2YXIgZGF0ZXMgPSBwbHVnaW4uX2V4dHJhY3REYXRlcyhpbnN0LCBpbnN0LmVsZW0udmFsKCkpO1xyXG5cdFx0XHRcdFx0aWYgKGRhdGVzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdFx0cGx1Z2luLnNldERhdGUoZWxlbSwgZGF0ZXMsIG51bGwsIHRydWUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjYXRjaCAoZXZlbnQpIHtcclxuXHRcdFx0XHRcdC8vIElnbm9yZVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEluY3JlbWVudC9kZWNyZW1lbnQgbW9udGgveWVhciBvbiBtb3VzZSB3aGVlbCBhY3Rpdml0eS5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gZXZlbnQge2V2ZW50fSBUaGUgbW91c2Ugd2hlZWwgZXZlbnQuXHJcblx0XHRcdEBwYXJhbSBkZWx0YSB7bnVtYmVyfSBUaGUgYW1vdW50IG9mIGNoYW5nZS4gKi9cclxuXHRcdF9kb01vdXNlV2hlZWw6IGZ1bmN0aW9uKGV2ZW50LCBkZWx0YSkge1xyXG5cdFx0XHR2YXIgZWxlbSA9IChwbHVnaW4uY3VySW5zdCAmJiBwbHVnaW4uY3VySW5zdC5lbGVtWzBdKSB8fFxyXG5cdFx0XHRcdCQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KCcuJyArIHBsdWdpbi5fZ2V0TWFya2VyKCkpWzBdO1xyXG5cdFx0XHRpZiAocGx1Z2luLmlzRGlzYWJsZWQoZWxlbSkpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGluc3QgPSBwbHVnaW4uX2dldEluc3QoZWxlbSk7XHJcblx0XHRcdGlmIChpbnN0Lm9wdGlvbnMudXNlTW91c2VXaGVlbCkge1xyXG5cdFx0XHRcdGRlbHRhID0gKGRlbHRhIDwgMCA/IC0xIDogKzEpO1xyXG5cdFx0XHRcdHBsdWdpbi5jaGFuZ2VNb250aChlbGVtLCAtaW5zdC5vcHRpb25zW2V2ZW50LmN0cmxLZXkgPyAnbW9udGhzVG9KdW1wJyA6ICdtb250aHNUb1N0ZXAnXSAqIGRlbHRhKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQ2xlYXIgYW4gaW5wdXQgYW5kIGNsb3NlIGEgcG9wdXAgZGF0ZXBpY2tlci5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gdXNlLlxyXG5cdFx0XHRAZXhhbXBsZSAkKHNlbGVjdG9yKS5kYXRlcGljaygnY2xlYXInKSAqL1xyXG5cdFx0Y2xlYXI6IGZ1bmN0aW9uKGVsZW0pIHtcclxuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSkge1xyXG5cdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlcyA9IFtdO1xyXG5cdFx0XHRcdHRoaXMuaGlkZShlbGVtKTtcclxuXHRcdFx0XHR2YXIgZGVmYXVsdERhdGUgPSBpbnN0LmdldCgnZGVmYXVsdERhdGUnKTtcclxuXHRcdFx0XHRpZiAoaW5zdC5vcHRpb25zLnNlbGVjdERlZmF1bHREYXRlICYmIGRlZmF1bHREYXRlKSB7XHJcblx0XHRcdFx0XHR0aGlzLnNldERhdGUoZWxlbSwgKGRlZmF1bHREYXRlIHx8IGluc3Qub3B0aW9ucy5jYWxlbmRhci50b2RheSgpKS5uZXdEYXRlKCkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZUlucHV0KGVsZW0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIHNlbGVjdGVkIGRhdGUocykgZm9yIGEgZGF0ZXBpY2tlci5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gZXhhbWluZS5cclxuXHRcdFx0QHJldHVybiB7Q0RhdGVbXX0gVGhlIHNlbGVjdGVkIGRhdGUocykuXHJcblx0XHRcdEBleGFtcGxlIHZhciBkYXRlcyA9ICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdnZXREYXRlJykgKi9cclxuXHRcdGdldERhdGU6IGZ1bmN0aW9uKGVsZW0pIHtcclxuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHRyZXR1cm4gKCEkLmlzRW1wdHlPYmplY3QoaW5zdCkgPyBpbnN0LnNlbGVjdGVkRGF0ZXMgOiBbXSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBTZXQgdGhlIHNlbGVjdGVkIGRhdGUocykgZm9yIGEgZGF0ZXBpY2tlci5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gdGhlIGNvbnRyb2wgdG8gZXhhbWluZS5cclxuXHRcdFx0QHBhcmFtIGRhdGVzIHtDRGF0ZXxudW1iZXJ8c3RyaW5nfGFycmF5fSB0aGUgc2VsZWN0ZWQgZGF0ZShzKS5cclxuXHRcdFx0QHBhcmFtIFtlbmREYXRlXSB7Q0RhdGV8bnVtYmVyfHN0cmluZ30gdGhlIGVuZGluZyBkYXRlIGZvciBhIHJhbmdlLlxyXG5cdFx0XHRAcGFyYW0gW2tleVVwXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgY29taW5nIGZyb20gPGNvZGU+a2V5VXA8L2NvZGU+IHByb2Nlc3NpbmcgKGludGVybmFsKS5cclxuXHRcdFx0QHBhcmFtIFtzZXRPcHRdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBjb21pbmcgZnJvbSBvcHRpb24gcHJvY2Vzc2luZyAoaW50ZXJuYWwpLlxyXG5cdFx0XHRAZXhhbXBsZSAkKHNlbGVjdG9yKS5kYXRlcGljaygnc2V0RGF0ZScsIG5ldyBEYXRlKDIwMTQsIDEyLTEsIDI1KSlcclxuICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdzZXREYXRlJywgJzEyLzI1LzIwMTQnLCAnMDEvMDEvMjAxNScpXHJcbiAkKHNlbGVjdG9yKS5kYXRlcGljaygnc2V0RGF0ZScsIFtkYXRlMSwgZGF0ZTIsIGRhdGUzXSkgKi9cclxuXHRcdHNldERhdGU6IGZ1bmN0aW9uKGVsZW0sIGRhdGVzLCBlbmREYXRlLCBrZXlVcCwgc2V0T3B0KSB7XHJcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0aWYgKCEkLmlzRW1wdHlPYmplY3QoaW5zdCkpIHtcclxuXHRcdFx0XHRpZiAoISQuaXNBcnJheShkYXRlcykpIHtcclxuXHRcdFx0XHRcdGRhdGVzID0gW2RhdGVzXTtcclxuXHRcdFx0XHRcdGlmIChlbmREYXRlKSB7XHJcblx0XHRcdFx0XHRcdGRhdGVzLnB1c2goZW5kRGF0ZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhciBtaW5EYXRlID0gaW5zdC5nZXQoJ21pbkRhdGUnKTtcclxuXHRcdFx0XHR2YXIgbWF4RGF0ZSA9IGluc3QuZ2V0KCdtYXhEYXRlJyk7XHJcblx0XHRcdFx0dmFyIGN1ckRhdGUgPSBpbnN0LnNlbGVjdGVkRGF0ZXNbMF07XHJcblx0XHRcdFx0aW5zdC5zZWxlY3RlZERhdGVzID0gW107XHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGRhdGUgPSBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIuZGV0ZXJtaW5lRGF0ZShcclxuXHRcdFx0XHRcdFx0ZGF0ZXNbaV0sIG51bGwsIGN1ckRhdGUsIGluc3QuZ2V0KCdkYXRlRm9ybWF0JyksIGluc3QuZ2V0Q29uZmlnKCkpO1xyXG5cdFx0XHRcdFx0aWYgKGRhdGUpIHtcclxuXHRcdFx0XHRcdFx0aWYgKCghbWluRGF0ZSB8fCBkYXRlLmNvbXBhcmVUbyhtaW5EYXRlKSAhPT0gLTEpICYmXHJcblx0XHRcdFx0XHRcdFx0XHQoIW1heERhdGUgfHwgZGF0ZS5jb21wYXJlVG8obWF4RGF0ZSkgIT09ICsxKSkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBmb3VuZCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgaW5zdC5zZWxlY3RlZERhdGVzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoaW5zdC5zZWxlY3RlZERhdGVzW2pdLmNvbXBhcmVUbyhkYXRlKSA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRpZiAoIWZvdW5kKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF0ZXMucHVzaChkYXRlKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aW5zdC5zZWxlY3RlZERhdGVzLnNwbGljZShpbnN0Lm9wdGlvbnMubXVsdGlTZWxlY3QgfHxcclxuXHRcdFx0XHRcdChpbnN0Lm9wdGlvbnMucmFuZ2VTZWxlY3QgPyAyIDogMSksIGluc3Quc2VsZWN0ZWREYXRlcy5sZW5ndGgpO1xyXG5cdFx0XHRcdGlmIChpbnN0Lm9wdGlvbnMucmFuZ2VTZWxlY3QpIHtcclxuXHRcdFx0XHRcdHN3aXRjaCAoaW5zdC5zZWxlY3RlZERhdGVzLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRjYXNlIDE6IGluc3Quc2VsZWN0ZWREYXRlc1sxXSA9IGluc3Quc2VsZWN0ZWREYXRlc1swXTsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgMjogaW5zdC5zZWxlY3RlZERhdGVzWzFdID1cclxuXHRcdFx0XHRcdFx0XHQoaW5zdC5zZWxlY3RlZERhdGVzWzBdLmNvbXBhcmVUbyhpbnN0LnNlbGVjdGVkRGF0ZXNbMV0pID09PSArMSA/XHJcblx0XHRcdFx0XHRcdFx0aW5zdC5zZWxlY3RlZERhdGVzWzBdIDogaW5zdC5zZWxlY3RlZERhdGVzWzFdKTsgYnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpbnN0LnBpY2tpbmdSYW5nZSA9IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpbnN0LnByZXZEYXRlID0gKGluc3QuZHJhd0RhdGUgPyBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKSA6IG51bGwpO1xyXG5cdFx0XHRcdGluc3QuZHJhd0RhdGUgPSB0aGlzLl9jaGVja01pbk1heCgoaW5zdC5zZWxlY3RlZERhdGVzWzBdIHx8XHJcblx0XHRcdFx0XHRpbnN0LmdldCgnZGVmYXVsdERhdGUnKSB8fCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKSkubmV3RGF0ZSgpLCBpbnN0KTtcclxuXHRcdFx0XHRpZiAoIXNldE9wdCkge1xyXG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlKGVsZW0pO1xyXG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlSW5wdXQoZWxlbSwga2V5VXApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogRGV0ZXJtaW5lIHdoZXRoZXIgYSBkYXRlIGlzIHNlbGVjdGFibGUgZm9yIHRoaXMgZGF0ZXBpY2tlci5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gY2hlY2suXHJcblx0XHRcdEBwYXJhbSBkYXRlIHtDRGF0ZXxzdHJpbmd8bnVtYmVyfSBUaGUgZGF0ZSB0byBjaGVjay5cclxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgc2VsZWN0YWJsZSwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdC5cclxuXHRcdFx0QGV4YW1wbGUgdmFyIHNlbGVjdGFibGUgPSAkKHNlbGVjdG9yKS5kYXRlcGljaygnaXNTZWxlY3RhYmxlJywgZGF0ZSkgKi9cclxuXHRcdGlzU2VsZWN0YWJsZTogZnVuY3Rpb24oZWxlbSwgZGF0ZSkge1xyXG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XHJcblx0XHRcdGlmICgkLmlzRW1wdHlPYmplY3QoaW5zdCkpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0ZGF0ZSA9IGluc3Qub3B0aW9ucy5jYWxlbmRhci5kZXRlcm1pbmVEYXRlKGRhdGUsXHJcblx0XHRcdFx0aW5zdC5zZWxlY3RlZERhdGVzWzBdIHx8IGluc3Qub3B0aW9ucy5jYWxlbmRhci50b2RheSgpLCBudWxsLFxyXG5cdFx0XHRcdGluc3Qub3B0aW9ucy5kYXRlRm9ybWF0LCBpbnN0LmdldENvbmZpZygpKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX2lzU2VsZWN0YWJsZShlbGVtLCBkYXRlLCBpbnN0Lm9wdGlvbnMub25EYXRlLFxyXG5cdFx0XHRcdGluc3QuZ2V0KCdtaW5EYXRlJyksIGluc3QuZ2V0KCdtYXhEYXRlJykpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogSW50ZXJuYWxseSBkZXRlcm1pbmUgd2hldGhlciBhIGRhdGUgaXMgc2VsZWN0YWJsZSBmb3IgdGhpcyBkYXRlcGlja2VyLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSB0aGUgY29udHJvbCB0byBjaGVjay5cclxuXHRcdFx0QHBhcmFtIGRhdGUge0NEYXRlfSBUaGUgZGF0ZSB0byBjaGVjay5cclxuXHRcdFx0QHBhcmFtIG9uRGF0ZSB7ZnVuY3Rpb258Ym9vbGVhbn0gQW55IDxjb2RlPm9uRGF0ZTwvY29kZT4gY2FsbGJhY2sgb3IgPGNvZGU+Y2FsbGJhY2suc2VsZWN0YWJsZTwvY29kZT4uXHJcblx0XHRcdEBwYXJhbSBtaW5EYXRlIHtDRGF0ZX0gVGhlIG1pbmltdW0gYWxsb3dlZCBkYXRlLlxyXG5cdFx0XHRAcGFyYW0gbWF4RGF0ZSB7Q0RhdGV9IFRoZSBtYXhpbXVtIGFsbG93ZWQgZGF0ZS5cclxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgc2VsZWN0YWJsZSwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdC4gKi9cclxuXHRcdF9pc1NlbGVjdGFibGU6IGZ1bmN0aW9uKGVsZW0sIGRhdGUsIG9uRGF0ZSwgbWluRGF0ZSwgbWF4RGF0ZSkge1xyXG5cdFx0XHR2YXIgZGF0ZUluZm8gPSAodHlwZW9mIG9uRGF0ZSA9PT0gJ2Jvb2xlYW4nID8ge3NlbGVjdGFibGU6IG9uRGF0ZX0gOlxyXG5cdFx0XHRcdCghJC5pc0Z1bmN0aW9uKG9uRGF0ZSkgPyB7fSA6IG9uRGF0ZS5hcHBseShlbGVtLCBbZGF0ZSwgdHJ1ZV0pKSk7XHJcblx0XHRcdHJldHVybiAoZGF0ZUluZm8uc2VsZWN0YWJsZSAhPT0gZmFsc2UpICYmXHJcblx0XHRcdFx0KCFtaW5EYXRlIHx8IGRhdGUudG9KRCgpID49IG1pbkRhdGUudG9KRCgpKSAmJiAoIW1heERhdGUgfHwgZGF0ZS50b0pEKCkgPD0gbWF4RGF0ZS50b0pEKCkpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUGVyZm9ybSBhIG5hbWVkIGFjdGlvbiBmb3IgYSBkYXRlcGlja2VyLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtlbGVtZW50fSBUaGUgY29udHJvbCB0byBhZmZlY3QuXHJcblx0XHRcdEBwYXJhbSBhY3Rpb24ge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGFjdGlvbi4gKi9cclxuXHRcdHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uKGVsZW0sIGFjdGlvbikge1xyXG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XHJcblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KGluc3QpICYmICF0aGlzLmlzRGlzYWJsZWQoZWxlbSkpIHtcclxuXHRcdFx0XHR2YXIgY29tbWFuZHMgPSBpbnN0Lm9wdGlvbnMuY29tbWFuZHM7XHJcblx0XHRcdFx0aWYgKGNvbW1hbmRzW2FjdGlvbl0gJiYgY29tbWFuZHNbYWN0aW9uXS5lbmFibGVkLmFwcGx5KGVsZW0sIFtpbnN0XSkpIHtcclxuXHRcdFx0XHRcdGNvbW1hbmRzW2FjdGlvbl0uYWN0aW9uLmFwcGx5KGVsZW0sIFtpbnN0XSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBTZXQgdGhlIGN1cnJlbnRseSBzaG93biBtb250aCwgZGVmYXVsdGluZyB0byB0b2RheSdzLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBhZmZlY3QuXHJcblx0XHRcdEBwYXJhbSBbeWVhcl0ge251bWJlcn0gVGhlIHllYXIgdG8gc2hvdy5cclxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIHNob3cgKDEtMTIpLlxyXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSB0byBzaG93LlxyXG5cdFx0XHRAZXhhbXBsZSAkKHNlbGVjdG9yKS5kYXRlcGljaygnc2hvd01vbnRoJywgMjAxNCwgMTIsIDI1KSAqL1xyXG5cdFx0c2hvd01vbnRoOiBmdW5jdGlvbihlbGVtLCB5ZWFyLCBtb250aCwgZGF5KSB7XHJcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0aWYgKCEkLmlzRW1wdHlPYmplY3QoaW5zdCkgJiYgKGRheSAhPSBudWxsIHx8XHJcblx0XHRcdFx0XHQoaW5zdC5kcmF3RGF0ZS55ZWFyKCkgIT09IHllYXIgfHwgaW5zdC5kcmF3RGF0ZS5tb250aCgpICE9PSBtb250aCkpKSB7XHJcblx0XHRcdFx0aW5zdC5wcmV2RGF0ZSA9IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpO1xyXG5cdFx0XHRcdHZhciBjYWxlbmRhciA9IGluc3Qub3B0aW9ucy5jYWxlbmRhcjtcclxuXHRcdFx0XHR2YXIgc2hvdyA9IHRoaXMuX2NoZWNrTWluTWF4KCh5ZWFyICE9IG51bGwgP1xyXG5cdFx0XHRcdFx0Y2FsZW5kYXIubmV3RGF0ZSh5ZWFyLCBtb250aCwgMSkgOiBjYWxlbmRhci50b2RheSgpKSwgaW5zdCk7XHJcblx0XHRcdFx0aW5zdC5kcmF3RGF0ZS5kYXRlKHNob3cueWVhcigpLCBzaG93Lm1vbnRoKCksIFxyXG5cdFx0XHRcdFx0KGRheSAhPSBudWxsID8gZGF5IDogTWF0aC5taW4oaW5zdC5kcmF3RGF0ZS5kYXkoKSxcclxuXHRcdFx0XHRcdGNhbGVuZGFyLmRheXNJbk1vbnRoKHNob3cueWVhcigpLCBzaG93Lm1vbnRoKCkpKSkpO1xyXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZShlbGVtKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQWRqdXN0IHRoZSBjdXJyZW50bHkgc2hvd24gbW9udGguXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGFmZmVjdC5cclxuXHRcdFx0QHBhcmFtIG9mZnNldCB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIG1vbnRocyB0byBjaGFuZ2UgYnkuXHJcblx0XHRcdEBleGFtcGxlICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdjaGFuZ2VNb250aCcsIDIpKi9cclxuXHRcdGNoYW5nZU1vbnRoOiBmdW5jdGlvbihlbGVtLCBvZmZzZXQpIHtcclxuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSkge1xyXG5cdFx0XHRcdHZhciBkYXRlID0gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuYWRkKG9mZnNldCwgJ20nKTtcclxuXHRcdFx0XHR0aGlzLnNob3dNb250aChlbGVtLCBkYXRlLnllYXIoKSwgZGF0ZS5tb250aCgpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQWRqdXN0IHRoZSBjdXJyZW50bHkgc2hvd24gZGF5LlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBhZmZlY3QuXHJcblx0XHRcdEBwYXJhbSBvZmZzZXQge251bWJlcn0gVGhlIG51bWJlciBvZiBkYXlzIHRvIGNoYW5nZSBieS5cclxuXHRcdFx0QGV4YW1wbGUgJChzZWxlY3RvcikuZGF0ZXBpY2soJ2NoYW5nZURheScsIDcpKi9cclxuXHRcdGNoYW5nZURheTogZnVuY3Rpb24oZWxlbSwgb2Zmc2V0KSB7XHJcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0aWYgKCEkLmlzRW1wdHlPYmplY3QoaW5zdCkpIHtcclxuXHRcdFx0XHR2YXIgZGF0ZSA9IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLmFkZChvZmZzZXQsICdkJyk7XHJcblx0XHRcdFx0dGhpcy5zaG93TW9udGgoZWxlbSwgZGF0ZS55ZWFyKCksIGRhdGUubW9udGgoKSwgZGF0ZS5kYXkoKSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFJlc3RyaWN0IGEgZGF0ZSB0byB0aGUgbWluaW11bS9tYXhpbXVtIHNwZWNpZmllZC5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gZGF0ZSB7Q0RhdGV9IFRoZSBkYXRlIHRvIGNoZWNrLlxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy4gKi9cclxuXHRcdF9jaGVja01pbk1heDogZnVuY3Rpb24oZGF0ZSwgaW5zdCkge1xyXG5cdFx0XHR2YXIgbWluRGF0ZSA9IGluc3QuZ2V0KCdtaW5EYXRlJyk7XHJcblx0XHRcdHZhciBtYXhEYXRlID0gaW5zdC5nZXQoJ21heERhdGUnKTtcclxuXHRcdFx0ZGF0ZSA9IChtaW5EYXRlICYmIGRhdGUuY29tcGFyZVRvKG1pbkRhdGUpID09PSAtMSA/IG1pbkRhdGUubmV3RGF0ZSgpIDogZGF0ZSk7XHJcblx0XHRcdGRhdGUgPSAobWF4RGF0ZSAmJiBkYXRlLmNvbXBhcmVUbyhtYXhEYXRlKSA9PT0gKzEgPyBtYXhEYXRlLm5ld0RhdGUoKSA6IGRhdGUpO1xyXG5cdFx0XHRyZXR1cm4gZGF0ZTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBkYXRlIGFzc29jaWF0ZWQgd2l0aCBhbiBlbnRyeSBpbiB0aGUgZGF0ZXBpY2tlci5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gZXhhbWluZS5cclxuXHRcdFx0QHBhcmFtIHRhcmdldCB7RWxlbWVudH0gVGhlIHNlbGVjdGVkIGRhdGVwaWNrZXIgZWxlbWVudC5cclxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBjb3JyZXNwb25kaW5nIGRhdGUsIG9yIDxjb2RlPm51bGw8L2NvZGU+Llx0XHRcdFxyXG5cdFx0XHRAZXhhbXBsZSB2YXIgZGF0ZSA9ICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdyZXRyaWV2ZURhdGUnLCAkKCdkaXYuZGF0ZXBpY2stcG9wdXAgYTpjb250YWlucygxMCknKVswXSkgKi9cclxuXHRcdHJldHJpZXZlRGF0ZTogZnVuY3Rpb24oZWxlbSwgdGFyZ2V0KSB7XHJcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0cmV0dXJuICgkLmlzRW1wdHlPYmplY3QoaW5zdCkgPyBudWxsIDogaW5zdC5vcHRpb25zLmNhbGVuZGFyLmZyb21KRChcclxuXHRcdFx0XHRwYXJzZUZsb2F0KHRhcmdldC5jbGFzc05hbWUucmVwbGFjZSgvXi4qamQoXFxkK1xcLjUpLiokLywgJyQxJykpKSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBTZWxlY3QgYSBkYXRlIGZvciB0aGlzIGRhdGVwaWNrZXIuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGV4YW1pbmUuXHJcblx0XHRcdEBwYXJhbSB0YXJnZXQge0VsZW1lbnR9IFRoZSBzZWxlY3RlZCBkYXRlcGlja2VyIGVsZW1lbnQuXHJcblx0XHRcdEBleGFtcGxlICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdzZWxlY3REYXRlJywgJCgnZGl2LmRhdGVwaWNrLXBvcHVwIGE6Y29udGFpbnMoMTApJylbMF0pICovXHJcblx0XHRzZWxlY3REYXRlOiBmdW5jdGlvbihlbGVtLCB0YXJnZXQpIHtcclxuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSAmJiAhdGhpcy5pc0Rpc2FibGVkKGVsZW0pKSB7XHJcblx0XHRcdFx0dmFyIGRhdGUgPSB0aGlzLnJldHJpZXZlRGF0ZShlbGVtLCB0YXJnZXQpO1xyXG5cdFx0XHRcdGlmIChpbnN0Lm9wdGlvbnMubXVsdGlTZWxlY3QpIHtcclxuXHRcdFx0XHRcdHZhciBmb3VuZCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0LnNlbGVjdGVkRGF0ZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0aWYgKGRhdGUuY29tcGFyZVRvKGluc3Quc2VsZWN0ZWREYXRlc1tpXSkgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF0ZXMuc3BsaWNlKGksIDEpO1xyXG5cdFx0XHRcdFx0XHRcdGZvdW5kID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCFmb3VuZCAmJiBpbnN0LnNlbGVjdGVkRGF0ZXMubGVuZ3RoIDwgaW5zdC5vcHRpb25zLm11bHRpU2VsZWN0KSB7XHJcblx0XHRcdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlcy5wdXNoKGRhdGUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIGlmIChpbnN0Lm9wdGlvbnMucmFuZ2VTZWxlY3QpIHtcclxuXHRcdFx0XHRcdGlmIChpbnN0LnBpY2tpbmdSYW5nZSkge1xyXG5cdFx0XHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF0ZXNbMV0gPSBkYXRlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlcyA9IFtkYXRlLCBkYXRlXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGluc3QucGlja2luZ1JhbmdlID0gIWluc3QucGlja2luZ1JhbmdlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlcyA9IFtkYXRlXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aW5zdC5wcmV2RGF0ZSA9IGluc3QuZHJhd0RhdGUgPSBkYXRlLm5ld0RhdGUoKTtcclxuXHRcdFx0XHR0aGlzLl91cGRhdGVJbnB1dChlbGVtKTtcclxuXHRcdFx0XHRpZiAoaW5zdC5pbmxpbmUgfHwgaW5zdC5waWNraW5nUmFuZ2UgfHwgaW5zdC5zZWxlY3RlZERhdGVzLmxlbmd0aCA8XHJcblx0XHRcdFx0XHRcdChpbnN0Lm9wdGlvbnMubXVsdGlTZWxlY3QgfHwgKGluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCA/IDIgOiAxKSkpIHtcclxuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZShlbGVtKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHR0aGlzLmhpZGUoZWxlbSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBHZW5lcmF0ZSB0aGUgZGF0ZXBpY2tlciBjb250ZW50IGZvciB0aGlzIGNvbnRyb2wuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGFmZmVjdC5cclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEByZXR1cm4ge2pRdWVyeX0gVGhlIGRhdGVwaWNrZXIgY29udGVudCAqL1xyXG5cdFx0X2dlbmVyYXRlQ29udGVudDogZnVuY3Rpb24oZWxlbSwgaW5zdCkge1xyXG5cdFx0XHR2YXIgbW9udGhzVG9TaG93ID0gaW5zdC5vcHRpb25zLm1vbnRoc1RvU2hvdztcclxuXHRcdFx0bW9udGhzVG9TaG93ID0gKCQuaXNBcnJheShtb250aHNUb1Nob3cpID8gbW9udGhzVG9TaG93IDogWzEsIG1vbnRoc1RvU2hvd10pO1xyXG5cdFx0XHRpbnN0LmRyYXdEYXRlID0gdGhpcy5fY2hlY2tNaW5NYXgoXHJcblx0XHRcdFx0aW5zdC5kcmF3RGF0ZSB8fCBpbnN0LmdldCgnZGVmYXVsdERhdGUnKSB8fCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKSwgaW5zdCk7XHJcblx0XHRcdHZhciBkcmF3RGF0ZSA9IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLmFkZCgtaW5zdC5vcHRpb25zLm1vbnRoc09mZnNldCwgJ20nKTtcclxuXHRcdFx0Ly8gR2VuZXJhdGUgbW9udGhzXHJcblx0XHRcdHZhciBtb250aFJvd3MgPSAnJztcclxuXHRcdFx0Zm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9udGhzVG9TaG93WzBdOyByb3crKykge1xyXG5cdFx0XHRcdHZhciBtb250aHMgPSAnJztcclxuXHRcdFx0XHRmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb250aHNUb1Nob3dbMV07IGNvbCsrKSB7XHJcblx0XHRcdFx0XHRtb250aHMgKz0gdGhpcy5fZ2VuZXJhdGVNb250aChlbGVtLCBpbnN0LCBkcmF3RGF0ZS55ZWFyKCksXHJcblx0XHRcdFx0XHRcdGRyYXdEYXRlLm1vbnRoKCksIGluc3Qub3B0aW9ucy5jYWxlbmRhciwgaW5zdC5vcHRpb25zLnJlbmRlcmVyLCAocm93ID09PSAwICYmIGNvbCA9PT0gMCkpO1xyXG5cdFx0XHRcdFx0ZHJhd0RhdGUuYWRkKDEsICdtJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG1vbnRoUm93cyArPSB0aGlzLl9wcmVwYXJlKGluc3Qub3B0aW9ucy5yZW5kZXJlci5tb250aFJvdywgaW5zdCkucmVwbGFjZSgvXFx7bW9udGhzXFx9LywgbW9udGhzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgcGlja2VyID0gdGhpcy5fcHJlcGFyZShpbnN0Lm9wdGlvbnMucmVuZGVyZXIucGlja2VyLCBpbnN0KS5yZXBsYWNlKC9cXHttb250aHNcXH0vLCBtb250aFJvd3MpLlxyXG5cdFx0XHRcdHJlcGxhY2UoL1xce3dlZWtIZWFkZXJcXH0vZywgdGhpcy5fZ2VuZXJhdGVEYXlIZWFkZXJzKGluc3QsIGluc3Qub3B0aW9ucy5jYWxlbmRhciwgaW5zdC5vcHRpb25zLnJlbmRlcmVyKSk7XHJcblx0XHRcdC8vIEFkZCBjb21tYW5kc1xyXG5cdFx0XHR2YXIgYWRkQ29tbWFuZCA9IGZ1bmN0aW9uKHR5cGUsIG9wZW4sIGNsb3NlLCBuYW1lLCBjbGFzc2VzKSB7XHJcblx0XHRcdFx0aWYgKHBpY2tlci5pbmRleE9mKCd7JyArIHR5cGUgKyAnOicgKyBuYW1lICsgJ30nKSA9PT0gLTEpIHtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIGNvbW1hbmQgPSBpbnN0Lm9wdGlvbnMuY29tbWFuZHNbbmFtZV07XHJcblx0XHRcdFx0dmFyIGRhdGUgPSAoaW5zdC5vcHRpb25zLmNvbW1hbmRzQXNEYXRlRm9ybWF0ID8gY29tbWFuZC5kYXRlLmFwcGx5KGVsZW0sIFtpbnN0XSkgOiBudWxsKTtcclxuXHRcdFx0XHRwaWNrZXIgPSBwaWNrZXIucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxceycgKyB0eXBlICsgJzonICsgbmFtZSArICdcXFxcfScsICdnJyksXHJcblx0XHRcdFx0XHQnPCcgKyBvcGVuICsgKGNvbW1hbmQuc3RhdHVzID8gJyB0aXRsZT1cIicgKyBpbnN0Lm9wdGlvbnNbY29tbWFuZC5zdGF0dXNdICsgJ1wiJyA6ICcnKSArXHJcblx0XHRcdFx0XHQnIGNsYXNzPVwiJyArIGluc3Qub3B0aW9ucy5yZW5kZXJlci5jb21tYW5kQ2xhc3MgKyAnICcgK1xyXG5cdFx0XHRcdFx0aW5zdC5vcHRpb25zLnJlbmRlcmVyLmNvbW1hbmRDbGFzcyArICctJyArIG5hbWUgKyAnICcgKyBjbGFzc2VzICtcclxuXHRcdFx0XHRcdChjb21tYW5kLmVuYWJsZWQoaW5zdCkgPyAnJyA6ICcgJyArIGluc3Qub3B0aW9ucy5yZW5kZXJlci5kaXNhYmxlZENsYXNzKSArICdcIj4nICtcclxuXHRcdFx0XHRcdChkYXRlID8gZGF0ZS5mb3JtYXREYXRlKGluc3Qub3B0aW9uc1tjb21tYW5kLnRleHRdKSA6XHJcblx0XHRcdFx0XHRpbnN0Lm9wdGlvbnNbY29tbWFuZC50ZXh0XSkgKyAnPC8nICsgY2xvc2UgKyAnPicpO1xyXG5cdFx0XHR9O1xyXG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIGluc3Qub3B0aW9ucy5jb21tYW5kcykge1xyXG5cdFx0XHRcdGFkZENvbW1hbmQoJ2J1dHRvbicsICdidXR0b24gdHlwZT1cImJ1dHRvblwiJywgJ2J1dHRvbicsIG5hbWUsXHJcblx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMucmVuZGVyZXIuY29tbWFuZEJ1dHRvbkNsYXNzKTtcclxuXHRcdFx0XHRhZGRDb21tYW5kKCdsaW5rJywgJ2EgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKVwiJywgJ2EnLCBuYW1lLFxyXG5cdFx0XHRcdFx0aW5zdC5vcHRpb25zLnJlbmRlcmVyLmNvbW1hbmRMaW5rQ2xhc3MpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHBpY2tlciA9ICQocGlja2VyKTtcclxuXHRcdFx0aWYgKG1vbnRoc1RvU2hvd1sxXSA+IDEpIHtcclxuXHRcdFx0XHR2YXIgY291bnQgPSAwO1xyXG5cdFx0XHRcdCQoaW5zdC5vcHRpb25zLnJlbmRlcmVyLm1vbnRoU2VsZWN0b3IsIHBpY2tlcikuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHZhciBudGggPSArK2NvdW50ICUgbW9udGhzVG9TaG93WzFdO1xyXG5cdFx0XHRcdFx0JCh0aGlzKS5hZGRDbGFzcyhudGggPT09IDEgPyAnZmlyc3QnIDogKG50aCA9PT0gMCA/ICdsYXN0JyA6ICcnKSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gQWRkIGRhdGVwaWNrZXIgYmVoYXZpb3VyXHJcblx0XHRcdHZhciBzZWxmID0gdGhpcztcclxuXHRcdFx0ZnVuY3Rpb24gcmVtb3ZlSGlnaGxpZ2h0KCkge1xyXG5cdFx0XHRcdChpbnN0LmlubGluZSA/ICQodGhpcykuY2xvc2VzdCgnLicgKyBzZWxmLl9nZXRNYXJrZXIoKSkgOiBpbnN0LmRpdikuXHJcblx0XHRcdFx0XHRmaW5kKGluc3Qub3B0aW9ucy5yZW5kZXJlci5kYXlTZWxlY3RvciArICcgYScpLlxyXG5cdFx0XHRcdFx0cmVtb3ZlQ2xhc3MoaW5zdC5vcHRpb25zLnJlbmRlcmVyLmhpZ2hsaWdodGVkQ2xhc3MpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHBpY2tlci5maW5kKGluc3Qub3B0aW9ucy5yZW5kZXJlci5kYXlTZWxlY3RvciArICcgYScpLmhvdmVyKFxyXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdHJlbW92ZUhpZ2hsaWdodC5hcHBseSh0aGlzKTtcclxuXHRcdFx0XHRcdFx0JCh0aGlzKS5hZGRDbGFzcyhpbnN0Lm9wdGlvbnMucmVuZGVyZXIuaGlnaGxpZ2h0ZWRDbGFzcyk7XHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0cmVtb3ZlSGlnaGxpZ2h0KS5cclxuXHRcdFx0XHRjbGljayhmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHNlbGYuc2VsZWN0RGF0ZShlbGVtLCB0aGlzKTtcclxuXHRcdFx0XHR9KS5lbmQoKS5cclxuXHRcdFx0XHRmaW5kKCdzZWxlY3QuJyArIHRoaXMuX21vbnRoWWVhckNsYXNzICsgJzpub3QoLicgKyB0aGlzLl9hbnlZZWFyQ2xhc3MgKyAnKScpLlxyXG5cdFx0XHRcdGNoYW5nZShmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHZhciBtb250aFllYXIgPSAkKHRoaXMpLnZhbCgpLnNwbGl0KCcvJyk7XHJcblx0XHRcdFx0XHRzZWxmLnNob3dNb250aChlbGVtLCBwYXJzZUludChtb250aFllYXJbMV0sIDEwKSwgcGFyc2VJbnQobW9udGhZZWFyWzBdLCAxMCkpO1xyXG5cdFx0XHRcdH0pLmVuZCgpLlxyXG5cdFx0XHRcdGZpbmQoJ3NlbGVjdC4nICsgdGhpcy5fYW55WWVhckNsYXNzKS5jbGljayhmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdCQodGhpcykuY3NzKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpLlxyXG5cdFx0XHRcdFx0XHRuZXh0KCdpbnB1dCcpLmNzcyh7bGVmdDogdGhpcy5vZmZzZXRMZWZ0LCB0b3A6IHRoaXMub2Zmc2V0VG9wLFxyXG5cdFx0XHRcdFx0XHR3aWR0aDogdGhpcy5vZmZzZXRXaWR0aCwgaGVpZ2h0OiB0aGlzLm9mZnNldEhlaWdodH0pLnNob3coKS5mb2N1cygpO1xyXG5cdFx0XHRcdH0pLmVuZCgpLlxyXG5cdFx0XHRcdGZpbmQoJ2lucHV0LicgKyBzZWxmLl9tb250aFllYXJDbGFzcykuY2hhbmdlKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdFx0dmFyIHllYXIgPSBwYXJzZUludCgkKHRoaXMpLnZhbCgpLCAxMCk7XHJcblx0XHRcdFx0XHRcdHllYXIgPSAoaXNOYU4oeWVhcikgPyBpbnN0LmRyYXdEYXRlLnllYXIoKSA6IHllYXIpO1xyXG5cdFx0XHRcdFx0XHRzZWxmLnNob3dNb250aChlbGVtLCB5ZWFyLCBpbnN0LmRyYXdEYXRlLm1vbnRoKCksIGluc3QuZHJhd0RhdGUuZGF5KCkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Y2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRcdFx0YWxlcnQoZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSkua2V5ZG93bihmdW5jdGlvbihldmVudCkge1xyXG5cdFx0XHRcdFx0aWYgKGV2ZW50LmtleUNvZGUgPT09IDEzKSB7IC8vIEVudGVyXHJcblx0XHRcdFx0XHRcdCQoZXZlbnQuZWxlbSkuY2hhbmdlKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSAyNykgeyAvLyBFc2NhcGVcclxuXHRcdFx0XHRcdFx0JChldmVudC5lbGVtKS5oaWRlKCkucHJldignc2VsZWN0JykuY3NzKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcclxuXHRcdFx0XHRcdFx0aW5zdC5lbGVtLmZvY3VzKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdC8vIEFkZCBrZXlib2FyZCBoYW5kbGluZ1xyXG5cdFx0XHR2YXIgZGF0YSA9IHtlbGVtOiBpbnN0LmVsZW1bMF19O1xyXG5cdFx0XHRwaWNrZXIua2V5ZG93bihkYXRhLCB0aGlzLl9rZXlEb3duKS5rZXlwcmVzcyhkYXRhLCB0aGlzLl9rZXlQcmVzcykua2V5dXAoZGF0YSwgdGhpcy5fa2V5VXApO1xyXG5cdFx0XHQvLyBBZGQgY29tbWFuZCBiZWhhdmlvdXJcclxuXHRcdFx0cGlja2VyLmZpbmQoJy4nICsgaW5zdC5vcHRpb25zLnJlbmRlcmVyLmNvbW1hbmRDbGFzcykuY2xpY2soZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRpZiAoISQodGhpcykuaGFzQ2xhc3MoaW5zdC5vcHRpb25zLnJlbmRlcmVyLmRpc2FibGVkQ2xhc3MpKSB7XHJcblx0XHRcdFx0XHRcdHZhciBhY3Rpb24gPSB0aGlzLmNsYXNzTmFtZS5yZXBsYWNlKFxyXG5cdFx0XHRcdFx0XHRcdG5ldyBSZWdFeHAoJ14uKicgKyBpbnN0Lm9wdGlvbnMucmVuZGVyZXIuY29tbWFuZENsYXNzICsgJy0oW14gXSspLiokJyksICckMScpO1xyXG5cdFx0XHRcdFx0XHRwbHVnaW4ucGVyZm9ybUFjdGlvbihlbGVtLCBhY3Rpb24pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHQvLyBBZGQgY2xhc3Nlc1xyXG5cdFx0XHRpZiAoaW5zdC5vcHRpb25zLmlzUlRMKSB7XHJcblx0XHRcdFx0cGlja2VyLmFkZENsYXNzKGluc3Qub3B0aW9ucy5yZW5kZXJlci5ydGxDbGFzcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG1vbnRoc1RvU2hvd1swXSAqIG1vbnRoc1RvU2hvd1sxXSA+IDEpIHtcclxuXHRcdFx0XHRwaWNrZXIuYWRkQ2xhc3MoaW5zdC5vcHRpb25zLnJlbmRlcmVyLm11bHRpQ2xhc3MpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChpbnN0Lm9wdGlvbnMucGlja2VyQ2xhc3MpIHtcclxuXHRcdFx0XHRwaWNrZXIuYWRkQ2xhc3MoaW5zdC5vcHRpb25zLnBpY2tlckNsYXNzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBSZXNpemVcclxuXHRcdFx0JCgnYm9keScpLmFwcGVuZChwaWNrZXIpO1xyXG5cdFx0XHR2YXIgd2lkdGggPSAwO1xyXG5cdFx0XHRwaWNrZXIuZmluZChpbnN0Lm9wdGlvbnMucmVuZGVyZXIubW9udGhTZWxlY3RvcikuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR3aWR0aCArPSAkKHRoaXMpLm91dGVyV2lkdGgoKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdHBpY2tlci53aWR0aCh3aWR0aCAvIG1vbnRoc1RvU2hvd1swXSk7XHJcblx0XHRcdC8vIFByZS1zaG93IGN1c3RvbWlzYXRpb25cclxuXHRcdFx0aWYgKCQuaXNGdW5jdGlvbihpbnN0Lm9wdGlvbnMub25TaG93KSkge1xyXG5cdFx0XHRcdGluc3Qub3B0aW9ucy5vblNob3cuYXBwbHkoZWxlbSwgW3BpY2tlciwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLCBpbnN0XSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHBpY2tlcjtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEdlbmVyYXRlIHRoZSBjb250ZW50IGZvciBhIHNpbmdsZSBtb250aC5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gYWZmZWN0LlxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cclxuXHRcdFx0QHBhcmFtIHllYXIge251bWJlcn0gVGhlIHllYXIgdG8gZ2VuZXJhdGUuXHJcblx0XHRcdEBwYXJhbSBtb250aCB7bnVtYmVyfSBUaGUgbW9udGggdG8gZ2VuZXJhdGUuXHJcblx0XHRcdEBwYXJhbSBjYWxlbmRhciB7QmFzZUNhbGVuZGFyfSBUaGUgY3VycmVudCBjYWxlbmRhci5cclxuXHRcdFx0QHBhcmFtIHJlbmRlcmVyIHtvYmplY3R9IFRoZSByZW5kZXJpbmcgdGVtcGxhdGVzLlxyXG5cdFx0XHRAcGFyYW0gZmlyc3Qge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGZpcnN0IG9mIG11bHRpcGxlIG1vbnRocy5cclxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGUgbW9udGggY29udGVudC4gKi9cclxuXHRcdF9nZW5lcmF0ZU1vbnRoOiBmdW5jdGlvbihlbGVtLCBpbnN0LCB5ZWFyLCBtb250aCwgY2FsZW5kYXIsIHJlbmRlcmVyLCBmaXJzdCkge1xyXG5cdFx0XHR2YXIgZGF5c0luTW9udGggPSBjYWxlbmRhci5kYXlzSW5Nb250aCh5ZWFyLCBtb250aCk7XHJcblx0XHRcdHZhciBtb250aHNUb1Nob3cgPSBpbnN0Lm9wdGlvbnMubW9udGhzVG9TaG93O1xyXG5cdFx0XHRtb250aHNUb1Nob3cgPSAoJC5pc0FycmF5KG1vbnRoc1RvU2hvdykgPyBtb250aHNUb1Nob3cgOiBbMSwgbW9udGhzVG9TaG93XSk7XHJcblx0XHRcdHZhciBmaXhlZFdlZWtzID0gaW5zdC5vcHRpb25zLmZpeGVkV2Vla3MgfHwgKG1vbnRoc1RvU2hvd1swXSAqIG1vbnRoc1RvU2hvd1sxXSA+IDEpO1xyXG5cdFx0XHR2YXIgZmlyc3REYXkgPSBpbnN0Lm9wdGlvbnMuZmlyc3REYXk7XHJcblx0XHRcdGZpcnN0RGF5ID0gKGZpcnN0RGF5ID09IG51bGwgPyBjYWxlbmRhci5sb2NhbC5maXJzdERheSA6IGZpcnN0RGF5KTtcclxuXHRcdFx0dmFyIGxlYWREYXlzID0gKGNhbGVuZGFyLmRheU9mV2Vlayh5ZWFyLCBtb250aCwgY2FsZW5kYXIubWluRGF5KSAtXHJcblx0XHRcdFx0Zmlyc3REYXkgKyBjYWxlbmRhci5kYXlzSW5XZWVrKCkpICUgY2FsZW5kYXIuZGF5c0luV2VlaygpO1xyXG5cdFx0XHR2YXIgbnVtV2Vla3MgPSAoZml4ZWRXZWVrcyA/IDYgOiBNYXRoLmNlaWwoKGxlYWREYXlzICsgZGF5c0luTW9udGgpIC8gY2FsZW5kYXIuZGF5c0luV2VlaygpKSk7XHJcblx0XHRcdHZhciBzZWxlY3RPdGhlck1vbnRocyA9IGluc3Qub3B0aW9ucy5zZWxlY3RPdGhlck1vbnRocyAmJiBpbnN0Lm9wdGlvbnMuc2hvd090aGVyTW9udGhzO1xyXG5cdFx0XHR2YXIgbWluRGF0ZSA9IChpbnN0LnBpY2tpbmdSYW5nZSA/IGluc3Quc2VsZWN0ZWREYXRlc1swXSA6IGluc3QuZ2V0KCdtaW5EYXRlJykpO1xyXG5cdFx0XHR2YXIgbWF4RGF0ZSA9IGluc3QuZ2V0KCdtYXhEYXRlJyk7XHJcblx0XHRcdHZhciBzaG93V2Vla3MgPSByZW5kZXJlci53ZWVrLmluZGV4T2YoJ3t3ZWVrT2ZZZWFyfScpID4gLTE7XHJcblx0XHRcdHZhciB0b2RheSA9IGNhbGVuZGFyLnRvZGF5KCk7XHJcblx0XHRcdHZhciBkcmF3RGF0ZSA9IGNhbGVuZGFyLm5ld0RhdGUoeWVhciwgbW9udGgsIGNhbGVuZGFyLm1pbkRheSk7XHJcblx0XHRcdGRyYXdEYXRlLmFkZCgtbGVhZERheXMgLSAoZml4ZWRXZWVrcyAmJlxyXG5cdFx0XHRcdChkcmF3RGF0ZS5kYXlPZldlZWsoKSA9PT0gZmlyc3REYXkgfHwgZHJhd0RhdGUuZGF5c0luTW9udGgoKSA8IGNhbGVuZGFyLmRheXNJbldlZWsoKSk/XHJcblx0XHRcdFx0Y2FsZW5kYXIuZGF5c0luV2VlaygpIDogMCksICdkJyk7XHJcblx0XHRcdHZhciBqZCA9IGRyYXdEYXRlLnRvSkQoKTtcclxuXHRcdFx0Ly8gR2VuZXJhdGUgd2Vla3NcclxuXHRcdFx0dmFyIHdlZWtzID0gJyc7XHJcblx0XHRcdGZvciAodmFyIHdlZWsgPSAwOyB3ZWVrIDwgbnVtV2Vla3M7IHdlZWsrKykge1xyXG5cdFx0XHRcdHZhciB3ZWVrT2ZZZWFyID0gKCFzaG93V2Vla3MgPyAnJyA6ICc8c3BhbiBjbGFzcz1cImpkJyArIGpkICsgJ1wiPicgK1xyXG5cdFx0XHRcdFx0KCQuaXNGdW5jdGlvbihpbnN0Lm9wdGlvbnMuY2FsY3VsYXRlV2VlaykgP1xyXG5cdFx0XHRcdFx0aW5zdC5vcHRpb25zLmNhbGN1bGF0ZVdlZWsoZHJhd0RhdGUpIDogZHJhd0RhdGUud2Vla09mWWVhcigpKSArICc8L3NwYW4+Jyk7XHJcblx0XHRcdFx0dmFyIGRheXMgPSAnJztcclxuXHRcdFx0XHRmb3IgKHZhciBkYXkgPSAwOyBkYXkgPCBjYWxlbmRhci5kYXlzSW5XZWVrKCk7IGRheSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgc2VsZWN0ZWQgPSBmYWxzZTtcclxuXHRcdFx0XHRcdGlmIChpbnN0Lm9wdGlvbnMucmFuZ2VTZWxlY3QgJiYgaW5zdC5zZWxlY3RlZERhdGVzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdFx0c2VsZWN0ZWQgPSAoZHJhd0RhdGUuY29tcGFyZVRvKGluc3Quc2VsZWN0ZWREYXRlc1swXSkgIT09IC0xICYmXHJcblx0XHRcdFx0XHRcdFx0ZHJhd0RhdGUuY29tcGFyZVRvKGluc3Quc2VsZWN0ZWREYXRlc1sxXSkgIT09ICsxKVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdC5zZWxlY3RlZERhdGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGluc3Quc2VsZWN0ZWREYXRlc1tpXS5jb21wYXJlVG8oZHJhd0RhdGUpID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRzZWxlY3RlZCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHZhciBkYXRlSW5mbyA9ICghJC5pc0Z1bmN0aW9uKGluc3Qub3B0aW9ucy5vbkRhdGUpID8ge30gOlxyXG5cdFx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMub25EYXRlLmFwcGx5KGVsZW0sIFtkcmF3RGF0ZSwgZHJhd0RhdGUubW9udGgoKSA9PT0gbW9udGhdKSk7XHJcblx0XHRcdFx0XHR2YXIgc2VsZWN0YWJsZSA9IChzZWxlY3RPdGhlck1vbnRocyB8fCBkcmF3RGF0ZS5tb250aCgpID09PSBtb250aCkgJiZcclxuXHRcdFx0XHRcdFx0dGhpcy5faXNTZWxlY3RhYmxlKGVsZW0sIGRyYXdEYXRlLCBkYXRlSW5mby5zZWxlY3RhYmxlLCBtaW5EYXRlLCBtYXhEYXRlKTtcclxuXHRcdFx0XHRcdGRheXMgKz0gdGhpcy5fcHJlcGFyZShyZW5kZXJlci5kYXksIGluc3QpLnJlcGxhY2UoL1xce2RheVxcfS9nLFxyXG5cdFx0XHRcdFx0XHQoc2VsZWN0YWJsZSA/ICc8YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCInIDogJzxzcGFuJykgK1xyXG5cdFx0XHRcdFx0XHQnIGNsYXNzPVwiamQnICsgamQgKyAnICcgKyAoZGF0ZUluZm8uZGF0ZUNsYXNzIHx8ICcnKSArXHJcblx0XHRcdFx0XHRcdChzZWxlY3RlZCAmJiAoc2VsZWN0T3RoZXJNb250aHMgfHwgZHJhd0RhdGUubW9udGgoKSA9PT0gbW9udGgpID9cclxuXHRcdFx0XHRcdFx0JyAnICsgcmVuZGVyZXIuc2VsZWN0ZWRDbGFzcyA6ICcnKSArXHJcblx0XHRcdFx0XHRcdChzZWxlY3RhYmxlID8gJyAnICsgcmVuZGVyZXIuZGVmYXVsdENsYXNzIDogJycpICtcclxuXHRcdFx0XHRcdFx0KGRyYXdEYXRlLndlZWtEYXkoKSA/ICcnIDogJyAnICsgcmVuZGVyZXIud2Vla2VuZENsYXNzKSArXHJcblx0XHRcdFx0XHRcdChkcmF3RGF0ZS5tb250aCgpID09PSBtb250aCA/ICcnIDogJyAnICsgcmVuZGVyZXIub3RoZXJNb250aENsYXNzKSArXHJcblx0XHRcdFx0XHRcdChkcmF3RGF0ZS5jb21wYXJlVG8odG9kYXkpID09PSAwICYmIGRyYXdEYXRlLm1vbnRoKCkgPT09IG1vbnRoID9cclxuXHRcdFx0XHRcdFx0JyAnICsgcmVuZGVyZXIudG9kYXlDbGFzcyA6ICcnKSArXHJcblx0XHRcdFx0XHRcdChkcmF3RGF0ZS5jb21wYXJlVG8oaW5zdC5kcmF3RGF0ZSkgPT09IDAgJiYgZHJhd0RhdGUubW9udGgoKSA9PT0gbW9udGggP1xyXG5cdFx0XHRcdFx0XHQnICcgKyByZW5kZXJlci5oaWdobGlnaHRlZENsYXNzIDogJycpICsgJ1wiJyArXHJcblx0XHRcdFx0XHRcdChkYXRlSW5mby50aXRsZSB8fCAoaW5zdC5vcHRpb25zLmRheVN0YXR1cyAmJiBzZWxlY3RhYmxlKSA/ICcgdGl0bGU9XCInICtcclxuXHRcdFx0XHRcdFx0KGRhdGVJbmZvLnRpdGxlIHx8IGRyYXdEYXRlLmZvcm1hdERhdGUoaW5zdC5vcHRpb25zLmRheVN0YXR1cykpICsgJ1wiJyA6ICcnKSArICc+JyArXHJcblx0XHRcdFx0XHRcdChpbnN0Lm9wdGlvbnMuc2hvd090aGVyTW9udGhzIHx8IGRyYXdEYXRlLm1vbnRoKCkgPT09IG1vbnRoID9cclxuXHRcdFx0XHRcdFx0ZGF0ZUluZm8uY29udGVudCB8fCBkcmF3RGF0ZS5kYXkoKSA6ICcmIzE2MDsnKSArXHJcblx0XHRcdFx0XHRcdChzZWxlY3RhYmxlID8gJzwvYT4nIDogJzwvc3Bhbj4nKSk7XHJcblx0XHRcdFx0XHRkcmF3RGF0ZS5hZGQoMSwgJ2QnKTtcclxuXHRcdFx0XHRcdGpkKys7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHdlZWtzICs9IHRoaXMuX3ByZXBhcmUocmVuZGVyZXIud2VlaywgaW5zdCkucmVwbGFjZSgvXFx7ZGF5c1xcfS9nLCBkYXlzKS5cclxuXHRcdFx0XHRcdHJlcGxhY2UoL1xce3dlZWtPZlllYXJcXH0vZywgd2Vla09mWWVhcik7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIG1vbnRoSGVhZGVyID0gdGhpcy5fcHJlcGFyZShyZW5kZXJlci5tb250aCwgaW5zdCkubWF0Y2goL1xce21vbnRoSGVhZGVyKDpbXlxcfV0rKT9cXH0vKTtcclxuXHRcdFx0bW9udGhIZWFkZXIgPSAobW9udGhIZWFkZXJbMF0ubGVuZ3RoIDw9IDEzID8gJ01NIHl5eXknIDpcclxuXHRcdFx0XHRtb250aEhlYWRlclswXS5zdWJzdHJpbmcoMTMsIG1vbnRoSGVhZGVyWzBdLmxlbmd0aCAtIDEpKTtcclxuXHRcdFx0bW9udGhIZWFkZXIgPSAoZmlyc3QgPyB0aGlzLl9nZW5lcmF0ZU1vbnRoU2VsZWN0aW9uKFxyXG5cdFx0XHRcdGluc3QsIHllYXIsIG1vbnRoLCBtaW5EYXRlLCBtYXhEYXRlLCBtb250aEhlYWRlciwgY2FsZW5kYXIsIHJlbmRlcmVyKSA6XHJcblx0XHRcdFx0Y2FsZW5kYXIuZm9ybWF0RGF0ZShtb250aEhlYWRlciwgY2FsZW5kYXIubmV3RGF0ZSh5ZWFyLCBtb250aCwgY2FsZW5kYXIubWluRGF5KSkpO1xyXG5cdFx0XHR2YXIgd2Vla0hlYWRlciA9IHRoaXMuX3ByZXBhcmUocmVuZGVyZXIud2Vla0hlYWRlciwgaW5zdCkuXHJcblx0XHRcdFx0cmVwbGFjZSgvXFx7ZGF5c1xcfS9nLCB0aGlzLl9nZW5lcmF0ZURheUhlYWRlcnMoaW5zdCwgY2FsZW5kYXIsIHJlbmRlcmVyKSk7XHJcblx0XHRcdHJldHVybiB0aGlzLl9wcmVwYXJlKHJlbmRlcmVyLm1vbnRoLCBpbnN0KS5yZXBsYWNlKC9cXHttb250aEhlYWRlcig6W15cXH1dKyk/XFx9L2csIG1vbnRoSGVhZGVyKS5cclxuXHRcdFx0XHRyZXBsYWNlKC9cXHt3ZWVrSGVhZGVyXFx9L2csIHdlZWtIZWFkZXIpLnJlcGxhY2UoL1xce3dlZWtzXFx9L2csIHdlZWtzKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEdlbmVyYXRlIHRoZSBIVE1MIGZvciB0aGUgZGF5IGhlYWRlcnMuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEBwYXJhbSBjYWxlbmRhciB7QmFzZUNhbGVuZGFyfSBUaGUgY3VycmVudCBjYWxlbmRhci5cclxuXHRcdFx0QHBhcmFtIHJlbmRlcmVyIHtvYmplY3R9IFRoZSByZW5kZXJpbmcgdGVtcGxhdGVzLlxyXG5cdFx0XHRAcmV0dXJuIHtzdHJpbmd9IEEgd2VlaydzIHdvcnRoIG9mIGRheSBoZWFkZXJzLiAqL1xyXG5cdFx0X2dlbmVyYXRlRGF5SGVhZGVyczogZnVuY3Rpb24oaW5zdCwgY2FsZW5kYXIsIHJlbmRlcmVyKSB7XHJcblx0XHRcdHZhciBmaXJzdERheSA9IGluc3Qub3B0aW9ucy5maXJzdERheTtcclxuXHRcdFx0Zmlyc3REYXkgPSAoZmlyc3REYXkgPT0gbnVsbCA/IGNhbGVuZGFyLmxvY2FsLmZpcnN0RGF5IDogZmlyc3REYXkpO1xyXG5cdFx0XHR2YXIgaGVhZGVyID0gJyc7XHJcblx0XHRcdGZvciAodmFyIGRheSA9IDA7IGRheSA8IGNhbGVuZGFyLmRheXNJbldlZWsoKTsgZGF5KyspIHtcclxuXHRcdFx0XHR2YXIgZG93ID0gKGRheSArIGZpcnN0RGF5KSAlIGNhbGVuZGFyLmRheXNJbldlZWsoKTtcclxuXHRcdFx0XHRoZWFkZXIgKz0gdGhpcy5fcHJlcGFyZShyZW5kZXJlci5kYXlIZWFkZXIsIGluc3QpLnJlcGxhY2UoL1xce2RheVxcfS9nLFxyXG5cdFx0XHRcdFx0JzxzcGFuIGNsYXNzPVwiJyArIHRoaXMuX2N1ckRvV0NsYXNzICsgZG93ICsgJ1wiIHRpdGxlPVwiJyArXHJcblx0XHRcdFx0XHRjYWxlbmRhci5sb2NhbC5kYXlOYW1lc1tkb3ddICsgJ1wiPicgKyBjYWxlbmRhci5sb2NhbC5kYXlOYW1lc01pbltkb3ddICsgJzwvc3Bhbj4nKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gaGVhZGVyO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogR2VuZXJhdGUgc2VsZWN0aW9uIGNvbnRyb2xzIGZvciBtb250aC5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cclxuXHRcdFx0QHBhcmFtIHllYXIge251bWJlcn0gVGhlIHllYXIgdG8gZ2VuZXJhdGUuXHJcblx0XHRcdEBwYXJhbSBtb250aCB7bnVtYmVyfSBUaGUgbW9udGggdG8gZ2VuZXJhdGUuXHJcblx0XHRcdEBwYXJhbSBtaW5EYXRlIHtDRGF0ZX0gVGhlIG1pbmltdW0gZGF0ZSBhbGxvd2VkLlxyXG5cdFx0XHRAcGFyYW0gbWF4RGF0ZSB7Q0RhdGV9IFRoZSBtYXhpbXVtIGRhdGUgYWxsb3dlZC5cclxuXHRcdFx0QHBhcmFtIG1vbnRoSGVhZGVyIHtzdHJpbmd9IFRoZSBtb250aC95ZWFyIGZvcm1hdC5cclxuXHRcdFx0QHBhcmFtIGNhbGVuZGFyIHtCYXNlQ2FsZW5kYXJ9IFRoZSBjdXJyZW50IGNhbGVuZGFyLlxyXG5cdFx0XHRAcmV0dXJuIHtzdHJpbmd9IFRoZSBtb250aCBzZWxlY3Rpb24gY29udGVudC4gKi9cclxuXHRcdF9nZW5lcmF0ZU1vbnRoU2VsZWN0aW9uOiBmdW5jdGlvbihpbnN0LCB5ZWFyLCBtb250aCwgbWluRGF0ZSwgbWF4RGF0ZSwgbW9udGhIZWFkZXIsIGNhbGVuZGFyKSB7XHJcblx0XHRcdGlmICghaW5zdC5vcHRpb25zLmNoYW5nZU1vbnRoKSB7XHJcblx0XHRcdFx0cmV0dXJuIGNhbGVuZGFyLmZvcm1hdERhdGUobW9udGhIZWFkZXIsIGNhbGVuZGFyLm5ld0RhdGUoeWVhciwgbW9udGgsIDEpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBNb250aHNcclxuXHRcdFx0dmFyIG1vbnRoTmFtZXMgPSBjYWxlbmRhci5sb2NhbFtcclxuXHRcdFx0XHQnbW9udGhOYW1lcycgKyAobW9udGhIZWFkZXIubWF0Y2goL21tL2kpID8gJycgOiAnU2hvcnQnKV07XHJcblx0XHRcdHZhciBodG1sID0gbW9udGhIZWFkZXIucmVwbGFjZSgvbSsvaSwgJ1xcXFx4MkUnKS5yZXBsYWNlKC95Ky9pLCAnXFxcXHgyRicpO1xyXG5cdFx0XHR2YXIgc2VsZWN0b3IgPSAnPHNlbGVjdCBjbGFzcz1cIicgKyB0aGlzLl9tb250aFllYXJDbGFzcyArXHJcblx0XHRcdFx0J1wiIHRpdGxlPVwiJyArIGluc3Qub3B0aW9ucy5tb250aFN0YXR1cyArICdcIj4nO1xyXG5cdFx0XHR2YXIgbWF4TW9udGggPSBjYWxlbmRhci5tb250aHNJblllYXIoeWVhcikgKyBjYWxlbmRhci5taW5Nb250aDtcclxuXHRcdFx0Zm9yICh2YXIgbSA9IGNhbGVuZGFyLm1pbk1vbnRoOyBtIDwgbWF4TW9udGg7IG0rKykge1xyXG5cdFx0XHRcdGlmICgoIW1pbkRhdGUgfHwgY2FsZW5kYXIubmV3RGF0ZSh5ZWFyLCBtLFxyXG5cdFx0XHRcdFx0XHRjYWxlbmRhci5kYXlzSW5Nb250aCh5ZWFyLCBtKSAtIDEgKyBjYWxlbmRhci5taW5EYXkpLlxyXG5cdFx0XHRcdFx0XHRjb21wYXJlVG8obWluRGF0ZSkgIT09IC0xKSAmJlxyXG5cdFx0XHRcdFx0XHQoIW1heERhdGUgfHwgY2FsZW5kYXIubmV3RGF0ZSh5ZWFyLCBtLCBjYWxlbmRhci5taW5EYXkpLlxyXG5cdFx0XHRcdFx0XHRjb21wYXJlVG8obWF4RGF0ZSkgIT09ICsxKSkge1xyXG5cdFx0XHRcdFx0c2VsZWN0b3IgKz0gJzxvcHRpb24gdmFsdWU9XCInICsgbSArICcvJyArIHllYXIgKyAnXCInICtcclxuXHRcdFx0XHRcdFx0KG1vbnRoID09PSBtID8gJyBzZWxlY3RlZD1cInNlbGVjdGVkXCInIDogJycpICsgJz4nICtcclxuXHRcdFx0XHRcdFx0bW9udGhOYW1lc1ttIC0gY2FsZW5kYXIubWluTW9udGhdICsgJzwvb3B0aW9uPic7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHNlbGVjdG9yICs9ICc8L3NlbGVjdD4nO1xyXG5cdFx0XHRodG1sID0gaHRtbC5yZXBsYWNlKC9cXFxceDJFLywgc2VsZWN0b3IpO1xyXG5cdFx0XHQvLyBZZWFyc1xyXG5cdFx0XHR2YXIgeWVhclJhbmdlID0gaW5zdC5vcHRpb25zLnllYXJSYW5nZTtcclxuXHRcdFx0aWYgKHllYXJSYW5nZSA9PT0gJ2FueScpIHtcclxuXHRcdFx0XHRzZWxlY3RvciA9ICc8c2VsZWN0IGNsYXNzPVwiJyArIHRoaXMuX21vbnRoWWVhckNsYXNzICsgJyAnICsgdGhpcy5fYW55WWVhckNsYXNzICtcclxuXHRcdFx0XHRcdCdcIiB0aXRsZT1cIicgKyBpbnN0Lm9wdGlvbnMueWVhclN0YXR1cyArICdcIj4nICtcclxuXHRcdFx0XHRcdCc8b3B0aW9uPicgKyB5ZWFyICsgJzwvb3B0aW9uPjwvc2VsZWN0PicgK1xyXG5cdFx0XHRcdFx0JzxpbnB1dCBjbGFzcz1cIicgKyB0aGlzLl9tb250aFllYXJDbGFzcyArICcgJyArIHRoaXMuX2N1ck1vbnRoQ2xhc3MgK1xyXG5cdFx0XHRcdFx0bW9udGggKyAnXCIgdmFsdWU9XCInICsgeWVhciArICdcIj4nO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHllYXJSYW5nZSA9IHllYXJSYW5nZS5zcGxpdCgnOicpO1xyXG5cdFx0XHRcdHZhciB0b2RheVllYXIgPSBjYWxlbmRhci50b2RheSgpLnllYXIoKTtcclxuXHRcdFx0XHR2YXIgc3RhcnQgPSAoeWVhclJhbmdlWzBdLm1hdGNoKCdjWystXS4qJykgPyB5ZWFyICsgcGFyc2VJbnQoeWVhclJhbmdlWzBdLnN1YnN0cmluZygxKSwgMTApIDpcclxuXHRcdFx0XHRcdCgoeWVhclJhbmdlWzBdLm1hdGNoKCdbKy1dLionKSA/IHRvZGF5WWVhciA6IDApICsgcGFyc2VJbnQoeWVhclJhbmdlWzBdLCAxMCkpKTtcclxuXHRcdFx0XHR2YXIgZW5kID0gKHllYXJSYW5nZVsxXS5tYXRjaCgnY1srLV0uKicpID8geWVhciArIHBhcnNlSW50KHllYXJSYW5nZVsxXS5zdWJzdHJpbmcoMSksIDEwKSA6XHJcblx0XHRcdFx0XHQoKHllYXJSYW5nZVsxXS5tYXRjaCgnWystXS4qJykgPyB0b2RheVllYXIgOiAwKSArIHBhcnNlSW50KHllYXJSYW5nZVsxXSwgMTApKSk7XHJcblx0XHRcdFx0c2VsZWN0b3IgPSAnPHNlbGVjdCBjbGFzcz1cIicgKyB0aGlzLl9tb250aFllYXJDbGFzcyArXHJcblx0XHRcdFx0XHQnXCIgdGl0bGU9XCInICsgaW5zdC5vcHRpb25zLnllYXJTdGF0dXMgKyAnXCI+JztcclxuXHRcdFx0XHRzdGFydCA9IGNhbGVuZGFyLm5ld0RhdGUoc3RhcnQgKyAxLCBjYWxlbmRhci5maXJzdE1vbnRoLCBjYWxlbmRhci5taW5EYXkpLmFkZCgtMSwgJ2QnKTtcclxuXHRcdFx0XHRlbmQgPSBjYWxlbmRhci5uZXdEYXRlKGVuZCwgY2FsZW5kYXIuZmlyc3RNb250aCwgY2FsZW5kYXIubWluRGF5KTtcclxuXHRcdFx0XHR2YXIgYWRkWWVhciA9IGZ1bmN0aW9uKHksIHlEaXNwbGF5KSB7XHJcblx0XHRcdFx0XHRpZiAoeSAhPT0gMCB8fCBjYWxlbmRhci5oYXNZZWFyWmVybykge1xyXG5cdFx0XHRcdFx0XHRzZWxlY3RvciArPSAnPG9wdGlvbiB2YWx1ZT1cIicgK1xyXG5cdFx0XHRcdFx0XHRcdE1hdGgubWluKG1vbnRoLCBjYWxlbmRhci5tb250aHNJblllYXIoeSkgLSAxICsgY2FsZW5kYXIubWluTW9udGgpICtcclxuXHRcdFx0XHRcdFx0XHQnLycgKyB5ICsgJ1wiJyArICh5ZWFyID09PSB5ID8gJyBzZWxlY3RlZD1cInNlbGVjdGVkXCInIDogJycpICsgJz4nICtcclxuXHRcdFx0XHRcdFx0XHQoeURpc3BsYXkgfHwgeSkgKyAnPC9vcHRpb24+JztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdGlmIChzdGFydC50b0pEKCkgPCBlbmQudG9KRCgpKSB7XHJcblx0XHRcdFx0XHRzdGFydCA9IChtaW5EYXRlICYmIG1pbkRhdGUuY29tcGFyZVRvKHN0YXJ0KSA9PT0gKzEgPyBtaW5EYXRlIDogc3RhcnQpLnllYXIoKTtcclxuXHRcdFx0XHRcdGVuZCA9IChtYXhEYXRlICYmIG1heERhdGUuY29tcGFyZVRvKGVuZCkgPT09IC0xID8gbWF4RGF0ZSA6IGVuZCkueWVhcigpO1xyXG5cdFx0XHRcdFx0dmFyIGVhcmxpZXJMYXRlciA9IE1hdGguZmxvb3IoKGVuZCAtIHN0YXJ0KSAvIDIpO1xyXG5cdFx0XHRcdFx0aWYgKCFtaW5EYXRlIHx8IG1pbkRhdGUueWVhcigpIDwgc3RhcnQpIHtcclxuXHRcdFx0XHRcdFx0YWRkWWVhcihzdGFydCAtIGVhcmxpZXJMYXRlciwgaW5zdC5vcHRpb25zLmVhcmxpZXJUZXh0KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGZvciAodmFyIHkgPSBzdGFydDsgeSA8PSBlbmQ7IHkrKykge1xyXG5cdFx0XHRcdFx0XHRhZGRZZWFyKHkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCFtYXhEYXRlIHx8IG1heERhdGUueWVhcigpID4gZW5kKSB7XHJcblx0XHRcdFx0XHRcdGFkZFllYXIoZW5kICsgZWFybGllckxhdGVyLCBpbnN0Lm9wdGlvbnMubGF0ZXJUZXh0KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRzdGFydCA9IChtYXhEYXRlICYmIG1heERhdGUuY29tcGFyZVRvKHN0YXJ0KSA9PT0gLTEgPyBtYXhEYXRlIDogc3RhcnQpLnllYXIoKTtcclxuXHRcdFx0XHRcdGVuZCA9IChtaW5EYXRlICYmIG1pbkRhdGUuY29tcGFyZVRvKGVuZCkgPT09ICsxID8gbWluRGF0ZSA6IGVuZCkueWVhcigpO1xyXG5cdFx0XHRcdFx0dmFyIGVhcmxpZXJMYXRlciA9IE1hdGguZmxvb3IoKHN0YXJ0IC0gZW5kKSAvIDIpO1xyXG5cdFx0XHRcdFx0aWYgKCFtYXhEYXRlIHx8IG1heERhdGUueWVhcigpID4gc3RhcnQpIHtcclxuXHRcdFx0XHRcdFx0YWRkWWVhcihzdGFydCArIGVhcmxpZXJMYXRlciwgaW5zdC5vcHRpb25zLmVhcmxpZXJUZXh0KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGZvciAodmFyIHkgPSBzdGFydDsgeSA+PSBlbmQ7IHktLSkge1xyXG5cdFx0XHRcdFx0XHRhZGRZZWFyKHkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCFtaW5EYXRlIHx8IG1pbkRhdGUueWVhcigpIDwgZW5kKSB7XHJcblx0XHRcdFx0XHRcdGFkZFllYXIoZW5kIC0gZWFybGllckxhdGVyLCBpbnN0Lm9wdGlvbnMubGF0ZXJUZXh0KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0c2VsZWN0b3IgKz0gJzwvc2VsZWN0Pic7XHJcblx0XHRcdH1cclxuXHRcdFx0aHRtbCA9IGh0bWwucmVwbGFjZSgvXFxcXHgyRi8sIHNlbGVjdG9yKTtcclxuXHRcdFx0cmV0dXJuIGh0bWw7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBQcmVwYXJlIGEgcmVuZGVyIHRlbXBsYXRlIGZvciB1c2UuXHJcblx0XHRcdEV4Y2x1ZGUgcG9wdXAvaW5saW5lIHNlY3Rpb25zIHRoYXQgYXJlIG5vdCBhcHBsaWNhYmxlLlxyXG5cdFx0XHRMb2NhbGlzZSB0ZXh0IG9mIHRoZSBmb3JtOiB7bDEwbjpuYW1lfS5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gdGV4dCB7c3RyaW5nfSBUaGUgdGV4dCB0byBsb2NhbGlzZS5cclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEByZXR1cm4ge3N0cmluZ30gVGhlIGxvY2FsaXNlZCB0ZXh0LiAqL1xyXG5cdFx0X3ByZXBhcmU6IGZ1bmN0aW9uKHRleHQsIGluc3QpIHtcclxuXHRcdFx0dmFyIHJlcGxhY2VTZWN0aW9uID0gZnVuY3Rpb24odHlwZSwgcmV0YWluKSB7XHJcblx0XHRcdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0XHRcdHZhciBzdGFydCA9IHRleHQuaW5kZXhPZigneycgKyB0eXBlICsgJzpzdGFydH0nKTtcclxuXHRcdFx0XHRcdGlmIChzdGFydCA9PT0gLTEpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dmFyIGVuZCA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0KS5pbmRleE9mKCd7JyArIHR5cGUgKyAnOmVuZH0nKTtcclxuXHRcdFx0XHRcdGlmIChlbmQgPiAtMSkge1xyXG5cdFx0XHRcdFx0XHR0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnQpICtcclxuXHRcdFx0XHRcdFx0XHQocmV0YWluID8gdGV4dC5zdWJzdHIoc3RhcnQgKyB0eXBlLmxlbmd0aCArIDgsIGVuZCAtIHR5cGUubGVuZ3RoIC0gOCkgOiAnJykgK1xyXG5cdFx0XHRcdFx0XHRcdHRleHQuc3Vic3RyaW5nKHN0YXJ0ICsgZW5kICsgdHlwZS5sZW5ndGggKyA2KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHRcdHJlcGxhY2VTZWN0aW9uKCdpbmxpbmUnLCBpbnN0LmlubGluZSk7XHJcblx0XHRcdHJlcGxhY2VTZWN0aW9uKCdwb3B1cCcsICFpbnN0LmlubGluZSk7XHJcblx0XHRcdHZhciBwYXR0ZXJuID0gL1xce2wxMG46KFteXFx9XSspXFx9LztcclxuXHRcdFx0dmFyIG1hdGNoZXMgPSBudWxsO1xyXG5cdFx0XHR3aGlsZSAobWF0Y2hlcyA9IHBhdHRlcm4uZXhlYyh0ZXh0KSkge1xyXG5cdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UobWF0Y2hlc1swXSwgaW5zdC5vcHRpb25zW21hdGNoZXNbMV1dKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGV4dDtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0dmFyIHBsdWdpbiA9ICQuY2FsZW5kYXJzUGlja2VyOyAvLyBTaW5nbGV0b24gaW5zdGFuY2VcclxuXHJcblx0JChmdW5jdGlvbigpIHtcclxuXHRcdCQoZG9jdW1lbnQpLm9uKCdtb3VzZWRvd24uJyArIHBsdWdpbk5hbWUsIHBsdWdpbi5fY2hlY2tFeHRlcm5hbENsaWNrKS5cclxuXHRcdFx0b24oJ3Jlc2l6ZS4nICsgcGx1Z2luTmFtZSwgZnVuY3Rpb24oKSB7IHBsdWdpbi5oaWRlKHBsdWdpbi5jdXJJbnN0KTsgfSk7XHJcblx0fSk7XHJcblxyXG59KShqUXVlcnkpO1xyXG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
