/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/*!
 * jQuery JavaScript Library v3.6.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2022-08-26T17:52Z
 */
(function (global, factory) {
  "use strict";

  if ((typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && _typeof(module.exports) === "object") {
    // For CommonJS and CommonJS-like environments where a proper `window`
    // is present, execute the factory and get jQuery.
    // For environments that do not have a `window` with a `document`
    // (such as Node.js), expose a factory as module.exports.
    // This accentuates the need for the creation of a real `window`.
    // e.g. var jQuery = require("jquery")(window);
    // See ticket trac-14549 for more info.
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error("jQuery requires a window with a document");
      }

      return factory(w);
    };
  } else {
    factory(global);
  } // Pass this if window is not defined yet

})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {
  // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
  // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
  // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
  // enough that all such attempts are guarded in a try block.
  "use strict";

  var arr = [];
  var getProto = Object.getPrototypeOf;
  var _slice = arr.slice;
  var flat = arr.flat ? function (array) {
    return arr.flat.call(array);
  } : function (array) {
    return arr.concat.apply([], array);
  };
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var fnToString = hasOwn.toString;
  var ObjectFunctionString = fnToString.call(Object);
  var support = {};

  var isFunction = function isFunction(obj) {
    // Support: Chrome <=57, Firefox <=52
    // In some browsers, typeof returns "function" for HTML <object> elements
    // (i.e., `typeof document.createElement( "object" ) === "function"`).
    // We don't want to classify *any* DOM node as a function.
    // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
    // Plus for old WebKit, typeof returns "function" for HTML collections
    // (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
    return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
  };

  var isWindow = function isWindow(obj) {
    return obj != null && obj === obj.window;
  };

  var document = window.document;
  var preservedScriptAttributes = {
    type: true,
    src: true,
    nonce: true,
    noModule: true
  };

  function DOMEval(code, node, doc) {
    doc = doc || document;
    var i,
        val,
        script = doc.createElement("script");
    script.text = code;

    if (node) {
      for (i in preservedScriptAttributes) {
        // Support: Firefox 64+, Edge 18+
        // Some browsers don't support the "nonce" property on scripts.
        // On the other hand, just using `getAttribute` is not enough as
        // the `nonce` attribute is reset to an empty string whenever it
        // becomes browsing-context connected.
        // See https://github.com/whatwg/html/issues/2369
        // See https://html.spec.whatwg.org/#nonce-attributes
        // The `node.getAttribute` check was added for the sake of
        // `jQuery.globalEval` so that it can fake a nonce-containing node
        // via an object.
        val = node[i] || node.getAttribute && node.getAttribute(i);

        if (val) {
          script.setAttribute(i, val);
        }
      }
    }

    doc.head.appendChild(script).parentNode.removeChild(script);
  }

  function toType(obj) {
    if (obj == null) {
      return obj + "";
    } // Support: Android <=2.3 only (functionish RegExp)


    return _typeof(obj) === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : _typeof(obj);
  }
  /* global Symbol */
  // Defining this global in .eslintrc.json would create a danger of using the global
  // unguarded in another place, it seems safer to define global only for this module


  var version = "3.6.1",
      // Define a local copy of jQuery
  jQuery = function jQuery(selector, context) {
    // The jQuery object is actually just the init constructor 'enhanced'
    // Need init if jQuery is called (just allow error to be thrown if not included)
    return new jQuery.fn.init(selector, context);
  };

  jQuery.fn = jQuery.prototype = {
    // The current version of jQuery being used
    jquery: version,
    constructor: jQuery,
    // The default length of a jQuery object is 0
    length: 0,
    toArray: function toArray() {
      return _slice.call(this);
    },
    // Get the Nth element in the matched element set OR
    // Get the whole matched element set as a clean array
    get: function get(num) {
      // Return all the elements in a clean array
      if (num == null) {
        return _slice.call(this);
      } // Return just the one element from the set


      return num < 0 ? this[num + this.length] : this[num];
    },
    // Take an array of elements and push it onto the stack
    // (returning the new matched element set)
    pushStack: function pushStack(elems) {
      // Build a new jQuery matched element set
      var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)

      ret.prevObject = this; // Return the newly-formed element set

      return ret;
    },
    // Execute a callback for every element in the matched set.
    each: function each(callback) {
      return jQuery.each(this, callback);
    },
    map: function map(callback) {
      return this.pushStack(jQuery.map(this, function (elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function slice() {
      return this.pushStack(_slice.apply(this, arguments));
    },
    first: function first() {
      return this.eq(0);
    },
    last: function last() {
      return this.eq(-1);
    },
    even: function even() {
      return this.pushStack(jQuery.grep(this, function (_elem, i) {
        return (i + 1) % 2;
      }));
    },
    odd: function odd() {
      return this.pushStack(jQuery.grep(this, function (_elem, i) {
        return i % 2;
      }));
    },
    eq: function eq(i) {
      var len = this.length,
          j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function end() {
      return this.prevObject || this.constructor();
    },
    // For internal use only.
    // Behaves like an Array's method, not like a jQuery method.
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };

  jQuery.extend = jQuery.fn.extend = function () {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false; // Handle a deep copy situation

    if (typeof target === "boolean") {
      deep = target; // Skip the boolean and the target

      target = arguments[i] || {};
      i++;
    } // Handle case when target is a string or something (possible in deep copy)


    if (_typeof(target) !== "object" && !isFunction(target)) {
      target = {};
    } // Extend jQuery itself if only one argument is passed


    if (i === length) {
      target = this;
      i--;
    }

    for (; i < length; i++) {
      // Only deal with non-null/undefined values
      if ((options = arguments[i]) != null) {
        // Extend the base object
        for (name in options) {
          copy = options[name]; // Prevent Object.prototype pollution
          // Prevent never-ending loop

          if (name === "__proto__" || target === copy) {
            continue;
          } // Recurse if we're merging plain objects or arrays


          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
            src = target[name]; // Ensure proper type for the source value

            if (copyIsArray && !Array.isArray(src)) {
              clone = [];
            } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
              clone = {};
            } else {
              clone = src;
            }

            copyIsArray = false; // Never move original objects, clone them

            target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    } // Return the modified object


    return target;
  };

  jQuery.extend({
    // Unique for each copy of jQuery on the page
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    // Assume jQuery is ready without the ready module
    isReady: true,
    error: function error(msg) {
      throw new Error(msg);
    },
    noop: function noop() {},
    isPlainObject: function isPlainObject(obj) {
      var proto, Ctor; // Detect obvious negatives
      // Use toString instead of jQuery.type to catch host objects

      if (!obj || toString.call(obj) !== "[object Object]") {
        return false;
      }

      proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain

      if (!proto) {
        return true;
      } // Objects with prototype are plain iff they were constructed by a global Object function


      Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
      return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
    },
    isEmptyObject: function isEmptyObject(obj) {
      var name;

      for (name in obj) {
        return false;
      }

      return true;
    },
    // Evaluates a script in a provided context; falls back to the global one
    // if not specified.
    globalEval: function globalEval(code, options, doc) {
      DOMEval(code, {
        nonce: options && options.nonce
      }, doc);
    },
    each: function each(obj, callback) {
      var length,
          i = 0;

      if (isArrayLike(obj)) {
        length = obj.length;

        for (; i < length; i++) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      }

      return obj;
    },
    // results is for internal usage only
    makeArray: function makeArray(arr, results) {
      var ret = results || [];

      if (arr != null) {
        if (isArrayLike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }

      return ret;
    },
    inArray: function inArray(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    // Support: Android <=4.0 only, PhantomJS 1 only
    // push.apply(_, arraylike) throws on ancient WebKit
    merge: function merge(first, second) {
      var len = +second.length,
          j = 0,
          i = first.length;

      for (; j < len; j++) {
        first[i++] = second[j];
      }

      first.length = i;
      return first;
    },
    grep: function grep(elems, callback, invert) {
      var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert; // Go through the array, only saving the items
      // that pass the validator function

      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);

        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }

      return matches;
    },
    // arg is for internal usage only
    map: function map(elems, callback, arg) {
      var length,
          value,
          i = 0,
          ret = []; // Go through the array, translating each of the items to their new values

      if (isArrayLike(elems)) {
        length = elems.length;

        for (; i < length; i++) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        } // Go through every key on the object,

      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        }
      } // Flatten any nested arrays


      return flat(ret);
    },
    // A global GUID counter for objects
    guid: 1,
    // jQuery.support is not used in Core but other projects attach their
    // properties to it so it needs to exist.
    support: support
  });

  if (typeof Symbol === "function") {
    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
  } // Populate the class2type map


  jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (_i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });

  function isArrayLike(obj) {
    // Support: real iOS 8.2 only (not reproducible in simulator)
    // `in` check used to prevent JIT error (gh-2145)
    // hasOwn isn't used here due to false negatives
    // regarding Nodelist length in IE
    var length = !!obj && "length" in obj && obj.length,
        type = toType(obj);

    if (isFunction(obj) || isWindow(obj)) {
      return false;
    }

    return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
  }

  var Sizzle =
  /*!
   * Sizzle CSS Selector Engine v2.3.6
   * https://sizzlejs.com/
   *
   * Copyright JS Foundation and other contributors
   * Released under the MIT license
   * https://js.foundation/
   *
   * Date: 2021-02-16
   */
  function (window) {
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        // Local document vars
    setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        // Instance-specific data
    expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        nonnativeSelectorCache = createCache(),
        sortOrder = function sortOrder(a, b) {
      if (a === b) {
        hasDuplicate = true;
      }

      return 0;
    },
        // Instance methods
    hasOwn = {}.hasOwnProperty,
        arr = [],
        pop = arr.pop,
        pushNative = arr.push,
        push = arr.push,
        slice = arr.slice,
        // Use a stripped-down indexOf as it's faster than native
    // https://jsperf.com/thor-indexof-vs-for/5
    indexOf = function indexOf(list, elem) {
      var i = 0,
          len = list.length;

      for (; i < len; i++) {
        if (list[i] === elem) {
          return i;
        }
      }

      return -1;
    },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" + "ismap|loop|multiple|open|readonly|required|scoped",
        // Regular expressions
    // http://www.w3.org/TR/css3-selectors/#whitespace
    whitespace = "[\\x20\\t\\r\\n\\f]",
        // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
    identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
    attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
    "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5]
    // or strings [capture 3 or capture 4]"
    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
        pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
    // 1. quoted (capture 3; capture 4 or capture 5)
    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
    ".*" + ")\\)|)",
        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
    rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rdescend = new RegExp(whitespace + "|>"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
      "ID": new RegExp("^#(" + identifier + ")"),
      "CLASS": new RegExp("^\\.(" + identifier + ")"),
      "TAG": new RegExp("^(" + identifier + "|[*])"),
      "ATTR": new RegExp("^" + attributes),
      "PSEUDO": new RegExp("^" + pseudos),
      "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
      "bool": new RegExp("^(?:" + booleans + ")$", "i"),
      // For use in libraries implementing .is()
      // We use this for POS matching in `select`
      "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
    },
        rhtml = /HTML$/i,
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        // Easily-parseable/retrievable ID or TAG or CLASS selectors
    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        // CSS escapes
    // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
    runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"),
        funescape = function funescape(escape, nonHex) {
      var high = "0x" + escape.slice(1) - 0x10000;
      return nonHex ? // Strip the backslash prefix from a non-hex escape sequence
      nonHex : // Replace a hexadecimal escape sequence with the encoded Unicode code point
      // Support: IE <=11+
      // For values outside the Basic Multilingual Plane (BMP), manually construct a
      // surrogate pair
      high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
    },
        // CSS string/identifier serialization
    // https://drafts.csswg.org/cssom/#common-serializing-idioms
    rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
        fcssescape = function fcssescape(ch, asCodePoint) {
      if (asCodePoint) {
        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
        if (ch === "\0") {
          return "\uFFFD";
        } // Control characters and (dependent upon position) numbers get escaped as code points


        return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
      } // Other potentially-special ASCII characters get backslash-escaped


      return "\\" + ch;
    },
        // Used for iframes
    // See setDocument()
    // Removing the function wrapper causes a "Permission Denied"
    // error in IE
    unloadHandler = function unloadHandler() {
      setDocument();
    },
        inDisabledFieldset = addCombinator(function (elem) {
      return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
    }, {
      dir: "parentNode",
      next: "legend"
    }); // Optimize for push.apply( _, NodeList )


    try {
      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0
      // Detect silently failing push.apply
      // eslint-disable-next-line no-unused-expressions

      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {
        apply: arr.length ? // Leverage slice if possible
        function (target, els) {
          pushNative.apply(target, slice.call(els));
        } : // Support: IE<9
        // Otherwise append directly
        function (target, els) {
          var j = target.length,
              i = 0; // Can't trust NodeList.length

          while (target[j++] = els[i++]) {}

          target.length = j - 1;
        }
      };
    }

    function Sizzle(selector, context, results, seed) {
      var m,
          i,
          elem,
          nid,
          match,
          groups,
          newSelector,
          newContext = context && context.ownerDocument,
          // nodeType defaults to 9, since context defaults to document
      nodeType = context ? context.nodeType : 9;
      results = results || []; // Return early from calls with invalid selector or context

      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      } // Try to shortcut find operations (as opposed to filters) in HTML documents


      if (!seed) {
        setDocument(context);
        context = context || document;

        if (documentIsHTML) {
          // If the selector is sufficiently simple, try using a "get*By*" DOM method
          // (excepting DocumentFragment context, where the methods don't exist)
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            // ID selector
            if (m = match[1]) {
              // Document context
              if (nodeType === 9) {
                if (elem = context.getElementById(m)) {
                  // Support: IE, Opera, Webkit
                  // TODO: identify versions
                  // getElementById can match elements by name instead of ID
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                } // Element context

              } else {
                // Support: IE, Opera, Webkit
                // TODO: identify versions
                // getElementById can match elements by name instead of ID
                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } // Type selector

            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results; // Class selector
            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          } // Take advantage of querySelectorAll


          if (support.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && ( // Support: IE 8 only
          // Exclude object elements
          nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
            newSelector = selector;
            newContext = context; // qSA considers elements outside a scoping root when evaluating child or
            // descendant combinators, which is not what we want.
            // In such cases, we work around the behavior by prefixing every selector in the
            // list with an ID selector referencing the scope context.
            // The technique has to be used as well when a leading combinator is used
            // as such selectors are not recognized by querySelectorAll.
            // Thanks to Andrew Dupont for this technique.

            if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
              // Expand context for sibling selectors
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context; // We can use :scope instead of the ID hack if the browser
              // supports it & if we're not changing the context.

              if (newContext !== context || !support.scope) {
                // Capture the context ID, setting it first if necessary
                if (nid = context.getAttribute("id")) {
                  nid = nid.replace(rcssescape, fcssescape);
                } else {
                  context.setAttribute("id", nid = expando);
                }
              } // Prefix every selector in the list


              groups = tokenize(selector);
              i = groups.length;

              while (i--) {
                groups[i] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i]);
              }

              newSelector = groups.join(",");
            }

            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {
              nonnativeSelectorCache(selector, true);
            } finally {
              if (nid === expando) {
                context.removeAttribute("id");
              }
            }
          }
        }
      } // All others


      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    /**
     * Create key-value caches of limited size
     * @returns {function(string, object)} Returns the Object data after storing it on itself with
     *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
     *	deleting the oldest entry
     */


    function createCache() {
      var keys = [];

      function cache(key, value) {
        // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
        if (keys.push(key + " ") > Expr.cacheLength) {
          // Only keep the most recent entries
          delete cache[keys.shift()];
        }

        return cache[key + " "] = value;
      }

      return cache;
    }
    /**
     * Mark a function for special use by Sizzle
     * @param {Function} fn The function to mark
     */


    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    /**
     * Support testing using an element
     * @param {Function} fn Passed the created element and returns a boolean result
     */


    function assert(fn) {
      var el = document.createElement("fieldset");

      try {
        return !!fn(el);
      } catch (e) {
        return false;
      } finally {
        // Remove from its parent by default
        if (el.parentNode) {
          el.parentNode.removeChild(el);
        } // release memory in IE


        el = null;
      }
    }
    /**
     * Adds the same handler for all of the specified attrs
     * @param {String} attrs Pipe-separated list of attributes
     * @param {Function} handler The method that will be applied
     */


    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
          i = arr.length;

      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    /**
     * Checks document order of two siblings
     * @param {Element} a
     * @param {Element} b
     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
     */


    function siblingCheck(a, b) {
      var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes

      if (diff) {
        return diff;
      } // Check if b follows a


      if (cur) {
        while (cur = cur.nextSibling) {
          if (cur === b) {
            return -1;
          }
        }
      }

      return a ? 1 : -1;
    }
    /**
     * Returns a function to use in pseudos for input types
     * @param {String} type
     */


    function createInputPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    /**
     * Returns a function to use in pseudos for buttons
     * @param {String} type
     */


    function createButtonPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    /**
     * Returns a function to use in pseudos for :enabled/:disabled
     * @param {Boolean} disabled true for :disabled; false for :enabled
     */


    function createDisabledPseudo(disabled) {
      // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
      return function (elem) {
        // Only certain elements can match :enabled or :disabled
        // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
        // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
        if ("form" in elem) {
          // Check for inherited disabledness on relevant non-disabled elements:
          // * listed form-associated elements in a disabled fieldset
          //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
          //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
          // * option elements in a disabled optgroup
          //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
          // All such elements have a "form" property.
          if (elem.parentNode && elem.disabled === false) {
            // Option elements defer to a parent optgroup if present
            if ("label" in elem) {
              if ("label" in elem.parentNode) {
                return elem.parentNode.disabled === disabled;
              } else {
                return elem.disabled === disabled;
              }
            } // Support: IE 6 - 11
            // Use the isDisabled shortcut property to check for disabled fieldset ancestors


            return elem.isDisabled === disabled || // Where there is no isDisabled, check manually

            /* jshint -W018 */
            elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
          }

          return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.
          // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
          // even exist on them, let alone have a boolean value.
        } else if ("label" in elem) {
          return elem.disabled === disabled;
        } // Remaining elements are neither :enabled nor :disabled


        return false;
      };
    }
    /**
     * Returns a function to use in pseudos for positionals
     * @param {Function} fn
     */


    function createPositionalPseudo(fn) {
      return markFunction(function (argument) {
        argument = +argument;
        return markFunction(function (seed, matches) {
          var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length; // Match elements found at the specified indexes

          while (i--) {
            if (seed[j = matchIndexes[i]]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    /**
     * Checks a node for validity as a Sizzle context
     * @param {Element|Object=} context
     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
     */


    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    } // Expose support vars for convenience


    support = Sizzle.support = {};
    /**
     * Detects XML nodes
     * @param {Element|Object} elem An element or a document
     * @returns {Boolean} True iff elem is a non-HTML XML node
     */

    isXML = Sizzle.isXML = function (elem) {
      var namespace = elem && elem.namespaceURI,
          docElem = elem && (elem.ownerDocument || elem).documentElement; // Support: IE <=8
      // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
      // https://bugs.jquery.com/ticket/4833

      return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML");
    };
    /**
     * Sets document-related variables once based on the current document
     * @param {Element|Object} [doc] An element or document object to use to set the document
     * @returns {Object} Returns the current document
     */


    setDocument = Sizzle.setDocument = function (node) {
      var hasCompare,
          subWindow,
          doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq

      if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      } // Update global variables


      document = doc;
      docElem = document.documentElement;
      documentIsHTML = !isXML(document); // Support: IE 9 - 11+, Edge 12 - 18+
      // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq

      if (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
        // Support: IE 11, Edge
        if (subWindow.addEventListener) {
          subWindow.addEventListener("unload", unloadHandler, false); // Support: IE 9 - 10 only
        } else if (subWindow.attachEvent) {
          subWindow.attachEvent("onunload", unloadHandler);
        }
      } // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
      // Safari 4 - 5 only, Opera <=11.6 - 12.x only
      // IE/Edge & older browsers don't support the :scope pseudo-class.
      // Support: Safari 6.0 only
      // Safari 6.0 supports :scope but it's an alias of :root there.


      support.scope = assert(function (el) {
        docElem.appendChild(el).appendChild(document.createElement("div"));
        return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
      });
      /* Attributes
      ---------------------------------------------------------------------- */
      // Support: IE<8
      // Verify that getAttribute really returns attributes and not properties
      // (excepting IE8 booleans)

      support.attributes = assert(function (el) {
        el.className = "i";
        return !el.getAttribute("className");
      });
      /* getElement(s)By*
      ---------------------------------------------------------------------- */
      // Check if getElementsByTagName("*") returns only elements

      support.getElementsByTagName = assert(function (el) {
        el.appendChild(document.createComment(""));
        return !el.getElementsByTagName("*").length;
      }); // Support: IE<9

      support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10
      // Check if getElementById returns elements by name
      // The broken getElementById methods don't pick up programmatically-set names,
      // so use a roundabout getElementsByName test

      support.getById = assert(function (el) {
        docElem.appendChild(el).id = expando;
        return !document.getElementsByName || !document.getElementsByName(expando).length;
      }); // ID filter and find

      if (support.getById) {
        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            return elem.getAttribute("id") === attrId;
          };
        };

        Expr.find["ID"] = function (id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var elem = context.getElementById(id);
            return elem ? [elem] : [];
          }
        };
      } else {
        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        }; // Support: IE 6 - 7 only
        // getElementById is not reliable as a find shortcut


        Expr.find["ID"] = function (id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var node,
                i,
                elems,
                elem = context.getElementById(id);

            if (elem) {
              // Verify the id attribute
              node = elem.getAttributeNode("id");

              if (node && node.value === id) {
                return [elem];
              } // Fall back on getElementsByName


              elems = context.getElementsByName(id);
              i = 0;

              while (elem = elems[i++]) {
                node = elem.getAttributeNode("id");

                if (node && node.value === id) {
                  return [elem];
                }
              }
            }

            return [];
          }
        };
      } // Tag


      Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function (tag, context) {
        var elem,
            tmp = [],
            i = 0,
            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
        results = context.getElementsByTagName(tag); // Filter out possible comments

        if (tag === "*") {
          while (elem = results[i++]) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }

          return tmp;
        }

        return results;
      }; // Class

      Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
        if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      /* QSA/matchesSelector
      ---------------------------------------------------------------------- */
      // QSA and matchesSelector support
      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)


      rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)
      // We allow this because of a bug in IE8/9 that throws an error
      // whenever `document.activeElement` is accessed on an iframe
      // So, we allow :focus to pass through QSA all the time to avoid the IE error
      // See https://bugs.jquery.com/ticket/13378

      rbuggyQSA = [];

      if (support.qsa = rnative.test(document.querySelectorAll)) {
        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function (el) {
          var input; // Select is set to empty string on purpose
          // This is to test IE's treatment of not explicitly
          // setting a boolean content attribute,
          // since its presence should be enough
          // https://bugs.jquery.com/ticket/12359

          docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>"; // Support: IE8, Opera 11-12.16
          // Nothing should be selected when empty strings follow ^= or $= or *=
          // The test attribute must be unknown in Opera but "safe" for WinRT
          // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section

          if (el.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          } // Support: IE8
          // Boolean attributes and "value" are not treated correctly


          if (!el.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+


          if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          } // Support: IE 11+, Edge 15 - 18+
          // IE 11/Edge don't find elements on a `[name='']` query in some cases.
          // Adding a temporary attribute to the document before the selection works
          // around the issue.
          // Interestingly, IE 10 & older don't seem to have the issue.


          input = document.createElement("input");
          input.setAttribute("name", "");
          el.appendChild(input);

          if (!el.querySelectorAll("[name='']").length) {
            rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + "*(?:''|\"\")");
          } // Webkit/Opera - :checked should return selected option elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          // IE8 throws error here and will not see later tests


          if (!el.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          } // Support: Safari 8+, iOS 8+
          // https://bugs.webkit.org/show_bug.cgi?id=136851
          // In-page `selector#id sibling-combinator selector` fails


          if (!el.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          } // Support: Firefox <=3.6 - 5 only
          // Old Firefox doesn't throw on a badly-escaped identifier.


          el.querySelectorAll("\\\f");
          rbuggyQSA.push("[\\r\\n\\f]");
        });
        assert(function (el) {
          el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>"; // Support: Windows 8 Native Apps
          // The type and name attributes are restricted during .innerHTML assignment

          var input = document.createElement("input");
          input.setAttribute("type", "hidden");
          el.appendChild(input).setAttribute("name", "D"); // Support: IE8
          // Enforce case-sensitivity of name attribute

          if (el.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
          // IE8 throws error here and will not see later tests


          if (el.querySelectorAll(":enabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          } // Support: IE9-11+
          // IE's :disabled selector does not pick up the children of disabled fieldsets


          docElem.appendChild(el).disabled = true;

          if (el.querySelectorAll(":disabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          } // Support: Opera 10 - 11 only
          // Opera 10-11 does not throw on post-comma invalid pseudos


          el.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }

      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
        assert(function (el) {
          // Check to see if it's possible to do matchesSelector
          // on a disconnected node (IE 9)
          support.disconnectedMatch = matches.call(el, "*"); // This should fail with an exception
          // Gecko does not error, returns false instead

          matches.call(el, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }

      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      /* Contains
      ---------------------------------------------------------------------- */

      hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another
      // Purposefully self-exclusive
      // As in, an element does not contain itself

      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function (a, b) {
        if (b) {
          while (b = b.parentNode) {
            if (b === a) {
              return true;
            }
          }
        }

        return false;
      };
      /* Sorting
      ---------------------------------------------------------------------- */
      // Document order sorting

      sortOrder = hasCompare ? function (a, b) {
        // Flag for duplicate removal
        if (a === b) {
          hasDuplicate = true;
          return 0;
        } // Sort on method existence if only one input has compareDocumentPosition


        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;

        if (compare) {
          return compare;
        } // Calculate position if both inputs belong to the same document
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq


        compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
        1; // Disconnected nodes

        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
          // Choose the first element that is related to our preferred document
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          if (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {
            return -1;
          } // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq


          if (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {
            return 1;
          } // Maintain original order


          return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
        }

        return compare & 4 ? -1 : 1;
      } : function (a, b) {
        // Exit early if the nodes are identical
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }

        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b]; // Parentless nodes are either documents or disconnected

        if (!aup || !bup) {
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.

          /* eslint-disable eqeqeq */
          return a == document ? -1 : b == document ? 1 :
          /* eslint-enable eqeqeq */
          aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check
        } else if (aup === bup) {
          return siblingCheck(a, b);
        } // Otherwise we need full lists of their ancestors for comparison


        cur = a;

        while (cur = cur.parentNode) {
          ap.unshift(cur);
        }

        cur = b;

        while (cur = cur.parentNode) {
          bp.unshift(cur);
        } // Walk down the tree looking for a discrepancy


        while (ap[i] === bp[i]) {
          i++;
        }

        return i ? // Do a sibling check if the nodes have a common ancestor
        siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.

        /* eslint-disable eqeqeq */
        ap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 :
        /* eslint-enable eqeqeq */
        0;
      };
      return document;
    };

    Sizzle.matches = function (expr, elements) {
      return Sizzle(expr, null, null, elements);
    };

    Sizzle.matchesSelector = function (elem, expr) {
      setDocument(elem);

      if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes

          if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
          // fragment in IE 9
          elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {
          nonnativeSelectorCache(expr, true);
        }
      }

      return Sizzle(expr, document, null, [elem]).length > 0;
    };

    Sizzle.contains = function (context, elem) {
      // Set document vars if needed
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if ((context.ownerDocument || context) != document) {
        setDocument(context);
      }

      return contains(context, elem);
    };

    Sizzle.attr = function (elem, name) {
      // Set document vars if needed
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if ((elem.ownerDocument || elem) != document) {
        setDocument(elem);
      }

      var fn = Expr.attrHandle[name.toLowerCase()],
          // Don't get fooled by Object.prototype properties (jQuery #13807)
      val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };

    Sizzle.escape = function (sel) {
      return (sel + "").replace(rcssescape, fcssescape);
    };

    Sizzle.error = function (msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    /**
     * Document sorting and removing duplicates
     * @param {ArrayLike} results
     */


    Sizzle.uniqueSort = function (results) {
      var elem,
          duplicates = [],
          j = 0,
          i = 0; // Unless we *know* we can detect duplicates, assume their presence

      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);

      if (hasDuplicate) {
        while (elem = results[i++]) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }

        while (j--) {
          results.splice(duplicates[j], 1);
        }
      } // Clear input after sorting to release objects
      // See https://github.com/jquery/sizzle/pull/225


      sortInput = null;
      return results;
    };
    /**
     * Utility function for retrieving the text value of an array of DOM nodes
     * @param {Array|Element} elem
     */


    getText = Sizzle.getText = function (elem) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;

      if (!nodeType) {
        // If no nodeType, this is expected to be an array
        while (node = elem[i++]) {
          // Do not traverse comment nodes
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        // Use textContent for elements
        // innerText usage removed for consistency of new lines (jQuery #11153)
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          // Traverse its children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      } // Do not include comment or processing instruction nodes


      return ret;
    };

    Expr = Sizzle.selectors = {
      // Can be adjusted by the user
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {
          dir: "parentNode"
        },
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {
          dir: "previousSibling"
        }
      },
      preFilter: {
        "ATTR": function ATTR(match) {
          match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted

          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }

          return match.slice(0, 4);
        },
        "CHILD": function CHILD(match) {
          /* matches from matchExpr["CHILD"]
          	1 type (only|nth|...)
          	2 what (child|of-type)
          	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
          	4 xn-component of xn+y argument ([+-]?\d*n|)
          	5 sign of xn-component
          	6 x of xn-component
          	7 sign of y-component
          	8 y of y-component
          */
          match[1] = match[1].toLowerCase();

          if (match[1].slice(0, 3) === "nth") {
            // nth-* requires argument
            if (!match[3]) {
              Sizzle.error(match[0]);
            } // numeric x and y parameters for Expr.filter.CHILD
            // remember that false/true cast respectively to 0/1


            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +(match[7] + match[8] || match[3] === "odd"); // other types prohibit arguments
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }

          return match;
        },
        "PSEUDO": function PSEUDO(match) {
          var excess,
              unquoted = !match[6] && match[2];

          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          } // Accept quoted arguments as-is


          if (match[3]) {
            match[2] = match[4] || match[5] || ""; // Strip excess characters from unquoted arguments
          } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)
          excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis
          excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            // excess is a negative index
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          } // Return only captures needed by the pseudo filter method (type and argument)


          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function TAG(nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function () {
            return true;
          } : function (elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function CLASS(className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function ATTR(name, operator, check) {
          return function (elem) {
            var result = Sizzle.attr(elem, name);

            if (result == null) {
              return operator === "!=";
            }

            if (!operator) {
              return true;
            }

            result += "";
            /* eslint-disable max-len */

            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
            /* eslint-enable max-len */
          };
        },
        "CHILD": function CHILD(type, what, _argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
          return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
          function (elem) {
            return !!elem.parentNode;
          } : function (elem, _context, xml) {
            var cache,
                uniqueCache,
                outerCache,
                node,
                nodeIndex,
                start,
                dir = simple !== forward ? "nextSibling" : "previousSibling",
                parent = elem.parentNode,
                name = ofType && elem.nodeName.toLowerCase(),
                useCache = !xml && !ofType,
                diff = false;

            if (parent) {
              // :(first|last|only)-(child|of-type)
              if (simple) {
                while (dir) {
                  node = elem;

                  while (node = node[dir]) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  } // Reverse direction for :only-* (if we haven't yet done so)


                  start = dir = type === "only" && !start && "nextSibling";
                }

                return true;
              }

              start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`

              if (forward && useCache) {
                // Seek `elem` from a previously-cached index
                // ...in a gzip-friendly way
                node = parent;
                outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                // Defend against cloned attroperties (jQuery gh-1709)

                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];

                while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start
                diff = nodeIndex = 0) || start.pop()) {
                  // When found, cache indexes on `parent` and break
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    uniqueCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else {
                // Use previously-cached element index if available
                if (useCache) {
                  // ...in a gzip-friendly way
                  node = elem;
                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                  // Defend against cloned attroperties (jQuery gh-1709)

                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex;
                } // xml :nth-child(...)
                // or :nth-last-child(...) or :nth(-last)?-of-type(...)


                if (diff === false) {
                  // Use the same loop as above to seek `elem` from the start
                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                      // Cache the index of each encountered element
                      if (useCache) {
                        outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                        // Defend against cloned attroperties (jQuery gh-1709)

                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        uniqueCache[type] = [dirruns, diff];
                      }

                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
              } // Incorporate the offset, then check against cycle size


              diff -= last;
              return diff === first || diff % first === 0 && diff / first >= 0;
            }
          };
        },
        "PSEUDO": function PSEUDO(pseudo, argument) {
          // pseudo-class names are case-insensitive
          // http://www.w3.org/TR/selectors/#pseudo-classes
          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
          // Remember that setFilters inherits from pseudos
          var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo); // The user may use createPseudo to indicate that
          // arguments are needed to create the filter function
          // just as Sizzle does

          if (fn[expando]) {
            return fn(argument);
          } // But maintain support for old signatures


          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
              var idx,
                  matched = fn(seed, argument),
                  i = matched.length;

              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function (elem) {
              return fn(elem, 0, args);
            };
          }

          return fn;
        }
      },
      pseudos: {
        // Potentially complex pseudos
        "not": markFunction(function (selector) {
          // Trim the selector passed to compile
          // to avoid treating leading and trailing
          // spaces as combinators
          var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function (seed, matches, _context, xml) {
            var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length; // Match elements unmatched by `matcher`

            while (i--) {
              if (elem = unmatched[i]) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function (elem, _context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results); // Don't keep the element (issue #299)

            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function (selector) {
          return function (elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function (text) {
          text = text.replace(runescape, funescape);
          return function (elem) {
            return (elem.textContent || getText(elem)).indexOf(text) > -1;
          };
        }),
        // "Whether an element is represented by a :lang() selector
        // is based solely on the element's language value
        // being equal to the identifier C,
        // or beginning with the identifier C immediately followed by "-".
        // The matching of C against the element's language value is performed case-insensitively.
        // The identifier C does not have to be a valid language name."
        // http://www.w3.org/TR/selectors/#lang-pseudo
        "lang": markFunction(function (lang) {
          // lang value must be a valid identifier
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }

          lang = lang.replace(runescape, funescape).toLowerCase();
          return function (elem) {
            var elemLang;

            do {
              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);

            return false;
          };
        }),
        // Miscellaneous
        "target": function target(elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function root(elem) {
          return elem === docElem;
        },
        "focus": function focus(elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        // Boolean properties
        "enabled": createDisabledPseudo(false),
        "disabled": createDisabledPseudo(true),
        "checked": function checked(elem) {
          // In CSS3, :checked should return both checked and selected elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          var nodeName = elem.nodeName.toLowerCase();
          return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
        },
        "selected": function selected(elem) {
          // Accessing this property makes selected-by-default
          // options in Safari work properly
          if (elem.parentNode) {
            // eslint-disable-next-line no-unused-expressions
            elem.parentNode.selectedIndex;
          }

          return elem.selected === true;
        },
        // Contents
        "empty": function empty(elem) {
          // http://www.w3.org/TR/selectors/#empty-pseudo
          // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
          //   but not by others (comment: 8; processing instruction: 7; etc.)
          // nodeType < 6 works because attributes (2) do not appear as children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }

          return true;
        },
        "parent": function parent(elem) {
          return !Expr.pseudos["empty"](elem);
        },
        // Element/input types
        "header": function header(elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function input(elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function button(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "text": function text(elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ( // Support: IE<8
          // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
          (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        // Position-in-collection
        "first": createPositionalPseudo(function () {
          return [0];
        }),
        "last": createPositionalPseudo(function (_matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function (_matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function (matchIndexes, length) {
          var i = 0;

          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function (matchIndexes, length) {
          var i = 1;

          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument > length ? length : argument;

          for (; --i >= 0;) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;

          for (; ++i < length;) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"]; // Add button/input type pseudos

    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }

    for (i in {
      submit: true,
      reset: true
    }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    } // Easy API for creating new setFilters


    function setFilters() {}

    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();

    tokenize = Sizzle.tokenize = function (selector, parseOnly) {
      var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];

      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }

      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;

      while (soFar) {
        // Comma and first run
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            // Don't consume trailing commas as valid
            soFar = soFar.slice(match[0].length) || soFar;
          }

          groups.push(tokens = []);
        }

        matched = false; // Combinators

        if (match = rcombinators.exec(soFar)) {
          matched = match.shift();
          tokens.push({
            value: matched,
            // Cast descendant combinators to space
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        } // Filters


        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }

        if (!matched) {
          break;
        }
      } // Return the length of the invalid excess
      // if we're just parsing
      // Otherwise, throw an error or return tokens


      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
      tokenCache(selector, groups).slice(0);
    };

    function toSelector(tokens) {
      var i = 0,
          len = tokens.length,
          selector = "";

      for (; i < len; i++) {
        selector += tokens[i].value;
      }

      return selector;
    }

    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
          skip = combinator.next,
          key = skip || dir,
          checkNonElements = base && key === "parentNode",
          doneName = done++;
      return combinator.first ? // Check against closest ancestor/preceding element
      function (elem, context, xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }

        return false;
      } : // Check against all ancestor/preceding elements
      function (elem, context, xml) {
        var oldCache,
            uniqueCache,
            outerCache,
            newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching

        if (xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only
              // Defend against cloned attroperties (jQuery gh-1709)

              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

              if (skip && skip === elem.nodeName.toLowerCase()) {
                elem = elem[dir] || elem;
              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                // Assign to newCache so results back-propagate to previous elements
                return newCache[2] = oldCache[2];
              } else {
                // Reuse newcache so results back-propagate to previous elements
                uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking

                if (newCache[2] = matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          }
        }

        return false;
      };
    }

    function elementMatcher(matchers) {
      return matchers.length > 1 ? function (elem, context, xml) {
        var i = matchers.length;

        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }

        return true;
      } : matchers[0];
    }

    function multipleContexts(selector, contexts, results) {
      var i = 0,
          len = contexts.length;

      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }

      return results;
    }

    function condense(unmatched, map, filter, context, xml) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;

      for (; i < len; i++) {
        if (elem = unmatched[i]) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);

            if (mapped) {
              map.push(i);
            }
          }
        }
      }

      return newUnmatched;
    }

    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }

      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }

      return markFunction(function (seed, results, context, xml) {
        var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            // Get initial elements from seed or context
        elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            // Prefilter to get matcher input, preserving a map for seed-results synchronization
        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
            matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
        postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
        [] : // ...otherwise use results directly
        results : matcherIn; // Find primary matches

        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        } // Apply postFilter


        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn

          i = temp.length;

          while (i--) {
            if (elem = temp[i]) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }

        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              // Get the final matcherOut by condensing this intermediate into postFinder contexts
              temp = [];
              i = matcherOut.length;

              while (i--) {
                if (elem = matcherOut[i]) {
                  // Restore matcherIn since elem is not yet a final match
                  temp.push(matcherIn[i] = elem);
                }
              }

              postFinder(null, matcherOut = [], temp, xml);
            } // Move matched elements from seed to results to keep them synchronized


            i = matcherOut.length;

            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          } // Add elements to results, through postFinder if defined

        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);

          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }

    function matcherFromTokens(tokens) {
      var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          // The foundational matcher ensures that elements are reachable from top-level context(s)
      matchContext = addCombinator(function (elem) {
        return elem === checkContext;
      }, implicitRelative, true),
          matchAnyContext = addCombinator(function (elem) {
        return indexOf(checkContext, elem) > -1;
      }, implicitRelative, true),
          matchers = [function (elem, context, xml) {
        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)

        checkContext = null;
        return ret;
      }];

      for (; i < len; i++) {
        if (matcher = Expr.relative[tokens[i].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher

          if (matcher[expando]) {
            // Find the next relative operator (if any) for proper handling
            j = ++i;

            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }

            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`
            tokens.slice(0, i - 1).concat({
              value: tokens[i - 2].type === " " ? "*" : ""
            })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
          }

          matchers.push(matcher);
        }
      }

      return elementMatcher(matchers);
    }

    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function superMatcher(seed, context, xml, results, outermost) {
        var elem,
            j,
            matcher,
            matchedCount = 0,
            i = "0",
            unmatched = seed && [],
            setMatched = [],
            contextBackup = outermostContext,
            // We must always have either seed elements or outermost context
        elems = seed || byElement && Expr.find["TAG"]("*", outermost),
            // Use integer dirruns iff this is the outermost matcher
        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
            len = elems.length;

        if (outermost) {
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          outermostContext = context == document || context || outermost;
        } // Add elements passing elementMatchers directly to results
        // Support: IE<9, Safari
        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id


        for (; i !== len && (elem = elems[i]) != null; i++) {
          if (byElement && elem) {
            j = 0; // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq

            if (!context && elem.ownerDocument != document) {
              setDocument(elem);
              xml = !documentIsHTML;
            }

            while (matcher = elementMatchers[j++]) {
              if (matcher(elem, context || document, xml)) {
                results.push(elem);
                break;
              }
            }

            if (outermost) {
              dirruns = dirrunsUnique;
            }
          } // Track unmatched elements for set filters


          if (bySet) {
            // They will have gone through all possible matchers
            if (elem = !matcher && elem) {
              matchedCount--;
            } // Lengthen the array for every element, matched or not


            if (seed) {
              unmatched.push(elem);
            }
          }
        } // `i` is now the count of elements visited above, and adding it to `matchedCount`
        // makes the latter nonnegative.


        matchedCount += i; // Apply set filters to unmatched elements
        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
        // no element matchers and no seed.
        // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
        // case, which will result in a "00" `matchedCount` that differs from `i` but is also
        // numerically zero.

        if (bySet && i !== matchedCount) {
          j = 0;

          while (matcher = setMatchers[j++]) {
            matcher(unmatched, setMatched, context, xml);
          }

          if (seed) {
            // Reintegrate element matches to eliminate the need for sorting
            if (matchedCount > 0) {
              while (i--) {
                if (!(unmatched[i] || setMatched[i])) {
                  setMatched[i] = pop.call(results);
                }
              }
            } // Discard index placeholder values to get only actual matches


            setMatched = condense(setMatched);
          } // Add matches to results


          push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting

          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
            Sizzle.uniqueSort(results);
          }
        } // Override manipulation of globals by nested matchers


        if (outermost) {
          dirruns = dirrunsUnique;
          outermostContext = contextBackup;
        }

        return unmatched;
      };

      return bySet ? markFunction(superMatcher) : superMatcher;
    }

    compile = Sizzle.compile = function (selector, match
    /* Internal Use Only */
    ) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];

      if (!cached) {
        // Generate a function of recursive functions that can be used to check each element
        if (!match) {
          match = tokenize(selector);
        }

        i = match.length;

        while (i--) {
          cached = matcherFromTokens(match[i]);

          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        } // Cache the compiled function


        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization

        cached.selector = selector;
      }

      return cached;
    };
    /**
     * A low-level selection function that works with Sizzle's compiled
     *  selector functions
     * @param {String|Function} selector A selector or a pre-compiled
     *  selector function built with Sizzle.compile
     * @param {Element} context
     * @param {Array} [results]
     * @param {Array} [seed] A set of elements to match against
     */


    select = Sizzle.select = function (selector, context, results, seed) {
      var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize(selector = compiled.selector || selector);
      results = results || []; // Try to minimize operations if there is only one selector in the list and no seed
      // (the latter of which guarantees us context)

      if (match.length === 1) {
        // Reduce context if the leading compound selector is an ID
        tokens = match[0] = match[0].slice(0);

        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];

          if (!context) {
            return results; // Precompiled matchers will still verify ancestry, so step up a level
          } else if (compiled) {
            context = context.parentNode;
          }

          selector = selector.slice(tokens.shift().value.length);
        } // Fetch a seed set for right-to-left matching


        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;

        while (i--) {
          token = tokens[i]; // Abort if we hit a combinator

          if (Expr.relative[type = token.type]) {
            break;
          }

          if (find = Expr.find[type]) {
            // Search, expanding context for leading sibling combinators
            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
              // If seed is empty or no tokens remain, we can return early
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);

              if (!selector) {
                push.apply(results, seed);
                return results;
              }

              break;
            }
          }
        }
      } // Compile and execute a filtering function if one is not provided
      // Provide `match` to avoid retokenization if we modified the selector above


      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    }; // One-time assignments
    // Sort stability


    support.sortStable = expando.split("").sort(sortOrder).join("") === expando; // Support: Chrome 14-35+
    // Always assume duplicates if they aren't passed to the comparison function

    support.detectDuplicates = !!hasDuplicate; // Initialize against the default document

    setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
    // Detached nodes confoundingly follow *each other*

    support.sortDetached = assert(function (el) {
      // Should return 1, but returns 4 (following)
      return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
    }); // Support: IE<8
    // Prevent attribute/property "interpolation"
    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx

    if (!assert(function (el) {
      el.innerHTML = "<a href='#'></a>";
      return el.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function (elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    } // Support: IE<9
    // Use defaultValue in place of getAttribute("value")


    if (!support.attributes || !assert(function (el) {
      el.innerHTML = "<input/>";
      el.firstChild.setAttribute("value", "");
      return el.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function (elem, _name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    } // Support: IE<9
    // Use getAttributeNode to fetch booleans when getAttribute lies


    if (!assert(function (el) {
      return el.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function (elem, name, isXML) {
        var val;

        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }

    return Sizzle;
  }(window);

  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors; // Deprecated

  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  jQuery.escapeSelector = Sizzle.escape;

  var dir = function dir(elem, _dir, until) {
    var matched = [],
        truncate = until !== undefined;

    while ((elem = elem[_dir]) && elem.nodeType !== 9) {
      if (elem.nodeType === 1) {
        if (truncate && jQuery(elem).is(until)) {
          break;
        }

        matched.push(elem);
      }
    }

    return matched;
  };

  var _siblings = function siblings(n, elem) {
    var matched = [];

    for (; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n !== elem) {
        matched.push(n);
      }
    }

    return matched;
  };

  var rneedsContext = jQuery.expr.match.needsContext;

  function nodeName(elem, name) {
    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
  }

  var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; // Implement the identical functionality for filter and not

  function winnow(elements, qualifier, not) {
    if (isFunction(qualifier)) {
      return jQuery.grep(elements, function (elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    } // Single element


    if (qualifier.nodeType) {
      return jQuery.grep(elements, function (elem) {
        return elem === qualifier !== not;
      });
    } // Arraylike of elements (jQuery, arguments, Array)


    if (typeof qualifier !== "string") {
      return jQuery.grep(elements, function (elem) {
        return indexOf.call(qualifier, elem) > -1 !== not;
      });
    } // Filtered directly for both simple and complex selectors


    return jQuery.filter(qualifier, elements, not);
  }

  jQuery.filter = function (expr, elems, not) {
    var elem = elems[0];

    if (not) {
      expr = ":not(" + expr + ")";
    }

    if (elems.length === 1 && elem.nodeType === 1) {
      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
    }

    return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
      return elem.nodeType === 1;
    }));
  };

  jQuery.fn.extend({
    find: function find(selector) {
      var i,
          ret,
          len = this.length,
          self = this;

      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function () {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }

      ret = this.pushStack([]);

      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }

      return len > 1 ? jQuery.uniqueSort(ret) : ret;
    },
    filter: function filter(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function not(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function is(selector) {
      return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
      // so $("p:first").is("p:last") won't return true for a doc with two "p".
      typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  }); // Initialize a jQuery object
  // A central reference to the root jQuery(document)

  var rootjQuery,
      // A simple way to check for HTML strings
  // Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
  // Strict HTML recognition (trac-11290: must start with <)
  // Shortcut simple #id case for speed
  rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
      init = jQuery.fn.init = function (selector, context, root) {
    var match, elem; // HANDLE: $(""), $(null), $(undefined), $(false)

    if (!selector) {
      return this;
    } // Method init() accepts an alternate rootjQuery
    // so migrate can support jQuery.sub (gh-2101)


    root = root || rootjQuery; // Handle HTML strings

    if (typeof selector === "string") {
      if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
        // Assume that strings that start and end with <> are HTML and skip the regex check
        match = [null, selector, null];
      } else {
        match = rquickExpr.exec(selector);
      } // Match html or make sure no context is specified for #id


      if (match && (match[1] || !context)) {
        // HANDLE: $(html) -> $(array)
        if (match[1]) {
          context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat
          // Intentionally let the error be thrown if parseHTML is not present

          jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)

          if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
            for (match in context) {
              // Properties of context are called as methods if possible
              if (isFunction(this[match])) {
                this[match](context[match]); // ...and otherwise set as attributes
              } else {
                this.attr(match, context[match]);
              }
            }
          }

          return this; // HANDLE: $(#id)
        } else {
          elem = document.getElementById(match[2]);

          if (elem) {
            // Inject the element directly into the jQuery object
            this[0] = elem;
            this.length = 1;
          }

          return this;
        } // HANDLE: $(expr, $(...))

      } else if (!context || context.jquery) {
        return (context || root).find(selector); // HANDLE: $(expr, context)
        // (which is just equivalent to: $(context).find(expr)
      } else {
        return this.constructor(context).find(selector);
      } // HANDLE: $(DOMElement)

    } else if (selector.nodeType) {
      this[0] = selector;
      this.length = 1;
      return this; // HANDLE: $(function)
      // Shortcut for document ready
    } else if (isFunction(selector)) {
      return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present
      selector(jQuery);
    }

    return jQuery.makeArray(selector, this);
  }; // Give the init function the jQuery prototype for later instantiation


  init.prototype = jQuery.fn; // Initialize central reference

  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
      // Methods guaranteed to produce a unique set when starting from a unique set
  guaranteedUnique = {
    children: true,
    contents: true,
    next: true,
    prev: true
  };
  jQuery.fn.extend({
    has: function has(target) {
      var targets = jQuery(target, this),
          l = targets.length;
      return this.filter(function () {
        var i = 0;

        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function closest(selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          matched = [],
          targets = typeof selectors !== "string" && jQuery(selectors); // Positional selectors never match, since there's no _selection_ context

      if (!rneedsContext.test(selectors)) {
        for (; i < l; i++) {
          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
            // Always skip document fragments
            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle
            cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
              matched.push(cur);
              break;
            }
          }
        }
      }

      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
    },
    // Determine the position of an element within the set
    index: function index(elem) {
      // No argument, return index in parent
      if (!elem) {
        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
      } // Index in selector


      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      } // Locate the position of the desired element


      return indexOf.call(this, // If it receives a jQuery object, the first element is used
      elem.jquery ? elem[0] : elem);
    },
    add: function add(selector, context) {
      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function addBack(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });

  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}

    return cur;
  }

  jQuery.each({
    parent: function parent(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function parents(elem) {
      return dir(elem, "parentNode");
    },
    parentsUntil: function parentsUntil(elem, _i, until) {
      return dir(elem, "parentNode", until);
    },
    next: function next(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function prev(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function nextAll(elem) {
      return dir(elem, "nextSibling");
    },
    prevAll: function prevAll(elem) {
      return dir(elem, "previousSibling");
    },
    nextUntil: function nextUntil(elem, _i, until) {
      return dir(elem, "nextSibling", until);
    },
    prevUntil: function prevUntil(elem, _i, until) {
      return dir(elem, "previousSibling", until);
    },
    siblings: function siblings(elem) {
      return _siblings((elem.parentNode || {}).firstChild, elem);
    },
    children: function children(elem) {
      return _siblings(elem.firstChild);
    },
    contents: function contents(elem) {
      if (elem.contentDocument != null && // Support: IE 11+
      // <object> elements with no `data` attribute has an object
      // `contentDocument` with a `null` prototype.
      getProto(elem.contentDocument)) {
        return elem.contentDocument;
      } // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
      // Treat the template element as a regular one in browsers that
      // don't support it.


      if (nodeName(elem, "template")) {
        elem = elem.content || elem;
      }

      return jQuery.merge([], elem.childNodes);
    }
  }, function (name, fn) {
    jQuery.fn[name] = function (until, selector) {
      var matched = jQuery.map(this, fn, until);

      if (name.slice(-5) !== "Until") {
        selector = until;
      }

      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }

      if (this.length > 1) {
        // Remove duplicates
        if (!guaranteedUnique[name]) {
          jQuery.uniqueSort(matched);
        } // Reverse order for parents* and prev-derivatives


        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }

      return this.pushStack(matched);
    };
  });
  var rnothtmlwhite = /[^\x20\t\r\n\f]+/g; // Convert String-formatted options into Object-formatted ones

  function createOptions(options) {
    var object = {};
    jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
      object[flag] = true;
    });
    return object;
  }
  /*
   * Create a callback list using the following parameters:
   *
   *	options: an optional list of space-separated options that will change how
   *			the callback list behaves or a more traditional option object
   *
   * By default a callback list will act like an event callback list and can be
   * "fired" multiple times.
   *
   * Possible options:
   *
   *	once:			will ensure the callback list can only be fired once (like a Deferred)
   *
   *	memory:			will keep track of previous values and will call any callback added
   *					after the list has been fired right away with the latest "memorized"
   *					values (like a Deferred)
   *
   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
   *
   *	stopOnFalse:	interrupt callings when a callback returns false
   *
   */


  jQuery.Callbacks = function (options) {
    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

    var // Flag to know if list is currently firing
    firing,
        // Last fire value for non-forgettable lists
    memory,
        // Flag to know if list was already fired
    _fired,
        // Flag to prevent firing
    _locked,
        // Actual callback list
    list = [],
        // Queue of execution data for repeatable lists
    queue = [],
        // Index of currently firing callback (modified by add/remove as needed)
    firingIndex = -1,
        // Fire callbacks
    fire = function fire() {
      // Enforce single-firing
      _locked = _locked || options.once; // Execute callbacks for all pending executions,
      // respecting firingIndex overrides and runtime changes

      _fired = firing = true;

      for (; queue.length; firingIndex = -1) {
        memory = queue.shift();

        while (++firingIndex < list.length) {
          // Run callback and check for early termination
          if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
            // Jump to end and forget the data so .add doesn't re-fire
            firingIndex = list.length;
            memory = false;
          }
        }
      } // Forget the data if we're done with it


      if (!options.memory) {
        memory = false;
      }

      firing = false; // Clean up if we're done firing for good

      if (_locked) {
        // Keep an empty list if we have data for future add calls
        if (memory) {
          list = []; // Otherwise, this object is spent
        } else {
          list = "";
        }
      }
    },
        // Actual Callbacks object
    self = {
      // Add a callback or a collection of callbacks to the list
      add: function add() {
        if (list) {
          // If we have memory from a past run, we should fire after adding
          if (memory && !firing) {
            firingIndex = list.length - 1;
            queue.push(memory);
          }

          (function add(args) {
            jQuery.each(args, function (_, arg) {
              if (isFunction(arg)) {
                if (!options.unique || !self.has(arg)) {
                  list.push(arg);
                }
              } else if (arg && arg.length && toType(arg) !== "string") {
                // Inspect recursively
                add(arg);
              }
            });
          })(arguments);

          if (memory && !firing) {
            fire();
          }
        }

        return this;
      },
      // Remove a callback from the list
      remove: function remove() {
        jQuery.each(arguments, function (_, arg) {
          var index;

          while ((index = jQuery.inArray(arg, list, index)) > -1) {
            list.splice(index, 1); // Handle firing indexes

            if (index <= firingIndex) {
              firingIndex--;
            }
          }
        });
        return this;
      },
      // Check if a given callback is in the list.
      // If no argument is given, return whether or not list has callbacks attached.
      has: function has(fn) {
        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
      },
      // Remove all callbacks from the list
      empty: function empty() {
        if (list) {
          list = [];
        }

        return this;
      },
      // Disable .fire and .add
      // Abort any current/pending executions
      // Clear all callbacks and values
      disable: function disable() {
        _locked = queue = [];
        list = memory = "";
        return this;
      },
      disabled: function disabled() {
        return !list;
      },
      // Disable .fire
      // Also disable .add unless we have memory (since it would have no effect)
      // Abort any pending executions
      lock: function lock() {
        _locked = queue = [];

        if (!memory && !firing) {
          list = memory = "";
        }

        return this;
      },
      locked: function locked() {
        return !!_locked;
      },
      // Call all callbacks with the given context and arguments
      fireWith: function fireWith(context, args) {
        if (!_locked) {
          args = args || [];
          args = [context, args.slice ? args.slice() : args];
          queue.push(args);

          if (!firing) {
            fire();
          }
        }

        return this;
      },
      // Call all the callbacks with the given arguments
      fire: function fire() {
        self.fireWith(this, arguments);
        return this;
      },
      // To know if the callbacks have already been called at least once
      fired: function fired() {
        return !!_fired;
      }
    };

    return self;
  };

  function Identity(v) {
    return v;
  }

  function Thrower(ex) {
    throw ex;
  }

  function adoptValue(value, resolve, reject, noValue) {
    var method;

    try {
      // Check for promise aspect first to privilege synchronous behavior
      if (value && isFunction(method = value.promise)) {
        method.call(value).done(resolve).fail(reject); // Other thenables
      } else if (value && isFunction(method = value.then)) {
        method.call(value, resolve, reject); // Other non-thenables
      } else {
        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
        // * false: [ value ].slice( 0 ) => resolve( value )
        // * true: [ value ].slice( 1 ) => resolve()
        resolve.apply(undefined, [value].slice(noValue));
      } // For Promises/A+, convert exceptions into rejections
      // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
      // Deferred#then to conditionally suppress rejection.

    } catch (value) {
      // Support: Android 4.0 only
      // Strict mode functions invoked without .call/.apply get global-object context
      reject.apply(undefined, [value]);
    }
  }

  jQuery.extend({
    Deferred: function Deferred(func) {
      var tuples = [// action, add listener, callbacks,
      // ... .then handlers, argument index, [final state]
      ["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
          _state = "pending",
          _promise = {
        state: function state() {
          return _state;
        },
        always: function always() {
          deferred.done(arguments).fail(arguments);
          return this;
        },
        "catch": function _catch(fn) {
          return _promise.then(null, fn);
        },
        // Keep pipe for back-compat
        pipe: function
          /* fnDone, fnFail, fnProgress */
        pipe() {
          var fns = arguments;
          return jQuery.Deferred(function (newDefer) {
            jQuery.each(tuples, function (_i, tuple) {
              // Map tuples (progress, done, fail) to arguments (done, fail, progress)
              var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })
              // deferred.done(function() { bind to newDefer or newDefer.resolve })
              // deferred.fail(function() { bind to newDefer or newDefer.reject })

              deferred[tuple[1]](function () {
                var returned = fn && fn.apply(this, arguments);

                if (returned && isFunction(returned.promise)) {
                  returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                } else {
                  newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                }
              });
            });
            fns = null;
          }).promise();
        },
        then: function then(onFulfilled, onRejected, onProgress) {
          var maxDepth = 0;

          function resolve(depth, deferred, handler, special) {
            return function () {
              var that = this,
                  args = arguments,
                  mightThrow = function mightThrow() {
                var returned, then; // Support: Promises/A+ section 2.3.3.3.3
                // https://promisesaplus.com/#point-59
                // Ignore double-resolution attempts

                if (depth < maxDepth) {
                  return;
                }

                returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1
                // https://promisesaplus.com/#point-48

                if (returned === deferred.promise()) {
                  throw new TypeError("Thenable self-resolution");
                } // Support: Promises/A+ sections 2.3.3.1, 3.5
                // https://promisesaplus.com/#point-54
                // https://promisesaplus.com/#point-75
                // Retrieve `then` only once


                then = returned && ( // Support: Promises/A+ section 2.3.4
                // https://promisesaplus.com/#point-64
                // Only check objects and functions for thenability
                _typeof(returned) === "object" || typeof returned === "function") && returned.then; // Handle a returned thenable

                if (isFunction(then)) {
                  // Special processors (notify) just wait for resolution
                  if (special) {
                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress
                  } else {
                    // ...and disregard older resolution values
                    maxDepth++;
                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                  } // Handle all other returned values

                } else {
                  // Only substitute handlers pass on context
                  // and multiple values (non-spec behavior)
                  if (handler !== Identity) {
                    that = undefined;
                    args = [returned];
                  } // Process the value(s)
                  // Default process is resolve


                  (special || deferred.resolveWith)(that, args);
                }
              },
                  // Only normal processors (resolve) catch and reject exceptions
              process = special ? mightThrow : function () {
                try {
                  mightThrow();
                } catch (e) {
                  if (jQuery.Deferred.exceptionHook) {
                    jQuery.Deferred.exceptionHook(e, process.stackTrace);
                  } // Support: Promises/A+ section 2.3.3.3.4.1
                  // https://promisesaplus.com/#point-61
                  // Ignore post-resolution exceptions


                  if (depth + 1 >= maxDepth) {
                    // Only substitute handlers pass on context
                    // and multiple values (non-spec behavior)
                    if (handler !== Thrower) {
                      that = undefined;
                      args = [e];
                    }

                    deferred.rejectWith(that, args);
                  }
                }
              }; // Support: Promises/A+ section 2.3.3.3.1
              // https://promisesaplus.com/#point-57
              // Re-resolve promises immediately to dodge false rejection from
              // subsequent errors


              if (depth) {
                process();
              } else {
                // Call an optional hook to record the stack, in case of exception
                // since it's otherwise lost when execution goes async
                if (jQuery.Deferred.getStackHook) {
                  process.stackTrace = jQuery.Deferred.getStackHook();
                }

                window.setTimeout(process);
              }
            };
          }

          return jQuery.Deferred(function (newDefer) {
            // progress_handlers.add( ... )
            tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )

            tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )

            tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
          }).promise();
        },
        // Get a promise for this deferred
        // If obj is provided, the promise aspect is added to the object
        promise: function promise(obj) {
          return obj != null ? jQuery.extend(obj, _promise) : _promise;
        }
      },
          deferred = {}; // Add list-specific methods

      jQuery.each(tuples, function (i, tuple) {
        var list = tuple[2],
            stateString = tuple[5]; // promise.progress = list.add
        // promise.done = list.add
        // promise.fail = list.add

        _promise[tuple[1]] = list.add; // Handle state

        if (stateString) {
          list.add(function () {
            // state = "resolved" (i.e., fulfilled)
            // state = "rejected"
            _state = stateString;
          }, // rejected_callbacks.disable
          // fulfilled_callbacks.disable
          tuples[3 - i][2].disable, // rejected_handlers.disable
          // fulfilled_handlers.disable
          tuples[3 - i][3].disable, // progress_callbacks.lock
          tuples[0][2].lock, // progress_handlers.lock
          tuples[0][3].lock);
        } // progress_handlers.fire
        // fulfilled_handlers.fire
        // rejected_handlers.fire


        list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }
        // deferred.resolve = function() { deferred.resolveWith(...) }
        // deferred.reject = function() { deferred.rejectWith(...) }

        deferred[tuple[0]] = function () {
          deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
          return this;
        }; // deferred.notifyWith = list.fireWith
        // deferred.resolveWith = list.fireWith
        // deferred.rejectWith = list.fireWith


        deferred[tuple[0] + "With"] = list.fireWith;
      }); // Make the deferred a promise

      _promise.promise(deferred); // Call given func if any


      if (func) {
        func.call(deferred, deferred);
      } // All done!


      return deferred;
    },
    // Deferred helper
    when: function when(singleValue) {
      var // count of uncompleted subordinates
      remaining = arguments.length,
          // count of unprocessed arguments
      i = remaining,
          // subordinate fulfillment data
      resolveContexts = Array(i),
          resolveValues = _slice.call(arguments),
          // the primary Deferred
      primary = jQuery.Deferred(),
          // subordinate callback factory
      updateFunc = function updateFunc(i) {
        return function (value) {
          resolveContexts[i] = this;
          resolveValues[i] = arguments.length > 1 ? _slice.call(arguments) : value;

          if (! --remaining) {
            primary.resolveWith(resolveContexts, resolveValues);
          }
        };
      }; // Single- and empty arguments are adopted like Promise.resolve


      if (remaining <= 1) {
        adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject, !remaining); // Use .then() to unwrap secondary thenables (cf. gh-3000)

        if (primary.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
          return primary.then();
        }
      } // Multiple arguments are aggregated like Promise.all array elements


      while (i--) {
        adoptValue(resolveValues[i], updateFunc(i), primary.reject);
      }

      return primary.promise();
    }
  }); // These usually indicate a programmer mistake during development,
  // warn about them ASAP rather than swallowing them by default.

  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

  jQuery.Deferred.exceptionHook = function (error, stack) {
    // Support: IE 8 - 9 only
    // Console exists when dev tools are open, which can happen at any time
    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
      window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
    }
  };

  jQuery.readyException = function (error) {
    window.setTimeout(function () {
      throw error;
    });
  }; // The deferred used on DOM ready


  var readyList = jQuery.Deferred();

  jQuery.fn.ready = function (fn) {
    readyList.then(fn) // Wrap jQuery.readyException in a function so that the lookup
    // happens at the time of error handling instead of callback
    // registration.
    ["catch"](function (error) {
      jQuery.readyException(error);
    });
    return this;
  };

  jQuery.extend({
    // Is the DOM ready to be used? Set to true once it occurs.
    isReady: false,
    // A counter to track how many items to wait for before
    // the ready event fires. See trac-6781
    readyWait: 1,
    // Handle when the DOM is ready
    ready: function ready(wait) {
      // Abort if there are pending holds or we're already ready
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      } // Remember that the DOM is ready


      jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be

      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      } // If there are functions bound, to execute


      readyList.resolveWith(document, [jQuery]);
    }
  });
  jQuery.ready.then = readyList.then; // The ready event handler and self cleanup method

  function completed() {
    document.removeEventListener("DOMContentLoaded", completed);
    window.removeEventListener("load", completed);
    jQuery.ready();
  } // Catch cases where $(document).ready() is called
  // after the browser event has already occurred.
  // Support: IE <=9 - 10 only
  // Older IE sometimes signals "interactive" too soon


  if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
    // Handle it asynchronously to allow scripts the opportunity to delay ready
    window.setTimeout(jQuery.ready);
  } else {
    // Use the handy event callback
    document.addEventListener("DOMContentLoaded", completed); // A fallback to window.onload, that will always work

    window.addEventListener("load", completed);
  } // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function


  var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
        len = elems.length,
        bulk = key == null; // Sets many values

    if (toType(key) === "object") {
      chainable = true;

      for (i in key) {
        access(elems, fn, i, key[i], true, emptyGet, raw);
      } // Sets one value

    } else if (value !== undefined) {
      chainable = true;

      if (!isFunction(value)) {
        raw = true;
      }

      if (bulk) {
        // Bulk operations run against the entire set
        if (raw) {
          fn.call(elems, value);
          fn = null; // ...except when executing function values
        } else {
          bulk = fn;

          fn = function fn(elem, _key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }

      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }

    if (chainable) {
      return elems;
    } // Gets


    if (bulk) {
      return fn.call(elems);
    }

    return len ? fn(elems[0], key) : emptyGet;
  }; // Matches dashed string for camelizing


  var rmsPrefix = /^-ms-/,
      rdashAlpha = /-([a-z])/g; // Used by camelCase as callback to replace()

  function fcamelCase(_all, letter) {
    return letter.toUpperCase();
  } // Convert dashed to camelCase; used by the css and data modules
  // Support: IE <=9 - 11, Edge 12 - 15
  // Microsoft forgot to hump their vendor prefix (trac-9572)


  function camelCase(string) {
    return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
  }

  var acceptData = function acceptData(owner) {
    // Accepts only:
    //  - Node
    //    - Node.ELEMENT_NODE
    //    - Node.DOCUMENT_NODE
    //  - Object
    //    - Any
    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
  };

  function Data() {
    this.expando = jQuery.expando + Data.uid++;
  }

  Data.uid = 1;
  Data.prototype = {
    cache: function cache(owner) {
      // Check if the owner object already has a cache
      var value = owner[this.expando]; // If not, create one

      if (!value) {
        value = {}; // We can accept data for non-element nodes in modern browsers,
        // but we should not, see trac-8335.
        // Always return an empty object.

        if (acceptData(owner)) {
          // If it is a node unlikely to be stringify-ed or looped over
          // use plain assignment
          if (owner.nodeType) {
            owner[this.expando] = value; // Otherwise secure it in a non-enumerable property
            // configurable must be true to allow the property to be
            // deleted when data is removed
          } else {
            Object.defineProperty(owner, this.expando, {
              value: value,
              configurable: true
            });
          }
        }
      }

      return value;
    },
    set: function set(owner, data, value) {
      var prop,
          cache = this.cache(owner); // Handle: [ owner, key, value ] args
      // Always use camelCase key (gh-2257)

      if (typeof data === "string") {
        cache[camelCase(data)] = value; // Handle: [ owner, { properties } ] args
      } else {
        // Copy the properties one-by-one to the cache object
        for (prop in data) {
          cache[camelCase(prop)] = data[prop];
        }
      }

      return cache;
    },
    get: function get(owner, key) {
      return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)
      owner[this.expando] && owner[this.expando][camelCase(key)];
    },
    access: function access(owner, key, value) {
      // In cases where either:
      //
      //   1. No key was specified
      //   2. A string key was specified, but no value provided
      //
      // Take the "read" path and allow the get method to determine
      // which value to return, respectively either:
      //
      //   1. The entire cache object
      //   2. The data stored at the key
      //
      if (key === undefined || key && typeof key === "string" && value === undefined) {
        return this.get(owner, key);
      } // When the key is not a string, or both a key and value
      // are specified, set or extend (existing objects) with either:
      //
      //   1. An object of properties
      //   2. A key and value
      //


      this.set(owner, key, value); // Since the "set" path can have two possible entry points
      // return the expected data based on which path was taken[*]

      return value !== undefined ? value : key;
    },
    remove: function remove(owner, key) {
      var i,
          cache = owner[this.expando];

      if (cache === undefined) {
        return;
      }

      if (key !== undefined) {
        // Support array or space separated string of keys
        if (Array.isArray(key)) {
          // If key is an array of keys...
          // We always set camelCase keys, so remove that.
          key = key.map(camelCase);
        } else {
          key = camelCase(key); // If a key with the spaces exists, use it.
          // Otherwise, create an array by matching non-whitespace

          key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
        }

        i = key.length;

        while (i--) {
          delete cache[key[i]];
        }
      } // Remove the expando if there's no more data


      if (key === undefined || jQuery.isEmptyObject(cache)) {
        // Support: Chrome <=35 - 45
        // Webkit & Blink performance suffers when deleting properties
        // from DOM nodes, so set to undefined instead
        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
        if (owner.nodeType) {
          owner[this.expando] = undefined;
        } else {
          delete owner[this.expando];
        }
      }
    },
    hasData: function hasData(owner) {
      var cache = owner[this.expando];
      return cache !== undefined && !jQuery.isEmptyObject(cache);
    }
  };
  var dataPriv = new Data();
  var dataUser = new Data(); //	Implementation Summary
  //
  //	1. Enforce API surface and semantic compatibility with 1.9.x branch
  //	2. Improve the module's maintainability by reducing the storage
  //		paths to a single mechanism.
  //	3. Use the same single mechanism to support "private" and "user" data.
  //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
  //	5. Avoid exposing implementation details on user objects (eg. expando properties)
  //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /[A-Z]/g;

  function getData(data) {
    if (data === "true") {
      return true;
    }

    if (data === "false") {
      return false;
    }

    if (data === "null") {
      return null;
    } // Only convert to a number if it doesn't change the string


    if (data === +data + "") {
      return +data;
    }

    if (rbrace.test(data)) {
      return JSON.parse(data);
    }

    return data;
  }

  function dataAttr(elem, key, data) {
    var name; // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute

    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
      data = elem.getAttribute(name);

      if (typeof data === "string") {
        try {
          data = getData(data);
        } catch (e) {} // Make sure we set the data so it isn't changed later


        dataUser.set(elem, key, data);
      } else {
        data = undefined;
      }
    }

    return data;
  }

  jQuery.extend({
    hasData: function hasData(elem) {
      return dataUser.hasData(elem) || dataPriv.hasData(elem);
    },
    data: function data(elem, name, _data) {
      return dataUser.access(elem, name, _data);
    },
    removeData: function removeData(elem, name) {
      dataUser.remove(elem, name);
    },
    // TODO: Now that all calls to _data and _removeData have been replaced
    // with direct calls to dataPriv methods, these can be deprecated.
    _data: function _data(elem, name, data) {
      return dataPriv.access(elem, name, data);
    },
    _removeData: function _removeData(elem, name) {
      dataPriv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function data(key, value) {
      var i,
          name,
          data,
          elem = this[0],
          attrs = elem && elem.attributes; // Gets all values

      if (key === undefined) {
        if (this.length) {
          data = dataUser.get(elem);

          if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
            i = attrs.length;

            while (i--) {
              // Support: IE 11 only
              // The attrs elements can be null (trac-14894)
              if (attrs[i]) {
                name = attrs[i].name;

                if (name.indexOf("data-") === 0) {
                  name = camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }

            dataPriv.set(elem, "hasDataAttrs", true);
          }
        }

        return data;
      } // Sets multiple values


      if (_typeof(key) === "object") {
        return this.each(function () {
          dataUser.set(this, key);
        });
      }

      return access(this, function (value) {
        var data; // The calling jQuery object (element matches) is not empty
        // (and therefore has an element appears at this[ 0 ]) and the
        // `value` parameter was not undefined. An empty jQuery object
        // will result in `undefined` for elem = this[ 0 ] which will
        // throw an exception if an attempt to read a data cache is made.

        if (elem && value === undefined) {
          // Attempt to get data from the cache
          // The key will always be camelCased in Data
          data = dataUser.get(elem, key);

          if (data !== undefined) {
            return data;
          } // Attempt to "discover" the data in
          // HTML5 custom data-* attrs


          data = dataAttr(elem, key);

          if (data !== undefined) {
            return data;
          } // We tried really hard, but the data doesn't exist.


          return;
        } // Set the data...


        this.each(function () {
          // We always store the camelCased key
          dataUser.set(this, key, value);
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function removeData(key) {
      return this.each(function () {
        dataUser.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function queue(elem, type, data) {
      var queue;

      if (elem) {
        type = (type || "fx") + "queue";
        queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup

        if (data) {
          if (!queue || Array.isArray(data)) {
            queue = dataPriv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }

        return queue || [];
      }
    },
    dequeue: function dequeue(elem, type) {
      type = type || "fx";

      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function next() {
        jQuery.dequeue(elem, type);
      }; // If the fx queue is dequeued, always remove the progress sentinel


      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }

      if (fn) {
        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if (type === "fx") {
          queue.unshift("inprogress");
        } // Clear up the last queue stop function


        delete hooks.stop;
        fn.call(elem, next, hooks);
      }

      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    // Not public - generate a queueHooks object, or return the current one
    _queueHooks: function _queueHooks(elem, type) {
      var key = type + "queueHooks";
      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
        empty: jQuery.Callbacks("once memory").add(function () {
          dataPriv.remove(elem, [type + "queue", key]);
        })
      });
    }
  });
  jQuery.fn.extend({
    queue: function queue(type, data) {
      var setter = 2;

      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }

      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }

      return data === undefined ? this : this.each(function () {
        var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue

        jQuery._queueHooks(this, type);

        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function dequeue(type) {
      return this.each(function () {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function clearQueue(type) {
      return this.queue(type || "fx", []);
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function promise(type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function resolve() {
        if (! --count) {
          defer.resolveWith(elements, [elements]);
        }
      };

      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }

      type = type || "fx";

      while (i--) {
        tmp = dataPriv.get(elements[i], type + "queueHooks");

        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }

      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
  var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var documentElement = document.documentElement;

  var isAttached = function isAttached(elem) {
    return jQuery.contains(elem.ownerDocument, elem);
  },
      composed = {
    composed: true
  }; // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
  // Check attachment across shadow DOM boundaries when possible (gh-3504)
  // Support: iOS 10.0-10.2 only
  // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
  // leading to errors. We need to check for `getRootNode`.


  if (documentElement.getRootNode) {
    isAttached = function isAttached(elem) {
      return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
    };
  }

  var isHiddenWithinTree = function isHiddenWithinTree(elem, el) {
    // isHiddenWithinTree might be called from jQuery#filter function;
    // in that case, element will be second argument
    elem = el || elem; // Inline style trumps all

    return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
    // Support: Firefox <=43 - 45
    // Disconnected elements can have computed display: none, so first confirm that elem is
    // in the document.
    isAttached(elem) && jQuery.css(elem, "display") === "none";
  };

  function adjustCSS(elem, prop, valueParts, tween) {
    var adjusted,
        scale,
        maxIterations = 20,
        currentValue = tween ? function () {
      return tween.cur();
    } : function () {
      return jQuery.css(elem, prop, "");
    },
        initial = currentValue(),
        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
        // Starting value computation is required for potential unit mismatches
    initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

    if (initialInUnit && initialInUnit[3] !== unit) {
      // Support: Firefox <=54
      // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
      initial = initial / 2; // Trust units reported by jQuery.css

      unit = unit || initialInUnit[3]; // Iteratively approximate from a nonzero starting point

      initialInUnit = +initial || 1;

      while (maxIterations--) {
        // Evaluate and update our best guess (doubling guesses that zero out).
        // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
        jQuery.style(elem, prop, initialInUnit + unit);

        if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
          maxIterations = 0;
        }

        initialInUnit = initialInUnit / scale;
      }

      initialInUnit = initialInUnit * 2;
      jQuery.style(elem, prop, initialInUnit + unit); // Make sure we update the tween properties later on

      valueParts = valueParts || [];
    }

    if (valueParts) {
      initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified

      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];

      if (tween) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
      }
    }

    return adjusted;
  }

  var defaultDisplayMap = {};

  function getDefaultDisplay(elem) {
    var temp,
        doc = elem.ownerDocument,
        nodeName = elem.nodeName,
        display = defaultDisplayMap[nodeName];

    if (display) {
      return display;
    }

    temp = doc.body.appendChild(doc.createElement(nodeName));
    display = jQuery.css(temp, "display");
    temp.parentNode.removeChild(temp);

    if (display === "none") {
      display = "block";
    }

    defaultDisplayMap[nodeName] = display;
    return display;
  }

  function showHide(elements, show) {
    var display,
        elem,
        values = [],
        index = 0,
        length = elements.length; // Determine new display value for elements that need to change

    for (; index < length; index++) {
      elem = elements[index];

      if (!elem.style) {
        continue;
      }

      display = elem.style.display;

      if (show) {
        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
        // check is required in this first loop unless we have a nonempty display value (either
        // inline or about-to-be-restored)
        if (display === "none") {
          values[index] = dataPriv.get(elem, "display") || null;

          if (!values[index]) {
            elem.style.display = "";
          }
        }

        if (elem.style.display === "" && isHiddenWithinTree(elem)) {
          values[index] = getDefaultDisplay(elem);
        }
      } else {
        if (display !== "none") {
          values[index] = "none"; // Remember what we're overwriting

          dataPriv.set(elem, "display", display);
        }
      }
    } // Set the display of the elements in a second loop to avoid constant reflow


    for (index = 0; index < length; index++) {
      if (values[index] != null) {
        elements[index].style.display = values[index];
      }
    }

    return elements;
  }

  jQuery.fn.extend({
    show: function show() {
      return showHide(this, true);
    },
    hide: function hide() {
      return showHide(this);
    },
    toggle: function toggle(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }

      return this.each(function () {
        if (isHiddenWithinTree(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  var rcheckableType = /^(?:checkbox|radio)$/i;
  var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
  var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;

  (function () {
    var fragment = document.createDocumentFragment(),
        div = fragment.appendChild(document.createElement("div")),
        input = document.createElement("input"); // Support: Android 4.0 - 4.3 only
    // Check state lost if the name is set (trac-11217)
    // Support: Windows Web Apps (WWA)
    // `name` and `type` must use .setAttribute for WWA (trac-14901)

    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input); // Support: Android <=4.1 only
    // Older WebKit doesn't clone checked state correctly in fragments

    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE <=11 only
    // Make sure textarea (and checkbox) defaultValue is properly cloned

    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue; // Support: IE <=9 only
    // IE <=9 replaces <option> tags with their contents when inserted outside of
    // the select element.

    div.innerHTML = "<option></option>";
    support.option = !!div.lastChild;
  })(); // We have to close these tags to support XHTML (trac-13200)


  var wrapMap = {
    // XHTML parsers do not magically insert elements in the
    // same way that tag soup parsers do. So we cannot shorten
    // this by omitting <tbody> or other required elements.
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  };
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td; // Support: IE <=9 only

  if (!support.option) {
    wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
  }

  function getAll(context, tag) {
    // Support: IE <=9 - 11 only
    // Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
    var ret;

    if (typeof context.getElementsByTagName !== "undefined") {
      ret = context.getElementsByTagName(tag || "*");
    } else if (typeof context.querySelectorAll !== "undefined") {
      ret = context.querySelectorAll(tag || "*");
    } else {
      ret = [];
    }

    if (tag === undefined || tag && nodeName(context, tag)) {
      return jQuery.merge([context], ret);
    }

    return ret;
  } // Mark scripts as having already been evaluated


  function setGlobalEval(elems, refElements) {
    var i = 0,
        l = elems.length;

    for (; i < l; i++) {
      dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
  }

  var rhtml = /<|&#?\w+;/;

  function buildFragment(elems, context, scripts, selection, ignored) {
    var elem,
        tmp,
        tag,
        wrap,
        attached,
        j,
        fragment = context.createDocumentFragment(),
        nodes = [],
        i = 0,
        l = elems.length;

    for (; i < l; i++) {
      elem = elems[i];

      if (elem || elem === 0) {
        // Add nodes directly
        if (toType(elem) === "object") {
          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node
        } else if (!rhtml.test(elem)) {
          nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div")); // Deserialize a standard representation

          tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content

          j = wrap[0];

          while (j--) {
            tmp = tmp.lastChild;
          } // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit


          jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container

          tmp = fragment.firstChild; // Ensure the created nodes are orphaned (trac-12392)

          tmp.textContent = "";
        }
      }
    } // Remove wrapper from fragment


    fragment.textContent = "";
    i = 0;

    while (elem = nodes[i++]) {
      // Skip elements already in the context collection (trac-4087)
      if (selection && jQuery.inArray(elem, selection) > -1) {
        if (ignored) {
          ignored.push(elem);
        }

        continue;
      }

      attached = isAttached(elem); // Append to fragment

      tmp = getAll(fragment.appendChild(elem), "script"); // Preserve script evaluation history

      if (attached) {
        setGlobalEval(tmp);
      } // Capture executables


      if (scripts) {
        j = 0;

        while (elem = tmp[j++]) {
          if (rscriptType.test(elem.type || "")) {
            scripts.push(elem);
          }
        }
      }
    }

    return fragment;
  }

  var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

  function returnTrue() {
    return true;
  }

  function returnFalse() {
    return false;
  } // Support: IE <=9 - 11+
  // focus() and blur() are asynchronous, except when they are no-op.
  // So expect focus to be synchronous when the element is already active,
  // and blur to be synchronous when the element is not already active.
  // (focus and blur are always synchronous in other supported browsers,
  // this just defines when we can count on it).


  function expectSync(elem, type) {
    return elem === safeActiveElement() === (type === "focus");
  } // Support: IE <=9 only
  // Accessing document.activeElement can throw unexpectedly
  // https://bugs.jquery.com/ticket/13393


  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }

  function _on(elem, types, selector, data, fn, one) {
    var origFn, type; // Types can be a map of types/handlers

    if (_typeof(types) === "object") {
      // ( types-Object, selector, data )
      if (typeof selector !== "string") {
        // ( types-Object, data )
        data = data || selector;
        selector = undefined;
      }

      for (type in types) {
        _on(elem, type, selector, data, types[type], one);
      }

      return elem;
    }

    if (data == null && fn == null) {
      // ( types, fn )
      fn = selector;
      data = selector = undefined;
    } else if (fn == null) {
      if (typeof selector === "string") {
        // ( types, selector, fn )
        fn = data;
        data = undefined;
      } else {
        // ( types, data, fn )
        fn = data;
        data = selector;
        selector = undefined;
      }
    }

    if (fn === false) {
      fn = returnFalse;
    } else if (!fn) {
      return elem;
    }

    if (one === 1) {
      origFn = fn;

      fn = function fn(event) {
        // Can use an empty set, since event contains the info
        jQuery().off(event);
        return origFn.apply(this, arguments);
      }; // Use same guid so caller can remove using origFn


      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
    }

    return elem.each(function () {
      jQuery.event.add(this, types, fn, data, selector);
    });
  }
  /*
   * Helper functions for managing events -- not part of the public interface.
   * Props to Dean Edwards' addEvent library for many of the ideas.
   */


  jQuery.event = {
    global: {},
    add: function add(elem, types, handler, data, selector) {
      var handleObjIn,
          eventHandle,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.get(elem); // Only attach events to objects that accept data

      if (!acceptData(elem)) {
        return;
      } // Caller can pass in an object of custom data in lieu of the handler


      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      } // Ensure that invalid selectors throw exceptions at attach time
      // Evaluate against documentElement in case elem is a non-element node (e.g., document)


      if (selector) {
        jQuery.find.matchesSelector(documentElement, selector);
      } // Make sure that the handler has a unique ID, used to find/remove it later


      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      } // Init the element's event structure and main handler, if this is the first


      if (!(events = elemData.events)) {
        events = elemData.events = Object.create(null);
      }

      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function (e) {
          // Discard the second event of a jQuery.event.trigger() and
          // when an event is called after a page has unloaded
          return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      } // Handle multiple events separated by a space


      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;

      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort(); // There *must* be a type, no attaching namespace-only handlers

        if (!type) {
          continue;
        } // If event changes its type, use the special event handlers for the changed type


        special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type

        type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type

        special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers

        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn); // Init the event handler queue if we're the first

        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false

          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle);
            }
          }
        }

        if (special.add) {
          special.add.call(elem, handleObj);

          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        } // Add to the element's handler list, delegates in front


        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        } // Keep track of which events have ever been used, for event optimization


        jQuery.event.global[type] = true;
      }
    },
    // Detach an event or set of events from an element
    remove: function remove(elem, types, handler, selector, mappedTypes) {
      var j,
          origCount,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

      if (!elemData || !(events = elemData.events)) {
        return;
      } // Once for each type.namespace in types; type may be omitted


      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;

      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort(); // Unbind all events (on this namespace, if provided) for the element

        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }

          continue;
        }

        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"); // Remove matching events

        origCount = j = handlers.length;

        while (j--) {
          handleObj = handlers[j];

          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);

            if (handleObj.selector) {
              handlers.delegateCount--;
            }

            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        } // Remove generic event handler if we removed something and no more handlers exist
        // (avoids potential for endless recursion during removal of special event handlers)


        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }

          delete events[type];
        }
      } // Remove data and the expando if it's no longer used


      if (jQuery.isEmptyObject(events)) {
        dataPriv.remove(elem, "handle events");
      }
    },
    dispatch: function dispatch(nativeEvent) {
      var i,
          j,
          ret,
          matched,
          handleObj,
          handlerQueue,
          args = new Array(arguments.length),
          // Make a writable jQuery.Event from the native event object
      event = jQuery.event.fix(nativeEvent),
          handlers = (dataPriv.get(this, "events") || Object.create(null))[event.type] || [],
          special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event

      args[0] = event;

      for (i = 1; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired

      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      } // Determine handlers


      handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us

      i = 0;

      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;

        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          // If the event is namespaced, then each handler is only invoked if it is
          // specially universal or its namespaces are a superset of the event's.
          if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      } // Call the postDispatch hook for the mapped type


      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }

      return event.result;
    },
    handlers: function handlers(event, _handlers) {
      var i,
          handleObj,
          sel,
          matchedHandlers,
          matchedSelectors,
          handlerQueue = [],
          delegateCount = _handlers.delegateCount,
          cur = event.target; // Find delegate handlers

      if (delegateCount && // Support: IE <=9
      // Black-hole SVG <use> instance trees (trac-13180)
      cur.nodeType && // Support: Firefox <=42
      // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
      // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
      // Support: IE 11 only
      // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
      !(event.type === "click" && event.button >= 1)) {
        for (; cur !== this; cur = cur.parentNode || this) {
          // Don't check non-elements (trac-13208)
          // Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
          if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
            matchedHandlers = [];
            matchedSelectors = {};

            for (i = 0; i < delegateCount; i++) {
              handleObj = _handlers[i]; // Don't conflict with Object.prototype properties (trac-13203)

              sel = handleObj.selector + " ";

              if (matchedSelectors[sel] === undefined) {
                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
              }

              if (matchedSelectors[sel]) {
                matchedHandlers.push(handleObj);
              }
            }

            if (matchedHandlers.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matchedHandlers
              });
            }
          }
        }
      } // Add the remaining (directly-bound) handlers


      cur = this;

      if (delegateCount < _handlers.length) {
        handlerQueue.push({
          elem: cur,
          handlers: _handlers.slice(delegateCount)
        });
      }

      return handlerQueue;
    },
    addProp: function addProp(name, hook) {
      Object.defineProperty(jQuery.Event.prototype, name, {
        enumerable: true,
        configurable: true,
        get: isFunction(hook) ? function () {
          if (this.originalEvent) {
            return hook(this.originalEvent);
          }
        } : function () {
          if (this.originalEvent) {
            return this.originalEvent[name];
          }
        },
        set: function set(value) {
          Object.defineProperty(this, name, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
          });
        }
      });
    },
    fix: function fix(originalEvent) {
      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
    },
    special: {
      load: {
        // Prevent triggered image.load events from bubbling to window.load
        noBubble: true
      },
      click: {
        // Utilize native event to ensure correct state for checkable inputs
        setup: function setup(data) {
          // For mutual compressibility with _default, replace `this` access with a local var.
          // `|| data` is dead code meant only to preserve the variable through minification.
          var el = this || data; // Claim the first handler

          if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
            // dataPriv.set( el, "click", ... )
            leverageNative(el, "click", returnTrue);
          } // Return false to allow normal processing in the caller


          return false;
        },
        trigger: function trigger(data) {
          // For mutual compressibility with _default, replace `this` access with a local var.
          // `|| data` is dead code meant only to preserve the variable through minification.
          var el = this || data; // Force setup before triggering a click

          if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
            leverageNative(el, "click");
          } // Return non-false to allow normal event-path propagation


          return true;
        },
        // For cross-browser consistency, suppress native .click() on links
        // Also prevent it if we're currently inside a leveraged native-event stack
        _default: function _default(event) {
          var target = event.target;
          return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
        }
      },
      beforeunload: {
        postDispatch: function postDispatch(event) {
          // Support: Firefox 20+
          // Firefox doesn't alert if the returnValue field is not set.
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    }
  }; // Ensure the presence of an event listener that handles manually-triggered
  // synthetic events by interrupting progress until reinvoked in response to
  // *native* events that it fires directly, ensuring that state changes have
  // already occurred before other listeners are invoked.

  function leverageNative(el, type, expectSync) {
    // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
    if (!expectSync) {
      if (dataPriv.get(el, type) === undefined) {
        jQuery.event.add(el, type, returnTrue);
      }

      return;
    } // Register the controller as a special universal handler for all event namespaces


    dataPriv.set(el, type, false);
    jQuery.event.add(el, type, {
      namespace: false,
      handler: function handler(event) {
        var notAsync,
            result,
            saved = dataPriv.get(this, type);

        if (event.isTrigger & 1 && this[type]) {
          // Interrupt processing of the outer synthetic .trigger()ed event
          // Saved data should be false in such cases, but might be a leftover capture object
          // from an async native handler (gh-4350)
          if (!saved.length) {
            // Store arguments for use when handling the inner native event
            // There will always be at least one argument (an event object), so this array
            // will not be confused with a leftover capture object.
            saved = _slice.call(arguments);
            dataPriv.set(this, type, saved); // Trigger the native event and capture its result
            // Support: IE <=9 - 11+
            // focus() and blur() are asynchronous

            notAsync = expectSync(this, type);
            this[type]();
            result = dataPriv.get(this, type);

            if (saved !== result || notAsync) {
              dataPriv.set(this, type, false);
            } else {
              result = {};
            }

            if (saved !== result) {
              // Cancel the outer synthetic event
              event.stopImmediatePropagation();
              event.preventDefault(); // Support: Chrome 86+
              // In Chrome, if an element having a focusout handler is blurred by
              // clicking outside of it, it invokes the handler synchronously. If
              // that handler calls `.remove()` on the element, the data is cleared,
              // leaving `result` undefined. We need to guard against this.

              return result && result.value;
            } // If this is an inner synthetic event for an event with a bubbling surrogate
            // (focus or blur), assume that the surrogate already propagated from triggering the
            // native event and prevent that from happening again here.
            // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
            // bubbling surrogate propagates *after* the non-bubbling base), but that seems
            // less bad than duplication.

          } else if ((jQuery.event.special[type] || {}).delegateType) {
            event.stopPropagation();
          } // If this is a native event triggered above, everything is now in order
          // Fire an inner synthetic event with the original arguments

        } else if (saved.length) {
          // ...and capture the result
          dataPriv.set(this, type, {
            value: jQuery.event.trigger( // Support: IE <=9 - 11+
            // Extend with the prototype to reset the above stopImmediatePropagation()
            jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)
          }); // Abort handling of the native event

          event.stopImmediatePropagation();
        }
      }
    });
  }

  jQuery.removeEvent = function (elem, type, handle) {
    // This "if" is needed for plain objects
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle);
    }
  };

  jQuery.Event = function (src, props) {
    // Allow instantiation without the 'new' keyword
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    } // Event object


    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type; // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.

      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only
      src.returnValue === false ? returnTrue : returnFalse; // Create target properties
      // Support: Safari <=6 - 7 only
      // Target should not be a text node (trac-504, trac-13143)

      this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
      this.currentTarget = src.currentTarget;
      this.relatedTarget = src.relatedTarget; // Event type
    } else {
      this.type = src;
    } // Put explicitly provided properties onto the event object


    if (props) {
      jQuery.extend(this, props);
    } // Create a timestamp if incoming event doesn't have one


    this.timeStamp = src && src.timeStamp || Date.now(); // Mark it as fixed

    this[jQuery.expando] = true;
  }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


  jQuery.Event.prototype = {
    constructor: jQuery.Event,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    isSimulated: false,
    preventDefault: function preventDefault() {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;

      if (e && !this.isSimulated) {
        e.preventDefault();
      }
    },
    stopPropagation: function stopPropagation() {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;

      if (e && !this.isSimulated) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function stopImmediatePropagation() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;

      if (e && !this.isSimulated) {
        e.stopImmediatePropagation();
      }

      this.stopPropagation();
    }
  }; // Includes all common event props including KeyEvent and MouseEvent specific props

  jQuery.each({
    altKey: true,
    bubbles: true,
    cancelable: true,
    changedTouches: true,
    ctrlKey: true,
    detail: true,
    eventPhase: true,
    metaKey: true,
    pageX: true,
    pageY: true,
    shiftKey: true,
    view: true,
    "char": true,
    code: true,
    charCode: true,
    key: true,
    keyCode: true,
    button: true,
    buttons: true,
    clientX: true,
    clientY: true,
    offsetX: true,
    offsetY: true,
    pointerId: true,
    pointerType: true,
    screenX: true,
    screenY: true,
    targetTouches: true,
    toElement: true,
    touches: true,
    which: true
  }, jQuery.event.addProp);
  jQuery.each({
    focus: "focusin",
    blur: "focusout"
  }, function (type, delegateType) {
    jQuery.event.special[type] = {
      // Utilize native event if possible so blur/focus sequence is correct
      setup: function setup() {
        // Claim the first handler
        // dataPriv.set( this, "focus", ... )
        // dataPriv.set( this, "blur", ... )
        leverageNative(this, type, expectSync); // Return false to allow normal processing in the caller

        return false;
      },
      trigger: function trigger() {
        // Force setup before trigger
        leverageNative(this, type); // Return non-false to allow normal event-path propagation

        return true;
      },
      // Suppress native focus or blur if we're currently inside
      // a leveraged native-event stack
      _default: function _default(event) {
        return dataPriv.get(event.target, type);
      },
      delegateType: delegateType
    };
  }); // Create mouseenter/leave events using mouseover/out and event-time checks
  // so that event delegation works in jQuery.
  // Do the same for pointerenter/pointerleave and pointerover/pointerout
  //
  // Support: Safari 7 only
  // Safari sends mouseenter too often; see:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
  // for the description of the bug (it existed in older Chrome versions as well).

  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function (orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function handle(event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.
        // NB: No relatedTarget if the mouse left/entered the browser window

        if (!related || related !== target && !jQuery.contains(target, related)) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }

        return ret;
      }
    };
  });
  jQuery.fn.extend({
    on: function on(types, selector, data, fn) {
      return _on(this, types, selector, data, fn);
    },
    one: function one(types, selector, data, fn) {
      return _on(this, types, selector, data, fn, 1);
    },
    off: function off(types, selector, fn) {
      var handleObj, type;

      if (types && types.preventDefault && types.handleObj) {
        // ( event )  dispatched jQuery.Event
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }

      if (_typeof(types) === "object") {
        // ( types-object [, selector] )
        for (type in types) {
          this.off(type, selector, types[type]);
        }

        return this;
      }

      if (selector === false || typeof selector === "function") {
        // ( types [, fn] )
        fn = selector;
        selector = undefined;
      }

      if (fn === false) {
        fn = returnFalse;
      }

      return this.each(function () {
        jQuery.event.remove(this, types, fn, selector);
      });
    }
  });
  var // Support: IE <=10 - 11, Edge 12 - 13 only
  // In IE/Edge using regex groups here causes severe slowdowns.
  // See https://connect.microsoft.com/IE/feedback/details/1736512/
  rnoInnerhtml = /<script|<style|<link/i,
      // checked="checked" or checked
  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g; // Prefer a tbody over its parent table for containing new rows

  function manipulationTarget(elem, content) {
    if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
      return jQuery(elem).children("tbody")[0] || elem;
    }

    return elem;
  } // Replace/restore the type attribute of script elements for safe DOM manipulation


  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }

  function restoreScript(elem) {
    if ((elem.type || "").slice(0, 5) === "true/") {
      elem.type = elem.type.slice(5);
    } else {
      elem.removeAttribute("type");
    }

    return elem;
  }

  function cloneCopyEvent(src, dest) {
    var i, l, type, pdataOld, udataOld, udataCur, events;

    if (dest.nodeType !== 1) {
      return;
    } // 1. Copy private data: events, handlers, etc.


    if (dataPriv.hasData(src)) {
      pdataOld = dataPriv.get(src);
      events = pdataOld.events;

      if (events) {
        dataPriv.remove(dest, "handle events");

        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    } // 2. Copy user data


    if (dataUser.hasData(src)) {
      udataOld = dataUser.access(src);
      udataCur = jQuery.extend({}, udataOld);
      dataUser.set(dest, udataCur);
    }
  } // Fix IE bugs, see support tests


  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.

    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }

  function domManip(collection, args, callback, ignored) {
    // Flatten any nested arrays
    args = flat(args);
    var fragment,
        first,
        scripts,
        hasScripts,
        node,
        doc,
        i = 0,
        l = collection.length,
        iNoClone = l - 1,
        value = args[0],
        valueIsFunction = isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit

    if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
      return collection.each(function (index) {
        var self = collection.eq(index);

        if (valueIsFunction) {
          args[0] = value.call(this, index, self.html());
        }

        domManip(self, args, callback, ignored);
      });
    }

    if (l) {
      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
      first = fragment.firstChild;

      if (fragment.childNodes.length === 1) {
        fragment = first;
      } // Require either new content or an interest in ignored elements to invoke the callback


      if (first || ignored) {
        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
        hasScripts = scripts.length; // Use the original fragment for the last item
        // instead of the first because it can end up
        // being emptied incorrectly in certain situations (trac-8070).

        for (; i < l; i++) {
          node = fragment;

          if (i !== iNoClone) {
            node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration

            if (hasScripts) {
              // Support: Android <=4.0 only, PhantomJS 1 only
              // push.apply(_, arraylike) throws on ancient WebKit
              jQuery.merge(scripts, getAll(node, "script"));
            }
          }

          callback.call(collection[i], node, i);
        }

        if (hasScripts) {
          doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts

          jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion

          for (i = 0; i < hasScripts; i++) {
            node = scripts[i];

            if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
              if (node.src && (node.type || "").toLowerCase() !== "module") {
                // Optional AJAX dependency, but won't run scripts if not present
                if (jQuery._evalUrl && !node.noModule) {
                  jQuery._evalUrl(node.src, {
                    nonce: node.nonce || node.getAttribute("nonce")
                  }, doc);
                }
              } else {
                // Unwrap a CDATA section containing script contents. This shouldn't be
                // needed as in XML documents they're already not visible when
                // inspecting element contents and in HTML documents they have no
                // meaning but we're preserving that logic for backwards compatibility.
                // This will be removed completely in 4.0. See gh-4904.
                DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
              }
            }
          }
        }
      }
    }

    return collection;
  }

  function _remove(elem, selector, keepData) {
    var node,
        nodes = selector ? jQuery.filter(selector, elem) : elem,
        i = 0;

    for (; (node = nodes[i]) != null; i++) {
      if (!keepData && node.nodeType === 1) {
        jQuery.cleanData(getAll(node));
      }

      if (node.parentNode) {
        if (keepData && isAttached(node)) {
          setGlobalEval(getAll(node, "script"));
        }

        node.parentNode.removeChild(node);
      }
    }

    return elem;
  }

  jQuery.extend({
    htmlPrefilter: function htmlPrefilter(html) {
      return html;
    },
    clone: function clone(elem, dataAndEvents, deepDataAndEvents) {
      var i,
          l,
          srcElements,
          destElements,
          clone = elem.cloneNode(true),
          inPage = isAttached(elem); // Fix IE cloning issues

      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
        destElements = getAll(clone);
        srcElements = getAll(elem);

        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      } // Copy the events from the original to the clone


      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);

          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      } // Preserve script evaluation history


      destElements = getAll(clone, "script");

      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      } // Return the cloned set


      return clone;
    },
    cleanData: function cleanData(elems) {
      var data,
          elem,
          type,
          special = jQuery.event.special,
          i = 0;

      for (; (elem = elems[i]) !== undefined; i++) {
        if (acceptData(elem)) {
          if (data = elem[dataPriv.expando]) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            } // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove


            elem[dataPriv.expando] = undefined;
          }

          if (elem[dataUser.expando]) {
            // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove
            elem[dataUser.expando] = undefined;
          }
        }
      }
    }
  });
  jQuery.fn.extend({
    detach: function detach(selector) {
      return _remove(this, selector, true);
    },
    remove: function remove(selector) {
      return _remove(this, selector);
    },
    text: function text(value) {
      return access(this, function (value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function () {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function append() {
      return domManip(this, arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function prepend() {
      return domManip(this, arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function before() {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function after() {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    empty: function empty() {
      var elem,
          i = 0;

      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          // Prevent memory leaks
          jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes

          elem.textContent = "";
        }
      }

      return this;
    },
    clone: function clone(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function () {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function html(value) {
      return access(this, function (value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;

        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        } // See if we can take a shortcut and just use innerHTML


        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = jQuery.htmlPrefilter(value);

          try {
            for (; i < l; i++) {
              elem = this[i] || {}; // Remove element nodes and prevent memory leaks

              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }

            elem = 0; // If using innerHTML throws an exception, use the fallback method
          } catch (e) {}
        }

        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function replaceWith() {
      var ignored = []; // Make the changes, replacing each non-ignored context element with the new content

      return domManip(this, arguments, function (elem) {
        var parent = this.parentNode;

        if (jQuery.inArray(this, ignored) < 0) {
          jQuery.cleanData(getAll(this));

          if (parent) {
            parent.replaceChild(elem, this);
          }
        } // Force callback invocation

      }, ignored);
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function (name, original) {
    jQuery.fn[name] = function (selector) {
      var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;

      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems); // Support: Android <=4.0 only, PhantomJS 1 only
        // .get() because push.apply(_, arraylike) throws on ancient WebKit

        push.apply(ret, elems.get());
      }

      return this.pushStack(ret);
    };
  });
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
  var rcustomProp = /^--/;

  var getStyles = function getStyles(elem) {
    // Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
    // IE throws on elements created in popups
    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
    var view = elem.ownerDocument.defaultView;

    if (!view || !view.opener) {
      view = window;
    }

    return view.getComputedStyle(elem);
  };

  var swap = function swap(elem, options, callback) {
    var ret,
        name,
        old = {}; // Remember the old values, and insert the new ones

    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }

    ret = callback.call(elem); // Revert the old values

    for (name in options) {
      elem.style[name] = old[name];
    }

    return ret;
  };

  var rboxStyle = new RegExp(cssExpand.join("|"), "i");
  var whitespace = "[\\x20\\t\\r\\n\\f]";
  var rtrimCSS = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g");

  (function () {
    // Executing both pixelPosition & boxSizingReliable tests require only one layout
    // so they're executed at the same time to save the second computation.
    function computeStyleTests() {
      // This is a singleton, we need to execute it only once
      if (!div) {
        return;
      }

      container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
      div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
      documentElement.appendChild(container).appendChild(div);
      var divStyle = window.getComputedStyle(div);
      pixelPositionVal = divStyle.top !== "1%"; // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44

      reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12; // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
      // Some styles come back with percentage values, even though they shouldn't

      div.style.right = "60%";
      pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36; // Support: IE 9 - 11 only
      // Detect misreporting of content dimensions for box-sizing:border-box elements

      boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36; // Support: IE 9 only
      // Detect overflow:scroll screwiness (gh-3699)
      // Support: Chrome <=64
      // Don't get tricked when zoom affects offsetWidth (gh-4029)

      div.style.position = "absolute";
      scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
      documentElement.removeChild(container); // Nullify the div so it wouldn't be stored in the memory and
      // it will also be a sign that checks already performed

      div = null;
    }

    function roundPixelMeasures(measure) {
      return Math.round(parseFloat(measure));
    }

    var pixelPositionVal,
        boxSizingReliableVal,
        scrollboxSizeVal,
        pixelBoxStylesVal,
        reliableTrDimensionsVal,
        reliableMarginLeftVal,
        container = document.createElement("div"),
        div = document.createElement("div"); // Finish early in limited (non-browser) environments

    if (!div.style) {
      return;
    } // Support: IE <=9 - 11 only
    // Style of cloned element affects source element cloned (trac-8908)


    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    jQuery.extend(support, {
      boxSizingReliable: function boxSizingReliable() {
        computeStyleTests();
        return boxSizingReliableVal;
      },
      pixelBoxStyles: function pixelBoxStyles() {
        computeStyleTests();
        return pixelBoxStylesVal;
      },
      pixelPosition: function pixelPosition() {
        computeStyleTests();
        return pixelPositionVal;
      },
      reliableMarginLeft: function reliableMarginLeft() {
        computeStyleTests();
        return reliableMarginLeftVal;
      },
      scrollboxSize: function scrollboxSize() {
        computeStyleTests();
        return scrollboxSizeVal;
      },
      // Support: IE 9 - 11+, Edge 15 - 18+
      // IE/Edge misreport `getComputedStyle` of table rows with width/height
      // set in CSS while `offset*` properties report correct values.
      // Behavior in IE 9 is more subtle than in newer versions & it passes
      // some versions of this test; make sure not to make it pass there!
      //
      // Support: Firefox 70+
      // Only Firefox includes border widths
      // in computed dimensions. (gh-4529)
      reliableTrDimensions: function reliableTrDimensions() {
        var table, tr, trChild, trStyle;

        if (reliableTrDimensionsVal == null) {
          table = document.createElement("table");
          tr = document.createElement("tr");
          trChild = document.createElement("div");
          table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
          tr.style.cssText = "border:1px solid"; // Support: Chrome 86+
          // Height set through cssText does not get applied.
          // Computed height then comes back as 0.

          tr.style.height = "1px";
          trChild.style.height = "9px"; // Support: Android 8 Chrome 86+
          // In our bodyBackground.html iframe,
          // display for all div elements is set to "inline",
          // which causes a problem only in Android 8 Chrome 86.
          // Ensuring the div is display: block
          // gets around this issue.

          trChild.style.display = "block";
          documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
          trStyle = window.getComputedStyle(tr);
          reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
          documentElement.removeChild(table);
        }

        return reliableTrDimensionsVal;
      }
    });
  })();

  function curCSS(elem, name, computed) {
    var width,
        minWidth,
        maxWidth,
        ret,
        isCustomProp = rcustomProp.test(name),
        // Support: Firefox 51+
    // Retrieving style before computed somehow
    // fixes an issue with getting wrong values
    // on detached elements
    style = elem.style;
    computed = computed || getStyles(elem); // getPropertyValue is needed for:
    //   .css('filter') (IE 9 only, trac-12537)
    //   .css('--customProperty) (gh-3144)

    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name]; // trim whitespace for custom property (issue gh-4926)

      if (isCustomProp) {
        // rtrim treats U+000D CARRIAGE RETURN and U+000C FORM FEED
        // as whitespace while CSS does not, but this is not a problem
        // because CSS preprocessing replaces them with U+000A LINE FEED
        // (which *is* CSS whitespace)
        // https://www.w3.org/TR/css-syntax-3/#input-preprocessing
        ret = ret.replace(rtrimCSS, "$1");
      }

      if (ret === "" && !isAttached(elem)) {
        ret = jQuery.style(elem, name);
      } // A tribute to the "awesome hack by Dean Edwards"
      // Android Browser returns percentage for some values,
      // but width seems to be reliably pixels.
      // This is against the CSSOM draft spec:
      // https://drafts.csswg.org/cssom/#resolved-values


      if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
        // Remember the original values
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth; // Put in the new values to get a computed value out

        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width; // Revert the changed values

        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }

    return ret !== undefined ? // Support: IE <=9 - 11 only
    // IE returns zIndex value as an integer.
    ret + "" : ret;
  }

  function addGetHookIf(conditionFn, hookFn) {
    // Define the hook, we'll check on the first run if it's really needed.
    return {
      get: function get() {
        if (conditionFn()) {
          // Hook not needed (or it's not possible to use it due
          // to missing dependency), remove it.
          delete this.get;
          return;
        } // Hook needed; redefine it so that the support test is not executed again.


        return (this.get = hookFn).apply(this, arguments);
      }
    };
  }

  var cssPrefixes = ["Webkit", "Moz", "ms"],
      emptyStyle = document.createElement("div").style,
      vendorProps = {}; // Return a vendor-prefixed property or undefined

  function vendorPropName(name) {
    // Check for vendor prefixed names
    var capName = name[0].toUpperCase() + name.slice(1),
        i = cssPrefixes.length;

    while (i--) {
      name = cssPrefixes[i] + capName;

      if (name in emptyStyle) {
        return name;
      }
    }
  } // Return a potentially-mapped jQuery.cssProps or vendor prefixed property


  function finalPropName(name) {
    var _final = jQuery.cssProps[name] || vendorProps[name];

    if (_final) {
      return _final;
    }

    if (name in emptyStyle) {
      return name;
    }

    return vendorProps[name] = vendorPropName(name) || name;
  }

  var // Swappable if display is none or starts with table
  // except "table", "table-cell", or "table-caption"
  // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      cssShow = {
    position: "absolute",
    visibility: "hidden",
    display: "block"
  },
      cssNormalTransform = {
    letterSpacing: "0",
    fontWeight: "400"
  };

  function setPositiveNumber(_elem, value, subtract) {
    // Any relative (+/-) values have already been
    // normalized at this point
    var matches = rcssNum.exec(value);
    return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
  }

  function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
    var i = dimension === "width" ? 1 : 0,
        extra = 0,
        delta = 0; // Adjustment may not be necessary

    if (box === (isBorderBox ? "border" : "content")) {
      return 0;
    }

    for (; i < 4; i += 2) {
      // Both box models exclude margin
      if (box === "margin") {
        delta += jQuery.css(elem, box + cssExpand[i], true, styles);
      } // If we get here with a content-box, we're seeking "padding" or "border" or "margin"


      if (!isBorderBox) {
        // Add padding
        delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles); // For "border" or "margin", add border

        if (box !== "padding") {
          delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles); // But still keep track of it otherwise
        } else {
          extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        } // If we get here with a border-box (content + padding + border), we're seeking "content" or
        // "padding" or "margin"

      } else {
        // For "content", subtract padding
        if (box === "content") {
          delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        } // For "content" or "padding", subtract border


        if (box !== "margin") {
          delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    } // Account for positive content-box scroll gutter when requested by providing computedVal


    if (!isBorderBox && computedVal >= 0) {
      // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
      // Assuming integer scroll gutter, subtract the rest and round down
      delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5 // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
      // Use an explicit zero to avoid NaN (gh-3964)
      )) || 0;
    }

    return delta;
  }

  function getWidthOrHeight(elem, dimension, extra) {
    // Start with computed style
    var styles = getStyles(elem),
        // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
    // Fake content-box until we know it's needed to know the true value.
    boxSizingNeeded = !support.boxSizingReliable() || extra,
        isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
        valueIsBorderBox = isBorderBox,
        val = curCSS(elem, dimension, styles),
        offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1); // Support: Firefox <=54
    // Return a confounding non-pixel value or feign ignorance, as appropriate.

    if (rnumnonpx.test(val)) {
      if (!extra) {
        return val;
      }

      val = "auto";
    } // Support: IE 9 - 11 only
    // Use offsetWidth/offsetHeight for when box sizing is unreliable.
    // In those cases, the computed value can be trusted to be border-box.


    if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
    // IE/Edge misreport `getComputedStyle` of table rows with width/height
    // set in CSS while `offset*` properties report correct values.
    // Interestingly, in some cases IE 9 doesn't suffer from this issue.
    !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
    // This happens for inline elements with no explicit setting (gh-3571)
    val === "auto" || // Support: Android <=4.1 - 4.3 only
    // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
    !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
    elem.getClientRects().length) {
      isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box"; // Where available, offsetWidth/offsetHeight approximate border box dimensions.
      // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
      // retrieved value as a content box dimension.

      valueIsBorderBox = offsetProp in elem;

      if (valueIsBorderBox) {
        val = elem[offsetProp];
      }
    } // Normalize "" and auto


    val = parseFloat(val) || 0; // Adjust for the element's box model

    return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)
    val) + "px";
  }

  jQuery.extend({
    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
    cssHooks: {
      opacity: {
        get: function get(elem, computed) {
          if (computed) {
            // We should always get a number back from opacity
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }
      }
    },
    // Don't automatically add "px" to these possibly-unitless properties
    cssNumber: {
      "animationIterationCount": true,
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "gridArea": true,
      "gridColumn": true,
      "gridColumnEnd": true,
      "gridColumnStart": true,
      "gridRow": true,
      "gridRowEnd": true,
      "gridRowStart": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    // Add in properties whose names you wish to fix before
    // setting or getting the value
    cssProps: {},
    // Get and set the style property on a DOM Node
    style: function style(elem, name, value, extra) {
      // Don't set styles on text and comment nodes
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      } // Make sure that we're working with the right name


      var ret,
          type,
          hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name),
          style = elem.style; // Make sure that we're working with the right name. We don't
      // want to query the value if it is a CSS custom property
      // since they are user-defined.

      if (!isCustomProp) {
        name = finalPropName(origName);
      } // Gets hook for the prefixed version, then unprefixed version


      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value

      if (value !== undefined) {
        type = _typeof(value); // Convert "+=" or "-=" to relative numbers (trac-7345)

        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
          value = adjustCSS(elem, name, ret); // Fixes bug trac-9237

          type = "number";
        } // Make sure that null and NaN values aren't set (trac-7116)


        if (value == null || value !== value) {
          return;
        } // If a number was passed in, add the unit (except for certain CSS properties)
        // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
        // "px" to a few hardcoded values.


        if (type === "number" && !isCustomProp) {
          value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
        } // background-* props affect original clone's values


        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        } // If a hook was provided, use that value, otherwise just set the specified value


        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          if (isCustomProp) {
            style.setProperty(name, value);
          } else {
            style[name] = value;
          }
        }
      } else {
        // If a hook was provided get the non-computed value from there
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        } // Otherwise just get the value from the style object


        return style[name];
      }
    },
    css: function css(elem, name, extra, styles) {
      var val,
          num,
          hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name); // Make sure that we're working with the right name. We don't
      // want to modify the value if it is a CSS custom property
      // since they are user-defined.

      if (!isCustomProp) {
        name = finalPropName(origName);
      } // Try prefixed name followed by the unprefixed name


      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there

      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      } // Otherwise, if a way to get the computed value exists, use that


      if (val === undefined) {
        val = curCSS(elem, name, styles);
      } // Convert "normal" to computed value


      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      } // Make numeric if forced or a qualifier was provided and val looks numeric


      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || isFinite(num) ? num || 0 : val;
      }

      return val;
    }
  });
  jQuery.each(["height", "width"], function (_i, dimension) {
    jQuery.cssHooks[dimension] = {
      get: function get(elem, computed, extra) {
        if (computed) {
          // Certain elements can have dimension info if we invisibly show them
          // but it must have a current display style that would benefit
          return rdisplayswap.test(jQuery.css(elem, "display")) && ( // Support: Safari 8+
          // Table columns in Safari have non-zero offsetWidth & zero
          // getBoundingClientRect().width unless display is changed.
          // Support: IE <=11 only
          // Running getBoundingClientRect on a disconnected node
          // in IE throws an error.
          !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
            return getWidthOrHeight(elem, dimension, extra);
          }) : getWidthOrHeight(elem, dimension, extra);
        }
      },
      set: function set(elem, value, extra) {
        var matches,
            styles = getStyles(elem),
            // Only read styles.position if the test has a chance to fail
        // to avoid forcing a reflow.
        scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute",
            // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
        boxSizingNeeded = scrollboxSizeBuggy || extra,
            isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
            subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0; // Account for unreliable border-box dimensions by comparing offset* to computed and
        // faking a content-box to get border and padding (gh-3699)

        if (isBorderBox && scrollboxSizeBuggy) {
          subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
        } // Convert to pixels if value adjustment is needed


        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
          elem.style[dimension] = value;
          value = jQuery.css(elem, dimension);
        }

        return setPositiveNumber(elem, value, subtract);
      }
    };
  });
  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
    if (computed) {
      return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
        marginLeft: 0
      }, function () {
        return elem.getBoundingClientRect().left;
      })) + "px";
    }
  }); // These hooks are used by animate to expand properties

  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function (prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {
      expand: function expand(value) {
        var i = 0,
            expanded = {},
            // Assumes a single number if not a string
        parts = typeof value === "string" ? value.split(" ") : [value];

        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }

        return expanded;
      }
    };

    if (prefix !== "margin") {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({
    css: function css(name, value) {
      return access(this, function (elem, name, value) {
        var styles,
            len,
            map = {},
            i = 0;

        if (Array.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;

          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }

          return map;
        }

        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    }
  });

  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }

  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function init(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || jQuery.easing._default;
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function cur() {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function run(percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];

      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }

      this.now = (this.end - this.start) * eased + this.start;

      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }

      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }

      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function get(tween) {
        var result; // Use a property on the element directly when it is not a DOM element,
        // or when there is no matching style property that exists.

        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
          return tween.elem[tween.prop];
        } // Passing an empty string as a 3rd parameter to .css will automatically
        // attempt a parseFloat and fallback to a string if the parse fails.
        // Simple values such as "10px" are parsed to Float;
        // complex values such as "rotate(1rad)" are returned as-is.


        result = jQuery.css(tween.elem, tween.prop, ""); // Empty strings, null, undefined and "auto" are converted to 0.

        return !result || result === "auto" ? 0 : result;
      },
      set: function set(tween) {
        // Use step hook for back compat.
        // Use cssHook if its there.
        // Use .style if available and use plain properties where available.
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  }; // Support: IE <=9 only
  // Panic based approach to setting things on disconnected nodes

  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function set(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };
  jQuery.easing = {
    linear: function linear(p) {
      return p;
    },
    swing: function swing(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    },
    _default: "swing"
  };
  jQuery.fx = Tween.prototype.init; // Back compat <1.8 extension point

  jQuery.fx.step = {};
  var fxNow,
      inProgress,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rrun = /queueHooks$/;

  function schedule() {
    if (inProgress) {
      if (document.hidden === false && window.requestAnimationFrame) {
        window.requestAnimationFrame(schedule);
      } else {
        window.setTimeout(schedule, jQuery.fx.interval);
      }

      jQuery.fx.tick();
    }
  } // Animations created synchronously will run synchronously


  function createFxNow() {
    window.setTimeout(function () {
      fxNow = undefined;
    });
    return fxNow = Date.now();
  } // Generate parameters to create a standard animation


  function genFx(type, includeWidth) {
    var which,
        i = 0,
        attrs = {
      height: type
    }; // If we include width, step value is 1 to do all cssExpand values,
    // otherwise step value is 2 to skip over Left and Right

    includeWidth = includeWidth ? 1 : 0;

    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }

    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }

    return attrs;
  }

  function createTween(value, prop, animation) {
    var tween,
        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
        index = 0,
        length = collection.length;

    for (; index < length; index++) {
      if (tween = collection[index].call(animation, prop, value)) {
        // We're done with this property
        return tween;
      }
    }
  }

  function defaultPrefilter(elem, props, opts) {
    var prop,
        value,
        toggle,
        hooks,
        oldfire,
        propTween,
        restoreDisplay,
        display,
        isBox = "width" in props || "height" in props,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHiddenWithinTree(elem),
        dataShow = dataPriv.get(elem, "fxshow"); // Queue-skipping animations hijack the fx hooks

    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");

      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;

        hooks.empty.fire = function () {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }

      hooks.unqueued++;
      anim.always(function () {
        // Ensure the complete handler is called before this completes
        anim.always(function () {
          hooks.unqueued--;

          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    } // Detect show/hide animations


    for (prop in props) {
      value = props[prop];

      if (rfxtypes.test(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";

        if (value === (hidden ? "hide" : "show")) {
          // Pretend to be hidden if this is a "show" and
          // there is still data from a stopped show/hide
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true; // Ignore all other no-op show/hide data
          } else {
            continue;
          }
        }

        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      }
    } // Bail out if this is a no-op like .hide().hide()


    propTween = !jQuery.isEmptyObject(props);

    if (!propTween && jQuery.isEmptyObject(orig)) {
      return;
    } // Restrict "overflow" and "display" styles during box animations


    if (isBox && elem.nodeType === 1) {
      // Support: IE <=9 - 11, Edge 12 - 15
      // Record all 3 overflow attributes because IE does not infer the shorthand
      // from identically-valued overflowX and overflowY and Edge just mirrors
      // the overflowX value there.
      opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Identify a display type, preferring old show/hide data over the CSS cascade

      restoreDisplay = dataShow && dataShow.display;

      if (restoreDisplay == null) {
        restoreDisplay = dataPriv.get(elem, "display");
      }

      display = jQuery.css(elem, "display");

      if (display === "none") {
        if (restoreDisplay) {
          display = restoreDisplay;
        } else {
          // Get nonempty value(s) by temporarily forcing visibility
          showHide([elem], true);
          restoreDisplay = elem.style.display || restoreDisplay;
          display = jQuery.css(elem, "display");
          showHide([elem]);
        }
      } // Animate inline elements as inline-block


      if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
        if (jQuery.css(elem, "float") === "none") {
          // Restore the original display value at the end of pure show/hide animations
          if (!propTween) {
            anim.done(function () {
              style.display = restoreDisplay;
            });

            if (restoreDisplay == null) {
              display = style.display;
              restoreDisplay = display === "none" ? "" : display;
            }
          }

          style.display = "inline-block";
        }
      }
    }

    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function () {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    } // Implement show/hide animations


    propTween = false;

    for (prop in orig) {
      // General show/hide setup for this element animation
      if (!propTween) {
        if (dataShow) {
          if ("hidden" in dataShow) {
            hidden = dataShow.hidden;
          }
        } else {
          dataShow = dataPriv.access(elem, "fxshow", {
            display: restoreDisplay
          });
        } // Store hidden/visible for toggle so `.stop().toggle()` "reverses"


        if (toggle) {
          dataShow.hidden = !hidden;
        } // Show elements before animating them


        if (hidden) {
          showHide([elem], true);
        }
        /* eslint-disable no-loop-func */


        anim.done(function () {
          /* eslint-enable no-loop-func */
          // The final step of a "hide" animation is actually hiding the element
          if (!hidden) {
            showHide([elem]);
          }

          dataPriv.remove(elem, "fxshow");

          for (prop in orig) {
            jQuery.style(elem, prop, orig[prop]);
          }
        });
      } // Per-property setup


      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

      if (!(prop in dataShow)) {
        dataShow[prop] = propTween.start;

        if (hidden) {
          propTween.end = propTween.start;
          propTween.start = 0;
        }
      }
    }
  }

  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass

    for (index in props) {
      name = camelCase(index);
      easing = specialEasing[name];
      value = props[index];

      if (Array.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }

      if (index !== name) {
        props[name] = value;
        delete props[index];
      }

      hooks = jQuery.cssHooks[name];

      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name]; // Not quite $.extend, this won't overwrite existing keys.
        // Reusing 'index' because we have the correct "name"

        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }

  function Animation(elem, properties, options) {
    var result,
        stopped,
        index = 0,
        length = Animation.prefilters.length,
        deferred = jQuery.Deferred().always(function () {
      // Don't match elem in the :animated selector
      delete tick.elem;
    }),
        tick = function tick() {
      if (stopped) {
        return false;
      }

      var currentTime = fxNow || createFxNow(),
          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
          // Support: Android 2.3 only
      // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
      temp = remaining / animation.duration || 0,
          percent = 1 - temp,
          index = 0,
          length = animation.tweens.length;

      for (; index < length; index++) {
        animation.tweens[index].run(percent);
      }

      deferred.notifyWith(elem, [animation, percent, remaining]); // If there's more to do, yield

      if (percent < 1 && length) {
        return remaining;
      } // If this was an empty animation, synthesize a final progress notification


      if (!length) {
        deferred.notifyWith(elem, [animation, 1, 0]);
      } // Resolve the animation and report its conclusion


      deferred.resolveWith(elem, [animation]);
      return false;
    },
        animation = deferred.promise({
      elem: elem,
      props: jQuery.extend({}, properties),
      opts: jQuery.extend(true, {
        specialEasing: {},
        easing: jQuery.easing._default
      }, options),
      originalProperties: properties,
      originalOptions: options,
      startTime: fxNow || createFxNow(),
      duration: options.duration,
      tweens: [],
      createTween: function createTween(prop, end) {
        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
        animation.tweens.push(tween);
        return tween;
      },
      stop: function stop(gotoEnd) {
        var index = 0,
            // If we are going to the end, we want to run all the tweens
        // otherwise we skip this part
        length = gotoEnd ? animation.tweens.length : 0;

        if (stopped) {
          return this;
        }

        stopped = true;

        for (; index < length; index++) {
          animation.tweens[index].run(1);
        } // Resolve when we played the last frame; otherwise, reject


        if (gotoEnd) {
          deferred.notifyWith(elem, [animation, 1, 0]);
          deferred.resolveWith(elem, [animation, gotoEnd]);
        } else {
          deferred.rejectWith(elem, [animation, gotoEnd]);
        }

        return this;
      }
    }),
        props = animation.props;

    propFilter(props, animation.opts.specialEasing);

    for (; index < length; index++) {
      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);

      if (result) {
        if (isFunction(result.stop)) {
          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
        }

        return result;
      }
    }

    jQuery.map(props, createTween, animation);

    if (isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    } // Attach callbacks from options


    animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation;
  }

  jQuery.Animation = jQuery.extend(Animation, {
    tweeners: {
      "*": [function (prop, value) {
        var tween = this.createTween(prop, value);
        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
        return tween;
      }]
    },
    tweener: function tweener(props, callback) {
      if (isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.match(rnothtmlwhite);
      }

      var prop,
          index = 0,
          length = props.length;

      for (; index < length; index++) {
        prop = props[index];
        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
        Animation.tweeners[prop].unshift(callback);
      }
    },
    prefilters: [defaultPrefilter],
    prefilter: function prefilter(callback, prepend) {
      if (prepend) {
        Animation.prefilters.unshift(callback);
      } else {
        Animation.prefilters.push(callback);
      }
    }
  });

  jQuery.speed = function (speed, easing, fn) {
    var opt = speed && _typeof(speed) === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !isFunction(easing) && easing
    }; // Go to the end state if fx are off

    if (jQuery.fx.off) {
      opt.duration = 0;
    } else {
      if (typeof opt.duration !== "number") {
        if (opt.duration in jQuery.fx.speeds) {
          opt.duration = jQuery.fx.speeds[opt.duration];
        } else {
          opt.duration = jQuery.fx.speeds._default;
        }
      }
    } // Normalize opt.queue - true/undefined/null -> "fx"


    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    } // Queueing


    opt.old = opt.complete;

    opt.complete = function () {
      if (isFunction(opt.old)) {
        opt.old.call(this);
      }

      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };

    return opt;
  };

  jQuery.fn.extend({
    fadeTo: function fadeTo(speed, to, easing, callback) {
      // Show any hidden elements after setting opacity to 0
      return this.filter(isHiddenWithinTree).css("opacity", 0).show() // Animate to the value specified
      .end().animate({
        opacity: to
      }, speed, easing, callback);
    },
    animate: function animate(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function doAnimation() {
        // Operate on a copy of prop so per-property easing won't be lost
        var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately

        if (empty || dataPriv.get(this, "finish")) {
          anim.stop(true);
        }
      };

      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function stop(type, clearQueue, gotoEnd) {
      var stopQueue = function stopQueue(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };

      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }

      if (clearQueue) {
        this.queue(type || "fx", []);
      }

      return this.each(function () {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = dataPriv.get(this);

        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }

        for (index = timers.length; index--;) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        } // Start the next in the queue if the last step wasn't forced.
        // Timers currently will call their complete callbacks, which
        // will dequeue but only if they were gotoEnd.


        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function finish(type) {
      if (type !== false) {
        type = type || "fx";
      }

      return this.each(function () {
        var index,
            data = dataPriv.get(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0; // Enable finishing flag on private data

        data.finish = true; // Empty the queue first

        jQuery.queue(this, type, []);

        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        } // Look for any active animations, and finish them


        for (index = timers.length; index--;) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        } // Look for any animations in the old queue and finish them


        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        } // Turn off finishing flag


        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function (_i, name) {
    var cssFn = jQuery.fn[name];

    jQuery.fn[name] = function (speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  }); // Generate shortcuts for custom animations

  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {
      opacity: "show"
    },
    fadeOut: {
      opacity: "hide"
    },
    fadeToggle: {
      opacity: "toggle"
    }
  }, function (name, props) {
    jQuery.fn[name] = function (speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];

  jQuery.fx.tick = function () {
    var timer,
        i = 0,
        timers = jQuery.timers;
    fxNow = Date.now();

    for (; i < timers.length; i++) {
      timer = timers[i]; // Run the timer and safely remove it when done (allowing for external removal)

      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }

    if (!timers.length) {
      jQuery.fx.stop();
    }

    fxNow = undefined;
  };

  jQuery.fx.timer = function (timer) {
    jQuery.timers.push(timer);
    jQuery.fx.start();
  };

  jQuery.fx.interval = 13;

  jQuery.fx.start = function () {
    if (inProgress) {
      return;
    }

    inProgress = true;
    schedule();
  };

  jQuery.fx.stop = function () {
    inProgress = null;
  };

  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    // Default speed
    _default: 400
  }; // Based off of the plugin by Clint Helfers, with permission.

  jQuery.fn.delay = function (time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function (next, hooks) {
      var timeout = window.setTimeout(next, time);

      hooks.stop = function () {
        window.clearTimeout(timeout);
      };
    });
  };

  (function () {
    var input = document.createElement("input"),
        select = document.createElement("select"),
        opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox"; // Support: Android <=4.3 only
    // Default value for a checkbox should be "on"

    support.checkOn = input.value !== ""; // Support: IE <=11 only
    // Must access selectedIndex to make default options select

    support.optSelected = opt.selected; // Support: IE <=11 only
    // An input loses its value after becoming a radio

    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();

  var boolHook,
      attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function attr(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function removeAttr(name) {
      return this.each(function () {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function attr(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes

      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      } // Fallback to prop when attributes are not supported


      if (typeof elem.getAttribute === "undefined") {
        return jQuery.prop(elem, name, value);
      } // Attribute hooks are determined by the lowercase version
      // Grab necessary hook if one is defined


      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
      }

      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
          return;
        }

        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }

        elem.setAttribute(name, value + "");
        return value;
      }

      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }

      ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined

      return ret == null ? undefined : ret;
    },
    attrHooks: {
      type: {
        set: function set(elem, value) {
          if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);

            if (val) {
              elem.value = val;
            }

            return value;
          }
        }
      }
    },
    removeAttr: function removeAttr(elem, value) {
      var name,
          i = 0,
          // Attribute names can contain non-HTML whitespace characters
      // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
      attrNames = value && value.match(rnothtmlwhite);

      if (attrNames && elem.nodeType === 1) {
        while (name = attrNames[i++]) {
          elem.removeAttribute(name);
        }
      }
    }
  }); // Hooks for boolean attributes

  boolHook = {
    set: function set(elem, value, name) {
      if (value === false) {
        // Remove boolean attributes when set to false
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }

      return name;
    }
  };
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (_i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;

    attrHandle[name] = function (elem, name, isXML) {
      var ret,
          handle,
          lowercaseName = name.toLowerCase();

      if (!isXML) {
        // Avoid an infinite loop by temporarily removing this function from the getter
        handle = attrHandle[lowercaseName];
        attrHandle[lowercaseName] = ret;
        ret = getter(elem, name, isXML) != null ? lowercaseName : null;
        attrHandle[lowercaseName] = handle;
      }

      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i,
      rclickable = /^(?:a|area)$/i;
  jQuery.fn.extend({
    prop: function prop(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function removeProp(name) {
      return this.each(function () {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    prop: function prop(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes

      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }

      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        // Fix name and attach hooks
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }

      if (value !== undefined) {
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }

        return elem[name] = value;
      }

      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }

      return elem[name];
    },
    propHooks: {
      tabIndex: {
        get: function get(elem) {
          // Support: IE <=9 - 11 only
          // elem.tabIndex doesn't always return the
          // correct value when it hasn't been explicitly set
          // Use proper attribute retrieval (trac-12072)
          var tabindex = jQuery.find.attr(elem, "tabindex");

          if (tabindex) {
            return parseInt(tabindex, 10);
          }

          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
            return 0;
          }

          return -1;
        }
      }
    },
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  }); // Support: IE <=11 only
  // Accessing the selectedIndex property
  // forces the browser to respect setting selected
  // on the option
  // The getter ensures a default option is selected
  // when in an optgroup
  // eslint rule "no-unused-expressions" is disabled for this code
  // since it considers such accessions noop

  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function get(elem) {
        /* eslint no-unused-expressions: "off" */
        var parent = elem.parentNode;

        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }

        return null;
      },
      set: function set(elem) {
        /* eslint no-unused-expressions: "off" */
        var parent = elem.parentNode;

        if (parent) {
          parent.selectedIndex;

          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }
      }
    };
  }

  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
    jQuery.propFix[this.toLowerCase()] = this;
  }); // Strip and collapse whitespace according to HTML spec
  // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace

  function stripAndCollapse(value) {
    var tokens = value.match(rnothtmlwhite) || [];
    return tokens.join(" ");
  }

  function getClass(elem) {
    return elem.getAttribute && elem.getAttribute("class") || "";
  }

  function classesToArray(value) {
    if (Array.isArray(value)) {
      return value;
    }

    if (typeof value === "string") {
      return value.match(rnothtmlwhite) || [];
    }

    return [];
  }

  jQuery.fn.extend({
    addClass: function addClass(value) {
      var classNames, cur, curValue, className, i, finalValue;

      if (isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).addClass(value.call(this, j, getClass(this)));
        });
      }

      classNames = classesToArray(value);

      if (classNames.length) {
        return this.each(function () {
          curValue = getClass(this);
          cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

          if (cur) {
            for (i = 0; i < classNames.length; i++) {
              className = classNames[i];

              if (cur.indexOf(" " + className + " ") < 0) {
                cur += className + " ";
              }
            } // Only assign if different to avoid unneeded rendering.


            finalValue = stripAndCollapse(cur);

            if (curValue !== finalValue) {
              this.setAttribute("class", finalValue);
            }
          }
        });
      }

      return this;
    },
    removeClass: function removeClass(value) {
      var classNames, cur, curValue, className, i, finalValue;

      if (isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).removeClass(value.call(this, j, getClass(this)));
        });
      }

      if (!arguments.length) {
        return this.attr("class", "");
      }

      classNames = classesToArray(value);

      if (classNames.length) {
        return this.each(function () {
          curValue = getClass(this); // This expression is here for better compressibility (see addClass)

          cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

          if (cur) {
            for (i = 0; i < classNames.length; i++) {
              className = classNames[i]; // Remove *all* instances

              while (cur.indexOf(" " + className + " ") > -1) {
                cur = cur.replace(" " + className + " ", " ");
              }
            } // Only assign if different to avoid unneeded rendering.


            finalValue = stripAndCollapse(cur);

            if (curValue !== finalValue) {
              this.setAttribute("class", finalValue);
            }
          }
        });
      }

      return this;
    },
    toggleClass: function toggleClass(value, stateVal) {
      var classNames,
          className,
          i,
          self,
          type = _typeof(value),
          isValidValue = type === "string" || Array.isArray(value);

      if (isFunction(value)) {
        return this.each(function (i) {
          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
        });
      }

      if (typeof stateVal === "boolean" && isValidValue) {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }

      classNames = classesToArray(value);
      return this.each(function () {
        if (isValidValue) {
          // Toggle individual class names
          self = jQuery(this);

          for (i = 0; i < classNames.length; i++) {
            className = classNames[i]; // Check each className given, space separated list

            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          } // Toggle whole class name

        } else if (value === undefined || type === "boolean") {
          className = getClass(this);

          if (className) {
            // Store className if set
            dataPriv.set(this, "__className__", className);
          } // If the element has a class name or if we're passed `false`,
          // then remove the whole classname (if there was one, the above saved it).
          // Otherwise bring back whatever was previously saved (if anything),
          // falling back to the empty string if nothing was stored.


          if (this.setAttribute) {
            this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
          }
        }
      });
    },
    hasClass: function hasClass(selector) {
      var className,
          elem,
          i = 0;
      className = " " + selector + " ";

      while (elem = this[i++]) {
        if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
          return true;
        }
      }

      return false;
    }
  });
  var rreturn = /\r/g;
  jQuery.fn.extend({
    val: function val(value) {
      var hooks,
          ret,
          valueIsFunction,
          elem = this[0];

      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }

          ret = elem.value; // Handle most common string cases

          if (typeof ret === "string") {
            return ret.replace(rreturn, "");
          } // Handle cases where value is null/undef or number


          return ret == null ? "" : ret;
        }

        return;
      }

      valueIsFunction = isFunction(value);
      return this.each(function (i) {
        var val;

        if (this.nodeType !== 1) {
          return;
        }

        if (valueIsFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        } // Treat null/undefined as ""; convert numbers to string


        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (Array.isArray(val)) {
          val = jQuery.map(val, function (value) {
            return value == null ? "" : value + "";
          });
        }

        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting

        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }
  });
  jQuery.extend({
    valHooks: {
      option: {
        get: function get(elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val : // Support: IE <=10 - 11 only
          // option.text throws exceptions (trac-14686, trac-14858)
          // Strip and collapse whitespace
          // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
          stripAndCollapse(jQuery.text(elem));
        }
      },
      select: {
        get: function get(elem) {
          var value,
              option,
              i,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one",
              values = one ? null : [],
              max = one ? index + 1 : options.length;

          if (index < 0) {
            i = max;
          } else {
            i = one ? index : 0;
          } // Loop through all the selected options


          for (; i < max; i++) {
            option = options[i]; // Support: IE <=9 only
            // IE8-9 doesn't update selected after form reset (trac-2551)

            if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
            !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
              // Get the specific value for the option
              value = jQuery(option).val(); // We don't need an array for one selects

              if (one) {
                return value;
              } // Multi-Selects return an array


              values.push(value);
            }
          }

          return values;
        },
        set: function set(elem, value) {
          var optionSet,
              option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;

          while (i--) {
            option = options[i];
            /* eslint-disable no-cond-assign */

            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
              optionSet = true;
            }
            /* eslint-enable no-cond-assign */

          } // Force browsers to behave consistently when non-matching value is set


          if (!optionSet) {
            elem.selectedIndex = -1;
          }

          return values;
        }
      }
    }
  }); // Radios and checkboxes getter/setter

  jQuery.each(["radio", "checkbox"], function () {
    jQuery.valHooks[this] = {
      set: function set(elem, value) {
        if (Array.isArray(value)) {
          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
        }
      }
    };

    if (!support.checkOn) {
      jQuery.valHooks[this].get = function (elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  }); // Return jQuery for attributes-only inclusion

  support.focusin = "onfocusin" in window;

  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
      stopPropagationCallback = function stopPropagationCallback(e) {
    e.stopPropagation();
  };

  jQuery.extend(jQuery.event, {
    trigger: function trigger(event, data, elem, onlyHandlers) {
      var i,
          cur,
          tmp,
          bubbleType,
          ontype,
          handle,
          special,
          lastElement,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = lastElement = tmp = elem = elem || document; // Don't do events on text and comment nodes

      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      } // focus/blur morphs to focusin/out; ensure we're not firing them right now


      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }

      if (type.indexOf(".") > -1) {
        // Namespaced trigger; create a regexp to match event type in handle()
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }

      ontype = type.indexOf(":") < 0 && "on" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string

      event = event[jQuery.expando] ? event : new jQuery.Event(type, _typeof(event) === "object" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)

      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null; // Clean up the event in case it is being reused

      event.result = undefined;

      if (!event.target) {
        event.target = elem;
      } // Clone any incoming data and prepend the event, creating the handler arg list


      data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines

      special = jQuery.event.special[type] || {};

      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      } // Determine event propagation path in advance, per W3C events spec (trac-9951)
      // Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)


      if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
        bubbleType = special.delegateType || type;

        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }

        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        } // Only add window if we got to document (e.g., not plain obj or detached DOM)


        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      } // Fire handlers on the event path


      i = 0;

      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        lastElement = cur;
        event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler

        handle = (dataPriv.get(cur, "events") || Object.create(null))[event.type] && dataPriv.get(cur, "handle");

        if (handle) {
          handle.apply(cur, data);
        } // Native handler


        handle = ontype && cur[ontype];

        if (handle && handle.apply && acceptData(cur)) {
          event.result = handle.apply(cur, data);

          if (event.result === false) {
            event.preventDefault();
          }
        }
      }

      event.type = type; // If nobody prevented the default action, do it now

      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
          // Call a native DOM method on the target with the same name as the event.
          // Don't do default actions on window, that's where global variables be (trac-6170)
          if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
            // Don't re-trigger an onFOO event when we call its FOO() method
            tmp = elem[ontype];

            if (tmp) {
              elem[ontype] = null;
            } // Prevent re-triggering of the same event, since we already bubbled it above


            jQuery.event.triggered = type;

            if (event.isPropagationStopped()) {
              lastElement.addEventListener(type, stopPropagationCallback);
            }

            elem[type]();

            if (event.isPropagationStopped()) {
              lastElement.removeEventListener(type, stopPropagationCallback);
            }

            jQuery.event.triggered = undefined;

            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }

      return event.result;
    },
    // Piggyback on a donor event to simulate a different one
    // Used only for `focus(in | out)` events
    simulate: function simulate(type, elem, event) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true
      });
      jQuery.event.trigger(e, null, elem);
    }
  });
  jQuery.fn.extend({
    trigger: function trigger(type, data) {
      return this.each(function () {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function triggerHandler(type, data) {
      var elem = this[0];

      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  }); // Support: Firefox <=44
  // Firefox doesn't have focus(in | out) events
  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
  //
  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
  // focus(in | out) events fire after focus & blur events,
  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857

  if (!support.focusin) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function (orig, fix) {
      // Attach a single capturing handler on the document while someone wants focusin/focusout
      var handler = function handler(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
      };

      jQuery.event.special[fix] = {
        setup: function setup() {
          // Handle: regular nodes (via `this.ownerDocument`), window
          // (via `this.document`) & document (via `this`).
          var doc = this.ownerDocument || this.document || this,
              attaches = dataPriv.access(doc, fix);

          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }

          dataPriv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function teardown() {
          var doc = this.ownerDocument || this.document || this,
              attaches = dataPriv.access(doc, fix) - 1;

          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            dataPriv.remove(doc, fix);
          } else {
            dataPriv.access(doc, fix, attaches);
          }
        }
      };
    });
  }

  var location = window.location;
  var nonce = {
    guid: Date.now()
  };
  var rquery = /\?/; // Cross-browser xml parsing

  jQuery.parseXML = function (data) {
    var xml, parserErrorElem;

    if (!data || typeof data !== "string") {
      return null;
    } // Support: IE 9 - 11 only
    // IE throws on parseFromString with invalid input.


    try {
      xml = new window.DOMParser().parseFromString(data, "text/xml");
    } catch (e) {}

    parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];

    if (!xml || parserErrorElem) {
      jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function (el) {
        return el.textContent;
      }).join("\n") : data));
    }

    return xml;
  };

  var rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;

  function buildParams(prefix, obj, traditional, add) {
    var name;

    if (Array.isArray(obj)) {
      // Serialize array item.
      jQuery.each(obj, function (i, v) {
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v);
        } else {
          // Item is non-scalar (array or object), encode its numeric index.
          buildParams(prefix + "[" + (_typeof(v) === "object" && v != null ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && toType(obj) === "object") {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      // Serialize scalar item.
      add(prefix, obj);
    }
  } // Serialize an array of form elements or a set of
  // key/values into a query string


  jQuery.param = function (a, traditional) {
    var prefix,
        s = [],
        add = function add(key, valueOrFunction) {
      // If value is a function, invoke it and use its return value
      var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
      s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
    };

    if (a == null) {
      return "";
    } // If an array was passed in, assume that it is an array of form elements.


    if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
      // Serialize the form elements
      jQuery.each(a, function () {
        add(this.name, this.value);
      });
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    } // Return the resulting serialization


    return s.join("&");
  };

  jQuery.fn.extend({
    serialize: function serialize() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function serializeArray() {
      return this.map(function () {
        // Can add propHook for "elements" to filter or add form elements
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function () {
        var type = this.type; // Use .is( ":disabled" ) so that fieldset[disabled] works

        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function (_i, elem) {
        var val = jQuery(this).val();

        if (val == null) {
          return null;
        }

        if (Array.isArray(val)) {
          return jQuery.map(val, function (val) {
            return {
              name: elem.name,
              value: val.replace(rCRLF, "\r\n")
            };
          });
        }

        return {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  var r20 = /%20/g,
      rhash = /#.*$/,
      rantiCache = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
      // trac-7653, trac-8125, trac-8152: local protocol detection
  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,

  /* Prefilters
   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
   * 2) These are called:
   *    - BEFORE asking for a transport
   *    - AFTER param serialization (s.data is a string if s.processData is true)
   * 3) key is the dataType
   * 4) the catchall symbol "*" can be used
   * 5) execution will start with transport dataType and THEN continue down to "*" if needed
   */
  prefilters = {},

  /* Transports bindings
   * 1) key is the dataType
   * 2) the catchall symbol "*" can be used
   * 3) selection will start with transport dataType and THEN go to "*" if needed
   */
  transports = {},
      // Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
  allTypes = "*/".concat("*"),
      // Anchor tag for parsing the document origin
  originAnchor = document.createElement("a");
  originAnchor.href = location.href; // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport

  function addToPrefiltersOrTransports(structure) {
    // dataTypeExpression is optional and defaults to "*"
    return function (dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }

      var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

      if (isFunction(func)) {
        // For each dataType in the dataTypeExpression
        while (dataType = dataTypes[i++]) {
          // Prepend if requested
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  } // Base inspection function for prefilters and transports


  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
        seekingTransport = structure === transports;

    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);

        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }

    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  } // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes trac-9887


  function ajaxExtend(target, src) {
    var key,
        deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};

    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }

    if (deep) {
      jQuery.extend(true, target, deep);
    }

    return target;
  }
  /* Handles responses to an ajax request:
   * - finds the right dataType (mediates between content-type and expected dataType)
   * - returns the corresponding response
   */


  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
        type,
        finalDataType,
        firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process

    while (dataTypes[0] === "*") {
      dataTypes.shift();

      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    } // Check if we're dealing with a known content-type


    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    } // Check to see if we have a response for the expected dataType


    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      // Try convertible dataTypes
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }

        if (!firstDataType) {
          firstDataType = type;
        }
      } // Or just use first one


      finalDataType = finalDataType || firstDataType;
    } // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response


    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }

      return responses[finalDataType];
    }
  }
  /* Chain conversions given the request and the original response
   * Also sets the responseXXX fields on the jqXHR instance
   */


  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
        current,
        conv,
        tmp,
        prev,
        converters = {},
        // Work with a copy of dataTypes in case we need to modify it for conversion
    dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys

    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }

    current = dataTypes.shift(); // Convert to each sequential dataType

    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      } // Apply the dataFilter if provided


      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }

      prev = current;
      current = dataTypes.shift();

      if (current) {
        // There's only work to do if current dataType is non-auto
        if (current === "*") {
          current = prev; // Convert response if prev dataType is non-auto and differs from current
        } else if (prev !== "*" && prev !== current) {
          // Seek a direct converter
          conv = converters[prev + " " + current] || converters["* " + current]; // If none found, seek a pair

          if (!conv) {
            for (conv2 in converters) {
              // If conv2 outputs current
              tmp = conv2.split(" ");

              if (tmp[1] === current) {
                // If prev can be converted to accepted input
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];

                if (conv) {
                  // Condense equivalence converters
                  if (conv === true) {
                    conv = converters[conv2]; // Otherwise, insert the intermediate dataType
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }

                  break;
                }
              }
            }
          } // Apply converter (if not an equivalence)


          if (conv !== true) {
            // Unless errors are allowed to bubble, catch and return them
            if (conv && s["throws"]) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }

    return {
      state: "success",
      data: response
    };
  }

  jQuery.extend({
    // Counter for holding the number of active queries
    active: 0,
    // Last-Modified header cache for next request
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: location.href,
      type: "GET",
      isLocal: rlocalProtocol.test(location.protocol),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",

      /*
      timeout: 0,
      data: null,
      dataType: null,
      username: null,
      password: null,
      cache: null,
      throws: false,
      traditional: false,
      headers: {},
      */
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      // Data converters
      // Keys separate source (or catchall "*") and destination types with a single space
      converters: {
        // Convert anything to text
        "* text": String,
        // Text to html (true = no transformation)
        "text html": true,
        // Evaluate text as a json expression
        "text json": JSON.parse,
        // Parse text as xml
        "text xml": jQuery.parseXML
      },
      // For options that shouldn't be deep extended:
      // you can add your own custom options here if
      // and when you create one that shouldn't be
      // deep extended (see ajaxExtend)
      flatOptions: {
        url: true,
        context: true
      }
    },
    // Creates a full fledged settings object into target
    // with both ajaxSettings and settings fields.
    // If target is omitted, writes into ajaxSettings.
    ajaxSetup: function ajaxSetup(target, settings) {
      return settings ? // Building a settings object
      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings
      ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    // Main method
    ajax: function ajax(url, options) {
      // If url is an object, simulate pre-1.5 signature
      if (_typeof(url) === "object") {
        options = url;
        url = undefined;
      } // Force options to be an object


      options = options || {};

      var transport,
          // URL without anti-cache param
      cacheURL,
          // Response headers
      responseHeadersString,
          responseHeaders,
          // timeout handle
      timeoutTimer,
          // Url cleanup var
      urlAnchor,
          // Request state (becomes false upon send and true upon completion)
      completed,
          // To know if global events are to be dispatched
      fireGlobals,
          // Loop variable
      i,
          // uncached part of the url
      uncached,
          // Create the final options object
      s = jQuery.ajaxSetup({}, options),
          // Callbacks context
      callbackContext = s.context || s,
          // Context for global events is callbackContext if it is a DOM node or jQuery collection
      globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
          // Deferreds
      deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          // Status-dependent callbacks
      _statusCode = s.statusCode || {},
          // Headers (they are sent all at once)
      requestHeaders = {},
          requestHeadersNames = {},
          // Default abort message
      strAbort = "canceled",
          // Fake xhr
      jqXHR = {
        readyState: 0,
        // Builds headers hashtable if needed
        getResponseHeader: function getResponseHeader(key) {
          var match;

          if (completed) {
            if (!responseHeaders) {
              responseHeaders = {};

              while (match = rheaders.exec(responseHeadersString)) {
                responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
              }
            }

            match = responseHeaders[key.toLowerCase() + " "];
          }

          return match == null ? null : match.join(", ");
        },
        // Raw string
        getAllResponseHeaders: function getAllResponseHeaders() {
          return completed ? responseHeadersString : null;
        },
        // Caches the header
        setRequestHeader: function setRequestHeader(name, value) {
          if (completed == null) {
            name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
            requestHeaders[name] = value;
          }

          return this;
        },
        // Overrides response content-type header
        overrideMimeType: function overrideMimeType(type) {
          if (completed == null) {
            s.mimeType = type;
          }

          return this;
        },
        // Status-dependent callbacks
        statusCode: function statusCode(map) {
          var code;

          if (map) {
            if (completed) {
              // Execute the appropriate callbacks
              jqXHR.always(map[jqXHR.status]);
            } else {
              // Lazy-add the new callbacks in a way that preserves old ones
              for (code in map) {
                _statusCode[code] = [_statusCode[code], map[code]];
              }
            }
          }

          return this;
        },
        // Cancel the request
        abort: function abort(statusText) {
          var finalText = statusText || strAbort;

          if (transport) {
            transport.abort(finalText);
          }

          done(0, finalText);
          return this;
        }
      }; // Attach deferreds


      deferred.promise(jqXHR); // Add protocol if not provided (prefilters might expect it)
      // Handle falsy url in the settings object (trac-10093: consistency with old signature)
      // We also use the url parameter if available

      s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"); // Alias method option to type as per ticket trac-12004

      s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list

      s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""]; // A cross-domain request is in order when the origin doesn't match the current origin.

      if (s.crossDomain == null) {
        urlAnchor = document.createElement("a"); // Support: IE <=8 - 11, Edge 12 - 15
        // IE throws exception on accessing the href property if url is malformed,
        // e.g. http://example.com:80x/

        try {
          urlAnchor.href = s.url; // Support: IE <=8 - 11 only
          // Anchor's host property isn't correctly set when s.url is relative

          urlAnchor.href = urlAnchor.href;
          s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
        } catch (e) {
          // If there is an error parsing the URL, assume it is crossDomain,
          // it can be rejected by the transport if it is invalid
          s.crossDomain = true;
        }
      } // Convert data if not already a string


      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      } // Apply prefilters


      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there

      if (completed) {
        return jqXHR;
      } // We can fire global events as of now if asked to
      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)


      fireGlobals = jQuery.event && s.global; // Watch for a new set of requests

      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      } // Uppercase the type


      s.type = s.type.toUpperCase(); // Determine if request has content

      s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since
      // and/or If-None-Match header later on
      // Remove hash to simplify url manipulation

      cacheURL = s.url.replace(rhash, ""); // More options handling for requests with no content

      if (!s.hasContent) {
        // Remember the hash so we can put it back
        uncached = s.url.slice(cacheURL.length); // If data is available and should be processed, append data to url

        if (s.data && (s.processData || typeof s.data === "string")) {
          cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data; // trac-9682: remove data so that it's not used in an eventual retry

          delete s.data;
        } // Add or update anti-cache param if needed


        if (s.cache === false) {
          cacheURL = cacheURL.replace(rantiCache, "$1");
          uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
        } // Put hash and anti-cache on the URL that will be requested (gh-1732)


        s.url = cacheURL + uncached; // Change '%20' to '+' if this is encoded form body content (gh-2658)
      } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
        s.data = s.data.replace(r20, "+");
      } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.


      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }

        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      } // Set the correct header, if data is being sent


      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      } // Set the Accepts header for the server, depending on the dataType


      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]); // Check for headers option

      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      } // Allow custom headers/mimetypes and early abort


      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
        // Abort if not done already and return
        return jqXHR.abort();
      } // Aborting is no longer a cancellation


      strAbort = "abort"; // Install callbacks on deferreds

      completeDeferred.add(s.complete);
      jqXHR.done(s.success);
      jqXHR.fail(s.error); // Get transport

      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort

      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1; // Send global event

        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        } // If request was aborted inside ajaxSend, stop there


        if (completed) {
          return jqXHR;
        } // Timeout


        if (s.async && s.timeout > 0) {
          timeoutTimer = window.setTimeout(function () {
            jqXHR.abort("timeout");
          }, s.timeout);
        }

        try {
          completed = false;
          transport.send(requestHeaders, done);
        } catch (e) {
          // Rethrow post-completion exceptions
          if (completed) {
            throw e;
          } // Propagate others as results


          done(-1, e);
        }
      } // Callback for when everything is done


      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText; // Ignore repeat invocations

        if (completed) {
          return;
        }

        completed = true; // Clear timeout if it exists

        if (timeoutTimer) {
          window.clearTimeout(timeoutTimer);
        } // Dereference transport for early garbage collection
        // (no matter how long the jqXHR object will be used)


        transport = undefined; // Cache response headers

        responseHeadersString = headers || ""; // Set readyState

        jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful

        isSuccess = status >= 200 && status < 300 || status === 304; // Get response data

        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        } // Use a noop converter for missing script but not if jsonp


        if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1 && jQuery.inArray("json", s.dataTypes) < 0) {
          s.converters["text script"] = function () {};
        } // Convert no matter what (that way responseXXX fields are always set)


        response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining

        if (isSuccess) {
          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");

            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }

            modified = jqXHR.getResponseHeader("etag");

            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          } // if no content


          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent"; // if not modified
          } else if (status === 304) {
            statusText = "notmodified"; // If we have data, let's convert it
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          // Extract error from statusText and normalize for non-aborts
          error = statusText;

          if (status || !statusText) {
            statusText = "error";

            if (status < 0) {
              status = 0;
            }
          }
        } // Set data for the fake xhr object


        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + ""; // Success/Error

        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        } // Status-dependent callbacks


        jqXHR.statusCode(_statusCode);
        _statusCode = undefined;

        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        } // Complete


        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]); // Handle the global AJAX counter

          if (! --jQuery.active) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }

      return jqXHR;
    },
    getJSON: function getJSON(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function getScript(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function (_i, method) {
    jQuery[method] = function (url, data, callback, type) {
      // Shift arguments if data argument was omitted
      if (isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      } // The url can be an options object (which then must have .url)


      return jQuery.ajax(jQuery.extend({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      }, jQuery.isPlainObject(url) && url));
    };
  });
  jQuery.ajaxPrefilter(function (s) {
    var i;

    for (i in s.headers) {
      if (i.toLowerCase() === "content-type") {
        s.contentType = s.headers[i] || "";
      }
    }
  });

  jQuery._evalUrl = function (url, options, doc) {
    return jQuery.ajax({
      url: url,
      // Make this explicit, since user can override this through ajaxSetup (trac-11264)
      type: "GET",
      dataType: "script",
      cache: true,
      async: false,
      global: false,
      // Only evaluate the response if it is successful (gh-4126)
      // dataFilter is not invoked for failure responses, so using it instead
      // of the default converter is kludgy but it works.
      converters: {
        "text script": function textScript() {}
      },
      dataFilter: function dataFilter(response) {
        jQuery.globalEval(response, options, doc);
      }
    });
  };

  jQuery.fn.extend({
    wrapAll: function wrapAll(html) {
      var wrap;

      if (this[0]) {
        if (isFunction(html)) {
          html = html.call(this[0]);
        } // The elements to wrap the target around


        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }

        wrap.map(function () {
          var elem = this;

          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }

          return elem;
        }).append(this);
      }

      return this;
    },
    wrapInner: function wrapInner(html) {
      if (isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }

      return this.each(function () {
        var self = jQuery(this),
            contents = self.contents();

        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function wrap(html) {
      var htmlIsFunction = isFunction(html);
      return this.each(function (i) {
        jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function unwrap(selector) {
      this.parent(selector).not("body").each(function () {
        jQuery(this).replaceWith(this.childNodes);
      });
      return this;
    }
  });

  jQuery.expr.pseudos.hidden = function (elem) {
    return !jQuery.expr.pseudos.visible(elem);
  };

  jQuery.expr.pseudos.visible = function (elem) {
    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
  };

  jQuery.ajaxSettings.xhr = function () {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  };

  var xhrSuccessStatus = {
    // File protocol always yields status code 0, assume 200
    0: 200,
    // Support: IE <=9 only
    // trac-1450: sometimes IE returns 1223 when it should be 204
    1223: 204
  },
      xhrSupported = jQuery.ajaxSettings.xhr();
  support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function (options) {
    var _callback, errorCallback; // Cross domain only allowed if supported through XMLHttpRequest


    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function send(headers, complete) {
          var i,
              xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided

          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          } // Override mime type if needed


          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          } // X-Requested-With header
          // For cross-domain requests, seeing as conditions for a preflight are
          // akin to a jigsaw puzzle, we simply never set it to be sure.
          // (it can always be set on a per-request basis or even using ajaxSetup)
          // For same-domain requests, won't change header if already provided.


          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          } // Set headers


          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          } // Callback


          _callback = function callback(type) {
            return function () {
              if (_callback) {
                _callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;

                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  // Support: IE <=9 only
                  // On a manual native abort, IE9 throws
                  // errors on any property access that is not readyState
                  if (typeof xhr.status !== "number") {
                    complete(0, "error");
                  } else {
                    complete( // File: protocol always yields status 0; see trac-8605, trac-14207
                    xhr.status, xhr.statusText);
                  }
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only
                  // IE9 has no XHR2 but throws on binary (trac-11426)
                  // For XHR2 non-text, let the caller handle it (gh-2498)
                  (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                    binary: xhr.response
                  } : {
                    text: xhr.responseText
                  }, xhr.getAllResponseHeaders());
                }
              }
            };
          }; // Listen to events


          xhr.onload = _callback();
          errorCallback = xhr.onerror = xhr.ontimeout = _callback("error"); // Support: IE 9 only
          // Use onreadystatechange to replace onabort
          // to handle uncaught aborts

          if (xhr.onabort !== undefined) {
            xhr.onabort = errorCallback;
          } else {
            xhr.onreadystatechange = function () {
              // Check readyState before timeout as it changes
              if (xhr.readyState === 4) {
                // Allow onerror to be called first,
                // but that will not handle a native abort
                // Also, save errorCallback to a variable
                // as xhr.onerror cannot be accessed
                window.setTimeout(function () {
                  if (_callback) {
                    errorCallback();
                  }
                });
              }
            };
          } // Create the abort callback


          _callback = _callback("abort");

          try {
            // Do send the request (this may raise an exception)
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            // trac-14683: Only rethrow if this hasn't been notified as an error yet
            if (_callback) {
              throw e;
            }
          }
        },
        abort: function abort() {
          if (_callback) {
            _callback();
          }
        }
      };
    }
  }); // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)

  jQuery.ajaxPrefilter(function (s) {
    if (s.crossDomain) {
      s.contents.script = false;
    }
  }); // Install script dataType

  jQuery.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /\b(?:java|ecma)script\b/
    },
    converters: {
      "text script": function textScript(text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  }); // Handle cache's special case and crossDomain

  jQuery.ajaxPrefilter("script", function (s) {
    if (s.cache === undefined) {
      s.cache = false;
    }

    if (s.crossDomain) {
      s.type = "GET";
    }
  }); // Bind script tag hack transport

  jQuery.ajaxTransport("script", function (s) {
    // This transport only deals with cross domain or forced-by-attrs requests
    if (s.crossDomain || s.scriptAttrs) {
      var script, _callback2;

      return {
        send: function send(_, complete) {
          script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", _callback2 = function callback(evt) {
            script.remove();
            _callback2 = null;

            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          }); // Use native DOM manipulation to avoid our domManip AJAX trickery

          document.head.appendChild(script[0]);
        },
        abort: function abort() {
          if (_callback2) {
            _callback2();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/; // Default jsonp settings

  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function jsonpCallback() {
      var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
      this[callback] = true;
      return callback;
    }
  }); // Detect, normalize options and install callbacks for jsonp requests

  jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data"); // Handle iff the expected data type is "jsonp" or we have a parameter to set

    if (jsonProp || s.dataTypes[0] === "jsonp") {
      // Get callback name, remembering preexisting value associated with it
      callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data

      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      } // Use data converter to retrieve json after script execution


      s.converters["script json"] = function () {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }

        return responseContainer[0];
      }; // Force json dataType


      s.dataTypes[0] = "json"; // Install callback

      overwritten = window[callbackName];

      window[callbackName] = function () {
        responseContainer = arguments;
      }; // Clean-up function (fires after converters)


      jqXHR.always(function () {
        // If previous value didn't exist - remove it
        if (overwritten === undefined) {
          jQuery(window).removeProp(callbackName); // Otherwise restore preexisting value
        } else {
          window[callbackName] = overwritten;
        } // Save back as free


        if (s[callbackName]) {
          // Make sure that re-using the options doesn't screw things around
          s.jsonpCallback = originalSettings.jsonpCallback; // Save the callback name for future use

          oldCallbacks.push(callbackName);
        } // Call if it was a function and we have a response


        if (responseContainer && isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }

        responseContainer = overwritten = undefined;
      }); // Delegate to script

      return "script";
    }
  }); // Support: Safari 8 only
  // In Safari 8 documents created via document.implementation.createHTMLDocument
  // collapse sibling forms: the second one becomes a child of the first one.
  // Because of that, this security measure has to be disabled in Safari 8.
  // https://bugs.webkit.org/show_bug.cgi?id=137337

  support.createHTMLDocument = function () {
    var body = document.implementation.createHTMLDocument("").body;
    body.innerHTML = "<form></form><form></form>";
    return body.childNodes.length === 2;
  }(); // Argument "data" should be string of html
  // context (optional): If specified, the fragment will be created in this context,
  // defaults to document
  // keepScripts (optional): If true, will include scripts passed in the html string


  jQuery.parseHTML = function (data, context, keepScripts) {
    if (typeof data !== "string") {
      return [];
    }

    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }

    var base, parsed, scripts;

    if (!context) {
      // Stop scripts or inline event handlers from being executed immediately
      // by using document.implementation
      if (support.createHTMLDocument) {
        context = document.implementation.createHTMLDocument(""); // Set the base href for the created document
        // so any parsed elements with URLs
        // are based on the document's URL (gh-2965)

        base = context.createElement("base");
        base.href = document.location.href;
        context.head.appendChild(base);
      } else {
        context = document;
      }
    }

    parsed = rsingleTag.exec(data);
    scripts = !keepScripts && []; // Single tag

    if (parsed) {
      return [context.createElement(parsed[1])];
    }

    parsed = buildFragment([data], context, scripts);

    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }

    return jQuery.merge([], parsed.childNodes);
  };
  /**
   * Load a url into a page
   */


  jQuery.fn.load = function (url, params, callback) {
    var selector,
        type,
        response,
        self = this,
        off = url.indexOf(" ");

    if (off > -1) {
      selector = stripAndCollapse(url.slice(off));
      url = url.slice(0, off);
    } // If it's a function


    if (isFunction(params)) {
      // We assume that it's the callback
      callback = params;
      params = undefined; // Otherwise, build a param string
    } else if (params && _typeof(params) === "object") {
      type = "POST";
    } // If we have elements to modify, make the request


    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        // If "type" variable is undefined, then "GET" method will be used.
        // Make value of this field explicit since
        // user can override it through ajaxSetup method
        type: type || "GET",
        dataType: "html",
        data: params
      }).done(function (responseText) {
        // Save response for use in complete callback
        response = arguments;
        self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
        // Exclude scripts to avoid IE 'Permission Denied' errors
        jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
        responseText); // If the request succeeds, this function gets "data", "status", "jqXHR"
        // but they are ignored because response was set above.
        // If it fails, this function gets "jqXHR", "status", "error"
      }).always(callback && function (jqXHR, status) {
        self.each(function () {
          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
        });
      });
    }

    return this;
  };

  jQuery.expr.pseudos.animated = function (elem) {
    return jQuery.grep(jQuery.timers, function (fn) {
      return elem === fn.elem;
    }).length;
  };

  jQuery.offset = {
    setOffset: function setOffset(elem, options, i) {
      var curPosition,
          curLeft,
          curCSSTop,
          curTop,
          curOffset,
          curCSSLeft,
          calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {}; // Set position first, in-case top/left are set even on static elem

      if (position === "static") {
        elem.style.position = "relative";
      }

      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1; // Need to be able to calculate position if either
      // top or left is auto and position is either absolute or fixed

      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }

      if (isFunction(options)) {
        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
        options = options.call(elem, i, jQuery.extend({}, curOffset));
      }

      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }

      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }

      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };
  jQuery.fn.extend({
    // offset() relates an element's border box to the document origin
    offset: function offset(options) {
      // Preserve chaining for setter
      if (arguments.length) {
        return options === undefined ? this : this.each(function (i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }

      var rect,
          win,
          elem = this[0];

      if (!elem) {
        return;
      } // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
      // Support: IE <=11 only
      // Running getBoundingClientRect on a
      // disconnected node in IE throws an error


      if (!elem.getClientRects().length) {
        return {
          top: 0,
          left: 0
        };
      } // Get document-relative position by adding viewport scroll to viewport-relative gBCR


      rect = elem.getBoundingClientRect();
      win = elem.ownerDocument.defaultView;
      return {
        top: rect.top + win.pageYOffset,
        left: rect.left + win.pageXOffset
      };
    },
    // position() relates an element's margin box to its offset parent's padding box
    // This corresponds to the behavior of CSS absolute positioning
    position: function position() {
      if (!this[0]) {
        return;
      }

      var offsetParent,
          offset,
          doc,
          elem = this[0],
          parentOffset = {
        top: 0,
        left: 0
      }; // position:fixed elements are offset from the viewport, which itself always has zero offset

      if (jQuery.css(elem, "position") === "fixed") {
        // Assume position:fixed implies availability of getBoundingClientRect
        offset = elem.getBoundingClientRect();
      } else {
        offset = this.offset(); // Account for the *real* offset parent, which can be the document or its root element
        // when a statically positioned element is identified

        doc = elem.ownerDocument;
        offsetParent = elem.offsetParent || doc.documentElement;

        while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.parentNode;
        }

        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
          // Incorporate borders into its offset, since they are outside its content origin
          parentOffset = jQuery(offsetParent).offset();
          parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
          parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
        }
      } // Subtract parent offsets and element margins


      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    // This method will return documentElement in the following cases:
    // 1) For the element inside the iframe without offsetParent, this method will return
    //    documentElement of the parent window
    // 2) For the hidden or detached element
    // 3) For body or html element, i.e. in case of the html node - it will return itself
    //
    // but those exceptions were never presented as a real life use-cases
    // and might be considered as more preferable results.
    //
    // This logic, however, is not guaranteed and can change at any point in the future
    offsetParent: function offsetParent() {
      return this.map(function () {
        var offsetParent = this.offsetParent;

        while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.offsetParent;
        }

        return offsetParent || documentElement;
      });
    }
  }); // Create scrollLeft and scrollTop methods

  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function (method, prop) {
    var top = "pageYOffset" === prop;

    jQuery.fn[method] = function (val) {
      return access(this, function (elem, method, val) {
        // Coalesce documents and windows
        var win;

        if (isWindow(elem)) {
          win = elem;
        } else if (elem.nodeType === 9) {
          win = elem.defaultView;
        }

        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }

        if (win) {
          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length);
    };
  }); // Support: Safari <=7 - 9.1, Chrome <=37 - 49
  // Add the top/left cssHooks using jQuery.fn.position
  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
  // getComputedStyle returns percent when specified for top/left/bottom/right;
  // rather than make the css module depend on the offset module, just check for it here

  jQuery.each(["top", "left"], function (_i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset

        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods

  jQuery.each({
    Height: "height",
    Width: "width"
  }, function (name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function (defaultExtra, funcName) {
      // Margin is only for outerHeight, outerWidth
      jQuery.fn[funcName] = function (margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function (elem, type, value) {
          var doc;

          if (isWindow(elem)) {
            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
            return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
          } // Get document width or height


          if (elem.nodeType === 9) {
            doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
            // whichever is greatest

            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }

          return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
          jQuery.css(elem, type, extra) : // Set width or height on the element
          jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable);
      };
    });
  });
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (_i, type) {
    jQuery.fn[type] = function (fn) {
      return this.on(type, fn);
    };
  });
  jQuery.fn.extend({
    bind: function bind(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function unbind(types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function delegate(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function undelegate(selector, types, fn) {
      // ( namespace ) or ( selector, types [, fn] )
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    },
    hover: function hover(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }
  });
  jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (_i, name) {
    // Handle event binding
    jQuery.fn[name] = function (data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  }); // Support: Android <=4.0 only
  // Make sure we trim BOM and NBSP
  // Require that the "whitespace run" starts from a non-whitespace
  // to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.

  var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g; // Bind a function to a context, optionally partially applying any
  // arguments.
  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
  // However, it is not slated for removal any time soon

  jQuery.proxy = function (fn, context) {
    var tmp, args, proxy;

    if (typeof context === "string") {
      tmp = fn[context];
      context = fn;
      fn = tmp;
    } // Quick check to determine if target is callable, in the spec
    // this throws a TypeError, but we will just return undefined.


    if (!isFunction(fn)) {
      return undefined;
    } // Simulated bind


    args = _slice.call(arguments, 2);

    proxy = function proxy() {
      return fn.apply(context || this, args.concat(_slice.call(arguments)));
    }; // Set the guid of unique handler to the same of original handler, so it can be removed


    proxy.guid = fn.guid = fn.guid || jQuery.guid++;
    return proxy;
  };

  jQuery.holdReady = function (hold) {
    if (hold) {
      jQuery.readyWait++;
    } else {
      jQuery.ready(true);
    }
  };

  jQuery.isArray = Array.isArray;
  jQuery.parseJSON = JSON.parse;
  jQuery.nodeName = nodeName;
  jQuery.isFunction = isFunction;
  jQuery.isWindow = isWindow;
  jQuery.camelCase = camelCase;
  jQuery.type = toType;
  jQuery.now = Date.now;

  jQuery.isNumeric = function (obj) {
    // As of jQuery 3.0, isNumeric is limited to
    // strings and numbers (primitives or objects)
    // that can be coerced to finite numbers (gh-2662)
    var type = jQuery.type(obj);
    return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    !isNaN(obj - parseFloat(obj));
  };

  jQuery.trim = function (text) {
    return text == null ? "" : (text + "").replace(rtrim, "$1");
  }; // Register as a named AMD module, since jQuery can be concatenated with other
  // files that may use define, but not via a proper concatenation script that
  // understands anonymous AMD modules. A named AMD is safest and most robust
  // way to register. Lowercase jquery is used because AMD module names are
  // derived from file names, and jQuery is normally delivered in a lowercase
  // file name. Do this after creating the global so that if an AMD module wants
  // to call noConflict to hide this version of jQuery, it will work.
  // Note that for maximum portability, libraries that are not jQuery should
  // declare themselves as anonymous modules, and avoid setting a global if an
  // AMD loader is present. jQuery is a special case. For more information, see
  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon


  if (typeof define === "function" && define.amd) {
    define("jquery", [], function () {
      return jQuery;
    });
  }

  var // Map over jQuery in case of overwrite
  _jQuery = window.jQuery,
      // Map over the $ in case of overwrite
  _$ = window.$;

  jQuery.noConflict = function (deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }

    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }

    return jQuery;
  }; // Expose jQuery and $ identifiers, even in AMD
  // (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
  // and CommonJS for browser emulators (trac-13566)


  if (typeof noGlobal === "undefined") {
    window.jQuery = window.$ = jQuery;
  }

  return jQuery;
});
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * @popperjs/core v2.11.6 - MIT License
 */
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Popper = {}));
})(this, function (exports) {
  'use strict';

  function getWindow(node) {
    if (node == null) {
      return window;
    }

    if (node.toString() !== '[object Window]') {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }

    return node;
  }

  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }

  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }

  function isShadowRoot(node) {
    // IE 11 has no ShadowRoot
    if (typeof ShadowRoot === 'undefined') {
      return false;
    }

    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }

  var max = Math.max;
  var min = Math.min;
  var round = Math.round;

  function getUAString() {
    var uaData = navigator.userAgentData;

    if (uaData != null && uaData.brands) {
      return uaData.brands.map(function (item) {
        return item.brand + "/" + item.version;
      }).join(' ');
    }

    return navigator.userAgent;
  }

  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }

  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }

    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }

    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;

    if (includeScale && isHTMLElement(element)) {
      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
    }

    var _ref = isElement(element) ? getWindow(element) : window,
        visualViewport = _ref.visualViewport;

    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect.width / scaleX;
    var height = clientRect.height / scaleY;
    return {
      width: width,
      height: height,
      top: y,
      right: x + width,
      bottom: y + height,
      left: x,
      x: x,
      y: y
    };
  }

  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft: scrollLeft,
      scrollTop: scrollTop
    };
  }

  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  function getNodeName(element) {
    return element ? (element.nodeName || '').toLowerCase() : null;
  }

  function getDocumentElement(element) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
    element.document) || window.document).documentElement;
  }

  function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    // Popper 1 is broken in this case and never had a bug report so let's assume
    // it's not an issue. I don't think anyone ever specifies width on <html>
    // anyway.
    // Browsers where the left scrollbar doesn't cause an issue report `0` for
    // this (e.g. Edge 2019, IE11, Safari)
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
  }

  function isScrollParent(element) {
    // Firefox wants us to check `-x` and `-y` variations as well
    var _getComputedStyle = getComputedStyle(element),
        overflow = _getComputedStyle.overflow,
        overflowX = _getComputedStyle.overflowX,
        overflowY = _getComputedStyle.overflowY;

    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  } // Returns the composite rect of an element relative to its offsetParent.
  // Composite means it takes into account transforms as well as layout.


  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }

    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };

    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }

      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }

    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  } // means it doesn't take into account transforms.


  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
    // Fixes https://github.com/popperjs/popper-core/issues/1223

    var width = element.offsetWidth;
    var height = element.offsetHeight;

    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }

    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }

    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: width,
      height: height
    };
  }

  function getParentNode(element) {
    if (getNodeName(element) === 'html') {
      return element;
    }

    return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || ( // DOM Element detected
      isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element) // fallback

    );
  }

  function getScrollParent(node) {
    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return node.ownerDocument.body;
    }

    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }

    return getScrollParent(getParentNode(node));
  }
  /*
  given a DOM element, return the list of all scroll parents, up the list of ancesors
  until we get to the top window object. This list is what we attach scroll listeners
  to, because if any of these parent elements scroll, we'll need to re-calculate the
  reference element's position.
  */


  function listScrollParents(element, list) {
    var _element$ownerDocumen;

    if (list === void 0) {
      list = [];
    }

    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)));
  }

  function isTableElement(element) {
    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
  }

  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle(element).position === 'fixed') {
      return null;
    }

    return element.offsetParent;
  } // `.offsetParent` reports `null` for fixed elements, while absolute elements
  // return the containing block


  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());

    if (isIE && isHTMLElement(element)) {
      // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
      var elementCss = getComputedStyle(element);

      if (elementCss.position === 'fixed') {
        return null;
      }
    }

    var currentNode = getParentNode(element);

    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }

    while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
      // create a containing block.
      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

      if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }

    return null;
  } // Gets the closest ancestor positioned element. Handles some edge cases,
  // such as table ancestors and cross browser bugs.


  function getOffsetParent(element) {
    var window = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);

    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
      offsetParent = getTrueOffsetParent(offsetParent);
    }

    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
      return window;
    }

    return offsetParent || getContainingBlock(element) || window;
  }

  var top = 'top';
  var bottom = 'bottom';
  var right = 'right';
  var left = 'left';
  var auto = 'auto';
  var basePlacements = [top, bottom, right, left];
  var start = 'start';
  var end = 'end';
  var clippingParents = 'clippingParents';
  var viewport = 'viewport';
  var popper = 'popper';
  var reference = 'reference';
  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []); // modifiers that need to read the DOM

  var beforeRead = 'beforeRead';
  var read = 'read';
  var afterRead = 'afterRead'; // pure-logic modifiers

  var beforeMain = 'beforeMain';
  var main = 'main';
  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

  var beforeWrite = 'beforeWrite';
  var write = 'write';
  var afterWrite = 'afterWrite';
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  function order(modifiers) {
    var map = new Map();
    var visited = new Set();
    var result = [];
    modifiers.forEach(function (modifier) {
      map.set(modifier.name, modifier);
    }); // On visiting object, check for its dependencies and visit them recursively

    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function (dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);

          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }

    modifiers.forEach(function (modifier) {
      if (!visited.has(modifier.name)) {
        // check for visited object
        sort(modifier);
      }
    });
    return result;
  }

  function orderModifiers(modifiers) {
    // order based on dependencies
    var orderedModifiers = order(modifiers); // order based on phase

    return modifierPhases.reduce(function (acc, phase) {
      return acc.concat(orderedModifiers.filter(function (modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  function debounce(fn) {
    var pending;
    return function () {
      if (!pending) {
        pending = new Promise(function (resolve) {
          Promise.resolve().then(function () {
            pending = undefined;
            resolve(fn());
          });
        });
      }

      return pending;
    };
  }

  function format(str) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return [].concat(args).reduce(function (p, c) {
      return p.replace(/%s/, c);
    }, str);
  }

  var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
  var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
  var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];

  function validateModifiers(modifiers) {
    modifiers.forEach(function (modifier) {
      [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`
      .filter(function (value, index, self) {
        return self.indexOf(value) === index;
      }).forEach(function (key) {
        switch (key) {
          case 'name':
            if (typeof modifier.name !== 'string') {
              console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
            }

            break;

          case 'enabled':
            if (typeof modifier.enabled !== 'boolean') {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
            }

            break;

          case 'phase':
            if (modifierPhases.indexOf(modifier.phase) < 0) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
            }

            break;

          case 'fn':
            if (typeof modifier.fn !== 'function') {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
            }

            break;

          case 'effect':
            if (modifier.effect != null && typeof modifier.effect !== 'function') {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
            }

            break;

          case 'requires':
            if (modifier.requires != null && !Array.isArray(modifier.requires)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
            }

            break;

          case 'requiresIfExists':
            if (!Array.isArray(modifier.requiresIfExists)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
            }

            break;

          case 'options':
          case 'data':
            break;

          default:
            console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
              return "\"" + s + "\"";
            }).join(', ') + "; but \"" + key + "\" was provided.");
        }

        modifier.requires && modifier.requires.forEach(function (requirement) {
          if (modifiers.find(function (mod) {
            return mod.name === requirement;
          }) == null) {
            console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
          }
        });
      });
    });
  }

  function uniqueBy(arr, fn) {
    var identifiers = new Set();
    return arr.filter(function (item) {
      var identifier = fn(item);

      if (!identifiers.has(identifier)) {
        identifiers.add(identifier);
        return true;
      }
    });
  }

  function getBasePlacement(placement) {
    return placement.split('-')[0];
  }

  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function (merged, current) {
      var existing = merged[current.name];
      merged[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged;
    }, {}); // IE11 does not support Object.values

    return Object.keys(merged).map(function (key) {
      return merged[key];
    });
  }

  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;

    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      var layoutViewport = isLayoutViewport();

      if (layoutViewport || !layoutViewport && strategy === 'fixed') {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }

    return {
      width: width,
      height: height,
      x: x + getWindowScrollBarX(element),
      y: y
    };
  } // of the `<html>` and `<body>` rect bounds if horizontally scrollable


  function getDocumentRect(element) {
    var _element$ownerDocumen;

    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;

    if (getComputedStyle(body || html).direction === 'rtl') {
      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }

    return {
      width: width,
      height: height,
      x: x,
      y: y
    };
  }

  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

    if (parent.contains(child)) {
      return true;
    } // then fallback to custom implementation with Shadow DOM support
    else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


    return false;
  }

  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === 'fixed');
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }

  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  } // A "clipping parent" is an overflowable container with the characteristic of
  // clipping (or hiding) overflowing elements with a position different from
  // `initial`


  function getClippingParents(element) {
    var clippingParents = listScrollParents(getParentNode(element));
    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

    if (!isElement(clipperElement)) {
      return [];
    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


    return clippingParents.filter(function (clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
    });
  } // Gets the maximum area that the element is visible in due to any number of
  // clipping parents


  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents[0];
    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  function getVariation(placement) {
    return placement.split('-')[1];
  }

  function getMainAxisFromPlacement(placement) {
    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
  }

  function computeOffsets(_ref) {
    var reference = _ref.reference,
        element = _ref.element,
        placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference.x + reference.width / 2 - element.width / 2;
    var commonY = reference.y + reference.height / 2 - element.height / 2;
    var offsets;

    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference.y - element.height
        };
        break;

      case bottom:
        offsets = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;

      case right:
        offsets = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;

      case left:
        offsets = {
          x: reference.x - element.width,
          y: commonY
        };
        break;

      default:
        offsets = {
          x: reference.x,
          y: reference.y
        };
    }

    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

    if (mainAxis != null) {
      var len = mainAxis === 'y' ? 'height' : 'width';

      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
          break;

        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
          break;
      }
    }

    return offsets;
  }

  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  function expandToHashMap(value, keys) {
    return keys.reduce(function (hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        _options$placement = _options.placement,
        placement = _options$placement === void 0 ? state.placement : _options$placement,
        _options$strategy = _options.strategy,
        strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
        _options$boundary = _options.boundary,
        boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
        _options$rootBoundary = _options.rootBoundary,
        rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
        _options$elementConte = _options.elementContext,
        elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
        _options$altBoundary = _options.altBoundary,
        altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
        _options$padding = _options.padding,
        padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: 'absolute',
      placement: placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
    // 0 or negative = within the clipping rect

    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

    if (elementContext === popper && offsetData) {
      var offset = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function (key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
        overflowOffsets[key] += offset[axis] * multiply;
      });
    }

    return overflowOffsets;
  }

  var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
  var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
  var DEFAULT_OPTIONS = {
    placement: 'bottom',
    modifiers: [],
    strategy: 'absolute'
  };

  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return !args.some(function (element) {
      return !(element && typeof element.getBoundingClientRect === 'function');
    });
  }

  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }

    var _generatorOptions = generatorOptions,
        _generatorOptions$def = _generatorOptions.defaultModifiers,
        defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
        _generatorOptions$def2 = _generatorOptions.defaultOptions,
        defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper(reference, popper, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var state = {
        placement: 'bottom',
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference,
          popper: popper
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state: state,
        setOptions: function setOptions(setOptionsAction) {
          var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions, state.options, options);
          state.scrollParents = {
            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
            popper: listScrollParents(popper)
          }; // Orders the modifiers based on their dependencies and `phase`
          // properties

          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

          state.orderedModifiers = orderedModifiers.filter(function (m) {
            return m.enabled;
          }); // Validate the provided modifiers so that the consumer will get warned
          // if one of the modifiers is invalid for any reason

          {
            var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
              var name = _ref.name;
              return name;
            });
            validateModifiers(modifiers);

            if (getBasePlacement(state.options.placement) === auto) {
              var flipModifier = state.orderedModifiers.find(function (_ref2) {
                var name = _ref2.name;
                return name === 'flip';
              });

              if (!flipModifier) {
                console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
              }
            }

            var _getComputedStyle = getComputedStyle(popper),
                marginTop = _getComputedStyle.marginTop,
                marginRight = _getComputedStyle.marginRight,
                marginBottom = _getComputedStyle.marginBottom,
                marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
            // cause bugs with positioning, so we'll warn the consumer


            if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
              return parseFloat(margin);
            })) {
              console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
            }
          }
          runModifierEffects();
          return instance.update();
        },
        // Sync update  it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }

          var _state$elements = state.elements,
              reference = _state$elements.reference,
              popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
          // anymore

          if (!areValidElements(reference, popper)) {
            {
              console.error(INVALID_ELEMENT_ERROR);
            }
            return;
          } // Store the reference and popper rects to be read by modifiers


          state.rects = {
            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
            popper: getLayoutRect(popper)
          }; // Modifiers have the ability to reset the current update cycle. The
          // most common use case for this is the `flip` modifier changing the
          // placement, which then needs to re-run all the modifiers, because the
          // logic was previously ran for the previous placement and is therefore
          // stale/incorrect

          state.reset = false;
          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
          // is filled with the initial data specified by the modifier. This means
          // it doesn't persist and is fresh on each update.
          // To ensure persistent data, use `${name}#persistent`

          state.orderedModifiers.forEach(function (modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          var __debug_loops__ = 0;

          for (var index = 0; index < state.orderedModifiers.length; index++) {
            {
              __debug_loops__ += 1;

              if (__debug_loops__ > 100) {
                console.error(INFINITE_LOOP_ERROR);
                break;
              }
            }

            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }

            var _state$orderedModifie = state.orderedModifiers[index],
                fn = _state$orderedModifie.fn,
                _state$orderedModifie2 = _state$orderedModifie.options,
                _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                name = _state$orderedModifie.name;

            if (typeof fn === 'function') {
              state = fn({
                state: state,
                options: _options,
                name: name,
                instance: instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update  it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function () {
          return new Promise(function (resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };

      if (!areValidElements(reference, popper)) {
        {
          console.error(INVALID_ELEMENT_ERROR);
        }
        return instance;
      }

      instance.setOptions(options).then(function (state) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state);
        }
      }); // Modifiers have the ability to execute arbitrary code before the first
      // update cycle runs. They will be executed in the same order as the update
      // cycle. This is useful when a modifier adds some persistent data that
      // other modifiers need to use, but the modifier is run after the dependent
      // one.

      function runModifierEffects() {
        state.orderedModifiers.forEach(function (_ref3) {
          var name = _ref3.name,
              _ref3$options = _ref3.options,
              options = _ref3$options === void 0 ? {} : _ref3$options,
              effect = _ref3.effect;

          if (typeof effect === 'function') {
            var cleanupFn = effect({
              state: state,
              name: name,
              instance: instance,
              options: options
            });

            var noopFn = function noopFn() {};

            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }

      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function (fn) {
          return fn();
        });
        effectCleanupFns = [];
      }

      return instance;
    };
  }

  var passive = {
    passive: true
  };

  function effect$2(_ref) {
    var state = _ref.state,
        instance = _ref.instance,
        options = _ref.options;
    var _options$scroll = options.scroll,
        scroll = _options$scroll === void 0 ? true : _options$scroll,
        _options$resize = options.resize,
        resize = _options$resize === void 0 ? true : _options$resize;
    var window = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.addEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.addEventListener('resize', instance.update, passive);
    }

    return function () {
      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.removeEventListener('scroll', instance.update, passive);
        });
      }

      if (resize) {
        window.removeEventListener('resize', instance.update, passive);
      }
    };
  } // eslint-disable-next-line import/no-unused-modules


  var eventListeners = {
    name: 'eventListeners',
    enabled: true,
    phase: 'write',
    fn: function fn() {},
    effect: effect$2,
    data: {}
  };

  function popperOffsets(_ref) {
    var state = _ref.state,
        name = _ref.name; // Offsets are the actual position the popper needs to have to be
    // properly positioned near its reference element
    // This is the most basic placement, and will be adjusted by
    // the modifiers in the next step

    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: 'absolute',
      placement: state.placement
    });
  } // eslint-disable-next-line import/no-unused-modules


  var popperOffsets$1 = {
    name: 'popperOffsets',
    enabled: true,
    phase: 'read',
    fn: popperOffsets,
    data: {}
  };
  var unsetSides = {
    top: 'auto',
    right: 'auto',
    bottom: 'auto',
    left: 'auto'
  }; // Round the offsets to the nearest suitable subpixel based on the DPR.
  // Zooming can change the DPR, but it seems to report a value that will
  // cleanly divide the values into the appropriate subpixels.

  function roundOffsetsByDPR(_ref) {
    var x = _ref.x,
        y = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x * dpr) / dpr || 0,
      y: round(y * dpr) / dpr || 0
    };
  }

  function mapToStyles(_ref2) {
    var _Object$assign2;

    var popper = _ref2.popper,
        popperRect = _ref2.popperRect,
        placement = _ref2.placement,
        variation = _ref2.variation,
        offsets = _ref2.offsets,
        position = _ref2.position,
        gpuAcceleration = _ref2.gpuAcceleration,
        adaptive = _ref2.adaptive,
        roundOffsets = _ref2.roundOffsets,
        isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x,
        x = _offsets$x === void 0 ? 0 : _offsets$x,
        _offsets$y = offsets.y,
        y = _offsets$y === void 0 ? 0 : _offsets$y;

    var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
      x: x,
      y: y
    }) : {
      x: x,
      y: y
    };

    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty('x');
    var hasY = offsets.hasOwnProperty('y');
    var sideX = left;
    var sideY = top;
    var win = window;

    if (adaptive) {
      var offsetParent = getOffsetParent(popper);
      var heightProp = 'clientHeight';
      var widthProp = 'clientWidth';

      if (offsetParent === getWindow(popper)) {
        offsetParent = getDocumentElement(popper);

        if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {
          heightProp = 'scrollHeight';
          widthProp = 'scrollWidth';
        }
      } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


      offsetParent = offsetParent;

      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
        offsetParent[heightProp];
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }

      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
        offsetParent[widthProp];
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }

    var commonStyles = Object.assign({
      position: position
    }, adaptive && unsetSides);

    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x: x,
      y: y
    }) : {
      x: x,
      y: y
    };

    x = _ref4.x;
    y = _ref4.y;

    if (gpuAcceleration) {
      var _Object$assign;

      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }

    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
  }

  function computeStyles(_ref5) {
    var state = _ref5.state,
        options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration,
        gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
        _options$adaptive = options.adaptive,
        adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
        _options$roundOffsets = options.roundOffsets,
        roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    {
      var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || '';

      if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
        return transitionProperty.indexOf(property) >= 0;
      })) {
        console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
      }
    }
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration: gpuAcceleration,
      isFixed: state.options.strategy === 'fixed'
    };

    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive: adaptive,
        roundOffsets: roundOffsets
      })));
    }

    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: 'absolute',
        adaptive: false,
        roundOffsets: roundOffsets
      })));
    }

    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      'data-popper-placement': state.placement
    });
  } // eslint-disable-next-line import/no-unused-modules


  var computeStyles$1 = {
    name: 'computeStyles',
    enabled: true,
    phase: 'beforeWrite',
    fn: computeStyles,
    data: {}
  }; // and applies them to the HTMLElements such as popper and arrow

  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function (name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name]; // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      } // Flow doesn't support to extend this property, but it's the most
      // effective way to apply styles to an HTMLElement
      // $FlowFixMe[cannot-write]


      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (name) {
        var value = attributes[name];

        if (value === false) {
          element.removeAttribute(name);
        } else {
          element.setAttribute(name, value === true ? '' : value);
        }
      });
    });
  }

  function effect$1(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: '0',
        top: '0',
        margin: '0'
      },
      arrow: {
        position: 'absolute'
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;

    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }

    return function () {
      Object.keys(state.elements).forEach(function (name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

        var style = styleProperties.reduce(function (style, property) {
          style[property] = '';
          return style;
        }, {}); // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }

        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  } // eslint-disable-next-line import/no-unused-modules


  var applyStyles$1 = {
    name: 'applyStyles',
    enabled: true,
    phase: 'write',
    fn: applyStyles,
    effect: effect$1,
    requires: ['computeStyles']
  };

  function distanceAndSkiddingToXY(placement, rects, offset) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
      placement: placement
    })) : offset,
        skidding = _ref[0],
        distance = _ref[1];

    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }

  function offset(_ref2) {
    var state = _ref2.state,
        options = _ref2.options,
        name = _ref2.name;
    var _options$offset = options.offset,
        offset = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function (acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement],
        x = _data$state$placement.x,
        y = _data$state$placement.y;

    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }

    state.modifiersData[name] = data;
  } // eslint-disable-next-line import/no-unused-modules


  var offset$1 = {
    name: 'offset',
    enabled: true,
    phase: 'main',
    requires: ['popperOffsets'],
    fn: offset
  };
  var hash$1 = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };

  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash$1[matched];
    });
  }

  var hash = {
    start: 'end',
    end: 'start'
  };

  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function (matched) {
      return hash[matched];
    });
  }

  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        placement = _options.placement,
        boundary = _options.boundary,
        rootBoundary = _options.rootBoundary,
        padding = _options.padding,
        flipVariations = _options.flipVariations,
        _options$allowedAutoP = _options.allowedAutoPlacements,
        allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
      return getVariation(placement) === variation;
    }) : basePlacements;
    var allowedPlacements = placements$1.filter(function (placement) {
      return allowedAutoPlacements.indexOf(placement) >= 0;
    });

    if (allowedPlacements.length === 0) {
      allowedPlacements = placements$1;
      {
        console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
      }
    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


    var overflows = allowedPlacements.reduce(function (acc, placement) {
      acc[placement] = detectOverflow(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding
      })[getBasePlacement(placement)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function (a, b) {
      return overflows[a] - overflows[b];
    });
  }

  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }

    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }

  function flip(_ref) {
    var state = _ref.state,
        options = _ref.options,
        name = _ref.name;

    if (state.modifiersData[name]._skip) {
      return;
    }

    var _options$mainAxis = options.mainAxis,
        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
        _options$altAxis = options.altAxis,
        checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
        specifiedFallbackPlacements = options.fallbackPlacements,
        padding = options.padding,
        boundary = options.boundary,
        rootBoundary = options.rootBoundary,
        altBoundary = options.altBoundary,
        _options$flipVariatio = options.flipVariations,
        flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
        allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
      return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        flipVariations: flipVariations,
        allowedAutoPlacements: allowedAutoPlacements
      }) : placement);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements[0];

    for (var i = 0; i < placements.length; i++) {
      var placement = placements[i];

      var _basePlacement = getBasePlacement(placement);

      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? 'width' : 'height';
      var overflow = detectOverflow(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        altBoundary: altBoundary,
        padding: padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }

      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];

      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }

      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }

      if (checks.every(function (check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }

      checksMap.set(placement, checks);
    }

    if (makeFallbackChecks) {
      // `2` may be desired in some cases  research later
      var numberOfChecks = flipVariations ? 3 : 1;

      var _loop = function _loop(_i) {
        var fittingPlacement = placements.find(function (placement) {
          var checks = checksMap.get(placement);

          if (checks) {
            return checks.slice(0, _i).every(function (check) {
              return check;
            });
          }
        });

        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };

      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);

        if (_ret === "break") break;
      }
    }

    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  } // eslint-disable-next-line import/no-unused-modules


  var flip$1 = {
    name: 'flip',
    enabled: true,
    phase: 'main',
    fn: flip,
    requiresIfExists: ['offset'],
    data: {
      _skip: false
    }
  };

  function getAltAxis(axis) {
    return axis === 'x' ? 'y' : 'x';
  }

  function within(min$1, value, max$1) {
    return max(min$1, min(value, max$1));
  }

  function withinMaxClamp(min, value, max) {
    var v = within(min, value, max);
    return v > max ? max : v;
  }

  function preventOverflow(_ref) {
    var state = _ref.state,
        options = _ref.options,
        name = _ref.name;
    var _options$mainAxis = options.mainAxis,
        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
        _options$altAxis = options.altAxis,
        checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
        boundary = options.boundary,
        rootBoundary = options.rootBoundary,
        altBoundary = options.altBoundary,
        padding = options.padding,
        _options$tether = options.tether,
        tether = _options$tether === void 0 ? true : _options$tether,
        _options$tetherOffset = options.tetherOffset,
        tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      altBoundary: altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };

    if (!popperOffsets) {
      return;
    }

    if (checkMainAxis) {
      var _offsetModifierState$;

      var mainSide = mainAxis === 'y' ? top : left;
      var altSide = mainAxis === 'y' ? bottom : right;
      var len = mainAxis === 'y' ? 'height' : 'width';
      var offset = popperOffsets[mainAxis];
      var min$1 = offset + overflow[mainSide];
      var max$1 = offset - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
      // outside the reference bounds

      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
      // to include its full size in the calculation. If the reference is small
      // and near the edge of a boundary, the popper can overflow even if the
      // reference is not overflowing as well (e.g. virtual elements with no
      // width or height)

      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
      popperOffsets[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset;
    }

    if (checkAltAxis) {
      var _offsetModifierState$2;

      var _mainSide = mainAxis === 'x' ? top : left;

      var _altSide = mainAxis === 'x' ? bottom : right;

      var _offset = popperOffsets[altAxis];

      var _len = altAxis === 'y' ? 'height' : 'width';

      var _min = _offset + overflow[_mainSide];

      var _max = _offset - overflow[_altSide];

      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;

      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

      popperOffsets[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }

    state.modifiersData[name] = data;
  } // eslint-disable-next-line import/no-unused-modules


  var preventOverflow$1 = {
    name: 'preventOverflow',
    enabled: true,
    phase: 'main',
    fn: preventOverflow,
    requiresIfExists: ['offset']
  };

  var toPaddingObject = function toPaddingObject(padding, state) {
    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  };

  function arrow(_ref) {
    var _state$modifiersData$;

    var state = _ref.state,
        name = _ref.name,
        options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? 'height' : 'width';

    if (!arrowElement || !popperOffsets) {
      return;
    }

    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === 'y' ? top : left;
    var maxProp = axis === 'y' ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
    var startDiff = popperOffsets[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
    // outside of the popper bounds

    var min = paddingObject[minProp];
    var max = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset = within(min, center, max); // Prevents breaking syntax highlighting...

    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
  }

  function effect(_ref2) {
    var state = _ref2.state,
        options = _ref2.options;
    var _options$element = options.element,
        arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

    if (arrowElement == null) {
      return;
    } // CSS selector


    if (typeof arrowElement === 'string') {
      arrowElement = state.elements.popper.querySelector(arrowElement);

      if (!arrowElement) {
        return;
      }
    }

    {
      if (!isHTMLElement(arrowElement)) {
        console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
      }
    }

    if (!contains(state.elements.popper, arrowElement)) {
      {
        console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
      }
      return;
    }

    state.elements.arrow = arrowElement;
  } // eslint-disable-next-line import/no-unused-modules


  var arrow$1 = {
    name: 'arrow',
    enabled: true,
    phase: 'main',
    fn: arrow,
    effect: effect,
    requires: ['popperOffsets'],
    requiresIfExists: ['preventOverflow']
  };

  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }

    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }

  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function (side) {
      return overflow[side] >= 0;
    });
  }

  function hide(_ref) {
    var state = _ref.state,
        name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: 'reference'
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets: referenceClippingOffsets,
      popperEscapeOffsets: popperEscapeOffsets,
      isReferenceHidden: isReferenceHidden,
      hasPopperEscaped: hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      'data-popper-reference-hidden': isReferenceHidden,
      'data-popper-escaped': hasPopperEscaped
    });
  } // eslint-disable-next-line import/no-unused-modules


  var hide$1 = {
    name: 'hide',
    enabled: true,
    phase: 'main',
    requiresIfExists: ['preventOverflow'],
    fn: hide
  };
  var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
  var createPopper$1 = /*#__PURE__*/popperGenerator({
    defaultModifiers: defaultModifiers$1
  }); // eslint-disable-next-line import/no-unused-modules

  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
  var createPopper = /*#__PURE__*/popperGenerator({
    defaultModifiers: defaultModifiers
  }); // eslint-disable-next-line import/no-unused-modules

  exports.applyStyles = applyStyles$1;
  exports.arrow = arrow$1;
  exports.computeStyles = computeStyles$1;
  exports.createPopper = createPopper;
  exports.createPopperLite = createPopper$1;
  exports.defaultModifiers = defaultModifiers;
  exports.detectOverflow = detectOverflow;
  exports.eventListeners = eventListeners;
  exports.flip = flip$1;
  exports.hide = hide$1;
  exports.offset = offset$1;
  exports.popperGenerator = popperGenerator;
  exports.popperOffsets = popperOffsets$1;
  exports.preventOverflow = preventOverflow$1;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/*!
  * Bootstrap v5.2.2 (https://getbootstrap.com/)
  * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('@popperjs/core')) : typeof define === 'function' && define.amd ? define(['@popperjs/core'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.bootstrap = factory(global.Popper));
})(this, function (Popper) {
  'use strict';

  var _KEY_TO_DIRECTION;

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null, _defineProperty({}, Symbol.toStringTag, {
      value: 'Module'
    }));

    if (e) {
      var _loop = function _loop(k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function get() {
              return e[k];
            }
          });
        }
      };

      for (var k in e) {
        _loop(k);
      }
    }

    n["default"] = e;
    return Object.freeze(n);
  }

  var Popper__namespace = /*#__PURE__*/_interopNamespace(Popper);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var MAX_UID = 1000000;
  var MILLISECONDS_MULTIPLIER = 1000;
  var TRANSITION_END = 'transitionend'; // Shout-out Angus Croll (https://goo.gl/pxwQGp)

  var toType = function toType(object) {
    if (object === null || object === undefined) {
      return "".concat(object);
    }

    return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
  };
  /**
   * Public Util API
   */


  var getUID = function getUID(prefix) {
    do {
      prefix += Math.floor(Math.random() * MAX_UID);
    } while (document.getElementById(prefix));

    return prefix;
  };

  var getSelector = function getSelector(element) {
    var selector = element.getAttribute('data-bs-target');

    if (!selector || selector === '#') {
      var hrefAttribute = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,
      // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
      // `document.querySelector` will rightfully complain it is invalid.
      // See https://github.com/twbs/bootstrap/issues/32273

      if (!hrefAttribute || !hrefAttribute.includes('#') && !hrefAttribute.startsWith('.')) {
        return null;
      } // Just in case some CMS puts out a full URL with the anchor appended


      if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) {
        hrefAttribute = "#".concat(hrefAttribute.split('#')[1]);
      }

      selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null;
    }

    return selector;
  };

  var getSelectorFromElement = function getSelectorFromElement(element) {
    var selector = getSelector(element);

    if (selector) {
      return document.querySelector(selector) ? selector : null;
    }

    return null;
  };

  var getElementFromSelector = function getElementFromSelector(element) {
    var selector = getSelector(element);
    return selector ? document.querySelector(selector) : null;
  };

  var getTransitionDurationFromElement = function getTransitionDurationFromElement(element) {
    if (!element) {
      return 0;
    } // Get transition-duration of the element


    var _window$getComputedSt = window.getComputedStyle(element),
        transitionDuration = _window$getComputedSt.transitionDuration,
        transitionDelay = _window$getComputedSt.transitionDelay;

    var floatTransitionDuration = Number.parseFloat(transitionDuration);
    var floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found

    if (!floatTransitionDuration && !floatTransitionDelay) {
      return 0;
    } // If multiple durations are defined, take the first


    transitionDuration = transitionDuration.split(',')[0];
    transitionDelay = transitionDelay.split(',')[0];
    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
  };

  var triggerTransitionEnd = function triggerTransitionEnd(element) {
    element.dispatchEvent(new Event(TRANSITION_END));
  };

  var isElement = function isElement(object) {
    if (!object || _typeof(object) !== 'object') {
      return false;
    }

    if (typeof object.jquery !== 'undefined') {
      object = object[0];
    }

    return typeof object.nodeType !== 'undefined';
  };

  var getElement = function getElement(object) {
    // it's a jQuery object or a node element
    if (isElement(object)) {
      return object.jquery ? object[0] : object;
    }

    if (typeof object === 'string' && object.length > 0) {
      return document.querySelector(object);
    }

    return null;
  };

  var isVisible = function isVisible(element) {
    if (!isElement(element) || element.getClientRects().length === 0) {
      return false;
    }

    var elementIsVisible = getComputedStyle(element).getPropertyValue('visibility') === 'visible'; // Handle `details` element as its content may falsie appear visible when it is closed

    var closedDetails = element.closest('details:not([open])');

    if (!closedDetails) {
      return elementIsVisible;
    }

    if (closedDetails !== element) {
      var summary = element.closest('summary');

      if (summary && summary.parentNode !== closedDetails) {
        return false;
      }

      if (summary === null) {
        return false;
      }
    }

    return elementIsVisible;
  };

  var isDisabled = function isDisabled(element) {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }

    if (element.classList.contains('disabled')) {
      return true;
    }

    if (typeof element.disabled !== 'undefined') {
      return element.disabled;
    }

    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
  };

  var findShadowRoot = function findShadowRoot(element) {
    if (!document.documentElement.attachShadow) {
      return null;
    } // Can find the shadow root otherwise it'll return the document


    if (typeof element.getRootNode === 'function') {
      var root = element.getRootNode();
      return root instanceof ShadowRoot ? root : null;
    }

    if (element instanceof ShadowRoot) {
      return element;
    } // when we don't find a shadow root


    if (!element.parentNode) {
      return null;
    }

    return findShadowRoot(element.parentNode);
  };

  var noop = function noop() {};
  /**
   * Trick to restart an element's animation
   *
   * @param {HTMLElement} element
   * @return void
   *
   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
   */


  var reflow = function reflow(element) {
    element.offsetHeight; // eslint-disable-line no-unused-expressions
  };

  var getjQuery = function getjQuery() {
    if (window.jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return window.jQuery;
    }

    return null;
  };

  var DOMContentLoadedCallbacks = [];

  var onDOMContentLoaded = function onDOMContentLoaded(callback) {
    if (document.readyState === 'loading') {
      // add listener on the first call when the document is in loading state
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener('DOMContentLoaded', function () {
          var _iterator = _createForOfIteratorHelper(DOMContentLoadedCallbacks),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _callback = _step.value;

              _callback();
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        });
      }

      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };

  var isRTL = function isRTL() {
    return document.documentElement.dir === 'rtl';
  };

  var defineJQueryPlugin = function defineJQueryPlugin(plugin) {
    onDOMContentLoaded(function () {
      var $ = getjQuery();
      /* istanbul ignore if */

      if ($) {
        var name = plugin.NAME;
        var JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;

        $.fn[name].noConflict = function () {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };

  var execute = function execute(callback) {
    if (typeof callback === 'function') {
      callback();
    }
  };

  var executeAfterTransition = function executeAfterTransition(callback, transitionElement) {
    var waitForTransition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    if (!waitForTransition) {
      execute(callback);
      return;
    }

    var durationPadding = 5;
    var emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
    var called = false;

    var handler = function handler(_ref) {
      var target = _ref.target;

      if (target !== transitionElement) {
        return;
      }

      called = true;
      transitionElement.removeEventListener(TRANSITION_END, handler);
      execute(callback);
    };

    transitionElement.addEventListener(TRANSITION_END, handler);
    setTimeout(function () {
      if (!called) {
        triggerTransitionEnd(transitionElement);
      }
    }, emulatedDuration);
  };
  /**
   * Return the previous/next element of a list.
   *
   * @param {array} list    The list of elements
   * @param activeElement   The active element
   * @param shouldGetNext   Choose to get next or previous element
   * @param isCycleAllowed
   * @return {Element|elem} The proper element
   */


  var getNextActiveElement = function getNextActiveElement(list, activeElement, shouldGetNext, isCycleAllowed) {
    var listLength = list.length;
    var index = list.indexOf(activeElement); // if the element does not exist in the list return an element
    // depending on the direction and if cycle is allowed

    if (index === -1) {
      return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
    }

    index += shouldGetNext ? 1 : -1;

    if (isCycleAllowed) {
      index = (index + listLength) % listLength;
    }

    return list[Math.max(0, Math.min(index, listLength - 1))];
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): dom/event-handler.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */


  var namespaceRegex = /[^.]*(?=\..*)\.|.*/;
  var stripNameRegex = /\..*/;
  var stripUidRegex = /::\d+$/;
  var eventRegistry = {}; // Events storage

  var uidEvent = 1;
  var customEvents = {
    mouseenter: 'mouseover',
    mouseleave: 'mouseout'
  };
  var nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);
  /**
   * Private methods
   */

  function makeEventUid(element, uid) {
    return uid && "".concat(uid, "::").concat(uidEvent++) || element.uidEvent || uidEvent++;
  }

  function getElementEvents(element) {
    var uid = makeEventUid(element);
    element.uidEvent = uid;
    eventRegistry[uid] = eventRegistry[uid] || {};
    return eventRegistry[uid];
  }

  function bootstrapHandler(element, fn) {
    return function handler(event) {
      hydrateObj(event, {
        delegateTarget: element
      });

      if (handler.oneOff) {
        EventHandler.off(element, event.type, fn);
      }

      return fn.apply(element, [event]);
    };
  }

  function bootstrapDelegationHandler(element, selector, fn) {
    return function handler(event) {
      var domElements = element.querySelectorAll(selector);

      for (var target = event.target; target && target !== this; target = target.parentNode) {
        var _iterator2 = _createForOfIteratorHelper(domElements),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var domElement = _step2.value;

            if (domElement !== target) {
              continue;
            }

            hydrateObj(event, {
              delegateTarget: target
            });

            if (handler.oneOff) {
              EventHandler.off(element, event.type, selector, fn);
            }

            return fn.apply(target, [event]);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    };
  }

  function findHandler(events, callable) {
    var delegationSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return Object.values(events).find(function (event) {
      return event.callable === callable && event.delegationSelector === delegationSelector;
    });
  }

  function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
    var isDelegated = typeof handler === 'string'; // todo: tooltip passes `false` instead of selector, so we need to check

    var callable = isDelegated ? delegationFunction : handler || delegationFunction;
    var typeEvent = getTypeEvent(originalTypeEvent);

    if (!nativeEvents.has(typeEvent)) {
      typeEvent = originalTypeEvent;
    }

    return [isDelegated, callable, typeEvent];
  }

  function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
    if (typeof originalTypeEvent !== 'string' || !element) {
      return;
    }

    var _normalizeParameters = normalizeParameters(originalTypeEvent, handler, delegationFunction),
        _normalizeParameters2 = _slicedToArray(_normalizeParameters, 3),
        isDelegated = _normalizeParameters2[0],
        callable = _normalizeParameters2[1],
        typeEvent = _normalizeParameters2[2]; // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position
    // this prevents the handler from being dispatched the same way as mouseover or mouseout does


    if (originalTypeEvent in customEvents) {
      var wrapFunction = function wrapFunction(fn) {
        return function (event) {
          if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
            return fn.call(this, event);
          }
        };
      };

      callable = wrapFunction(callable);
    }

    var events = getElementEvents(element);
    var handlers = events[typeEvent] || (events[typeEvent] = {});
    var previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);

    if (previousFunction) {
      previousFunction.oneOff = previousFunction.oneOff && oneOff;
      return;
    }

    var uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ''));
    var fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
    fn.delegationSelector = isDelegated ? handler : null;
    fn.callable = callable;
    fn.oneOff = oneOff;
    fn.uidEvent = uid;
    handlers[uid] = fn;
    element.addEventListener(typeEvent, fn, isDelegated);
  }

  function removeHandler(element, events, typeEvent, handler, delegationSelector) {
    var fn = findHandler(events[typeEvent], handler, delegationSelector);

    if (!fn) {
      return;
    }

    element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
    delete events[typeEvent][fn.uidEvent];
  }

  function removeNamespacedHandlers(element, events, typeEvent, namespace) {
    var storeElementEvent = events[typeEvent] || {};

    for (var _i2 = 0, _Object$keys = Object.keys(storeElementEvent); _i2 < _Object$keys.length; _i2++) {
      var handlerKey = _Object$keys[_i2];

      if (handlerKey.includes(namespace)) {
        var event = storeElementEvent[handlerKey];
        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
      }
    }
  }

  function getTypeEvent(event) {
    // allow to get the native events from namespaced events ('click.bs.button' --> 'click')
    event = event.replace(stripNameRegex, '');
    return customEvents[event] || event;
  }

  var EventHandler = {
    on: function on(element, event, handler, delegationFunction) {
      addHandler(element, event, handler, delegationFunction, false);
    },
    one: function one(element, event, handler, delegationFunction) {
      addHandler(element, event, handler, delegationFunction, true);
    },
    off: function off(element, originalTypeEvent, handler, delegationFunction) {
      if (typeof originalTypeEvent !== 'string' || !element) {
        return;
      }

      var _normalizeParameters3 = normalizeParameters(originalTypeEvent, handler, delegationFunction),
          _normalizeParameters4 = _slicedToArray(_normalizeParameters3, 3),
          isDelegated = _normalizeParameters4[0],
          callable = _normalizeParameters4[1],
          typeEvent = _normalizeParameters4[2];

      var inNamespace = typeEvent !== originalTypeEvent;
      var events = getElementEvents(element);
      var storeElementEvent = events[typeEvent] || {};
      var isNamespace = originalTypeEvent.startsWith('.');

      if (typeof callable !== 'undefined') {
        // Simplest case: handler is passed, remove that listener ONLY.
        if (!Object.keys(storeElementEvent).length) {
          return;
        }

        removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
        return;
      }

      if (isNamespace) {
        for (var _i3 = 0, _Object$keys2 = Object.keys(events); _i3 < _Object$keys2.length; _i3++) {
          var elementEvent = _Object$keys2[_i3];
          removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
        }
      }

      for (var _i4 = 0, _Object$keys3 = Object.keys(storeElementEvent); _i4 < _Object$keys3.length; _i4++) {
        var keyHandlers = _Object$keys3[_i4];
        var handlerKey = keyHandlers.replace(stripUidRegex, '');

        if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
          var event = storeElementEvent[keyHandlers];
          removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
        }
      }
    },
    trigger: function trigger(element, event, args) {
      if (typeof event !== 'string' || !element) {
        return null;
      }

      var $ = getjQuery();
      var typeEvent = getTypeEvent(event);
      var inNamespace = event !== typeEvent;
      var jQueryEvent = null;
      var bubbles = true;
      var nativeDispatch = true;
      var defaultPrevented = false;

      if (inNamespace && $) {
        jQueryEvent = $.Event(event, args);
        $(element).trigger(jQueryEvent);
        bubbles = !jQueryEvent.isPropagationStopped();
        nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
        defaultPrevented = jQueryEvent.isDefaultPrevented();
      }

      var evt = new Event(event, {
        bubbles: bubbles,
        cancelable: true
      });
      evt = hydrateObj(evt, args);

      if (defaultPrevented) {
        evt.preventDefault();
      }

      if (nativeDispatch) {
        element.dispatchEvent(evt);
      }

      if (evt.defaultPrevented && jQueryEvent) {
        jQueryEvent.preventDefault();
      }

      return evt;
    }
  };

  function hydrateObj(obj, meta) {
    var _loop2 = function _loop2() {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i5], 2),
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];

      try {
        obj[key] = value;
      } catch (_unused) {
        Object.defineProperty(obj, key, {
          configurable: true,
          get: function get() {
            return value;
          }
        });
      }
    };

    for (var _i5 = 0, _Object$entries = Object.entries(meta || {}); _i5 < _Object$entries.length; _i5++) {
      _loop2();
    }

    return obj;
  }
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): dom/data.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */


  var elementMap = new Map();
  var Data = {
    set: function set(element, key, instance) {
      if (!elementMap.has(element)) {
        elementMap.set(element, new Map());
      }

      var instanceMap = elementMap.get(element); // make it clear we only want one instance per element
      // can be removed later when multiple key/instances are fine to be used

      if (!instanceMap.has(key) && instanceMap.size !== 0) {
        // eslint-disable-next-line no-console
        console.error("Bootstrap doesn't allow more than one instance per element. Bound instance: ".concat(Array.from(instanceMap.keys())[0], "."));
        return;
      }

      instanceMap.set(key, instance);
    },
    get: function get(element, key) {
      if (elementMap.has(element)) {
        return elementMap.get(element).get(key) || null;
      }

      return null;
    },
    remove: function remove(element, key) {
      if (!elementMap.has(element)) {
        return;
      }

      var instanceMap = elementMap.get(element);
      instanceMap["delete"](key); // free up element references if there are no instances left for an element

      if (instanceMap.size === 0) {
        elementMap["delete"](element);
      }
    }
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): dom/manipulator.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  function normalizeData(value) {
    if (value === 'true') {
      return true;
    }

    if (value === 'false') {
      return false;
    }

    if (value === Number(value).toString()) {
      return Number(value);
    }

    if (value === '' || value === 'null') {
      return null;
    }

    if (typeof value !== 'string') {
      return value;
    }

    try {
      return JSON.parse(decodeURIComponent(value));
    } catch (_unused) {
      return value;
    }
  }

  function normalizeDataKey(key) {
    return key.replace(/[A-Z]/g, function (chr) {
      return "-".concat(chr.toLowerCase());
    });
  }

  var Manipulator = {
    setDataAttribute: function setDataAttribute(element, key, value) {
      element.setAttribute("data-bs-".concat(normalizeDataKey(key)), value);
    },
    removeDataAttribute: function removeDataAttribute(element, key) {
      element.removeAttribute("data-bs-".concat(normalizeDataKey(key)));
    },
    getDataAttributes: function getDataAttributes(element) {
      if (!element) {
        return {};
      }

      var attributes = {};
      var bsKeys = Object.keys(element.dataset).filter(function (key) {
        return key.startsWith('bs') && !key.startsWith('bsConfig');
      });

      var _iterator3 = _createForOfIteratorHelper(bsKeys),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var key = _step3.value;
          var pureKey = key.replace(/^bs/, '');
          pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
          attributes[pureKey] = normalizeData(element.dataset[key]);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return attributes;
    },
    getDataAttribute: function getDataAttribute(element, key) {
      return normalizeData(element.getAttribute("data-bs-".concat(normalizeDataKey(key))));
    }
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): util/config.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Class definition
   */

  var Config = /*#__PURE__*/function () {
    function Config() {
      _classCallCheck(this, Config);
    }

    _createClass(Config, [{
      key: "_getConfig",
      value: function _getConfig(config) {
        config = this._mergeConfigObj(config);
        config = this._configAfterMerge(config);

        this._typeCheckConfig(config);

        return config;
      }
    }, {
      key: "_configAfterMerge",
      value: function _configAfterMerge(config) {
        return config;
      }
    }, {
      key: "_mergeConfigObj",
      value: function _mergeConfigObj(config, element) {
        var jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, 'config') : {}; // try to parse

        return _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, this.constructor.Default), _typeof(jsonConfig) === 'object' ? jsonConfig : {}), isElement(element) ? Manipulator.getDataAttributes(element) : {}), _typeof(config) === 'object' ? config : {});
      }
    }, {
      key: "_typeCheckConfig",
      value: function _typeCheckConfig(config) {
        var configTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.constructor.DefaultType;

        for (var _i6 = 0, _Object$keys4 = Object.keys(configTypes); _i6 < _Object$keys4.length; _i6++) {
          var property = _Object$keys4[_i6];
          var expectedTypes = configTypes[property];
          var value = config[property];
          var valueType = isElement(value) ? 'element' : toType(value);

          if (!new RegExp(expectedTypes).test(valueType)) {
            throw new TypeError("".concat(this.constructor.NAME.toUpperCase(), ": Option \"").concat(property, "\" provided type \"").concat(valueType, "\" but expected type \"").concat(expectedTypes, "\"."));
          }
        }
      }
    }], [{
      key: "Default",
      get: // Getters
      function get() {
        return {};
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return {};
      }
    }, {
      key: "NAME",
      get: function get() {
        throw new Error('You have to implement the static method "NAME", for each component!');
      }
    }]);

    return Config;
  }();
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): base-component.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */


  var VERSION = '5.2.2';
  /**
   * Class definition
   */

  var BaseComponent = /*#__PURE__*/function (_Config) {
    _inherits(BaseComponent, _Config);

    var _super = _createSuper(BaseComponent);

    function BaseComponent(element, config) {
      var _this;

      _classCallCheck(this, BaseComponent);

      _this = _super.call(this);
      element = getElement(element);

      if (!element) {
        return _possibleConstructorReturn(_this);
      }

      _this._element = element;
      _this._config = _this._getConfig(config);
      Data.set(_this._element, _this.constructor.DATA_KEY, _assertThisInitialized(_this));
      return _this;
    } // Public


    _createClass(BaseComponent, [{
      key: "dispose",
      value: function dispose() {
        Data.remove(this._element, this.constructor.DATA_KEY);
        EventHandler.off(this._element, this.constructor.EVENT_KEY);

        var _iterator4 = _createForOfIteratorHelper(Object.getOwnPropertyNames(this)),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var propertyName = _step4.value;
            this[propertyName] = null;
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      }
    }, {
      key: "_queueCallback",
      value: function _queueCallback(callback, element) {
        var isAnimated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        executeAfterTransition(callback, element, isAnimated);
      }
    }, {
      key: "_getConfig",
      value: function _getConfig(config) {
        config = this._mergeConfigObj(config, this._element);
        config = this._configAfterMerge(config);

        this._typeCheckConfig(config);

        return config;
      } // Static

    }], [{
      key: "getInstance",
      value: function getInstance(element) {
        return Data.get(getElement(element), this.DATA_KEY);
      }
    }, {
      key: "getOrCreateInstance",
      value: function getOrCreateInstance(element) {
        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return this.getInstance(element) || new this(element, _typeof(config) === 'object' ? config : null);
      }
    }, {
      key: "VERSION",
      get: function get() {
        return VERSION;
      }
    }, {
      key: "DATA_KEY",
      get: function get() {
        return "bs.".concat(this.NAME);
      }
    }, {
      key: "EVENT_KEY",
      get: function get() {
        return ".".concat(this.DATA_KEY);
      }
    }, {
      key: "eventName",
      value: function eventName(name) {
        return "".concat(name).concat(this.EVENT_KEY);
      }
    }]);

    return BaseComponent;
  }(Config);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): util/component-functions.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var enableDismissTrigger = function enableDismissTrigger(component) {
    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hide';
    var clickEvent = "click.dismiss".concat(component.EVENT_KEY);
    var name = component.NAME;
    EventHandler.on(document, clickEvent, "[data-bs-dismiss=\"".concat(name, "\"]"), function (event) {
      if (['A', 'AREA'].includes(this.tagName)) {
        event.preventDefault();
      }

      if (isDisabled(this)) {
        return;
      }

      var target = getElementFromSelector(this) || this.closest(".".concat(name));
      var instance = component.getOrCreateInstance(target); // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method

      instance[method]();
    });
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): alert.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */


  var NAME$f = 'alert';
  var DATA_KEY$a = 'bs.alert';
  var EVENT_KEY$b = ".".concat(DATA_KEY$a);
  var EVENT_CLOSE = "close".concat(EVENT_KEY$b);
  var EVENT_CLOSED = "closed".concat(EVENT_KEY$b);
  var CLASS_NAME_FADE$5 = 'fade';
  var CLASS_NAME_SHOW$8 = 'show';
  /**
   * Class definition
   */

  var Alert = /*#__PURE__*/function (_BaseComponent) {
    _inherits(Alert, _BaseComponent);

    var _super2 = _createSuper(Alert);

    function Alert() {
      _classCallCheck(this, Alert);

      return _super2.apply(this, arguments);
    }

    _createClass(Alert, [{
      key: "close",
      value: // Public
      function close() {
        var _this2 = this;

        var closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);

        if (closeEvent.defaultPrevented) {
          return;
        }

        this._element.classList.remove(CLASS_NAME_SHOW$8);

        var isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);

        this._queueCallback(function () {
          return _this2._destroyElement();
        }, this._element, isAnimated);
      } // Private

    }, {
      key: "_destroyElement",
      value: function _destroyElement() {
        this._element.remove();

        EventHandler.trigger(this._element, EVENT_CLOSED);
        this.dispose();
      } // Static

    }], [{
      key: "NAME",
      get: // Getters
      function get() {
        return NAME$f;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        return this.each(function () {
          var data = Alert.getOrCreateInstance(this);

          if (typeof config !== 'string') {
            return;
          }

          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config](this);
        });
      }
    }]);

    return Alert;
  }(BaseComponent);
  /**
   * Data API implementation
   */


  enableDismissTrigger(Alert, 'close');
  /**
   * jQuery
   */

  defineJQueryPlugin(Alert);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): button.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  var NAME$e = 'button';
  var DATA_KEY$9 = 'bs.button';
  var EVENT_KEY$a = ".".concat(DATA_KEY$9);
  var DATA_API_KEY$6 = '.data-api';
  var CLASS_NAME_ACTIVE$3 = 'active';
  var SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
  var EVENT_CLICK_DATA_API$6 = "click".concat(EVENT_KEY$a).concat(DATA_API_KEY$6);
  /**
   * Class definition
   */

  var Button = /*#__PURE__*/function (_BaseComponent2) {
    _inherits(Button, _BaseComponent2);

    var _super3 = _createSuper(Button);

    function Button() {
      _classCallCheck(this, Button);

      return _super3.apply(this, arguments);
    }

    _createClass(Button, [{
      key: "toggle",
      value: // Public
      function toggle() {
        // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method
        this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
      } // Static

    }], [{
      key: "NAME",
      get: // Getters
      function get() {
        return NAME$e;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        return this.each(function () {
          var data = Button.getOrCreateInstance(this);

          if (config === 'toggle') {
            data[config]();
          }
        });
      }
    }]);

    return Button;
  }(BaseComponent);
  /**
   * Data API implementation
   */


  EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, function (event) {
    event.preventDefault();
    var button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
    var data = Button.getOrCreateInstance(button);
    data.toggle();
  });
  /**
   * jQuery
   */

  defineJQueryPlugin(Button);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): dom/selector-engine.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  var SelectorEngine = {
    find: function find(selector) {
      var _ref2;

      var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.documentElement;
      return (_ref2 = []).concat.apply(_ref2, _toConsumableArray(Element.prototype.querySelectorAll.call(element, selector)));
    },
    findOne: function findOne(selector) {
      var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.documentElement;
      return Element.prototype.querySelector.call(element, selector);
    },
    children: function children(element, selector) {
      var _ref3;

      return (_ref3 = []).concat.apply(_ref3, _toConsumableArray(element.children)).filter(function (child) {
        return child.matches(selector);
      });
    },
    parents: function parents(element, selector) {
      var parents = [];
      var ancestor = element.parentNode.closest(selector);

      while (ancestor) {
        parents.push(ancestor);
        ancestor = ancestor.parentNode.closest(selector);
      }

      return parents;
    },
    prev: function prev(element, selector) {
      var previous = element.previousElementSibling;

      while (previous) {
        if (previous.matches(selector)) {
          return [previous];
        }

        previous = previous.previousElementSibling;
      }

      return [];
    },
    // TODO: this is now unused; remove later along with prev()
    next: function next(element, selector) {
      var next = element.nextElementSibling;

      while (next) {
        if (next.matches(selector)) {
          return [next];
        }

        next = next.nextElementSibling;
      }

      return [];
    },
    focusableChildren: function focusableChildren(element) {
      var focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable="true"]'].map(function (selector) {
        return "".concat(selector, ":not([tabindex^=\"-\"])");
      }).join(',');
      return this.find(focusables, element).filter(function (el) {
        return !isDisabled(el) && isVisible(el);
      });
    }
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): util/swipe.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  var NAME$d = 'swipe';
  var EVENT_KEY$9 = '.bs.swipe';
  var EVENT_TOUCHSTART = "touchstart".concat(EVENT_KEY$9);
  var EVENT_TOUCHMOVE = "touchmove".concat(EVENT_KEY$9);
  var EVENT_TOUCHEND = "touchend".concat(EVENT_KEY$9);
  var EVENT_POINTERDOWN = "pointerdown".concat(EVENT_KEY$9);
  var EVENT_POINTERUP = "pointerup".concat(EVENT_KEY$9);
  var POINTER_TYPE_TOUCH = 'touch';
  var POINTER_TYPE_PEN = 'pen';
  var CLASS_NAME_POINTER_EVENT = 'pointer-event';
  var SWIPE_THRESHOLD = 40;
  var Default$c = {
    endCallback: null,
    leftCallback: null,
    rightCallback: null
  };
  var DefaultType$c = {
    endCallback: '(function|null)',
    leftCallback: '(function|null)',
    rightCallback: '(function|null)'
  };
  /**
   * Class definition
   */

  var Swipe = /*#__PURE__*/function (_Config2) {
    _inherits(Swipe, _Config2);

    var _super4 = _createSuper(Swipe);

    function Swipe(element, config) {
      var _this3;

      _classCallCheck(this, Swipe);

      _this3 = _super4.call(this);
      _this3._element = element;

      if (!element || !Swipe.isSupported()) {
        return _possibleConstructorReturn(_this3);
      }

      _this3._config = _this3._getConfig(config);
      _this3._deltaX = 0;
      _this3._supportPointerEvents = Boolean(window.PointerEvent);

      _this3._initEvents();

      return _this3;
    } // Getters


    _createClass(Swipe, [{
      key: "dispose",
      value: // Public
      function dispose() {
        EventHandler.off(this._element, EVENT_KEY$9);
      } // Private

    }, {
      key: "_start",
      value: function _start(event) {
        if (!this._supportPointerEvents) {
          this._deltaX = event.touches[0].clientX;
          return;
        }

        if (this._eventIsPointerPenTouch(event)) {
          this._deltaX = event.clientX;
        }
      }
    }, {
      key: "_end",
      value: function _end(event) {
        if (this._eventIsPointerPenTouch(event)) {
          this._deltaX = event.clientX - this._deltaX;
        }

        this._handleSwipe();

        execute(this._config.endCallback);
      }
    }, {
      key: "_move",
      value: function _move(event) {
        this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
      }
    }, {
      key: "_handleSwipe",
      value: function _handleSwipe() {
        var absDeltaX = Math.abs(this._deltaX);

        if (absDeltaX <= SWIPE_THRESHOLD) {
          return;
        }

        var direction = absDeltaX / this._deltaX;
        this._deltaX = 0;

        if (!direction) {
          return;
        }

        execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
      }
    }, {
      key: "_initEvents",
      value: function _initEvents() {
        var _this4 = this;

        if (this._supportPointerEvents) {
          EventHandler.on(this._element, EVENT_POINTERDOWN, function (event) {
            return _this4._start(event);
          });
          EventHandler.on(this._element, EVENT_POINTERUP, function (event) {
            return _this4._end(event);
          });

          this._element.classList.add(CLASS_NAME_POINTER_EVENT);
        } else {
          EventHandler.on(this._element, EVENT_TOUCHSTART, function (event) {
            return _this4._start(event);
          });
          EventHandler.on(this._element, EVENT_TOUCHMOVE, function (event) {
            return _this4._move(event);
          });
          EventHandler.on(this._element, EVENT_TOUCHEND, function (event) {
            return _this4._end(event);
          });
        }
      }
    }, {
      key: "_eventIsPointerPenTouch",
      value: function _eventIsPointerPenTouch(event) {
        return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
      } // Static

    }], [{
      key: "Default",
      get: function get() {
        return Default$c;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$c;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME$d;
      }
    }, {
      key: "isSupported",
      value: function isSupported() {
        return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;
      }
    }]);

    return Swipe;
  }(Config);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): carousel.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */


  var NAME$c = 'carousel';
  var DATA_KEY$8 = 'bs.carousel';
  var EVENT_KEY$8 = ".".concat(DATA_KEY$8);
  var DATA_API_KEY$5 = '.data-api';
  var ARROW_LEFT_KEY$1 = 'ArrowLeft';
  var ARROW_RIGHT_KEY$1 = 'ArrowRight';
  var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

  var ORDER_NEXT = 'next';
  var ORDER_PREV = 'prev';
  var DIRECTION_LEFT = 'left';
  var DIRECTION_RIGHT = 'right';
  var EVENT_SLIDE = "slide".concat(EVENT_KEY$8);
  var EVENT_SLID = "slid".concat(EVENT_KEY$8);
  var EVENT_KEYDOWN$1 = "keydown".concat(EVENT_KEY$8);
  var EVENT_MOUSEENTER$1 = "mouseenter".concat(EVENT_KEY$8);
  var EVENT_MOUSELEAVE$1 = "mouseleave".concat(EVENT_KEY$8);
  var EVENT_DRAG_START = "dragstart".concat(EVENT_KEY$8);
  var EVENT_LOAD_DATA_API$3 = "load".concat(EVENT_KEY$8).concat(DATA_API_KEY$5);
  var EVENT_CLICK_DATA_API$5 = "click".concat(EVENT_KEY$8).concat(DATA_API_KEY$5);
  var CLASS_NAME_CAROUSEL = 'carousel';
  var CLASS_NAME_ACTIVE$2 = 'active';
  var CLASS_NAME_SLIDE = 'slide';
  var CLASS_NAME_END = 'carousel-item-end';
  var CLASS_NAME_START = 'carousel-item-start';
  var CLASS_NAME_NEXT = 'carousel-item-next';
  var CLASS_NAME_PREV = 'carousel-item-prev';
  var SELECTOR_ACTIVE = '.active';
  var SELECTOR_ITEM = '.carousel-item';
  var SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
  var SELECTOR_ITEM_IMG = '.carousel-item img';
  var SELECTOR_INDICATORS = '.carousel-indicators';
  var SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';
  var SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
  var KEY_TO_DIRECTION = (_KEY_TO_DIRECTION = {}, _defineProperty(_KEY_TO_DIRECTION, ARROW_LEFT_KEY$1, DIRECTION_RIGHT), _defineProperty(_KEY_TO_DIRECTION, ARROW_RIGHT_KEY$1, DIRECTION_LEFT), _KEY_TO_DIRECTION);
  var Default$b = {
    interval: 5000,
    keyboard: true,
    pause: 'hover',
    ride: false,
    touch: true,
    wrap: true
  };
  var DefaultType$b = {
    interval: '(number|boolean)',
    // TODO:v6 remove boolean support
    keyboard: 'boolean',
    pause: '(string|boolean)',
    ride: '(boolean|string)',
    touch: 'boolean',
    wrap: 'boolean'
  };
  /**
   * Class definition
   */

  var Carousel = /*#__PURE__*/function (_BaseComponent3) {
    _inherits(Carousel, _BaseComponent3);

    var _super5 = _createSuper(Carousel);

    function Carousel(element, config) {
      var _this5;

      _classCallCheck(this, Carousel);

      _this5 = _super5.call(this, element, config);
      _this5._interval = null;
      _this5._activeElement = null;
      _this5._isSliding = false;
      _this5.touchTimeout = null;
      _this5._swipeHelper = null;
      _this5._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, _this5._element);

      _this5._addEventListeners();

      if (_this5._config.ride === CLASS_NAME_CAROUSEL) {
        _this5.cycle();
      }

      return _this5;
    } // Getters


    _createClass(Carousel, [{
      key: "next",
      value: // Public
      function next() {
        this._slide(ORDER_NEXT);
      }
    }, {
      key: "nextWhenVisible",
      value: function nextWhenVisible() {
        // FIXME TODO use `document.visibilityState`
        // Don't call next when the page isn't visible
        // or the carousel or its parent isn't visible
        if (!document.hidden && isVisible(this._element)) {
          this.next();
        }
      }
    }, {
      key: "prev",
      value: function prev() {
        this._slide(ORDER_PREV);
      }
    }, {
      key: "pause",
      value: function pause() {
        if (this._isSliding) {
          triggerTransitionEnd(this._element);
        }

        this._clearInterval();
      }
    }, {
      key: "cycle",
      value: function cycle() {
        var _this6 = this;

        this._clearInterval();

        this._updateInterval();

        this._interval = setInterval(function () {
          return _this6.nextWhenVisible();
        }, this._config.interval);
      }
    }, {
      key: "_maybeEnableCycle",
      value: function _maybeEnableCycle() {
        var _this7 = this;

        if (!this._config.ride) {
          return;
        }

        if (this._isSliding) {
          EventHandler.one(this._element, EVENT_SLID, function () {
            return _this7.cycle();
          });
          return;
        }

        this.cycle();
      }
    }, {
      key: "to",
      value: function to(index) {
        var _this8 = this;

        var items = this._getItems();

        if (index > items.length - 1 || index < 0) {
          return;
        }

        if (this._isSliding) {
          EventHandler.one(this._element, EVENT_SLID, function () {
            return _this8.to(index);
          });
          return;
        }

        var activeIndex = this._getItemIndex(this._getActive());

        if (activeIndex === index) {
          return;
        }

        var order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;

        this._slide(order, items[index]);
      }
    }, {
      key: "dispose",
      value: function dispose() {
        if (this._swipeHelper) {
          this._swipeHelper.dispose();
        }

        _get(_getPrototypeOf(Carousel.prototype), "dispose", this).call(this);
      } // Private

    }, {
      key: "_configAfterMerge",
      value: function _configAfterMerge(config) {
        config.defaultInterval = config.interval;
        return config;
      }
    }, {
      key: "_addEventListeners",
      value: function _addEventListeners() {
        var _this9 = this;

        if (this._config.keyboard) {
          EventHandler.on(this._element, EVENT_KEYDOWN$1, function (event) {
            return _this9._keydown(event);
          });
        }

        if (this._config.pause === 'hover') {
          EventHandler.on(this._element, EVENT_MOUSEENTER$1, function () {
            return _this9.pause();
          });
          EventHandler.on(this._element, EVENT_MOUSELEAVE$1, function () {
            return _this9._maybeEnableCycle();
          });
        }

        if (this._config.touch && Swipe.isSupported()) {
          this._addTouchEventListeners();
        }
      }
    }, {
      key: "_addTouchEventListeners",
      value: function _addTouchEventListeners() {
        var _this10 = this;

        var _iterator5 = _createForOfIteratorHelper(SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var img = _step5.value;
            EventHandler.on(img, EVENT_DRAG_START, function (event) {
              return event.preventDefault();
            });
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }

        var endCallBack = function endCallBack() {
          if (_this10._config.pause !== 'hover') {
            return;
          } // If it's a touch-enabled device, mouseenter/leave are fired as
          // part of the mouse compatibility events on first tap - the carousel
          // would stop cycling until user tapped out of it;
          // here, we listen for touchend, explicitly pause the carousel
          // (as if it's the second time we tap on it, mouseenter compat event
          // is NOT fired) and after a timeout (to allow for mouse compatibility
          // events to fire) we explicitly restart cycling


          _this10.pause();

          if (_this10.touchTimeout) {
            clearTimeout(_this10.touchTimeout);
          }

          _this10.touchTimeout = setTimeout(function () {
            return _this10._maybeEnableCycle();
          }, TOUCHEVENT_COMPAT_WAIT + _this10._config.interval);
        };

        var swipeConfig = {
          leftCallback: function leftCallback() {
            return _this10._slide(_this10._directionToOrder(DIRECTION_LEFT));
          },
          rightCallback: function rightCallback() {
            return _this10._slide(_this10._directionToOrder(DIRECTION_RIGHT));
          },
          endCallback: endCallBack
        };
        this._swipeHelper = new Swipe(this._element, swipeConfig);
      }
    }, {
      key: "_keydown",
      value: function _keydown(event) {
        if (/input|textarea/i.test(event.target.tagName)) {
          return;
        }

        var direction = KEY_TO_DIRECTION[event.key];

        if (direction) {
          event.preventDefault();

          this._slide(this._directionToOrder(direction));
        }
      }
    }, {
      key: "_getItemIndex",
      value: function _getItemIndex(element) {
        return this._getItems().indexOf(element);
      }
    }, {
      key: "_setActiveIndicatorElement",
      value: function _setActiveIndicatorElement(index) {
        if (!this._indicatorsElement) {
          return;
        }

        var activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
        activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
        activeIndicator.removeAttribute('aria-current');
        var newActiveIndicator = SelectorEngine.findOne("[data-bs-slide-to=\"".concat(index, "\"]"), this._indicatorsElement);

        if (newActiveIndicator) {
          newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
          newActiveIndicator.setAttribute('aria-current', 'true');
        }
      }
    }, {
      key: "_updateInterval",
      value: function _updateInterval() {
        var element = this._activeElement || this._getActive();

        if (!element) {
          return;
        }

        var elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);
        this._config.interval = elementInterval || this._config.defaultInterval;
      }
    }, {
      key: "_slide",
      value: function _slide(order) {
        var _this11 = this;

        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        if (this._isSliding) {
          return;
        }

        var activeElement = this._getActive();

        var isNext = order === ORDER_NEXT;
        var nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);

        if (nextElement === activeElement) {
          return;
        }

        var nextElementIndex = this._getItemIndex(nextElement);

        var triggerEvent = function triggerEvent(eventName) {
          return EventHandler.trigger(_this11._element, eventName, {
            relatedTarget: nextElement,
            direction: _this11._orderToDirection(order),
            from: _this11._getItemIndex(activeElement),
            to: nextElementIndex
          });
        };

        var slideEvent = triggerEvent(EVENT_SLIDE);

        if (slideEvent.defaultPrevented) {
          return;
        }

        if (!activeElement || !nextElement) {
          // Some weirdness is happening, so we bail
          // todo: change tests that use empty divs to avoid this check
          return;
        }

        var isCycling = Boolean(this._interval);
        this.pause();
        this._isSliding = true;

        this._setActiveIndicatorElement(nextElementIndex);

        this._activeElement = nextElement;
        var directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
        var orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
        nextElement.classList.add(orderClassName);
        reflow(nextElement);
        activeElement.classList.add(directionalClassName);
        nextElement.classList.add(directionalClassName);

        var completeCallBack = function completeCallBack() {
          nextElement.classList.remove(directionalClassName, orderClassName);
          nextElement.classList.add(CLASS_NAME_ACTIVE$2);
          activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
          _this11._isSliding = false;
          triggerEvent(EVENT_SLID);
        };

        this._queueCallback(completeCallBack, activeElement, this._isAnimated());

        if (isCycling) {
          this.cycle();
        }
      }
    }, {
      key: "_isAnimated",
      value: function _isAnimated() {
        return this._element.classList.contains(CLASS_NAME_SLIDE);
      }
    }, {
      key: "_getActive",
      value: function _getActive() {
        return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
      }
    }, {
      key: "_getItems",
      value: function _getItems() {
        return SelectorEngine.find(SELECTOR_ITEM, this._element);
      }
    }, {
      key: "_clearInterval",
      value: function _clearInterval() {
        if (this._interval) {
          clearInterval(this._interval);
          this._interval = null;
        }
      }
    }, {
      key: "_directionToOrder",
      value: function _directionToOrder(direction) {
        if (isRTL()) {
          return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
        }

        return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
      }
    }, {
      key: "_orderToDirection",
      value: function _orderToDirection(order) {
        if (isRTL()) {
          return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }

        return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
      } // Static

    }], [{
      key: "Default",
      get: function get() {
        return Default$b;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$b;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME$c;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        return this.each(function () {
          var data = Carousel.getOrCreateInstance(this, config);

          if (typeof config === 'number') {
            data.to(config);
            return;
          }

          if (typeof config === 'string') {
            if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
              throw new TypeError("No method named \"".concat(config, "\""));
            }

            data[config]();
          }
        });
      }
    }]);

    return Carousel;
  }(BaseComponent);
  /**
   * Data API implementation
   */


  EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function (event) {
    var target = getElementFromSelector(this);

    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
      return;
    }

    event.preventDefault();
    var carousel = Carousel.getOrCreateInstance(target);
    var slideIndex = this.getAttribute('data-bs-slide-to');

    if (slideIndex) {
      carousel.to(slideIndex);

      carousel._maybeEnableCycle();

      return;
    }

    if (Manipulator.getDataAttribute(this, 'slide') === 'next') {
      carousel.next();

      carousel._maybeEnableCycle();

      return;
    }

    carousel.prev();

    carousel._maybeEnableCycle();
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API$3, function () {
    var carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);

    var _iterator6 = _createForOfIteratorHelper(carousels),
        _step6;

    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var carousel = _step6.value;
        Carousel.getOrCreateInstance(carousel);
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }
  });
  /**
   * jQuery
   */

  defineJQueryPlugin(Carousel);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): collapse.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  var NAME$b = 'collapse';
  var DATA_KEY$7 = 'bs.collapse';
  var EVENT_KEY$7 = ".".concat(DATA_KEY$7);
  var DATA_API_KEY$4 = '.data-api';
  var EVENT_SHOW$6 = "show".concat(EVENT_KEY$7);
  var EVENT_SHOWN$6 = "shown".concat(EVENT_KEY$7);
  var EVENT_HIDE$6 = "hide".concat(EVENT_KEY$7);
  var EVENT_HIDDEN$6 = "hidden".concat(EVENT_KEY$7);
  var EVENT_CLICK_DATA_API$4 = "click".concat(EVENT_KEY$7).concat(DATA_API_KEY$4);
  var CLASS_NAME_SHOW$7 = 'show';
  var CLASS_NAME_COLLAPSE = 'collapse';
  var CLASS_NAME_COLLAPSING = 'collapsing';
  var CLASS_NAME_COLLAPSED = 'collapsed';
  var CLASS_NAME_DEEPER_CHILDREN = ":scope .".concat(CLASS_NAME_COLLAPSE, " .").concat(CLASS_NAME_COLLAPSE);
  var CLASS_NAME_HORIZONTAL = 'collapse-horizontal';
  var WIDTH = 'width';
  var HEIGHT = 'height';
  var SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';
  var SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
  var Default$a = {
    parent: null,
    toggle: true
  };
  var DefaultType$a = {
    parent: '(null|element)',
    toggle: 'boolean'
  };
  /**
   * Class definition
   */

  var Collapse = /*#__PURE__*/function (_BaseComponent4) {
    _inherits(Collapse, _BaseComponent4);

    var _super6 = _createSuper(Collapse);

    function Collapse(element, config) {
      var _this12;

      _classCallCheck(this, Collapse);

      _this12 = _super6.call(this, element, config);
      _this12._isTransitioning = false;
      _this12._triggerArray = [];
      var toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);

      var _iterator7 = _createForOfIteratorHelper(toggleList),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var elem = _step7.value;
          var selector = getSelectorFromElement(elem);
          var filterElement = SelectorEngine.find(selector).filter(function (foundElement) {
            return foundElement === _this12._element;
          });

          if (selector !== null && filterElement.length) {
            _this12._triggerArray.push(elem);
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }

      _this12._initializeChildren();

      if (!_this12._config.parent) {
        _this12._addAriaAndCollapsedClass(_this12._triggerArray, _this12._isShown());
      }

      if (_this12._config.toggle) {
        _this12.toggle();
      }

      return _this12;
    } // Getters


    _createClass(Collapse, [{
      key: "toggle",
      value: // Public
      function toggle() {
        if (this._isShown()) {
          this.hide();
        } else {
          this.show();
        }
      }
    }, {
      key: "show",
      value: function show() {
        var _this13 = this;

        if (this._isTransitioning || this._isShown()) {
          return;
        }

        var activeChildren = []; // find active children

        if (this._config.parent) {
          activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter(function (element) {
            return element !== _this13._element;
          }).map(function (element) {
            return Collapse.getOrCreateInstance(element, {
              toggle: false
            });
          });
        }

        if (activeChildren.length && activeChildren[0]._isTransitioning) {
          return;
        }

        var startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);

        if (startEvent.defaultPrevented) {
          return;
        }

        var _iterator8 = _createForOfIteratorHelper(activeChildren),
            _step8;

        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
            var activeInstance = _step8.value;
            activeInstance.hide();
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }

        var dimension = this._getDimension();

        this._element.classList.remove(CLASS_NAME_COLLAPSE);

        this._element.classList.add(CLASS_NAME_COLLAPSING);

        this._element.style[dimension] = 0;

        this._addAriaAndCollapsedClass(this._triggerArray, true);

        this._isTransitioning = true;

        var complete = function complete() {
          _this13._isTransitioning = false;

          _this13._element.classList.remove(CLASS_NAME_COLLAPSING);

          _this13._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);

          _this13._element.style[dimension] = '';
          EventHandler.trigger(_this13._element, EVENT_SHOWN$6);
        };

        var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
        var scrollSize = "scroll".concat(capitalizedDimension);

        this._queueCallback(complete, this._element, true);

        this._element.style[dimension] = "".concat(this._element[scrollSize], "px");
      }
    }, {
      key: "hide",
      value: function hide() {
        var _this14 = this;

        if (this._isTransitioning || !this._isShown()) {
          return;
        }

        var startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);

        if (startEvent.defaultPrevented) {
          return;
        }

        var dimension = this._getDimension();

        this._element.style[dimension] = "".concat(this._element.getBoundingClientRect()[dimension], "px");
        reflow(this._element);

        this._element.classList.add(CLASS_NAME_COLLAPSING);

        this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);

        var _iterator9 = _createForOfIteratorHelper(this._triggerArray),
            _step9;

        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var trigger = _step9.value;
            var element = getElementFromSelector(trigger);

            if (element && !this._isShown(element)) {
              this._addAriaAndCollapsedClass([trigger], false);
            }
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }

        this._isTransitioning = true;

        var complete = function complete() {
          _this14._isTransitioning = false;

          _this14._element.classList.remove(CLASS_NAME_COLLAPSING);

          _this14._element.classList.add(CLASS_NAME_COLLAPSE);

          EventHandler.trigger(_this14._element, EVENT_HIDDEN$6);
        };

        this._element.style[dimension] = '';

        this._queueCallback(complete, this._element, true);
      }
    }, {
      key: "_isShown",
      value: function _isShown() {
        var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._element;
        return element.classList.contains(CLASS_NAME_SHOW$7);
      } // Private

    }, {
      key: "_configAfterMerge",
      value: function _configAfterMerge(config) {
        config.toggle = Boolean(config.toggle); // Coerce string values

        config.parent = getElement(config.parent);
        return config;
      }
    }, {
      key: "_getDimension",
      value: function _getDimension() {
        return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
      }
    }, {
      key: "_initializeChildren",
      value: function _initializeChildren() {
        if (!this._config.parent) {
          return;
        }

        var children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);

        var _iterator10 = _createForOfIteratorHelper(children),
            _step10;

        try {
          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
            var element = _step10.value;
            var selected = getElementFromSelector(element);

            if (selected) {
              this._addAriaAndCollapsedClass([element], this._isShown(selected));
            }
          }
        } catch (err) {
          _iterator10.e(err);
        } finally {
          _iterator10.f();
        }
      }
    }, {
      key: "_getFirstLevelChildren",
      value: function _getFirstLevelChildren(selector) {
        var children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent); // remove children if greater depth

        return SelectorEngine.find(selector, this._config.parent).filter(function (element) {
          return !children.includes(element);
        });
      }
    }, {
      key: "_addAriaAndCollapsedClass",
      value: function _addAriaAndCollapsedClass(triggerArray, isOpen) {
        if (!triggerArray.length) {
          return;
        }

        var _iterator11 = _createForOfIteratorHelper(triggerArray),
            _step11;

        try {
          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
            var element = _step11.value;
            element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
            element.setAttribute('aria-expanded', isOpen);
          }
        } catch (err) {
          _iterator11.e(err);
        } finally {
          _iterator11.f();
        }
      } // Static

    }], [{
      key: "Default",
      get: function get() {
        return Default$a;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$a;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME$b;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        var _config = {};

        if (typeof config === 'string' && /show|hide/.test(config)) {
          _config.toggle = false;
        }

        return this.each(function () {
          var data = Collapse.getOrCreateInstance(this, _config);

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"".concat(config, "\""));
            }

            data[config]();
          }
        });
      }
    }]);

    return Collapse;
  }(BaseComponent);
  /**
   * Data API implementation
   */


  EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {
    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
    if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {
      event.preventDefault();
    }

    var selector = getSelectorFromElement(this);
    var selectorElements = SelectorEngine.find(selector);

    var _iterator12 = _createForOfIteratorHelper(selectorElements),
        _step12;

    try {
      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
        var element = _step12.value;
        Collapse.getOrCreateInstance(element, {
          toggle: false
        }).toggle();
      }
    } catch (err) {
      _iterator12.e(err);
    } finally {
      _iterator12.f();
    }
  });
  /**
   * jQuery
   */

  defineJQueryPlugin(Collapse);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): dropdown.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  var NAME$a = 'dropdown';
  var DATA_KEY$6 = 'bs.dropdown';
  var EVENT_KEY$6 = ".".concat(DATA_KEY$6);
  var DATA_API_KEY$3 = '.data-api';
  var ESCAPE_KEY$2 = 'Escape';
  var TAB_KEY$1 = 'Tab';
  var ARROW_UP_KEY$1 = 'ArrowUp';
  var ARROW_DOWN_KEY$1 = 'ArrowDown';
  var RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button

  var EVENT_HIDE$5 = "hide".concat(EVENT_KEY$6);
  var EVENT_HIDDEN$5 = "hidden".concat(EVENT_KEY$6);
  var EVENT_SHOW$5 = "show".concat(EVENT_KEY$6);
  var EVENT_SHOWN$5 = "shown".concat(EVENT_KEY$6);
  var EVENT_CLICK_DATA_API$3 = "click".concat(EVENT_KEY$6).concat(DATA_API_KEY$3);
  var EVENT_KEYDOWN_DATA_API = "keydown".concat(EVENT_KEY$6).concat(DATA_API_KEY$3);
  var EVENT_KEYUP_DATA_API = "keyup".concat(EVENT_KEY$6).concat(DATA_API_KEY$3);
  var CLASS_NAME_SHOW$6 = 'show';
  var CLASS_NAME_DROPUP = 'dropup';
  var CLASS_NAME_DROPEND = 'dropend';
  var CLASS_NAME_DROPSTART = 'dropstart';
  var CLASS_NAME_DROPUP_CENTER = 'dropup-center';
  var CLASS_NAME_DROPDOWN_CENTER = 'dropdown-center';
  var SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
  var SELECTOR_DATA_TOGGLE_SHOWN = "".concat(SELECTOR_DATA_TOGGLE$3, ".").concat(CLASS_NAME_SHOW$6);
  var SELECTOR_MENU = '.dropdown-menu';
  var SELECTOR_NAVBAR = '.navbar';
  var SELECTOR_NAVBAR_NAV = '.navbar-nav';
  var SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';
  var PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';
  var PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';
  var PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';
  var PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';
  var PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';
  var PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';
  var PLACEMENT_TOPCENTER = 'top';
  var PLACEMENT_BOTTOMCENTER = 'bottom';
  var Default$9 = {
    autoClose: true,
    boundary: 'clippingParents',
    display: 'dynamic',
    offset: [0, 2],
    popperConfig: null,
    reference: 'toggle'
  };
  var DefaultType$9 = {
    autoClose: '(boolean|string)',
    boundary: '(string|element)',
    display: 'string',
    offset: '(array|string|function)',
    popperConfig: '(null|object|function)',
    reference: '(string|element|object)'
  };
  /**
   * Class definition
   */

  var Dropdown = /*#__PURE__*/function (_BaseComponent5) {
    _inherits(Dropdown, _BaseComponent5);

    var _super7 = _createSuper(Dropdown);

    function Dropdown(element, config) {
      var _this15;

      _classCallCheck(this, Dropdown);

      _this15 = _super7.call(this, element, config);
      _this15._popper = null;
      _this15._parent = _this15._element.parentNode; // dropdown wrapper
      // todo: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.2/forms/input-group/

      _this15._menu = SelectorEngine.next(_this15._element, SELECTOR_MENU)[0] || SelectorEngine.prev(_this15._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, _this15._parent);
      _this15._inNavbar = _this15._detectNavbar();
      return _this15;
    } // Getters


    _createClass(Dropdown, [{
      key: "toggle",
      value: // Public
      function toggle() {
        return this._isShown() ? this.hide() : this.show();
      }
    }, {
      key: "show",
      value: function show() {
        if (isDisabled(this._element) || this._isShown()) {
          return;
        }

        var relatedTarget = {
          relatedTarget: this._element
        };
        var showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);

        if (showEvent.defaultPrevented) {
          return;
        }

        this._createPopper(); // If this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html


        if ('ontouchstart' in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {
          var _ref4;

          var _iterator13 = _createForOfIteratorHelper((_ref4 = []).concat.apply(_ref4, _toConsumableArray(document.body.children))),
              _step13;

          try {
            for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
              var element = _step13.value;
              EventHandler.on(element, 'mouseover', noop);
            }
          } catch (err) {
            _iterator13.e(err);
          } finally {
            _iterator13.f();
          }
        }

        this._element.focus();

        this._element.setAttribute('aria-expanded', true);

        this._menu.classList.add(CLASS_NAME_SHOW$6);

        this._element.classList.add(CLASS_NAME_SHOW$6);

        EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
      }
    }, {
      key: "hide",
      value: function hide() {
        if (isDisabled(this._element) || !this._isShown()) {
          return;
        }

        var relatedTarget = {
          relatedTarget: this._element
        };

        this._completeHide(relatedTarget);
      }
    }, {
      key: "dispose",
      value: function dispose() {
        if (this._popper) {
          this._popper.destroy();
        }

        _get(_getPrototypeOf(Dropdown.prototype), "dispose", this).call(this);
      }
    }, {
      key: "update",
      value: function update() {
        this._inNavbar = this._detectNavbar();

        if (this._popper) {
          this._popper.update();
        }
      } // Private

    }, {
      key: "_completeHide",
      value: function _completeHide(relatedTarget) {
        var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);

        if (hideEvent.defaultPrevented) {
          return;
        } // If this is a touch-enabled device we remove the extra
        // empty mouseover listeners we added for iOS support


        if ('ontouchstart' in document.documentElement) {
          var _ref5;

          var _iterator14 = _createForOfIteratorHelper((_ref5 = []).concat.apply(_ref5, _toConsumableArray(document.body.children))),
              _step14;

          try {
            for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
              var element = _step14.value;
              EventHandler.off(element, 'mouseover', noop);
            }
          } catch (err) {
            _iterator14.e(err);
          } finally {
            _iterator14.f();
          }
        }

        if (this._popper) {
          this._popper.destroy();
        }

        this._menu.classList.remove(CLASS_NAME_SHOW$6);

        this._element.classList.remove(CLASS_NAME_SHOW$6);

        this._element.setAttribute('aria-expanded', 'false');

        Manipulator.removeDataAttribute(this._menu, 'popper');
        EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
      }
    }, {
      key: "_getConfig",
      value: function _getConfig(config) {
        config = _get(_getPrototypeOf(Dropdown.prototype), "_getConfig", this).call(this, config);

        if (_typeof(config.reference) === 'object' && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {
          // Popper virtual elements require a getBoundingClientRect method
          throw new TypeError("".concat(NAME$a.toUpperCase(), ": Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method."));
        }

        return config;
      }
    }, {
      key: "_createPopper",
      value: function _createPopper() {
        if (typeof Popper__namespace === 'undefined') {
          throw new TypeError('Bootstrap\'s dropdowns require Popper (https://popper.js.org)');
        }

        var referenceElement = this._element;

        if (this._config.reference === 'parent') {
          referenceElement = this._parent;
        } else if (isElement(this._config.reference)) {
          referenceElement = getElement(this._config.reference);
        } else if (_typeof(this._config.reference) === 'object') {
          referenceElement = this._config.reference;
        }

        var popperConfig = this._getPopperConfig();

        this._popper = Popper__namespace.createPopper(referenceElement, this._menu, popperConfig);
      }
    }, {
      key: "_isShown",
      value: function _isShown() {
        return this._menu.classList.contains(CLASS_NAME_SHOW$6);
      }
    }, {
      key: "_getPlacement",
      value: function _getPlacement() {
        var parentDropdown = this._parent;

        if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
          return PLACEMENT_RIGHT;
        }

        if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
          return PLACEMENT_LEFT;
        }

        if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
          return PLACEMENT_TOPCENTER;
        }

        if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
          return PLACEMENT_BOTTOMCENTER;
        } // We need to trim the value because custom properties can also include spaces


        var isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';

        if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
          return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
        }

        return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
      }
    }, {
      key: "_detectNavbar",
      value: function _detectNavbar() {
        return this._element.closest(SELECTOR_NAVBAR) !== null;
      }
    }, {
      key: "_getOffset",
      value: function _getOffset() {
        var _this16 = this;

        var offset = this._config.offset;

        if (typeof offset === 'string') {
          return offset.split(',').map(function (value) {
            return Number.parseInt(value, 10);
          });
        }

        if (typeof offset === 'function') {
          return function (popperData) {
            return offset(popperData, _this16._element);
          };
        }

        return offset;
      }
    }, {
      key: "_getPopperConfig",
      value: function _getPopperConfig() {
        var defaultBsPopperConfig = {
          placement: this._getPlacement(),
          modifiers: [{
            name: 'preventOverflow',
            options: {
              boundary: this._config.boundary
            }
          }, {
            name: 'offset',
            options: {
              offset: this._getOffset()
            }
          }]
        }; // Disable Popper if we have a static display or Dropdown is in Navbar

        if (this._inNavbar || this._config.display === 'static') {
          Manipulator.setDataAttribute(this._menu, 'popper', 'static'); // todo:v6 remove

          defaultBsPopperConfig.modifiers = [{
            name: 'applyStyles',
            enabled: false
          }];
        }

        return _objectSpread(_objectSpread({}, defaultBsPopperConfig), typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig);
      }
    }, {
      key: "_selectMenuItem",
      value: function _selectMenuItem(_ref6) {
        var key = _ref6.key,
            target = _ref6.target;
        var items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(function (element) {
          return isVisible(element);
        });

        if (!items.length) {
          return;
        } // if target isn't included in items (e.g. when expanding the dropdown)
        // allow cycling to get the last item in case key equals ARROW_UP_KEY


        getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
      } // Static

    }], [{
      key: "Default",
      get: function get() {
        return Default$9;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$9;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME$a;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        return this.each(function () {
          var data = Dropdown.getOrCreateInstance(this, config);

          if (typeof config !== 'string') {
            return;
          }

          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config]();
        });
      }
    }, {
      key: "clearMenus",
      value: function clearMenus(event) {
        if (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY$1) {
          return;
        }

        var openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);

        var _iterator15 = _createForOfIteratorHelper(openToggles),
            _step15;

        try {
          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
            var toggle = _step15.value;
            var context = Dropdown.getInstance(toggle);

            if (!context || context._config.autoClose === false) {
              continue;
            }

            var composedPath = event.composedPath();
            var isMenuTarget = composedPath.includes(context._menu);

            if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {
              continue;
            } // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu


            if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
              continue;
            }

            var relatedTarget = {
              relatedTarget: context._element
            };

            if (event.type === 'click') {
              relatedTarget.clickEvent = event;
            }

            context._completeHide(relatedTarget);
          }
        } catch (err) {
          _iterator15.e(err);
        } finally {
          _iterator15.f();
        }
      }
    }, {
      key: "dataApiKeydownHandler",
      value: function dataApiKeydownHandler(event) {
        // If not an UP | DOWN | ESCAPE key => not a dropdown command
        // If input/textarea && if key is other than ESCAPE => not a dropdown command
        var isInput = /input|textarea/i.test(event.target.tagName);
        var isEscapeEvent = event.key === ESCAPE_KEY$2;
        var isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);

        if (!isUpOrDownEvent && !isEscapeEvent) {
          return;
        }

        if (isInput && !isEscapeEvent) {
          return;
        }

        event.preventDefault(); // todo: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.2/forms/input-group/

        var getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
        var instance = Dropdown.getOrCreateInstance(getToggleButton);

        if (isUpOrDownEvent) {
          event.stopPropagation();
          instance.show();

          instance._selectMenuItem(event);

          return;
        }

        if (instance._isShown()) {
          // else is escape and we check if it is shown
          event.stopPropagation();
          instance.hide();
          getToggleButton.focus();
        }
      }
    }]);

    return Dropdown;
  }(BaseComponent);
  /**
   * Data API implementation
   */


  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
  EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
  EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
  EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {
    event.preventDefault();
    Dropdown.getOrCreateInstance(this).toggle();
  });
  /**
   * jQuery
   */

  defineJQueryPlugin(Dropdown);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): util/scrollBar.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  var SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';
  var SELECTOR_STICKY_CONTENT = '.sticky-top';
  var PROPERTY_PADDING = 'padding-right';
  var PROPERTY_MARGIN = 'margin-right';
  /**
   * Class definition
   */

  var ScrollBarHelper = /*#__PURE__*/function () {
    function ScrollBarHelper() {
      _classCallCheck(this, ScrollBarHelper);

      this._element = document.body;
    } // Public


    _createClass(ScrollBarHelper, [{
      key: "getWidth",
      value: function getWidth() {
        // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
        var documentWidth = document.documentElement.clientWidth;
        return Math.abs(window.innerWidth - documentWidth);
      }
    }, {
      key: "hide",
      value: function hide() {
        var width = this.getWidth();

        this._disableOverFlow(); // give padding to element to balance the hidden scrollbar width


        this._setElementAttributes(this._element, PROPERTY_PADDING, function (calculatedValue) {
          return calculatedValue + width;
        }); // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth


        this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, function (calculatedValue) {
          return calculatedValue + width;
        });

        this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, function (calculatedValue) {
          return calculatedValue - width;
        });
      }
    }, {
      key: "reset",
      value: function reset() {
        this._resetElementAttributes(this._element, 'overflow');

        this._resetElementAttributes(this._element, PROPERTY_PADDING);

        this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);

        this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
      }
    }, {
      key: "isOverflowing",
      value: function isOverflowing() {
        return this.getWidth() > 0;
      } // Private

    }, {
      key: "_disableOverFlow",
      value: function _disableOverFlow() {
        this._saveInitialAttribute(this._element, 'overflow');

        this._element.style.overflow = 'hidden';
      }
    }, {
      key: "_setElementAttributes",
      value: function _setElementAttributes(selector, styleProperty, callback) {
        var _this17 = this;

        var scrollbarWidth = this.getWidth();

        var manipulationCallBack = function manipulationCallBack(element) {
          if (element !== _this17._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
            return;
          }

          _this17._saveInitialAttribute(element, styleProperty);

          var calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
          element.style.setProperty(styleProperty, "".concat(callback(Number.parseFloat(calculatedValue)), "px"));
        };

        this._applyManipulationCallback(selector, manipulationCallBack);
      }
    }, {
      key: "_saveInitialAttribute",
      value: function _saveInitialAttribute(element, styleProperty) {
        var actualValue = element.style.getPropertyValue(styleProperty);

        if (actualValue) {
          Manipulator.setDataAttribute(element, styleProperty, actualValue);
        }
      }
    }, {
      key: "_resetElementAttributes",
      value: function _resetElementAttributes(selector, styleProperty) {
        var manipulationCallBack = function manipulationCallBack(element) {
          var value = Manipulator.getDataAttribute(element, styleProperty); // We only want to remove the property if the value is `null`; the value can also be zero

          if (value === null) {
            element.style.removeProperty(styleProperty);
            return;
          }

          Manipulator.removeDataAttribute(element, styleProperty);
          element.style.setProperty(styleProperty, value);
        };

        this._applyManipulationCallback(selector, manipulationCallBack);
      }
    }, {
      key: "_applyManipulationCallback",
      value: function _applyManipulationCallback(selector, callBack) {
        if (isElement(selector)) {
          callBack(selector);
          return;
        }

        var _iterator16 = _createForOfIteratorHelper(SelectorEngine.find(selector, this._element)),
            _step16;

        try {
          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
            var sel = _step16.value;
            callBack(sel);
          }
        } catch (err) {
          _iterator16.e(err);
        } finally {
          _iterator16.f();
        }
      }
    }]);

    return ScrollBarHelper;
  }();
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): util/backdrop.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */


  var NAME$9 = 'backdrop';
  var CLASS_NAME_FADE$4 = 'fade';
  var CLASS_NAME_SHOW$5 = 'show';
  var EVENT_MOUSEDOWN = "mousedown.bs.".concat(NAME$9);
  var Default$8 = {
    className: 'modal-backdrop',
    clickCallback: null,
    isAnimated: false,
    isVisible: true,
    // if false, we use the backdrop helper without adding any element to the dom
    rootElement: 'body' // give the choice to place backdrop under different elements

  };
  var DefaultType$8 = {
    className: 'string',
    clickCallback: '(function|null)',
    isAnimated: 'boolean',
    isVisible: 'boolean',
    rootElement: '(element|string)'
  };
  /**
   * Class definition
   */

  var Backdrop = /*#__PURE__*/function (_Config3) {
    _inherits(Backdrop, _Config3);

    var _super8 = _createSuper(Backdrop);

    function Backdrop(config) {
      var _this18;

      _classCallCheck(this, Backdrop);

      _this18 = _super8.call(this);
      _this18._config = _this18._getConfig(config);
      _this18._isAppended = false;
      _this18._element = null;
      return _this18;
    } // Getters


    _createClass(Backdrop, [{
      key: "show",
      value: // Public
      function show(callback) {
        if (!this._config.isVisible) {
          execute(callback);
          return;
        }

        this._append();

        var element = this._getElement();

        if (this._config.isAnimated) {
          reflow(element);
        }

        element.classList.add(CLASS_NAME_SHOW$5);

        this._emulateAnimation(function () {
          execute(callback);
        });
      }
    }, {
      key: "hide",
      value: function hide(callback) {
        var _this19 = this;

        if (!this._config.isVisible) {
          execute(callback);
          return;
        }

        this._getElement().classList.remove(CLASS_NAME_SHOW$5);

        this._emulateAnimation(function () {
          _this19.dispose();

          execute(callback);
        });
      }
    }, {
      key: "dispose",
      value: function dispose() {
        if (!this._isAppended) {
          return;
        }

        EventHandler.off(this._element, EVENT_MOUSEDOWN);

        this._element.remove();

        this._isAppended = false;
      } // Private

    }, {
      key: "_getElement",
      value: function _getElement() {
        if (!this._element) {
          var backdrop = document.createElement('div');
          backdrop.className = this._config.className;

          if (this._config.isAnimated) {
            backdrop.classList.add(CLASS_NAME_FADE$4);
          }

          this._element = backdrop;
        }

        return this._element;
      }
    }, {
      key: "_configAfterMerge",
      value: function _configAfterMerge(config) {
        // use getElement() with the default "body" to get a fresh Element on each instantiation
        config.rootElement = getElement(config.rootElement);
        return config;
      }
    }, {
      key: "_append",
      value: function _append() {
        var _this20 = this;

        if (this._isAppended) {
          return;
        }

        var element = this._getElement();

        this._config.rootElement.append(element);

        EventHandler.on(element, EVENT_MOUSEDOWN, function () {
          execute(_this20._config.clickCallback);
        });
        this._isAppended = true;
      }
    }, {
      key: "_emulateAnimation",
      value: function _emulateAnimation(callback) {
        executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
      }
    }], [{
      key: "Default",
      get: function get() {
        return Default$8;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$8;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME$9;
      }
    }]);

    return Backdrop;
  }(Config);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): util/focustrap.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */


  var NAME$8 = 'focustrap';
  var DATA_KEY$5 = 'bs.focustrap';
  var EVENT_KEY$5 = ".".concat(DATA_KEY$5);
  var EVENT_FOCUSIN$2 = "focusin".concat(EVENT_KEY$5);
  var EVENT_KEYDOWN_TAB = "keydown.tab".concat(EVENT_KEY$5);
  var TAB_KEY = 'Tab';
  var TAB_NAV_FORWARD = 'forward';
  var TAB_NAV_BACKWARD = 'backward';
  var Default$7 = {
    autofocus: true,
    trapElement: null // The element to trap focus inside of

  };
  var DefaultType$7 = {
    autofocus: 'boolean',
    trapElement: 'element'
  };
  /**
   * Class definition
   */

  var FocusTrap = /*#__PURE__*/function (_Config4) {
    _inherits(FocusTrap, _Config4);

    var _super9 = _createSuper(FocusTrap);

    function FocusTrap(config) {
      var _this21;

      _classCallCheck(this, FocusTrap);

      _this21 = _super9.call(this);
      _this21._config = _this21._getConfig(config);
      _this21._isActive = false;
      _this21._lastTabNavDirection = null;
      return _this21;
    } // Getters


    _createClass(FocusTrap, [{
      key: "activate",
      value: // Public
      function activate() {
        var _this22 = this;

        if (this._isActive) {
          return;
        }

        if (this._config.autofocus) {
          this._config.trapElement.focus();
        }

        EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop

        EventHandler.on(document, EVENT_FOCUSIN$2, function (event) {
          return _this22._handleFocusin(event);
        });
        EventHandler.on(document, EVENT_KEYDOWN_TAB, function (event) {
          return _this22._handleKeydown(event);
        });
        this._isActive = true;
      }
    }, {
      key: "deactivate",
      value: function deactivate() {
        if (!this._isActive) {
          return;
        }

        this._isActive = false;
        EventHandler.off(document, EVENT_KEY$5);
      } // Private

    }, {
      key: "_handleFocusin",
      value: function _handleFocusin(event) {
        var trapElement = this._config.trapElement;

        if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
          return;
        }

        var elements = SelectorEngine.focusableChildren(trapElement);

        if (elements.length === 0) {
          trapElement.focus();
        } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
          elements[elements.length - 1].focus();
        } else {
          elements[0].focus();
        }
      }
    }, {
      key: "_handleKeydown",
      value: function _handleKeydown(event) {
        if (event.key !== TAB_KEY) {
          return;
        }

        this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
      }
    }], [{
      key: "Default",
      get: function get() {
        return Default$7;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$7;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME$8;
      }
    }]);

    return FocusTrap;
  }(Config);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): modal.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */


  var NAME$7 = 'modal';
  var DATA_KEY$4 = 'bs.modal';
  var EVENT_KEY$4 = ".".concat(DATA_KEY$4);
  var DATA_API_KEY$2 = '.data-api';
  var ESCAPE_KEY$1 = 'Escape';
  var EVENT_HIDE$4 = "hide".concat(EVENT_KEY$4);
  var EVENT_HIDE_PREVENTED$1 = "hidePrevented".concat(EVENT_KEY$4);
  var EVENT_HIDDEN$4 = "hidden".concat(EVENT_KEY$4);
  var EVENT_SHOW$4 = "show".concat(EVENT_KEY$4);
  var EVENT_SHOWN$4 = "shown".concat(EVENT_KEY$4);
  var EVENT_RESIZE$1 = "resize".concat(EVENT_KEY$4);
  var EVENT_CLICK_DISMISS = "click.dismiss".concat(EVENT_KEY$4);
  var EVENT_MOUSEDOWN_DISMISS = "mousedown.dismiss".concat(EVENT_KEY$4);
  var EVENT_KEYDOWN_DISMISS$1 = "keydown.dismiss".concat(EVENT_KEY$4);
  var EVENT_CLICK_DATA_API$2 = "click".concat(EVENT_KEY$4).concat(DATA_API_KEY$2);
  var CLASS_NAME_OPEN = 'modal-open';
  var CLASS_NAME_FADE$3 = 'fade';
  var CLASS_NAME_SHOW$4 = 'show';
  var CLASS_NAME_STATIC = 'modal-static';
  var OPEN_SELECTOR$1 = '.modal.show';
  var SELECTOR_DIALOG = '.modal-dialog';
  var SELECTOR_MODAL_BODY = '.modal-body';
  var SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
  var Default$6 = {
    backdrop: true,
    focus: true,
    keyboard: true
  };
  var DefaultType$6 = {
    backdrop: '(boolean|string)',
    focus: 'boolean',
    keyboard: 'boolean'
  };
  /**
   * Class definition
   */

  var Modal = /*#__PURE__*/function (_BaseComponent6) {
    _inherits(Modal, _BaseComponent6);

    var _super10 = _createSuper(Modal);

    function Modal(element, config) {
      var _this23;

      _classCallCheck(this, Modal);

      _this23 = _super10.call(this, element, config);
      _this23._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, _this23._element);
      _this23._backdrop = _this23._initializeBackDrop();
      _this23._focustrap = _this23._initializeFocusTrap();
      _this23._isShown = false;
      _this23._isTransitioning = false;
      _this23._scrollBar = new ScrollBarHelper();

      _this23._addEventListeners();

      return _this23;
    } // Getters


    _createClass(Modal, [{
      key: "toggle",
      value: // Public
      function toggle(relatedTarget) {
        return this._isShown ? this.hide() : this.show(relatedTarget);
      }
    }, {
      key: "show",
      value: function show(relatedTarget) {
        var _this24 = this;

        if (this._isShown || this._isTransitioning) {
          return;
        }

        var showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
          relatedTarget: relatedTarget
        });

        if (showEvent.defaultPrevented) {
          return;
        }

        this._isShown = true;
        this._isTransitioning = true;

        this._scrollBar.hide();

        document.body.classList.add(CLASS_NAME_OPEN);

        this._adjustDialog();

        this._backdrop.show(function () {
          return _this24._showElement(relatedTarget);
        });
      }
    }, {
      key: "hide",
      value: function hide() {
        var _this25 = this;

        if (!this._isShown || this._isTransitioning) {
          return;
        }

        var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);

        if (hideEvent.defaultPrevented) {
          return;
        }

        this._isShown = false;
        this._isTransitioning = true;

        this._focustrap.deactivate();

        this._element.classList.remove(CLASS_NAME_SHOW$4);

        this._queueCallback(function () {
          return _this25._hideModal();
        }, this._element, this._isAnimated());
      }
    }, {
      key: "dispose",
      value: function dispose() {
        for (var _i7 = 0, _arr2 = [window, this._dialog]; _i7 < _arr2.length; _i7++) {
          var htmlElement = _arr2[_i7];
          EventHandler.off(htmlElement, EVENT_KEY$4);
        }

        this._backdrop.dispose();

        this._focustrap.deactivate();

        _get(_getPrototypeOf(Modal.prototype), "dispose", this).call(this);
      }
    }, {
      key: "handleUpdate",
      value: function handleUpdate() {
        this._adjustDialog();
      } // Private

    }, {
      key: "_initializeBackDrop",
      value: function _initializeBackDrop() {
        return new Backdrop({
          isVisible: Boolean(this._config.backdrop),
          // 'static' option will be translated to true, and booleans will keep their value,
          isAnimated: this._isAnimated()
        });
      }
    }, {
      key: "_initializeFocusTrap",
      value: function _initializeFocusTrap() {
        return new FocusTrap({
          trapElement: this._element
        });
      }
    }, {
      key: "_showElement",
      value: function _showElement(relatedTarget) {
        var _this26 = this;

        // try to append dynamic modal
        if (!document.body.contains(this._element)) {
          document.body.append(this._element);
        }

        this._element.style.display = 'block';

        this._element.removeAttribute('aria-hidden');

        this._element.setAttribute('aria-modal', true);

        this._element.setAttribute('role', 'dialog');

        this._element.scrollTop = 0;
        var modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);

        if (modalBody) {
          modalBody.scrollTop = 0;
        }

        reflow(this._element);

        this._element.classList.add(CLASS_NAME_SHOW$4);

        var transitionComplete = function transitionComplete() {
          if (_this26._config.focus) {
            _this26._focustrap.activate();
          }

          _this26._isTransitioning = false;
          EventHandler.trigger(_this26._element, EVENT_SHOWN$4, {
            relatedTarget: relatedTarget
          });
        };

        this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
      }
    }, {
      key: "_addEventListeners",
      value: function _addEventListeners() {
        var _this27 = this;

        EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, function (event) {
          if (event.key !== ESCAPE_KEY$1) {
            return;
          }

          if (_this27._config.keyboard) {
            event.preventDefault();

            _this27.hide();

            return;
          }

          _this27._triggerBackdropTransition();
        });
        EventHandler.on(window, EVENT_RESIZE$1, function () {
          if (_this27._isShown && !_this27._isTransitioning) {
            _this27._adjustDialog();
          }
        });
        EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, function (event) {
          // a bad trick to segregate clicks that may start inside dialog but end outside, and avoid listen to scrollbar clicks
          EventHandler.one(_this27._element, EVENT_CLICK_DISMISS, function (event2) {
            if (_this27._element !== event.target || _this27._element !== event2.target) {
              return;
            }

            if (_this27._config.backdrop === 'static') {
              _this27._triggerBackdropTransition();

              return;
            }

            if (_this27._config.backdrop) {
              _this27.hide();
            }
          });
        });
      }
    }, {
      key: "_hideModal",
      value: function _hideModal() {
        var _this28 = this;

        this._element.style.display = 'none';

        this._element.setAttribute('aria-hidden', true);

        this._element.removeAttribute('aria-modal');

        this._element.removeAttribute('role');

        this._isTransitioning = false;

        this._backdrop.hide(function () {
          document.body.classList.remove(CLASS_NAME_OPEN);

          _this28._resetAdjustments();

          _this28._scrollBar.reset();

          EventHandler.trigger(_this28._element, EVENT_HIDDEN$4);
        });
      }
    }, {
      key: "_isAnimated",
      value: function _isAnimated() {
        return this._element.classList.contains(CLASS_NAME_FADE$3);
      }
    }, {
      key: "_triggerBackdropTransition",
      value: function _triggerBackdropTransition() {
        var _this29 = this;

        var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);

        if (hideEvent.defaultPrevented) {
          return;
        }

        var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
        var initialOverflowY = this._element.style.overflowY; // return if the following background transition hasn't yet completed

        if (initialOverflowY === 'hidden' || this._element.classList.contains(CLASS_NAME_STATIC)) {
          return;
        }

        if (!isModalOverflowing) {
          this._element.style.overflowY = 'hidden';
        }

        this._element.classList.add(CLASS_NAME_STATIC);

        this._queueCallback(function () {
          _this29._element.classList.remove(CLASS_NAME_STATIC);

          _this29._queueCallback(function () {
            _this29._element.style.overflowY = initialOverflowY;
          }, _this29._dialog);
        }, this._dialog);

        this._element.focus();
      }
      /**
       * The following methods are used to handle overflowing modals
       */

    }, {
      key: "_adjustDialog",
      value: function _adjustDialog() {
        var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

        var scrollbarWidth = this._scrollBar.getWidth();

        var isBodyOverflowing = scrollbarWidth > 0;

        if (isBodyOverflowing && !isModalOverflowing) {
          var property = isRTL() ? 'paddingLeft' : 'paddingRight';
          this._element.style[property] = "".concat(scrollbarWidth, "px");
        }

        if (!isBodyOverflowing && isModalOverflowing) {
          var _property = isRTL() ? 'paddingRight' : 'paddingLeft';

          this._element.style[_property] = "".concat(scrollbarWidth, "px");
        }
      }
    }, {
      key: "_resetAdjustments",
      value: function _resetAdjustments() {
        this._element.style.paddingLeft = '';
        this._element.style.paddingRight = '';
      } // Static

    }], [{
      key: "Default",
      get: function get() {
        return Default$6;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$6;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME$7;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config, relatedTarget) {
        return this.each(function () {
          var data = Modal.getOrCreateInstance(this, config);

          if (typeof config !== 'string') {
            return;
          }

          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config](relatedTarget);
        });
      }
    }]);

    return Modal;
  }(BaseComponent);
  /**
   * Data API implementation
   */


  EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {
    var _this30 = this;

    var target = getElementFromSelector(this);

    if (['A', 'AREA'].includes(this.tagName)) {
      event.preventDefault();
    }

    EventHandler.one(target, EVENT_SHOW$4, function (showEvent) {
      if (showEvent.defaultPrevented) {
        // only register focus restorer if modal will actually get shown
        return;
      }

      EventHandler.one(target, EVENT_HIDDEN$4, function () {
        if (isVisible(_this30)) {
          _this30.focus();
        }
      });
    }); // avoid conflict when clicking modal toggler while another one is open

    var alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);

    if (alreadyOpen) {
      Modal.getInstance(alreadyOpen).hide();
    }

    var data = Modal.getOrCreateInstance(target);
    data.toggle(this);
  });
  enableDismissTrigger(Modal);
  /**
   * jQuery
   */

  defineJQueryPlugin(Modal);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): offcanvas.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  var NAME$6 = 'offcanvas';
  var DATA_KEY$3 = 'bs.offcanvas';
  var EVENT_KEY$3 = ".".concat(DATA_KEY$3);
  var DATA_API_KEY$1 = '.data-api';
  var EVENT_LOAD_DATA_API$2 = "load".concat(EVENT_KEY$3).concat(DATA_API_KEY$1);
  var ESCAPE_KEY = 'Escape';
  var CLASS_NAME_SHOW$3 = 'show';
  var CLASS_NAME_SHOWING$1 = 'showing';
  var CLASS_NAME_HIDING = 'hiding';
  var CLASS_NAME_BACKDROP = 'offcanvas-backdrop';
  var OPEN_SELECTOR = '.offcanvas.show';
  var EVENT_SHOW$3 = "show".concat(EVENT_KEY$3);
  var EVENT_SHOWN$3 = "shown".concat(EVENT_KEY$3);
  var EVENT_HIDE$3 = "hide".concat(EVENT_KEY$3);
  var EVENT_HIDE_PREVENTED = "hidePrevented".concat(EVENT_KEY$3);
  var EVENT_HIDDEN$3 = "hidden".concat(EVENT_KEY$3);
  var EVENT_RESIZE = "resize".concat(EVENT_KEY$3);
  var EVENT_CLICK_DATA_API$1 = "click".concat(EVENT_KEY$3).concat(DATA_API_KEY$1);
  var EVENT_KEYDOWN_DISMISS = "keydown.dismiss".concat(EVENT_KEY$3);
  var SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
  var Default$5 = {
    backdrop: true,
    keyboard: true,
    scroll: false
  };
  var DefaultType$5 = {
    backdrop: '(boolean|string)',
    keyboard: 'boolean',
    scroll: 'boolean'
  };
  /**
   * Class definition
   */

  var Offcanvas = /*#__PURE__*/function (_BaseComponent7) {
    _inherits(Offcanvas, _BaseComponent7);

    var _super11 = _createSuper(Offcanvas);

    function Offcanvas(element, config) {
      var _this31;

      _classCallCheck(this, Offcanvas);

      _this31 = _super11.call(this, element, config);
      _this31._isShown = false;
      _this31._backdrop = _this31._initializeBackDrop();
      _this31._focustrap = _this31._initializeFocusTrap();

      _this31._addEventListeners();

      return _this31;
    } // Getters


    _createClass(Offcanvas, [{
      key: "toggle",
      value: // Public
      function toggle(relatedTarget) {
        return this._isShown ? this.hide() : this.show(relatedTarget);
      }
    }, {
      key: "show",
      value: function show(relatedTarget) {
        var _this32 = this;

        if (this._isShown) {
          return;
        }

        var showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
          relatedTarget: relatedTarget
        });

        if (showEvent.defaultPrevented) {
          return;
        }

        this._isShown = true;

        this._backdrop.show();

        if (!this._config.scroll) {
          new ScrollBarHelper().hide();
        }

        this._element.setAttribute('aria-modal', true);

        this._element.setAttribute('role', 'dialog');

        this._element.classList.add(CLASS_NAME_SHOWING$1);

        var completeCallBack = function completeCallBack() {
          if (!_this32._config.scroll || _this32._config.backdrop) {
            _this32._focustrap.activate();
          }

          _this32._element.classList.add(CLASS_NAME_SHOW$3);

          _this32._element.classList.remove(CLASS_NAME_SHOWING$1);

          EventHandler.trigger(_this32._element, EVENT_SHOWN$3, {
            relatedTarget: relatedTarget
          });
        };

        this._queueCallback(completeCallBack, this._element, true);
      }
    }, {
      key: "hide",
      value: function hide() {
        var _this33 = this;

        if (!this._isShown) {
          return;
        }

        var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);

        if (hideEvent.defaultPrevented) {
          return;
        }

        this._focustrap.deactivate();

        this._element.blur();

        this._isShown = false;

        this._element.classList.add(CLASS_NAME_HIDING);

        this._backdrop.hide();

        var completeCallback = function completeCallback() {
          _this33._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);

          _this33._element.removeAttribute('aria-modal');

          _this33._element.removeAttribute('role');

          if (!_this33._config.scroll) {
            new ScrollBarHelper().reset();
          }

          EventHandler.trigger(_this33._element, EVENT_HIDDEN$3);
        };

        this._queueCallback(completeCallback, this._element, true);
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this._backdrop.dispose();

        this._focustrap.deactivate();

        _get(_getPrototypeOf(Offcanvas.prototype), "dispose", this).call(this);
      } // Private

    }, {
      key: "_initializeBackDrop",
      value: function _initializeBackDrop() {
        var _this34 = this;

        var clickCallback = function clickCallback() {
          if (_this34._config.backdrop === 'static') {
            EventHandler.trigger(_this34._element, EVENT_HIDE_PREVENTED);
            return;
          }

          _this34.hide();
        }; // 'static' option will be translated to true, and booleans will keep their value


        var isVisible = Boolean(this._config.backdrop);
        return new Backdrop({
          className: CLASS_NAME_BACKDROP,
          isVisible: isVisible,
          isAnimated: true,
          rootElement: this._element.parentNode,
          clickCallback: isVisible ? clickCallback : null
        });
      }
    }, {
      key: "_initializeFocusTrap",
      value: function _initializeFocusTrap() {
        return new FocusTrap({
          trapElement: this._element
        });
      }
    }, {
      key: "_addEventListeners",
      value: function _addEventListeners() {
        var _this35 = this;

        EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, function (event) {
          if (event.key !== ESCAPE_KEY) {
            return;
          }

          if (!_this35._config.keyboard) {
            EventHandler.trigger(_this35._element, EVENT_HIDE_PREVENTED);
            return;
          }

          _this35.hide();
        });
      } // Static

    }], [{
      key: "Default",
      get: function get() {
        return Default$5;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$5;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME$6;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        return this.each(function () {
          var data = Offcanvas.getOrCreateInstance(this, config);

          if (typeof config !== 'string') {
            return;
          }

          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config](this);
        });
      }
    }]);

    return Offcanvas;
  }(BaseComponent);
  /**
   * Data API implementation
   */


  EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {
    var _this36 = this;

    var target = getElementFromSelector(this);

    if (['A', 'AREA'].includes(this.tagName)) {
      event.preventDefault();
    }

    if (isDisabled(this)) {
      return;
    }

    EventHandler.one(target, EVENT_HIDDEN$3, function () {
      // focus on trigger when it is closed
      if (isVisible(_this36)) {
        _this36.focus();
      }
    }); // avoid conflict when clicking a toggler of an offcanvas, while another is open

    var alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);

    if (alreadyOpen && alreadyOpen !== target) {
      Offcanvas.getInstance(alreadyOpen).hide();
    }

    var data = Offcanvas.getOrCreateInstance(target);
    data.toggle(this);
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API$2, function () {
    var _iterator17 = _createForOfIteratorHelper(SelectorEngine.find(OPEN_SELECTOR)),
        _step17;

    try {
      for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
        var selector = _step17.value;
        Offcanvas.getOrCreateInstance(selector).show();
      }
    } catch (err) {
      _iterator17.e(err);
    } finally {
      _iterator17.f();
    }
  });
  EventHandler.on(window, EVENT_RESIZE, function () {
    var _iterator18 = _createForOfIteratorHelper(SelectorEngine.find('[aria-modal][class*=show][class*=offcanvas-]')),
        _step18;

    try {
      for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
        var element = _step18.value;

        if (getComputedStyle(element).position !== 'fixed') {
          Offcanvas.getOrCreateInstance(element).hide();
        }
      }
    } catch (err) {
      _iterator18.e(err);
    } finally {
      _iterator18.f();
    }
  });
  enableDismissTrigger(Offcanvas);
  /**
   * jQuery
   */

  defineJQueryPlugin(Offcanvas);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): util/sanitizer.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  var uriAttributes = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);
  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
  /**
   * A pattern that recognizes a commonly useful subset of URLs that are safe.
   *
   * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts
   */

  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
  /**
   * A pattern that matches safe data URLs. Only matches image, video and audio types.
   *
   * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts
   */

  var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;

  var allowedAttribute = function allowedAttribute(attribute, allowedAttributeList) {
    var attributeName = attribute.nodeName.toLowerCase();

    if (allowedAttributeList.includes(attributeName)) {
      if (uriAttributes.has(attributeName)) {
        return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue) || DATA_URL_PATTERN.test(attribute.nodeValue));
      }

      return true;
    } // Check if a regular expression validates the attribute.


    return allowedAttributeList.filter(function (attributeRegex) {
      return attributeRegex instanceof RegExp;
    }).some(function (regex) {
      return regex.test(attributeName);
    });
  };

  var DefaultAllowlist = {
    // Global attributes allowed on any supplied element below.
    '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
    a: ['target', 'href', 'title', 'rel'],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    div: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
  };

  function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
    var _ref7;

    if (!unsafeHtml.length) {
      return unsafeHtml;
    }

    if (sanitizeFunction && typeof sanitizeFunction === 'function') {
      return sanitizeFunction(unsafeHtml);
    }

    var domParser = new window.DOMParser();
    var createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');

    var elements = (_ref7 = []).concat.apply(_ref7, _toConsumableArray(createdDocument.body.querySelectorAll('*')));

    var _iterator19 = _createForOfIteratorHelper(elements),
        _step19;

    try {
      for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
        var _ref8;

        var element = _step19.value;
        var elementName = element.nodeName.toLowerCase();

        if (!Object.keys(allowList).includes(elementName)) {
          element.remove();
          continue;
        }

        var attributeList = (_ref8 = []).concat.apply(_ref8, _toConsumableArray(element.attributes));

        var allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);

        var _iterator20 = _createForOfIteratorHelper(attributeList),
            _step20;

        try {
          for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
            var attribute = _step20.value;

            if (!allowedAttribute(attribute, allowedAttributes)) {
              element.removeAttribute(attribute.nodeName);
            }
          }
        } catch (err) {
          _iterator20.e(err);
        } finally {
          _iterator20.f();
        }
      }
    } catch (err) {
      _iterator19.e(err);
    } finally {
      _iterator19.f();
    }

    return createdDocument.body.innerHTML;
  }
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): util/template-factory.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */


  var NAME$5 = 'TemplateFactory';
  var Default$4 = {
    allowList: DefaultAllowlist,
    content: {},
    // { selector : text ,  selector2 : text2 , }
    extraClass: '',
    html: false,
    sanitize: true,
    sanitizeFn: null,
    template: '<div></div>'
  };
  var DefaultType$4 = {
    allowList: 'object',
    content: 'object',
    extraClass: '(string|function)',
    html: 'boolean',
    sanitize: 'boolean',
    sanitizeFn: '(null|function)',
    template: 'string'
  };
  var DefaultContentType = {
    entry: '(string|element|function|null)',
    selector: '(string|element)'
  };
  /**
   * Class definition
   */

  var TemplateFactory = /*#__PURE__*/function (_Config5) {
    _inherits(TemplateFactory, _Config5);

    var _super12 = _createSuper(TemplateFactory);

    function TemplateFactory(config) {
      var _this37;

      _classCallCheck(this, TemplateFactory);

      _this37 = _super12.call(this);
      _this37._config = _this37._getConfig(config);
      return _this37;
    } // Getters


    _createClass(TemplateFactory, [{
      key: "getContent",
      value: // Public
      function getContent() {
        var _this38 = this;

        return Object.values(this._config.content).map(function (config) {
          return _this38._resolvePossibleFunction(config);
        }).filter(Boolean);
      }
    }, {
      key: "hasContent",
      value: function hasContent() {
        return this.getContent().length > 0;
      }
    }, {
      key: "changeContent",
      value: function changeContent(content) {
        this._checkContent(content);

        this._config.content = _objectSpread(_objectSpread({}, this._config.content), content);
        return this;
      }
    }, {
      key: "toHtml",
      value: function toHtml() {
        var templateWrapper = document.createElement('div');
        templateWrapper.innerHTML = this._maybeSanitize(this._config.template);

        for (var _i8 = 0, _Object$entries2 = Object.entries(this._config.content); _i8 < _Object$entries2.length; _i8++) {
          var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i8], 2),
              selector = _Object$entries2$_i[0],
              text = _Object$entries2$_i[1];

          this._setContent(templateWrapper, text, selector);
        }

        var template = templateWrapper.children[0];

        var extraClass = this._resolvePossibleFunction(this._config.extraClass);

        if (extraClass) {
          var _template$classList;

          (_template$classList = template.classList).add.apply(_template$classList, _toConsumableArray(extraClass.split(' ')));
        }

        return template;
      } // Private

    }, {
      key: "_typeCheckConfig",
      value: function _typeCheckConfig(config) {
        _get(_getPrototypeOf(TemplateFactory.prototype), "_typeCheckConfig", this).call(this, config);

        this._checkContent(config.content);
      }
    }, {
      key: "_checkContent",
      value: function _checkContent(arg) {
        for (var _i9 = 0, _Object$entries3 = Object.entries(arg); _i9 < _Object$entries3.length; _i9++) {
          var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i9], 2),
              selector = _Object$entries3$_i[0],
              content = _Object$entries3$_i[1];

          _get(_getPrototypeOf(TemplateFactory.prototype), "_typeCheckConfig", this).call(this, {
            selector: selector,
            entry: content
          }, DefaultContentType);
        }
      }
    }, {
      key: "_setContent",
      value: function _setContent(template, content, selector) {
        var templateElement = SelectorEngine.findOne(selector, template);

        if (!templateElement) {
          return;
        }

        content = this._resolvePossibleFunction(content);

        if (!content) {
          templateElement.remove();
          return;
        }

        if (isElement(content)) {
          this._putElementInTemplate(getElement(content), templateElement);

          return;
        }

        if (this._config.html) {
          templateElement.innerHTML = this._maybeSanitize(content);
          return;
        }

        templateElement.textContent = content;
      }
    }, {
      key: "_maybeSanitize",
      value: function _maybeSanitize(arg) {
        return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
      }
    }, {
      key: "_resolvePossibleFunction",
      value: function _resolvePossibleFunction(arg) {
        return typeof arg === 'function' ? arg(this) : arg;
      }
    }, {
      key: "_putElementInTemplate",
      value: function _putElementInTemplate(element, templateElement) {
        if (this._config.html) {
          templateElement.innerHTML = '';
          templateElement.append(element);
          return;
        }

        templateElement.textContent = element.textContent;
      }
    }], [{
      key: "Default",
      get: function get() {
        return Default$4;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$4;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME$5;
      }
    }]);

    return TemplateFactory;
  }(Config);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): tooltip.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */


  var NAME$4 = 'tooltip';
  var DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);
  var CLASS_NAME_FADE$2 = 'fade';
  var CLASS_NAME_MODAL = 'modal';
  var CLASS_NAME_SHOW$2 = 'show';
  var SELECTOR_TOOLTIP_INNER = '.tooltip-inner';
  var SELECTOR_MODAL = ".".concat(CLASS_NAME_MODAL);
  var EVENT_MODAL_HIDE = 'hide.bs.modal';
  var TRIGGER_HOVER = 'hover';
  var TRIGGER_FOCUS = 'focus';
  var TRIGGER_CLICK = 'click';
  var TRIGGER_MANUAL = 'manual';
  var EVENT_HIDE$2 = 'hide';
  var EVENT_HIDDEN$2 = 'hidden';
  var EVENT_SHOW$2 = 'show';
  var EVENT_SHOWN$2 = 'shown';
  var EVENT_INSERTED = 'inserted';
  var EVENT_CLICK$1 = 'click';
  var EVENT_FOCUSIN$1 = 'focusin';
  var EVENT_FOCUSOUT$1 = 'focusout';
  var EVENT_MOUSEENTER = 'mouseenter';
  var EVENT_MOUSELEAVE = 'mouseleave';
  var AttachmentMap = {
    AUTO: 'auto',
    TOP: 'top',
    RIGHT: isRTL() ? 'left' : 'right',
    BOTTOM: 'bottom',
    LEFT: isRTL() ? 'right' : 'left'
  };
  var Default$3 = {
    allowList: DefaultAllowlist,
    animation: true,
    boundary: 'clippingParents',
    container: false,
    customClass: '',
    delay: 0,
    fallbackPlacements: ['top', 'right', 'bottom', 'left'],
    html: false,
    offset: [0, 0],
    placement: 'top',
    popperConfig: null,
    sanitize: true,
    sanitizeFn: null,
    selector: false,
    template: '<div class="tooltip" role="tooltip">' + '<div class="tooltip-arrow"></div>' + '<div class="tooltip-inner"></div>' + '</div>',
    title: '',
    trigger: 'hover focus'
  };
  var DefaultType$3 = {
    allowList: 'object',
    animation: 'boolean',
    boundary: '(string|element)',
    container: '(string|element|boolean)',
    customClass: '(string|function)',
    delay: '(number|object)',
    fallbackPlacements: 'array',
    html: 'boolean',
    offset: '(array|string|function)',
    placement: '(string|function)',
    popperConfig: '(null|object|function)',
    sanitize: 'boolean',
    sanitizeFn: '(null|function)',
    selector: '(string|boolean)',
    template: 'string',
    title: '(string|element|function)',
    trigger: 'string'
  };
  /**
   * Class definition
   */

  var Tooltip = /*#__PURE__*/function (_BaseComponent8) {
    _inherits(Tooltip, _BaseComponent8);

    var _super13 = _createSuper(Tooltip);

    function Tooltip(element, config) {
      var _this39;

      _classCallCheck(this, Tooltip);

      if (typeof Popper__namespace === 'undefined') {
        throw new TypeError('Bootstrap\'s tooltips require Popper (https://popper.js.org)');
      }

      _this39 = _super13.call(this, element, config); // Private

      _this39._isEnabled = true;
      _this39._timeout = 0;
      _this39._isHovered = null;
      _this39._activeTrigger = {};
      _this39._popper = null;
      _this39._templateFactory = null;
      _this39._newContent = null; // Protected

      _this39.tip = null;

      _this39._setListeners();

      if (!_this39._config.selector) {
        _this39._fixTitle();
      }

      return _this39;
    } // Getters


    _createClass(Tooltip, [{
      key: "enable",
      value: // Public
      function enable() {
        this._isEnabled = true;
      }
    }, {
      key: "disable",
      value: function disable() {
        this._isEnabled = false;
      }
    }, {
      key: "toggleEnabled",
      value: function toggleEnabled() {
        this._isEnabled = !this._isEnabled;
      }
    }, {
      key: "toggle",
      value: function toggle() {
        if (!this._isEnabled) {
          return;
        }

        this._activeTrigger.click = !this._activeTrigger.click;

        if (this._isShown()) {
          this._leave();

          return;
        }

        this._enter();
      }
    }, {
      key: "dispose",
      value: function dispose() {
        clearTimeout(this._timeout);
        EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);

        if (this.tip) {
          this.tip.remove();
        }

        if (this._element.getAttribute('data-bs-original-title')) {
          this._element.setAttribute('title', this._element.getAttribute('data-bs-original-title'));
        }

        this._disposePopper();

        _get(_getPrototypeOf(Tooltip.prototype), "dispose", this).call(this);
      }
    }, {
      key: "show",
      value: function show() {
        var _this40 = this;

        if (this._element.style.display === 'none') {
          throw new Error('Please use show on visible elements');
        }

        if (!(this._isWithContent() && this._isEnabled)) {
          return;
        }

        var showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
        var shadowRoot = findShadowRoot(this._element);

        var isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);

        if (showEvent.defaultPrevented || !isInTheDom) {
          return;
        } // todo v6 remove this OR make it optional


        if (this.tip) {
          this.tip.remove();
          this.tip = null;
        }

        var tip = this._getTipElement();

        this._element.setAttribute('aria-describedby', tip.getAttribute('id'));

        var container = this._config.container;

        if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
          container.append(tip);
          EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
        }

        if (this._popper) {
          this._popper.update();
        } else {
          this._popper = this._createPopper(tip);
        }

        tip.classList.add(CLASS_NAME_SHOW$2); // If this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html

        if ('ontouchstart' in document.documentElement) {
          var _ref9;

          var _iterator21 = _createForOfIteratorHelper((_ref9 = []).concat.apply(_ref9, _toConsumableArray(document.body.children))),
              _step21;

          try {
            for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
              var element = _step21.value;
              EventHandler.on(element, 'mouseover', noop);
            }
          } catch (err) {
            _iterator21.e(err);
          } finally {
            _iterator21.f();
          }
        }

        var complete = function complete() {
          EventHandler.trigger(_this40._element, _this40.constructor.eventName(EVENT_SHOWN$2));

          if (_this40._isHovered === false) {
            _this40._leave();
          }

          _this40._isHovered = false;
        };

        this._queueCallback(complete, this.tip, this._isAnimated());
      }
    }, {
      key: "hide",
      value: function hide() {
        var _this41 = this;

        if (!this._isShown()) {
          return;
        }

        var hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));

        if (hideEvent.defaultPrevented) {
          return;
        }

        var tip = this._getTipElement();

        tip.classList.remove(CLASS_NAME_SHOW$2); // If this is a touch-enabled device we remove the extra
        // empty mouseover listeners we added for iOS support

        if ('ontouchstart' in document.documentElement) {
          var _ref10;

          var _iterator22 = _createForOfIteratorHelper((_ref10 = []).concat.apply(_ref10, _toConsumableArray(document.body.children))),
              _step22;

          try {
            for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
              var element = _step22.value;
              EventHandler.off(element, 'mouseover', noop);
            }
          } catch (err) {
            _iterator22.e(err);
          } finally {
            _iterator22.f();
          }
        }

        this._activeTrigger[TRIGGER_CLICK] = false;
        this._activeTrigger[TRIGGER_FOCUS] = false;
        this._activeTrigger[TRIGGER_HOVER] = false;
        this._isHovered = null; // it is a trick to support manual triggering

        var complete = function complete() {
          if (_this41._isWithActiveTrigger()) {
            return;
          }

          if (!_this41._isHovered) {
            tip.remove();
          }

          _this41._element.removeAttribute('aria-describedby');

          EventHandler.trigger(_this41._element, _this41.constructor.eventName(EVENT_HIDDEN$2));

          _this41._disposePopper();
        };

        this._queueCallback(complete, this.tip, this._isAnimated());
      }
    }, {
      key: "update",
      value: function update() {
        if (this._popper) {
          this._popper.update();
        }
      } // Protected

    }, {
      key: "_isWithContent",
      value: function _isWithContent() {
        return Boolean(this._getTitle());
      }
    }, {
      key: "_getTipElement",
      value: function _getTipElement() {
        if (!this.tip) {
          this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
        }

        return this.tip;
      }
    }, {
      key: "_createTipElement",
      value: function _createTipElement(content) {
        var tip = this._getTemplateFactory(content).toHtml(); // todo: remove this check on v6


        if (!tip) {
          return null;
        }

        tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2); // todo: on v6 the following can be achieved with CSS only

        tip.classList.add("bs-".concat(this.constructor.NAME, "-auto"));
        var tipId = getUID(this.constructor.NAME).toString();
        tip.setAttribute('id', tipId);

        if (this._isAnimated()) {
          tip.classList.add(CLASS_NAME_FADE$2);
        }

        return tip;
      }
    }, {
      key: "setContent",
      value: function setContent(content) {
        this._newContent = content;

        if (this._isShown()) {
          this._disposePopper();

          this.show();
        }
      }
    }, {
      key: "_getTemplateFactory",
      value: function _getTemplateFactory(content) {
        if (this._templateFactory) {
          this._templateFactory.changeContent(content);
        } else {
          this._templateFactory = new TemplateFactory(_objectSpread(_objectSpread({}, this._config), {}, {
            // the `content` var has to be after `this._config`
            // to override config.content in case of popover
            content: content,
            extraClass: this._resolvePossibleFunction(this._config.customClass)
          }));
        }

        return this._templateFactory;
      }
    }, {
      key: "_getContentForTemplate",
      value: function _getContentForTemplate() {
        return _defineProperty({}, SELECTOR_TOOLTIP_INNER, this._getTitle());
      }
    }, {
      key: "_getTitle",
      value: function _getTitle() {
        return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute('data-bs-original-title');
      } // Private

    }, {
      key: "_initializeOnDelegatedTarget",
      value: function _initializeOnDelegatedTarget(event) {
        return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
      }
    }, {
      key: "_isAnimated",
      value: function _isAnimated() {
        return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
      }
    }, {
      key: "_isShown",
      value: function _isShown() {
        return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
      }
    }, {
      key: "_createPopper",
      value: function _createPopper(tip) {
        var placement = typeof this._config.placement === 'function' ? this._config.placement.call(this, tip, this._element) : this._config.placement;
        var attachment = AttachmentMap[placement.toUpperCase()];
        return Popper__namespace.createPopper(this._element, tip, this._getPopperConfig(attachment));
      }
    }, {
      key: "_getOffset",
      value: function _getOffset() {
        var _this42 = this;

        var offset = this._config.offset;

        if (typeof offset === 'string') {
          return offset.split(',').map(function (value) {
            return Number.parseInt(value, 10);
          });
        }

        if (typeof offset === 'function') {
          return function (popperData) {
            return offset(popperData, _this42._element);
          };
        }

        return offset;
      }
    }, {
      key: "_resolvePossibleFunction",
      value: function _resolvePossibleFunction(arg) {
        return typeof arg === 'function' ? arg.call(this._element) : arg;
      }
    }, {
      key: "_getPopperConfig",
      value: function _getPopperConfig(attachment) {
        var _this43 = this;

        var defaultBsPopperConfig = {
          placement: attachment,
          modifiers: [{
            name: 'flip',
            options: {
              fallbackPlacements: this._config.fallbackPlacements
            }
          }, {
            name: 'offset',
            options: {
              offset: this._getOffset()
            }
          }, {
            name: 'preventOverflow',
            options: {
              boundary: this._config.boundary
            }
          }, {
            name: 'arrow',
            options: {
              element: ".".concat(this.constructor.NAME, "-arrow")
            }
          }, {
            name: 'preSetPlacement',
            enabled: true,
            phase: 'beforeMain',
            fn: function fn(data) {
              // Pre-set Popper's placement attribute in order to read the arrow sizes properly.
              // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement
              _this43._getTipElement().setAttribute('data-popper-placement', data.state.placement);
            }
          }]
        };
        return _objectSpread(_objectSpread({}, defaultBsPopperConfig), typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig);
      }
    }, {
      key: "_setListeners",
      value: function _setListeners() {
        var _this44 = this;

        var triggers = this._config.trigger.split(' ');

        var _iterator23 = _createForOfIteratorHelper(triggers),
            _step23;

        try {
          for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
            var trigger = _step23.value;

            if (trigger === 'click') {
              EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, function (event) {
                var context = _this44._initializeOnDelegatedTarget(event);

                context.toggle();
              });
            } else if (trigger !== TRIGGER_MANUAL) {
              var eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
              var eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
              EventHandler.on(this._element, eventIn, this._config.selector, function (event) {
                var context = _this44._initializeOnDelegatedTarget(event);

                context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;

                context._enter();
              });
              EventHandler.on(this._element, eventOut, this._config.selector, function (event) {
                var context = _this44._initializeOnDelegatedTarget(event);

                context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);

                context._leave();
              });
            }
          }
        } catch (err) {
          _iterator23.e(err);
        } finally {
          _iterator23.f();
        }

        this._hideModalHandler = function () {
          if (_this44._element) {
            _this44.hide();
          }
        };

        EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
      }
    }, {
      key: "_fixTitle",
      value: function _fixTitle() {
        var title = this._element.getAttribute('title');

        if (!title) {
          return;
        }

        if (!this._element.getAttribute('aria-label') && !this._element.textContent.trim()) {
          this._element.setAttribute('aria-label', title);
        }

        this._element.setAttribute('data-bs-original-title', title); // DO NOT USE IT. Is only for backwards compatibility


        this._element.removeAttribute('title');
      }
    }, {
      key: "_enter",
      value: function _enter() {
        var _this45 = this;

        if (this._isShown() || this._isHovered) {
          this._isHovered = true;
          return;
        }

        this._isHovered = true;

        this._setTimeout(function () {
          if (_this45._isHovered) {
            _this45.show();
          }
        }, this._config.delay.show);
      }
    }, {
      key: "_leave",
      value: function _leave() {
        var _this46 = this;

        if (this._isWithActiveTrigger()) {
          return;
        }

        this._isHovered = false;

        this._setTimeout(function () {
          if (!_this46._isHovered) {
            _this46.hide();
          }
        }, this._config.delay.hide);
      }
    }, {
      key: "_setTimeout",
      value: function _setTimeout(handler, timeout) {
        clearTimeout(this._timeout);
        this._timeout = setTimeout(handler, timeout);
      }
    }, {
      key: "_isWithActiveTrigger",
      value: function _isWithActiveTrigger() {
        return Object.values(this._activeTrigger).includes(true);
      }
    }, {
      key: "_getConfig",
      value: function _getConfig(config) {
        var dataAttributes = Manipulator.getDataAttributes(this._element);

        for (var _i10 = 0, _Object$keys5 = Object.keys(dataAttributes); _i10 < _Object$keys5.length; _i10++) {
          var dataAttribute = _Object$keys5[_i10];

          if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {
            delete dataAttributes[dataAttribute];
          }
        }

        config = _objectSpread(_objectSpread({}, dataAttributes), _typeof(config) === 'object' && config ? config : {});
        config = this._mergeConfigObj(config);
        config = this._configAfterMerge(config);

        this._typeCheckConfig(config);

        return config;
      }
    }, {
      key: "_configAfterMerge",
      value: function _configAfterMerge(config) {
        config.container = config.container === false ? document.body : getElement(config.container);

        if (typeof config.delay === 'number') {
          config.delay = {
            show: config.delay,
            hide: config.delay
          };
        }

        if (typeof config.title === 'number') {
          config.title = config.title.toString();
        }

        if (typeof config.content === 'number') {
          config.content = config.content.toString();
        }

        return config;
      }
    }, {
      key: "_getDelegateConfig",
      value: function _getDelegateConfig() {
        var config = {};

        for (var key in this._config) {
          if (this.constructor.Default[key] !== this._config[key]) {
            config[key] = this._config[key];
          }
        }

        config.selector = false;
        config.trigger = 'manual'; // In the future can be replaced with:
        // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])
        // `Object.fromEntries(keysWithDifferentValues)`

        return config;
      }
    }, {
      key: "_disposePopper",
      value: function _disposePopper() {
        if (this._popper) {
          this._popper.destroy();

          this._popper = null;
        }
      } // Static

    }], [{
      key: "Default",
      get: function get() {
        return Default$3;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$3;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME$4;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        return this.each(function () {
          var data = Tooltip.getOrCreateInstance(this, config);

          if (typeof config !== 'string') {
            return;
          }

          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config]();
        });
      }
    }]);

    return Tooltip;
  }(BaseComponent);
  /**
   * jQuery
   */


  defineJQueryPlugin(Tooltip);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): popover.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  var NAME$3 = 'popover';
  var SELECTOR_TITLE = '.popover-header';
  var SELECTOR_CONTENT = '.popover-body';

  var Default$2 = _objectSpread(_objectSpread({}, Tooltip.Default), {}, {
    content: '',
    offset: [0, 8],
    placement: 'right',
    template: '<div class="popover" role="tooltip">' + '<div class="popover-arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div>' + '</div>',
    trigger: 'click'
  });

  var DefaultType$2 = _objectSpread(_objectSpread({}, Tooltip.DefaultType), {}, {
    content: '(null|string|element|function)'
  });
  /**
   * Class definition
   */


  var Popover = /*#__PURE__*/function (_Tooltip) {
    _inherits(Popover, _Tooltip);

    var _super14 = _createSuper(Popover);

    function Popover() {
      _classCallCheck(this, Popover);

      return _super14.apply(this, arguments);
    }

    _createClass(Popover, [{
      key: "_isWithContent",
      value: // Overrides
      function _isWithContent() {
        return this._getTitle() || this._getContent();
      } // Private

    }, {
      key: "_getContentForTemplate",
      value: function _getContentForTemplate() {
        var _ref12;

        return _ref12 = {}, _defineProperty(_ref12, SELECTOR_TITLE, this._getTitle()), _defineProperty(_ref12, SELECTOR_CONTENT, this._getContent()), _ref12;
      }
    }, {
      key: "_getContent",
      value: function _getContent() {
        return this._resolvePossibleFunction(this._config.content);
      } // Static

    }], [{
      key: "Default",
      get: // Getters
      function get() {
        return Default$2;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$2;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME$3;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        return this.each(function () {
          var data = Popover.getOrCreateInstance(this, config);

          if (typeof config !== 'string') {
            return;
          }

          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config]();
        });
      }
    }]);

    return Popover;
  }(Tooltip);
  /**
   * jQuery
   */


  defineJQueryPlugin(Popover);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): scrollspy.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  var NAME$2 = 'scrollspy';
  var DATA_KEY$2 = 'bs.scrollspy';
  var EVENT_KEY$2 = ".".concat(DATA_KEY$2);
  var DATA_API_KEY = '.data-api';
  var EVENT_ACTIVATE = "activate".concat(EVENT_KEY$2);
  var EVENT_CLICK = "click".concat(EVENT_KEY$2);
  var EVENT_LOAD_DATA_API$1 = "load".concat(EVENT_KEY$2).concat(DATA_API_KEY);
  var CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';
  var CLASS_NAME_ACTIVE$1 = 'active';
  var SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
  var SELECTOR_TARGET_LINKS = '[href]';
  var SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';
  var SELECTOR_NAV_LINKS = '.nav-link';
  var SELECTOR_NAV_ITEMS = '.nav-item';
  var SELECTOR_LIST_ITEMS = '.list-group-item';
  var SELECTOR_LINK_ITEMS = "".concat(SELECTOR_NAV_LINKS, ", ").concat(SELECTOR_NAV_ITEMS, " > ").concat(SELECTOR_NAV_LINKS, ", ").concat(SELECTOR_LIST_ITEMS);
  var SELECTOR_DROPDOWN = '.dropdown';
  var SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';
  var Default$1 = {
    offset: null,
    // TODO: v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: '0px 0px -25%',
    smoothScroll: false,
    target: null,
    threshold: [0.1, 0.5, 1]
  };
  var DefaultType$1 = {
    offset: '(number|null)',
    // TODO v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: 'string',
    smoothScroll: 'boolean',
    target: 'element',
    threshold: 'array'
  };
  /**
   * Class definition
   */

  var ScrollSpy = /*#__PURE__*/function (_BaseComponent9) {
    _inherits(ScrollSpy, _BaseComponent9);

    var _super15 = _createSuper(ScrollSpy);

    function ScrollSpy(element, config) {
      var _this47;

      _classCallCheck(this, ScrollSpy);

      _this47 = _super15.call(this, element, config); // this._element is the observablesContainer and config.target the menu links wrapper

      _this47._targetLinks = new Map();
      _this47._observableSections = new Map();
      _this47._rootElement = getComputedStyle(_this47._element).overflowY === 'visible' ? null : _this47._element;
      _this47._activeTarget = null;
      _this47._observer = null;
      _this47._previousScrollData = {
        visibleEntryTop: 0,
        parentScrollTop: 0
      };

      _this47.refresh(); // initialize


      return _this47;
    } // Getters


    _createClass(ScrollSpy, [{
      key: "refresh",
      value: // Public
      function refresh() {
        this._initializeTargetsAndObservables();

        this._maybeEnableSmoothScroll();

        if (this._observer) {
          this._observer.disconnect();
        } else {
          this._observer = this._getNewObserver();
        }

        var _iterator24 = _createForOfIteratorHelper(this._observableSections.values()),
            _step24;

        try {
          for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
            var section = _step24.value;

            this._observer.observe(section);
          }
        } catch (err) {
          _iterator24.e(err);
        } finally {
          _iterator24.f();
        }
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this._observer.disconnect();

        _get(_getPrototypeOf(ScrollSpy.prototype), "dispose", this).call(this);
      } // Private

    }, {
      key: "_configAfterMerge",
      value: function _configAfterMerge(config) {
        // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case
        config.target = getElement(config.target) || document.body; // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only

        config.rootMargin = config.offset ? "".concat(config.offset, "px 0px -30%") : config.rootMargin;

        if (typeof config.threshold === 'string') {
          config.threshold = config.threshold.split(',').map(function (value) {
            return Number.parseFloat(value);
          });
        }

        return config;
      }
    }, {
      key: "_maybeEnableSmoothScroll",
      value: function _maybeEnableSmoothScroll() {
        var _this48 = this;

        if (!this._config.smoothScroll) {
          return;
        } // unregister any previous listeners


        EventHandler.off(this._config.target, EVENT_CLICK);
        EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, function (event) {
          var observableSection = _this48._observableSections.get(event.target.hash);

          if (observableSection) {
            event.preventDefault();
            var root = _this48._rootElement || window;
            var height = observableSection.offsetTop - _this48._element.offsetTop;

            if (root.scrollTo) {
              root.scrollTo({
                top: height,
                behavior: 'smooth'
              });
              return;
            } // Chrome 60 doesn't support `scrollTo`


            root.scrollTop = height;
          }
        });
      }
    }, {
      key: "_getNewObserver",
      value: function _getNewObserver() {
        var _this49 = this;

        var options = {
          root: this._rootElement,
          threshold: this._config.threshold,
          rootMargin: this._config.rootMargin
        };
        return new IntersectionObserver(function (entries) {
          return _this49._observerCallback(entries);
        }, options);
      } // The logic of selection

    }, {
      key: "_observerCallback",
      value: function _observerCallback(entries) {
        var _this50 = this;

        var targetElement = function targetElement(entry) {
          return _this50._targetLinks.get("#".concat(entry.target.id));
        };

        var activate = function activate(entry) {
          _this50._previousScrollData.visibleEntryTop = entry.target.offsetTop;

          _this50._process(targetElement(entry));
        };

        var parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
        var userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
        this._previousScrollData.parentScrollTop = parentScrollTop;

        var _iterator25 = _createForOfIteratorHelper(entries),
            _step25;

        try {
          for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
            var entry = _step25.value;

            if (!entry.isIntersecting) {
              this._activeTarget = null;

              this._clearActiveClass(targetElement(entry));

              continue;
            }

            var entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop; // if we are scrolling down, pick the bigger offsetTop

            if (userScrollsDown && entryIsLowerThanPrevious) {
              activate(entry); // if parent isn't scrolled, let's keep the first visible item, breaking the iteration

              if (!parentScrollTop) {
                return;
              }

              continue;
            } // if we are scrolling up, pick the smallest offsetTop


            if (!userScrollsDown && !entryIsLowerThanPrevious) {
              activate(entry);
            }
          }
        } catch (err) {
          _iterator25.e(err);
        } finally {
          _iterator25.f();
        }
      }
    }, {
      key: "_initializeTargetsAndObservables",
      value: function _initializeTargetsAndObservables() {
        this._targetLinks = new Map();
        this._observableSections = new Map();
        var targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);

        var _iterator26 = _createForOfIteratorHelper(targetLinks),
            _step26;

        try {
          for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
            var anchor = _step26.value;

            // ensure that the anchor has an id and is not disabled
            if (!anchor.hash || isDisabled(anchor)) {
              continue;
            }

            var observableSection = SelectorEngine.findOne(anchor.hash, this._element); // ensure that the observableSection exists & is visible

            if (isVisible(observableSection)) {
              this._targetLinks.set(anchor.hash, anchor);

              this._observableSections.set(anchor.hash, observableSection);
            }
          }
        } catch (err) {
          _iterator26.e(err);
        } finally {
          _iterator26.f();
        }
      }
    }, {
      key: "_process",
      value: function _process(target) {
        if (this._activeTarget === target) {
          return;
        }

        this._clearActiveClass(this._config.target);

        this._activeTarget = target;
        target.classList.add(CLASS_NAME_ACTIVE$1);

        this._activateParents(target);

        EventHandler.trigger(this._element, EVENT_ACTIVATE, {
          relatedTarget: target
        });
      }
    }, {
      key: "_activateParents",
      value: function _activateParents(target) {
        // Activate dropdown parents
        if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
          SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
          return;
        }

        var _iterator27 = _createForOfIteratorHelper(SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)),
            _step27;

        try {
          for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
            var listGroup = _step27.value;

            // Set triggered links parents as active
            // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor
            var _iterator28 = _createForOfIteratorHelper(SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)),
                _step28;

            try {
              for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
                var item = _step28.value;
                item.classList.add(CLASS_NAME_ACTIVE$1);
              }
            } catch (err) {
              _iterator28.e(err);
            } finally {
              _iterator28.f();
            }
          }
        } catch (err) {
          _iterator27.e(err);
        } finally {
          _iterator27.f();
        }
      }
    }, {
      key: "_clearActiveClass",
      value: function _clearActiveClass(parent) {
        parent.classList.remove(CLASS_NAME_ACTIVE$1);
        var activeNodes = SelectorEngine.find("".concat(SELECTOR_TARGET_LINKS, ".").concat(CLASS_NAME_ACTIVE$1), parent);

        var _iterator29 = _createForOfIteratorHelper(activeNodes),
            _step29;

        try {
          for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
            var node = _step29.value;
            node.classList.remove(CLASS_NAME_ACTIVE$1);
          }
        } catch (err) {
          _iterator29.e(err);
        } finally {
          _iterator29.f();
        }
      } // Static

    }], [{
      key: "Default",
      get: function get() {
        return Default$1;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$1;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME$2;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        return this.each(function () {
          var data = ScrollSpy.getOrCreateInstance(this, config);

          if (typeof config !== 'string') {
            return;
          }

          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config]();
        });
      }
    }]);

    return ScrollSpy;
  }(BaseComponent);
  /**
   * Data API implementation
   */


  EventHandler.on(window, EVENT_LOAD_DATA_API$1, function () {
    var _iterator30 = _createForOfIteratorHelper(SelectorEngine.find(SELECTOR_DATA_SPY)),
        _step30;

    try {
      for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {
        var spy = _step30.value;
        ScrollSpy.getOrCreateInstance(spy);
      }
    } catch (err) {
      _iterator30.e(err);
    } finally {
      _iterator30.f();
    }
  });
  /**
   * jQuery
   */

  defineJQueryPlugin(ScrollSpy);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): tab.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  var NAME$1 = 'tab';
  var DATA_KEY$1 = 'bs.tab';
  var EVENT_KEY$1 = ".".concat(DATA_KEY$1);
  var EVENT_HIDE$1 = "hide".concat(EVENT_KEY$1);
  var EVENT_HIDDEN$1 = "hidden".concat(EVENT_KEY$1);
  var EVENT_SHOW$1 = "show".concat(EVENT_KEY$1);
  var EVENT_SHOWN$1 = "shown".concat(EVENT_KEY$1);
  var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY$1);
  var EVENT_KEYDOWN = "keydown".concat(EVENT_KEY$1);
  var EVENT_LOAD_DATA_API = "load".concat(EVENT_KEY$1);
  var ARROW_LEFT_KEY = 'ArrowLeft';
  var ARROW_RIGHT_KEY = 'ArrowRight';
  var ARROW_UP_KEY = 'ArrowUp';
  var ARROW_DOWN_KEY = 'ArrowDown';
  var CLASS_NAME_ACTIVE = 'active';
  var CLASS_NAME_FADE$1 = 'fade';
  var CLASS_NAME_SHOW$1 = 'show';
  var CLASS_DROPDOWN = 'dropdown';
  var SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';
  var SELECTOR_DROPDOWN_MENU = '.dropdown-menu';
  var NOT_SELECTOR_DROPDOWN_TOGGLE = ':not(.dropdown-toggle)';
  var SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
  var SELECTOR_OUTER = '.nav-item, .list-group-item';
  var SELECTOR_INNER = ".nav-link".concat(NOT_SELECTOR_DROPDOWN_TOGGLE, ", .list-group-item").concat(NOT_SELECTOR_DROPDOWN_TOGGLE, ", [role=\"tab\"]").concat(NOT_SELECTOR_DROPDOWN_TOGGLE);
  var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]'; // todo:v6: could be only `tab`

  var SELECTOR_INNER_ELEM = "".concat(SELECTOR_INNER, ", ").concat(SELECTOR_DATA_TOGGLE);
  var SELECTOR_DATA_TOGGLE_ACTIVE = ".".concat(CLASS_NAME_ACTIVE, "[data-bs-toggle=\"tab\"], .").concat(CLASS_NAME_ACTIVE, "[data-bs-toggle=\"pill\"], .").concat(CLASS_NAME_ACTIVE, "[data-bs-toggle=\"list\"]");
  /**
   * Class definition
   */

  var Tab = /*#__PURE__*/function (_BaseComponent10) {
    _inherits(Tab, _BaseComponent10);

    var _super16 = _createSuper(Tab);

    function Tab(element) {
      var _this51;

      _classCallCheck(this, Tab);

      _this51 = _super16.call(this, element);
      _this51._parent = _this51._element.closest(SELECTOR_TAB_PANEL);

      if (!_this51._parent) {
        return _possibleConstructorReturn(_this51); // todo: should Throw exception on v6
        // throw new TypeError(`${element.outerHTML} has not a valid parent ${SELECTOR_INNER_ELEM}`)
      } // Set up initial aria attributes


      _this51._setInitialAttributes(_this51._parent, _this51._getChildren());

      EventHandler.on(_this51._element, EVENT_KEYDOWN, function (event) {
        return _this51._keydown(event);
      });
      return _this51;
    } // Getters


    _createClass(Tab, [{
      key: "show",
      value: // Public
      function show() {
        // Shows this elem and deactivate the active sibling if exists
        var innerElem = this._element;

        if (this._elemIsActive(innerElem)) {
          return;
        } // Search for active tab on same parent to deactivate it


        var active = this._getActiveElem();

        var hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
          relatedTarget: innerElem
        }) : null;
        var showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
          relatedTarget: active
        });

        if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
          return;
        }

        this._deactivate(active, innerElem);

        this._activate(innerElem, active);
      } // Private

    }, {
      key: "_activate",
      value: function _activate(element, relatedElem) {
        var _this52 = this;

        if (!element) {
          return;
        }

        element.classList.add(CLASS_NAME_ACTIVE);

        this._activate(getElementFromSelector(element)); // Search and activate/show the proper section


        var complete = function complete() {
          if (element.getAttribute('role') !== 'tab') {
            element.classList.add(CLASS_NAME_SHOW$1);
            return;
          }

          element.removeAttribute('tabindex');
          element.setAttribute('aria-selected', true);

          _this52._toggleDropDown(element, true);

          EventHandler.trigger(element, EVENT_SHOWN$1, {
            relatedTarget: relatedElem
          });
        };

        this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
      }
    }, {
      key: "_deactivate",
      value: function _deactivate(element, relatedElem) {
        var _this53 = this;

        if (!element) {
          return;
        }

        element.classList.remove(CLASS_NAME_ACTIVE);
        element.blur();

        this._deactivate(getElementFromSelector(element)); // Search and deactivate the shown section too


        var complete = function complete() {
          if (element.getAttribute('role') !== 'tab') {
            element.classList.remove(CLASS_NAME_SHOW$1);
            return;
          }

          element.setAttribute('aria-selected', false);
          element.setAttribute('tabindex', '-1');

          _this53._toggleDropDown(element, false);

          EventHandler.trigger(element, EVENT_HIDDEN$1, {
            relatedTarget: relatedElem
          });
        };

        this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
      }
    }, {
      key: "_keydown",
      value: function _keydown(event) {
        if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY].includes(event.key)) {
          return;
        }

        event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page

        event.preventDefault();
        var isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);
        var nextActiveElement = getNextActiveElement(this._getChildren().filter(function (element) {
          return !isDisabled(element);
        }), event.target, isNext, true);

        if (nextActiveElement) {
          nextActiveElement.focus({
            preventScroll: true
          });
          Tab.getOrCreateInstance(nextActiveElement).show();
        }
      }
    }, {
      key: "_getChildren",
      value: function _getChildren() {
        // collection of inner elements
        return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
      }
    }, {
      key: "_getActiveElem",
      value: function _getActiveElem() {
        var _this54 = this;

        return this._getChildren().find(function (child) {
          return _this54._elemIsActive(child);
        }) || null;
      }
    }, {
      key: "_setInitialAttributes",
      value: function _setInitialAttributes(parent, children) {
        this._setAttributeIfNotExists(parent, 'role', 'tablist');

        var _iterator31 = _createForOfIteratorHelper(children),
            _step31;

        try {
          for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {
            var child = _step31.value;

            this._setInitialAttributesOnChild(child);
          }
        } catch (err) {
          _iterator31.e(err);
        } finally {
          _iterator31.f();
        }
      }
    }, {
      key: "_setInitialAttributesOnChild",
      value: function _setInitialAttributesOnChild(child) {
        child = this._getInnerElement(child);

        var isActive = this._elemIsActive(child);

        var outerElem = this._getOuterElement(child);

        child.setAttribute('aria-selected', isActive);

        if (outerElem !== child) {
          this._setAttributeIfNotExists(outerElem, 'role', 'presentation');
        }

        if (!isActive) {
          child.setAttribute('tabindex', '-1');
        }

        this._setAttributeIfNotExists(child, 'role', 'tab'); // set attributes to the related panel too


        this._setInitialAttributesOnTargetPanel(child);
      }
    }, {
      key: "_setInitialAttributesOnTargetPanel",
      value: function _setInitialAttributesOnTargetPanel(child) {
        var target = getElementFromSelector(child);

        if (!target) {
          return;
        }

        this._setAttributeIfNotExists(target, 'role', 'tabpanel');

        if (child.id) {
          this._setAttributeIfNotExists(target, 'aria-labelledby', "#".concat(child.id));
        }
      }
    }, {
      key: "_toggleDropDown",
      value: function _toggleDropDown(element, open) {
        var outerElem = this._getOuterElement(element);

        if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
          return;
        }

        var toggle = function toggle(selector, className) {
          var element = SelectorEngine.findOne(selector, outerElem);

          if (element) {
            element.classList.toggle(className, open);
          }
        };

        toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
        toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
        outerElem.setAttribute('aria-expanded', open);
      }
    }, {
      key: "_setAttributeIfNotExists",
      value: function _setAttributeIfNotExists(element, attribute, value) {
        if (!element.hasAttribute(attribute)) {
          element.setAttribute(attribute, value);
        }
      }
    }, {
      key: "_elemIsActive",
      value: function _elemIsActive(elem) {
        return elem.classList.contains(CLASS_NAME_ACTIVE);
      } // Try to get the inner element (usually the .nav-link)

    }, {
      key: "_getInnerElement",
      value: function _getInnerElement(elem) {
        return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
      } // Try to get the outer element (usually the .nav-item)

    }, {
      key: "_getOuterElement",
      value: function _getOuterElement(elem) {
        return elem.closest(SELECTOR_OUTER) || elem;
      } // Static

    }], [{
      key: "NAME",
      get: function get() {
        return NAME$1;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        return this.each(function () {
          var data = Tab.getOrCreateInstance(this);

          if (typeof config !== 'string') {
            return;
          }

          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config]();
        });
      }
    }]);

    return Tab;
  }(BaseComponent);
  /**
   * Data API implementation
   */


  EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
    if (['A', 'AREA'].includes(this.tagName)) {
      event.preventDefault();
    }

    if (isDisabled(this)) {
      return;
    }

    Tab.getOrCreateInstance(this).show();
  });
  /**
   * Initialize on focus
   */

  EventHandler.on(window, EVENT_LOAD_DATA_API, function () {
    var _iterator32 = _createForOfIteratorHelper(SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)),
        _step32;

    try {
      for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {
        var element = _step32.value;
        Tab.getOrCreateInstance(element);
      }
    } catch (err) {
      _iterator32.e(err);
    } finally {
      _iterator32.f();
    }
  });
  /**
   * jQuery
   */

  defineJQueryPlugin(Tab);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): toast.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  var NAME = 'toast';
  var DATA_KEY = 'bs.toast';
  var EVENT_KEY = ".".concat(DATA_KEY);
  var EVENT_MOUSEOVER = "mouseover".concat(EVENT_KEY);
  var EVENT_MOUSEOUT = "mouseout".concat(EVENT_KEY);
  var EVENT_FOCUSIN = "focusin".concat(EVENT_KEY);
  var EVENT_FOCUSOUT = "focusout".concat(EVENT_KEY);
  var EVENT_HIDE = "hide".concat(EVENT_KEY);
  var EVENT_HIDDEN = "hidden".concat(EVENT_KEY);
  var EVENT_SHOW = "show".concat(EVENT_KEY);
  var EVENT_SHOWN = "shown".concat(EVENT_KEY);
  var CLASS_NAME_FADE = 'fade';
  var CLASS_NAME_HIDE = 'hide'; // @deprecated - kept here only for backwards compatibility

  var CLASS_NAME_SHOW = 'show';
  var CLASS_NAME_SHOWING = 'showing';
  var DefaultType = {
    animation: 'boolean',
    autohide: 'boolean',
    delay: 'number'
  };
  var Default = {
    animation: true,
    autohide: true,
    delay: 5000
  };
  /**
   * Class definition
   */

  var Toast = /*#__PURE__*/function (_BaseComponent11) {
    _inherits(Toast, _BaseComponent11);

    var _super17 = _createSuper(Toast);

    function Toast(element, config) {
      var _this55;

      _classCallCheck(this, Toast);

      _this55 = _super17.call(this, element, config);
      _this55._timeout = null;
      _this55._hasMouseInteraction = false;
      _this55._hasKeyboardInteraction = false;

      _this55._setListeners();

      return _this55;
    } // Getters


    _createClass(Toast, [{
      key: "show",
      value: // Public
      function show() {
        var _this56 = this;

        var showEvent = EventHandler.trigger(this._element, EVENT_SHOW);

        if (showEvent.defaultPrevented) {
          return;
        }

        this._clearTimeout();

        if (this._config.animation) {
          this._element.classList.add(CLASS_NAME_FADE);
        }

        var complete = function complete() {
          _this56._element.classList.remove(CLASS_NAME_SHOWING);

          EventHandler.trigger(_this56._element, EVENT_SHOWN);

          _this56._maybeScheduleHide();
        };

        this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated


        reflow(this._element);

        this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);

        this._queueCallback(complete, this._element, this._config.animation);
      }
    }, {
      key: "hide",
      value: function hide() {
        var _this57 = this;

        if (!this.isShown()) {
          return;
        }

        var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);

        if (hideEvent.defaultPrevented) {
          return;
        }

        var complete = function complete() {
          _this57._element.classList.add(CLASS_NAME_HIDE); // @deprecated


          _this57._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);

          EventHandler.trigger(_this57._element, EVENT_HIDDEN);
        };

        this._element.classList.add(CLASS_NAME_SHOWING);

        this._queueCallback(complete, this._element, this._config.animation);
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this._clearTimeout();

        if (this.isShown()) {
          this._element.classList.remove(CLASS_NAME_SHOW);
        }

        _get(_getPrototypeOf(Toast.prototype), "dispose", this).call(this);
      }
    }, {
      key: "isShown",
      value: function isShown() {
        return this._element.classList.contains(CLASS_NAME_SHOW);
      } // Private

    }, {
      key: "_maybeScheduleHide",
      value: function _maybeScheduleHide() {
        var _this58 = this;

        if (!this._config.autohide) {
          return;
        }

        if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
          return;
        }

        this._timeout = setTimeout(function () {
          _this58.hide();
        }, this._config.delay);
      }
    }, {
      key: "_onInteraction",
      value: function _onInteraction(event, isInteracting) {
        switch (event.type) {
          case 'mouseover':
          case 'mouseout':
            {
              this._hasMouseInteraction = isInteracting;
              break;
            }

          case 'focusin':
          case 'focusout':
            {
              this._hasKeyboardInteraction = isInteracting;
              break;
            }
        }

        if (isInteracting) {
          this._clearTimeout();

          return;
        }

        var nextElement = event.relatedTarget;

        if (this._element === nextElement || this._element.contains(nextElement)) {
          return;
        }

        this._maybeScheduleHide();
      }
    }, {
      key: "_setListeners",
      value: function _setListeners() {
        var _this59 = this;

        EventHandler.on(this._element, EVENT_MOUSEOVER, function (event) {
          return _this59._onInteraction(event, true);
        });
        EventHandler.on(this._element, EVENT_MOUSEOUT, function (event) {
          return _this59._onInteraction(event, false);
        });
        EventHandler.on(this._element, EVENT_FOCUSIN, function (event) {
          return _this59._onInteraction(event, true);
        });
        EventHandler.on(this._element, EVENT_FOCUSOUT, function (event) {
          return _this59._onInteraction(event, false);
        });
      }
    }, {
      key: "_clearTimeout",
      value: function _clearTimeout() {
        clearTimeout(this._timeout);
        this._timeout = null;
      } // Static

    }], [{
      key: "Default",
      get: function get() {
        return Default;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        return this.each(function () {
          var data = Toast.getOrCreateInstance(this, config);

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"".concat(config, "\""));
            }

            data[config](this);
          }
        });
      }
    }]);

    return Toast;
  }(BaseComponent);
  /**
   * Data API implementation
   */


  enableDismissTrigger(Toast);
  /**
   * jQuery
   */

  defineJQueryPlugin(Toast);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.2): index.umd.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  var index_umd = {
    Alert: Alert,
    Button: Button,
    Carousel: Carousel,
    Collapse: Collapse,
    Dropdown: Dropdown,
    Modal: Modal,
    Offcanvas: Offcanvas,
    Popover: Popover,
    ScrollSpy: ScrollSpy,
    Tab: Tab,
    Toast: Toast,
    Tooltip: Tooltip
  };
  return index_umd;
});
$(function () {
  toggleConnectionStringAndPrefix(); // Show hide the connection string when a provider is selected

  $("#DatabaseProvider").change(function () {
    toggleConnectionStringAndPrefix();
  }); // Refresh the recipe description

  $("#recipes div a").on('click', function () {
    refreshDescription($(this));
  });
}); // Show or hide the connection string or table prefix section when the database provider is selected

function toggleConnectionStringAndPrefix() {
  $("#DatabaseProvider option:selected").each(function () {
    $(this).data("connection-string").toLowerCase() === "true" ? $(".connectionString").show() : $(".connectionString").hide();
    $(this).data("table-prefix").toLowerCase() === "true" ? $(".tablePrefix").show() : $(".tablePrefix").hide();
    $(this).data("connection-string").toLowerCase() === "true" ? $(".pwd").attr('required', 'required') : $(".pwd").removeAttr('required');
    $("#connectionStringHint").text($(this).data("connection-string-sample"));
  });
} // Show the recipe description


function refreshDescription(target) {
  var recipeName = $(target).data("recipe-name");
  var recipeDisplayName = $(target).data("recipe-display-name");
  var recipeDescription = $(target).data("recipe-description");
  $("#recipeButton").text(recipeDisplayName);
  $("#RecipeName").val(recipeName);
  $("#recipeButton").attr("title", recipeDescription);
  $("#recipeButton").focus();
}

function setLocalizationUrl() {
  var culturesList = document.getElementById('culturesList');
  window.location = culturesList.options[culturesList.selectedIndex].dataset.url;
}

function togglePasswordVisibility(passwordCtl, togglePasswordCtl) {
  // toggle the type attribute
  type = passwordCtl.getAttribute('type') === 'password' ? 'text' : 'password';
  passwordCtl.setAttribute('type', type); // toggle the eye slash icon

  icon = togglePasswordCtl.getElementsByClassName('icon')[0];

  if (icon.getAttribute('data-icon')) {
    // if the icon is rendered as a svg
    type === 'password' ? icon.setAttribute('data-icon', 'eye') : icon.setAttribute('data-icon', 'eye-slash');
  } else {
    // if the icon is still a <i> element
    type === 'password' ? icon.classList.remove('fa-eye-slash') : icon.classList.remove('fa-eye');
    type === 'password' ? icon.classList.add('fa-eye') : icon.classList.add('fa-eye-slash');
  }
}
(function ($) {
  $.fn.strength = function (options) {
    var settings = $.extend({
      minLength: 8,
      upperCase: false,
      lowerCase: false,
      numbers: false,
      specialchars: false,
      target: '',
      style: ''
    }, options);
    var capitalletters = 0;
    var lowerletters = 0;
    var numbers = 0;
    var specialchars = 0;
    var upperCase = new RegExp('[A-Z]');
    var lowerCase = new RegExp('[a-z]');
    var number = new RegExp('[0-9]');
    var specialchar = new RegExp('[^A-Za-z0-9]');
    var valid = false;
    createProgressBar(0, '');

    function getPercentage(a, b) {
      return (b / a * 100).toFixed(0);
    }

    function getLevel(value) {
      if (value >= 100) {
        return "bg-success";
      }

      if (value >= 50) {
        return "bg-warning";
      }

      if (value == 0) {
        return ''; // grayed
      }

      return "bg-danger";
    }

    function checkStrength(value) {
      minLength = value.length >= settings.minLength ? 1 : 0;
      capitalletters = !settings.upperCase || value.match(upperCase) ? 1 : 0;
      lowerletters = !settings.lowerCase || value.match(lowerCase) ? 1 : 0;
      numbers = !settings.numbers || value.match(number) ? 1 : 0;
      specialchars = !settings.specialchars || value.match(specialchar) ? 1 : 0;
      var total = minLength + capitalletters + lowerletters + numbers + specialchars;
      var percentage = getPercentage(5, total);
      valid = percentage >= 100;
      createProgressBar(percentage, getLevel(percentage));
    }

    function createProgressBar(percentage, level) {
      var el = $('<div class="progress" value="' + percentage + '" style="' + settings.style + '" max="100" aria-describedby=""><div class="progress-bar ' + level + '" role="progress-bar" style="width: ' + percentage + '%;"></div></div>');
      var target = $(settings.target);
      target.empty();
      target.append(el);
    }

    this.bind('keyup keydown', function (event) {
      checkStrength($(this).val());
    });
    this.bind('drop', function (event) {
      checkStrength(event.originalEvent.dataTransfer.getData("text"));
    });
    this.parents('form').on('submit', function () {
      if (!valid) {
        event.preventDefault();
      }
    });
  };
})(jQuery);
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0V2luZG93LmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzIiwiLi4vLi4vc3JjL3V0aWxzL21hdGguanMiLCIuLi8uLi9zcmMvdXRpbHMvdXNlckFnZW50LmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9pc0xheW91dFZpZXdwb3J0LmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbC5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2dldE5vZGVTY3JvbGwuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbEJhclguanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXRTY3JvbGxQYXJlbnQuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9pc1RhYmxlRWxlbWVudC5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzIiwiLi4vLi4vc3JjL2VudW1zLmpzIiwiLi4vLi4vc3JjL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzIiwiLi4vLi4vc3JjL3V0aWxzL2RlYm91bmNlLmpzIiwiLi4vLi4vc3JjL3V0aWxzL2Zvcm1hdC5qcyIsIi4uLy4uL3NyYy91dGlscy92YWxpZGF0ZU1vZGlmaWVycy5qcyIsIi4uLy4uL3NyYy91dGlscy91bmlxdWVCeS5qcyIsIi4uLy4uL3NyYy91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzIiwiLi4vLi4vc3JjL3V0aWxzL21lcmdlQnlOYW1lLmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXRWaWV3cG9ydFJlY3QuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2dldERvY3VtZW50UmVjdC5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvY29udGFpbnMuanMiLCIuLi8uLi9zcmMvdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzIiwiLi4vLi4vc3JjL3V0aWxzL2dldFZhcmlhdGlvbi5qcyIsIi4uLy4uL3NyYy91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanMiLCIuLi8uLi9zcmMvdXRpbHMvY29tcHV0ZU9mZnNldHMuanMiLCIuLi8uLi9zcmMvdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzIiwiLi4vLi4vc3JjL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcyIsIi4uLy4uL3NyYy91dGlscy9leHBhbmRUb0hhc2hNYXAuanMiLCIuLi8uLi9zcmMvdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanMiLCIuLi8uLi9zcmMvY3JlYXRlUG9wcGVyLmpzIiwiLi4vLi4vc3JjL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qcyIsIi4uLy4uL3NyYy9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcyIsIi4uLy4uL3NyYy9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qcyIsIi4uLy4uL3NyYy9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanMiLCIuLi8uLi9zcmMvbW9kaWZpZXJzL29mZnNldC5qcyIsIi4uLy4uL3NyYy91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qcyIsIi4uLy4uL3NyYy91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qcyIsIi4uLy4uL3NyYy91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qcyIsIi4uLy4uL3NyYy9tb2RpZmllcnMvZmxpcC5qcyIsIi4uLy4uL3NyYy91dGlscy9nZXRBbHRBeGlzLmpzIiwiLi4vLi4vc3JjL3V0aWxzL3dpdGhpbi5qcyIsIi4uLy4uL3NyYy9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzIiwiLi4vLi4vc3JjL21vZGlmaWVycy9hcnJvdy5qcyIsIi4uLy4uL3NyYy9tb2RpZmllcnMvaGlkZS5qcyIsIi4uLy4uL3NyYy9wb3BwZXItbGl0ZS5qcyIsIi4uLy4uL3NyYy9wb3BwZXIuanMiLCIuLi8uLi9qcy9zcmMvdXRpbC9pbmRleC5qcyIsIi4uLy4uL2pzL3NyYy9kb20vZXZlbnQtaGFuZGxlci5qcyIsIi4uLy4uL2pzL3NyYy9kb20vZGF0YS5qcyIsIi4uLy4uL2pzL3NyYy9kb20vbWFuaXB1bGF0b3IuanMiLCIuLi8uLi9qcy9zcmMvdXRpbC9jb25maWcuanMiLCIuLi8uLi9qcy9zcmMvYmFzZS1jb21wb25lbnQuanMiLCIuLi8uLi9qcy9zcmMvdXRpbC9jb21wb25lbnQtZnVuY3Rpb25zLmpzIiwiLi4vLi4vanMvc3JjL2FsZXJ0LmpzIiwiLi4vLi4vanMvc3JjL2J1dHRvbi5qcyIsIi4uLy4uL2pzL3NyYy9kb20vc2VsZWN0b3ItZW5naW5lLmpzIiwiLi4vLi4vanMvc3JjL3V0aWwvc3dpcGUuanMiLCIuLi8uLi9qcy9zcmMvY2Fyb3VzZWwuanMiLCIuLi8uLi9qcy9zcmMvY29sbGFwc2UuanMiLCIuLi8uLi9qcy9zcmMvZHJvcGRvd24uanMiLCIuLi8uLi9qcy9zcmMvdXRpbC9zY3JvbGxiYXIuanMiLCIuLi8uLi9qcy9zcmMvdXRpbC9iYWNrZHJvcC5qcyIsIi4uLy4uL2pzL3NyYy91dGlsL2ZvY3VzdHJhcC5qcyIsIi4uLy4uL2pzL3NyYy9tb2RhbC5qcyIsIi4uLy4uL2pzL3NyYy9vZmZjYW52YXMuanMiLCIuLi8uLi9qcy9zcmMvdXRpbC9zYW5pdGl6ZXIuanMiLCIuLi8uLi9qcy9zcmMvdXRpbC90ZW1wbGF0ZS1mYWN0b3J5LmpzIiwiLi4vLi4vanMvc3JjL3Rvb2x0aXAuanMiLCIuLi8uLi9qcy9zcmMvcG9wb3Zlci5qcyIsIi4uLy4uL2pzL3NyYy9zY3JvbGxzcHkuanMiLCIuLi8uLi9qcy9zcmMvdGFiLmpzIiwiLi4vLi4vanMvc3JjL3RvYXN0LmpzIiwiLi4vLi4vanMvaW5kZXgudW1kLmpzIiwic2V0dXAuanMiLCJzdHJlbmd0aC5qcyJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwibW9kdWxlIiwiZXhwb3J0cyIsImRvY3VtZW50IiwidyIsIkVycm9yIiwid2luZG93Iiwibm9HbG9iYWwiLCJhcnIiLCJnZXRQcm90byIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwic2xpY2UiLCJmbGF0IiwiYXJyYXkiLCJjYWxsIiwiY29uY2F0IiwiYXBwbHkiLCJwdXNoIiwiaW5kZXhPZiIsImNsYXNzMnR5cGUiLCJ0b1N0cmluZyIsImhhc093biIsImhhc093blByb3BlcnR5IiwiZm5Ub1N0cmluZyIsIk9iamVjdEZ1bmN0aW9uU3RyaW5nIiwic3VwcG9ydCIsImlzRnVuY3Rpb24iLCJvYmoiLCJub2RlVHlwZSIsIml0ZW0iLCJpc1dpbmRvdyIsInByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMiLCJ0eXBlIiwic3JjIiwibm9uY2UiLCJub01vZHVsZSIsIkRPTUV2YWwiLCJjb2RlIiwibm9kZSIsImRvYyIsImkiLCJ2YWwiLCJzY3JpcHQiLCJjcmVhdGVFbGVtZW50IiwidGV4dCIsImdldEF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsImhlYWQiLCJhcHBlbmRDaGlsZCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsInRvVHlwZSIsInZlcnNpb24iLCJqUXVlcnkiLCJzZWxlY3RvciIsImNvbnRleHQiLCJmbiIsImluaXQiLCJwcm90b3R5cGUiLCJqcXVlcnkiLCJjb25zdHJ1Y3RvciIsImxlbmd0aCIsInRvQXJyYXkiLCJnZXQiLCJudW0iLCJwdXNoU3RhY2siLCJlbGVtcyIsInJldCIsIm1lcmdlIiwicHJldk9iamVjdCIsImVhY2giLCJjYWxsYmFjayIsIm1hcCIsImVsZW0iLCJhcmd1bWVudHMiLCJmaXJzdCIsImVxIiwibGFzdCIsImV2ZW4iLCJncmVwIiwiX2VsZW0iLCJvZGQiLCJsZW4iLCJqIiwiZW5kIiwic29ydCIsInNwbGljZSIsImV4dGVuZCIsIm9wdGlvbnMiLCJuYW1lIiwiY29weSIsImNvcHlJc0FycmF5IiwiY2xvbmUiLCJ0YXJnZXQiLCJkZWVwIiwiaXNQbGFpbk9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsInVuZGVmaW5lZCIsImV4cGFuZG8iLCJNYXRoIiwicmFuZG9tIiwicmVwbGFjZSIsImlzUmVhZHkiLCJlcnJvciIsIm1zZyIsIm5vb3AiLCJwcm90byIsIkN0b3IiLCJpc0VtcHR5T2JqZWN0IiwiZ2xvYmFsRXZhbCIsImlzQXJyYXlMaWtlIiwibWFrZUFycmF5IiwicmVzdWx0cyIsImluQXJyYXkiLCJzZWNvbmQiLCJpbnZlcnQiLCJjYWxsYmFja0ludmVyc2UiLCJtYXRjaGVzIiwiY2FsbGJhY2tFeHBlY3QiLCJhcmciLCJ2YWx1ZSIsImd1aWQiLCJTeW1ib2wiLCJpdGVyYXRvciIsInNwbGl0IiwiX2kiLCJ0b0xvd2VyQ2FzZSIsIlNpenpsZSIsIkV4cHIiLCJnZXRUZXh0IiwiaXNYTUwiLCJ0b2tlbml6ZSIsImNvbXBpbGUiLCJzZWxlY3QiLCJvdXRlcm1vc3RDb250ZXh0Iiwic29ydElucHV0IiwiaGFzRHVwbGljYXRlIiwic2V0RG9jdW1lbnQiLCJkb2NFbGVtIiwiZG9jdW1lbnRJc0hUTUwiLCJyYnVnZ3lRU0EiLCJyYnVnZ3lNYXRjaGVzIiwiY29udGFpbnMiLCJEYXRlIiwicHJlZmVycmVkRG9jIiwiZGlycnVucyIsImRvbmUiLCJjbGFzc0NhY2hlIiwiY3JlYXRlQ2FjaGUiLCJ0b2tlbkNhY2hlIiwiY29tcGlsZXJDYWNoZSIsIm5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUiLCJzb3J0T3JkZXIiLCJhIiwiYiIsInBvcCIsInB1c2hOYXRpdmUiLCJsaXN0IiwiYm9vbGVhbnMiLCJ3aGl0ZXNwYWNlIiwiaWRlbnRpZmllciIsImF0dHJpYnV0ZXMiLCJwc2V1ZG9zIiwicndoaXRlc3BhY2UiLCJSZWdFeHAiLCJydHJpbSIsInJjb21tYSIsInJjb21iaW5hdG9ycyIsInJkZXNjZW5kIiwicnBzZXVkbyIsInJpZGVudGlmaWVyIiwibWF0Y2hFeHByIiwicmh0bWwiLCJyaW5wdXRzIiwicmhlYWRlciIsInJuYXRpdmUiLCJycXVpY2tFeHByIiwicnNpYmxpbmciLCJydW5lc2NhcGUiLCJmdW5lc2NhcGUiLCJlc2NhcGUiLCJub25IZXgiLCJoaWdoIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwicmNzc2VzY2FwZSIsImZjc3Nlc2NhcGUiLCJjaCIsImFzQ29kZVBvaW50IiwiY2hhckNvZGVBdCIsInVubG9hZEhhbmRsZXIiLCJpbkRpc2FibGVkRmllbGRzZXQiLCJhZGRDb21iaW5hdG9yIiwiZGlzYWJsZWQiLCJub2RlTmFtZSIsImRpciIsIm5leHQiLCJjaGlsZE5vZGVzIiwiZSIsImVscyIsInNlZWQiLCJtIiwibmlkIiwibWF0Y2giLCJncm91cHMiLCJuZXdTZWxlY3RvciIsIm5ld0NvbnRleHQiLCJvd25lckRvY3VtZW50IiwiZXhlYyIsImdldEVsZW1lbnRCeUlkIiwiaWQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJxc2EiLCJ0ZXN0IiwidGVzdENvbnRleHQiLCJzY29wZSIsInRvU2VsZWN0b3IiLCJqb2luIiwicXVlcnlTZWxlY3RvckFsbCIsInFzYUVycm9yIiwicmVtb3ZlQXR0cmlidXRlIiwia2V5cyIsImNhY2hlIiwia2V5IiwiY2FjaGVMZW5ndGgiLCJzaGlmdCIsIm1hcmtGdW5jdGlvbiIsImFzc2VydCIsImVsIiwiYWRkSGFuZGxlIiwiYXR0cnMiLCJoYW5kbGVyIiwiYXR0ckhhbmRsZSIsInNpYmxpbmdDaGVjayIsImN1ciIsImRpZmYiLCJzb3VyY2VJbmRleCIsIm5leHRTaWJsaW5nIiwiY3JlYXRlSW5wdXRQc2V1ZG8iLCJjcmVhdGVCdXR0b25Qc2V1ZG8iLCJjcmVhdGVEaXNhYmxlZFBzZXVkbyIsImlzRGlzYWJsZWQiLCJjcmVhdGVQb3NpdGlvbmFsUHNldWRvIiwiYXJndW1lbnQiLCJtYXRjaEluZGV4ZXMiLCJuYW1lc3BhY2UiLCJuYW1lc3BhY2VVUkkiLCJkb2N1bWVudEVsZW1lbnQiLCJoYXNDb21wYXJlIiwic3ViV2luZG93IiwiZGVmYXVsdFZpZXciLCJ0b3AiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJjbGFzc05hbWUiLCJjcmVhdGVDb21tZW50IiwiZ2V0QnlJZCIsImdldEVsZW1lbnRzQnlOYW1lIiwiZmlsdGVyIiwiYXR0cklkIiwiZmluZCIsImdldEF0dHJpYnV0ZU5vZGUiLCJ0YWciLCJ0bXAiLCJpbnB1dCIsImlubmVySFRNTCIsIm1hdGNoZXNTZWxlY3RvciIsIndlYmtpdE1hdGNoZXNTZWxlY3RvciIsIm1vek1hdGNoZXNTZWxlY3RvciIsIm9NYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsImRpc2Nvbm5lY3RlZE1hdGNoIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJhZG93biIsImJ1cCIsImNvbXBhcmUiLCJzb3J0RGV0YWNoZWQiLCJhdXAiLCJhcCIsImJwIiwidW5zaGlmdCIsImV4cHIiLCJlbGVtZW50cyIsImF0dHIiLCJzcGVjaWZpZWQiLCJzZWwiLCJ1bmlxdWVTb3J0IiwiZHVwbGljYXRlcyIsImRldGVjdER1cGxpY2F0ZXMiLCJzb3J0U3RhYmxlIiwidGV4dENvbnRlbnQiLCJmaXJzdENoaWxkIiwibm9kZVZhbHVlIiwic2VsZWN0b3JzIiwiY3JlYXRlUHNldWRvIiwicmVsYXRpdmUiLCJwcmVGaWx0ZXIiLCJleGNlc3MiLCJ1bnF1b3RlZCIsIm5vZGVOYW1lU2VsZWN0b3IiLCJwYXR0ZXJuIiwib3BlcmF0b3IiLCJjaGVjayIsInJlc3VsdCIsIndoYXQiLCJfYXJndW1lbnQiLCJzaW1wbGUiLCJmb3J3YXJkIiwib2ZUeXBlIiwiX2NvbnRleHQiLCJ4bWwiLCJ1bmlxdWVDYWNoZSIsIm91dGVyQ2FjaGUiLCJub2RlSW5kZXgiLCJzdGFydCIsInBhcmVudCIsInVzZUNhY2hlIiwibGFzdENoaWxkIiwidW5pcXVlSUQiLCJwc2V1ZG8iLCJhcmdzIiwic2V0RmlsdGVycyIsImlkeCIsIm1hdGNoZWQiLCJtYXRjaGVyIiwidW5tYXRjaGVkIiwibGFuZyIsImVsZW1MYW5nIiwiaGFzaCIsImxvY2F0aW9uIiwiYWN0aXZlRWxlbWVudCIsImhhc0ZvY3VzIiwiaHJlZiIsInRhYkluZGV4IiwiY2hlY2tlZCIsInNlbGVjdGVkIiwic2VsZWN0ZWRJbmRleCIsIl9tYXRjaEluZGV4ZXMiLCJyYWRpbyIsImNoZWNrYm94IiwiZmlsZSIsInBhc3N3b3JkIiwiaW1hZ2UiLCJzdWJtaXQiLCJyZXNldCIsImZpbHRlcnMiLCJwYXJzZU9ubHkiLCJ0b2tlbnMiLCJzb0ZhciIsInByZUZpbHRlcnMiLCJjYWNoZWQiLCJjb21iaW5hdG9yIiwiYmFzZSIsInNraXAiLCJjaGVja05vbkVsZW1lbnRzIiwiZG9uZU5hbWUiLCJvbGRDYWNoZSIsIm5ld0NhY2hlIiwiZWxlbWVudE1hdGNoZXIiLCJtYXRjaGVycyIsIm11bHRpcGxlQ29udGV4dHMiLCJjb250ZXh0cyIsImNvbmRlbnNlIiwibmV3VW5tYXRjaGVkIiwibWFwcGVkIiwic2V0TWF0Y2hlciIsInBvc3RGaWx0ZXIiLCJwb3N0RmluZGVyIiwicG9zdFNlbGVjdG9yIiwidGVtcCIsInByZU1hcCIsInBvc3RNYXAiLCJwcmVleGlzdGluZyIsIm1hdGNoZXJJbiIsIm1hdGNoZXJPdXQiLCJtYXRjaGVyRnJvbVRva2VucyIsImNoZWNrQ29udGV4dCIsImxlYWRpbmdSZWxhdGl2ZSIsImltcGxpY2l0UmVsYXRpdmUiLCJtYXRjaENvbnRleHQiLCJtYXRjaEFueUNvbnRleHQiLCJtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMiLCJlbGVtZW50TWF0Y2hlcnMiLCJzZXRNYXRjaGVycyIsImJ5U2V0IiwiYnlFbGVtZW50Iiwic3VwZXJNYXRjaGVyIiwib3V0ZXJtb3N0IiwibWF0Y2hlZENvdW50Iiwic2V0TWF0Y2hlZCIsImNvbnRleHRCYWNrdXAiLCJkaXJydW5zVW5pcXVlIiwidG9rZW4iLCJjb21waWxlZCIsIl9uYW1lIiwiZGVmYXVsdFZhbHVlIiwidW5pcXVlIiwiaXNYTUxEb2MiLCJlc2NhcGVTZWxlY3RvciIsInVudGlsIiwidHJ1bmNhdGUiLCJpcyIsInNpYmxpbmdzIiwibiIsInJuZWVkc0NvbnRleHQiLCJuZWVkc0NvbnRleHQiLCJyc2luZ2xlVGFnIiwid2lubm93IiwicXVhbGlmaWVyIiwibm90Iiwic2VsZiIsInJvb3RqUXVlcnkiLCJyb290IiwicGFyc2VIVE1MIiwicmVhZHkiLCJycGFyZW50c3ByZXYiLCJndWFyYW50ZWVkVW5pcXVlIiwiY2hpbGRyZW4iLCJjb250ZW50cyIsInByZXYiLCJoYXMiLCJ0YXJnZXRzIiwibCIsImNsb3Nlc3QiLCJpbmRleCIsInByZXZBbGwiLCJhZGQiLCJhZGRCYWNrIiwic2libGluZyIsInBhcmVudHMiLCJwYXJlbnRzVW50aWwiLCJuZXh0QWxsIiwibmV4dFVudGlsIiwicHJldlVudGlsIiwiY29udGVudERvY3VtZW50IiwiY29udGVudCIsInJldmVyc2UiLCJybm90aHRtbHdoaXRlIiwiY3JlYXRlT3B0aW9ucyIsIm9iamVjdCIsIl8iLCJmbGFnIiwiQ2FsbGJhY2tzIiwiZmlyaW5nIiwibWVtb3J5IiwiZmlyZWQiLCJsb2NrZWQiLCJxdWV1ZSIsImZpcmluZ0luZGV4IiwiZmlyZSIsIm9uY2UiLCJzdG9wT25GYWxzZSIsInJlbW92ZSIsImVtcHR5IiwiZGlzYWJsZSIsImxvY2siLCJmaXJlV2l0aCIsIklkZW50aXR5IiwidiIsIlRocm93ZXIiLCJleCIsImFkb3B0VmFsdWUiLCJyZXNvbHZlIiwicmVqZWN0Iiwibm9WYWx1ZSIsIm1ldGhvZCIsInByb21pc2UiLCJmYWlsIiwidGhlbiIsIkRlZmVycmVkIiwiZnVuYyIsInR1cGxlcyIsInN0YXRlIiwiYWx3YXlzIiwiZGVmZXJyZWQiLCJwaXBlIiwiZm5zIiwibmV3RGVmZXIiLCJ0dXBsZSIsInJldHVybmVkIiwicHJvZ3Jlc3MiLCJub3RpZnkiLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJvblByb2dyZXNzIiwibWF4RGVwdGgiLCJkZXB0aCIsInNwZWNpYWwiLCJ0aGF0IiwibWlnaHRUaHJvdyIsIlR5cGVFcnJvciIsIm5vdGlmeVdpdGgiLCJyZXNvbHZlV2l0aCIsInByb2Nlc3MiLCJleGNlcHRpb25Ib29rIiwic3RhY2tUcmFjZSIsInJlamVjdFdpdGgiLCJnZXRTdGFja0hvb2siLCJzZXRUaW1lb3V0Iiwic3RhdGVTdHJpbmciLCJ3aGVuIiwic2luZ2xlVmFsdWUiLCJyZW1haW5pbmciLCJyZXNvbHZlQ29udGV4dHMiLCJyZXNvbHZlVmFsdWVzIiwicHJpbWFyeSIsInVwZGF0ZUZ1bmMiLCJyZXJyb3JOYW1lcyIsInN0YWNrIiwiY29uc29sZSIsIndhcm4iLCJtZXNzYWdlIiwicmVhZHlFeGNlcHRpb24iLCJyZWFkeUxpc3QiLCJyZWFkeVdhaXQiLCJ3YWl0IiwiY29tcGxldGVkIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlYWR5U3RhdGUiLCJkb1Njcm9sbCIsImFjY2VzcyIsImNoYWluYWJsZSIsImVtcHR5R2V0IiwicmF3IiwiYnVsayIsIl9rZXkiLCJybXNQcmVmaXgiLCJyZGFzaEFscGhhIiwiZmNhbWVsQ2FzZSIsIl9hbGwiLCJsZXR0ZXIiLCJ0b1VwcGVyQ2FzZSIsImNhbWVsQ2FzZSIsInN0cmluZyIsImFjY2VwdERhdGEiLCJvd25lciIsIkRhdGEiLCJ1aWQiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsInNldCIsImRhdGEiLCJwcm9wIiwiaGFzRGF0YSIsImRhdGFQcml2IiwiZGF0YVVzZXIiLCJyYnJhY2UiLCJybXVsdGlEYXNoIiwiZ2V0RGF0YSIsIkpTT04iLCJwYXJzZSIsImRhdGFBdHRyIiwicmVtb3ZlRGF0YSIsIl9kYXRhIiwiX3JlbW92ZURhdGEiLCJkZXF1ZXVlIiwic3RhcnRMZW5ndGgiLCJob29rcyIsIl9xdWV1ZUhvb2tzIiwic3RvcCIsInNldHRlciIsImNsZWFyUXVldWUiLCJjb3VudCIsImRlZmVyIiwicG51bSIsInNvdXJjZSIsInJjc3NOdW0iLCJjc3NFeHBhbmQiLCJpc0F0dGFjaGVkIiwiY29tcG9zZWQiLCJnZXRSb290Tm9kZSIsImlzSGlkZGVuV2l0aGluVHJlZSIsInN0eWxlIiwiZGlzcGxheSIsImNzcyIsImFkanVzdENTUyIsInZhbHVlUGFydHMiLCJ0d2VlbiIsImFkanVzdGVkIiwic2NhbGUiLCJtYXhJdGVyYXRpb25zIiwiY3VycmVudFZhbHVlIiwiaW5pdGlhbCIsInVuaXQiLCJjc3NOdW1iZXIiLCJpbml0aWFsSW5Vbml0IiwiZGVmYXVsdERpc3BsYXlNYXAiLCJnZXREZWZhdWx0RGlzcGxheSIsImJvZHkiLCJzaG93SGlkZSIsInNob3ciLCJ2YWx1ZXMiLCJoaWRlIiwidG9nZ2xlIiwicmNoZWNrYWJsZVR5cGUiLCJydGFnTmFtZSIsInJzY3JpcHRUeXBlIiwiZnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiZGl2IiwiY2hlY2tDbG9uZSIsImNsb25lTm9kZSIsIm5vQ2xvbmVDaGVja2VkIiwib3B0aW9uIiwid3JhcE1hcCIsInRoZWFkIiwiY29sIiwidHIiLCJ0ZCIsIl9kZWZhdWx0IiwidGJvZHkiLCJ0Zm9vdCIsImNvbGdyb3VwIiwiY2FwdGlvbiIsInRoIiwib3B0Z3JvdXAiLCJnZXRBbGwiLCJzZXRHbG9iYWxFdmFsIiwicmVmRWxlbWVudHMiLCJidWlsZEZyYWdtZW50Iiwic2NyaXB0cyIsInNlbGVjdGlvbiIsImlnbm9yZWQiLCJ3cmFwIiwiYXR0YWNoZWQiLCJub2RlcyIsImNyZWF0ZVRleHROb2RlIiwiaHRtbFByZWZpbHRlciIsInJ0eXBlbmFtZXNwYWNlIiwicmV0dXJuVHJ1ZSIsInJldHVybkZhbHNlIiwiZXhwZWN0U3luYyIsInNhZmVBY3RpdmVFbGVtZW50IiwiZXJyIiwib24iLCJ0eXBlcyIsIm9uZSIsIm9yaWdGbiIsImV2ZW50Iiwib2ZmIiwiaGFuZGxlT2JqSW4iLCJldmVudEhhbmRsZSIsImV2ZW50cyIsInQiLCJoYW5kbGVPYmoiLCJoYW5kbGVycyIsIm5hbWVzcGFjZXMiLCJvcmlnVHlwZSIsImVsZW1EYXRhIiwiY3JlYXRlIiwiaGFuZGxlIiwidHJpZ2dlcmVkIiwiZGlzcGF0Y2giLCJkZWxlZ2F0ZVR5cGUiLCJiaW5kVHlwZSIsImRlbGVnYXRlQ291bnQiLCJzZXR1cCIsIm1hcHBlZFR5cGVzIiwib3JpZ0NvdW50IiwidGVhcmRvd24iLCJyZW1vdmVFdmVudCIsIm5hdGl2ZUV2ZW50IiwiaGFuZGxlclF1ZXVlIiwiZml4IiwiZGVsZWdhdGVUYXJnZXQiLCJwcmVEaXNwYXRjaCIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiY3VycmVudFRhcmdldCIsImlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkIiwicm5hbWVzcGFjZSIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwicG9zdERpc3BhdGNoIiwibWF0Y2hlZEhhbmRsZXJzIiwibWF0Y2hlZFNlbGVjdG9ycyIsImJ1dHRvbiIsImFkZFByb3AiLCJob29rIiwiRXZlbnQiLCJlbnVtZXJhYmxlIiwib3JpZ2luYWxFdmVudCIsIndyaXRhYmxlIiwibG9hZCIsIm5vQnViYmxlIiwiY2xpY2siLCJsZXZlcmFnZU5hdGl2ZSIsInRyaWdnZXIiLCJiZWZvcmV1bmxvYWQiLCJyZXR1cm5WYWx1ZSIsIm5vdEFzeW5jIiwic2F2ZWQiLCJpc1RyaWdnZXIiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJwcm9wcyIsImlzRGVmYXVsdFByZXZlbnRlZCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJyZWxhdGVkVGFyZ2V0IiwidGltZVN0YW1wIiwibm93IiwiaXNTaW11bGF0ZWQiLCJhbHRLZXkiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImNoYW5nZWRUb3VjaGVzIiwiY3RybEtleSIsImRldGFpbCIsImV2ZW50UGhhc2UiLCJtZXRhS2V5IiwicGFnZVgiLCJwYWdlWSIsInNoaWZ0S2V5IiwidmlldyIsImNoYXJDb2RlIiwia2V5Q29kZSIsImJ1dHRvbnMiLCJjbGllbnRYIiwiY2xpZW50WSIsIm9mZnNldFgiLCJvZmZzZXRZIiwicG9pbnRlcklkIiwicG9pbnRlclR5cGUiLCJzY3JlZW5YIiwic2NyZWVuWSIsInRhcmdldFRvdWNoZXMiLCJ0b0VsZW1lbnQiLCJ0b3VjaGVzIiwid2hpY2giLCJmb2N1cyIsImJsdXIiLCJtb3VzZWVudGVyIiwibW91c2VsZWF2ZSIsInBvaW50ZXJlbnRlciIsInBvaW50ZXJsZWF2ZSIsIm9yaWciLCJyZWxhdGVkIiwicm5vSW5uZXJodG1sIiwicmNoZWNrZWQiLCJyY2xlYW5TY3JpcHQiLCJtYW5pcHVsYXRpb25UYXJnZXQiLCJkaXNhYmxlU2NyaXB0IiwicmVzdG9yZVNjcmlwdCIsImNsb25lQ29weUV2ZW50IiwiZGVzdCIsInBkYXRhT2xkIiwidWRhdGFPbGQiLCJ1ZGF0YUN1ciIsImZpeElucHV0IiwiZG9tTWFuaXAiLCJjb2xsZWN0aW9uIiwiaGFzU2NyaXB0cyIsImlOb0Nsb25lIiwidmFsdWVJc0Z1bmN0aW9uIiwiaHRtbCIsIl9ldmFsVXJsIiwia2VlcERhdGEiLCJjbGVhbkRhdGEiLCJkYXRhQW5kRXZlbnRzIiwiZGVlcERhdGFBbmRFdmVudHMiLCJzcmNFbGVtZW50cyIsImRlc3RFbGVtZW50cyIsImluUGFnZSIsImRldGFjaCIsImFwcGVuZCIsInByZXBlbmQiLCJpbnNlcnRCZWZvcmUiLCJiZWZvcmUiLCJhZnRlciIsInJlcGxhY2VXaXRoIiwicmVwbGFjZUNoaWxkIiwiYXBwZW5kVG8iLCJwcmVwZW5kVG8iLCJpbnNlcnRBZnRlciIsInJlcGxhY2VBbGwiLCJvcmlnaW5hbCIsImluc2VydCIsInJudW1ub25weCIsInJjdXN0b21Qcm9wIiwiZ2V0U3R5bGVzIiwib3BlbmVyIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInN3YXAiLCJvbGQiLCJyYm94U3R5bGUiLCJydHJpbUNTUyIsImNvbXB1dGVTdHlsZVRlc3RzIiwiY29udGFpbmVyIiwiY3NzVGV4dCIsImRpdlN0eWxlIiwicGl4ZWxQb3NpdGlvblZhbCIsInJlbGlhYmxlTWFyZ2luTGVmdFZhbCIsInJvdW5kUGl4ZWxNZWFzdXJlcyIsIm1hcmdpbkxlZnQiLCJyaWdodCIsInBpeGVsQm94U3R5bGVzVmFsIiwiYm94U2l6aW5nUmVsaWFibGVWYWwiLCJ3aWR0aCIsInBvc2l0aW9uIiwic2Nyb2xsYm94U2l6ZVZhbCIsIm9mZnNldFdpZHRoIiwibWVhc3VyZSIsInJvdW5kIiwicGFyc2VGbG9hdCIsInJlbGlhYmxlVHJEaW1lbnNpb25zVmFsIiwiYmFja2dyb3VuZENsaXAiLCJjbGVhckNsb25lU3R5bGUiLCJib3hTaXppbmdSZWxpYWJsZSIsInBpeGVsQm94U3R5bGVzIiwicGl4ZWxQb3NpdGlvbiIsInJlbGlhYmxlTWFyZ2luTGVmdCIsInNjcm9sbGJveFNpemUiLCJyZWxpYWJsZVRyRGltZW5zaW9ucyIsInRhYmxlIiwidHJDaGlsZCIsInRyU3R5bGUiLCJoZWlnaHQiLCJwYXJzZUludCIsImJvcmRlclRvcFdpZHRoIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJjdXJDU1MiLCJjb21wdXRlZCIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJpc0N1c3RvbVByb3AiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiYWRkR2V0SG9va0lmIiwiY29uZGl0aW9uRm4iLCJob29rRm4iLCJjc3NQcmVmaXhlcyIsImVtcHR5U3R5bGUiLCJ2ZW5kb3JQcm9wcyIsInZlbmRvclByb3BOYW1lIiwiY2FwTmFtZSIsImZpbmFsUHJvcE5hbWUiLCJmaW5hbCIsImNzc1Byb3BzIiwicmRpc3BsYXlzd2FwIiwiY3NzU2hvdyIsInZpc2liaWxpdHkiLCJjc3NOb3JtYWxUcmFuc2Zvcm0iLCJsZXR0ZXJTcGFjaW5nIiwiZm9udFdlaWdodCIsInNldFBvc2l0aXZlTnVtYmVyIiwic3VidHJhY3QiLCJtYXgiLCJib3hNb2RlbEFkanVzdG1lbnQiLCJkaW1lbnNpb24iLCJib3giLCJpc0JvcmRlckJveCIsInN0eWxlcyIsImNvbXB1dGVkVmFsIiwiZXh0cmEiLCJkZWx0YSIsImNlaWwiLCJnZXRXaWR0aE9ySGVpZ2h0IiwiYm94U2l6aW5nTmVlZGVkIiwidmFsdWVJc0JvcmRlckJveCIsIm9mZnNldFByb3AiLCJnZXRDbGllbnRSZWN0cyIsImNzc0hvb2tzIiwib3BhY2l0eSIsIm9yaWdOYW1lIiwic2V0UHJvcGVydHkiLCJpc0Zpbml0ZSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNjcm9sbGJveFNpemVCdWdneSIsImxlZnQiLCJtYXJnaW4iLCJwYWRkaW5nIiwiYm9yZGVyIiwicHJlZml4Iiwic3VmZml4IiwiZXhwYW5kIiwiZXhwYW5kZWQiLCJwYXJ0cyIsIlR3ZWVuIiwiZWFzaW5nIiwicHJvcEhvb2tzIiwicnVuIiwicGVyY2VudCIsImVhc2VkIiwiZHVyYXRpb24iLCJwb3MiLCJzdGVwIiwiZngiLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0IiwibGluZWFyIiwicCIsInN3aW5nIiwiY29zIiwiUEkiLCJmeE5vdyIsImluUHJvZ3Jlc3MiLCJyZnh0eXBlcyIsInJydW4iLCJzY2hlZHVsZSIsImhpZGRlbiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImludGVydmFsIiwidGljayIsImNyZWF0ZUZ4Tm93IiwiZ2VuRngiLCJpbmNsdWRlV2lkdGgiLCJjcmVhdGVUd2VlbiIsImFuaW1hdGlvbiIsIkFuaW1hdGlvbiIsInR3ZWVuZXJzIiwiZGVmYXVsdFByZWZpbHRlciIsIm9wdHMiLCJvbGRmaXJlIiwicHJvcFR3ZWVuIiwicmVzdG9yZURpc3BsYXkiLCJpc0JveCIsImFuaW0iLCJkYXRhU2hvdyIsInVucXVldWVkIiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJwcm9wRmlsdGVyIiwic3BlY2lhbEVhc2luZyIsInByb3BlcnRpZXMiLCJzdG9wcGVkIiwicHJlZmlsdGVycyIsImN1cnJlbnRUaW1lIiwic3RhcnRUaW1lIiwidHdlZW5zIiwib3JpZ2luYWxQcm9wZXJ0aWVzIiwib3JpZ2luYWxPcHRpb25zIiwiZ290b0VuZCIsImJpbmQiLCJjb21wbGV0ZSIsInRpbWVyIiwidHdlZW5lciIsInByZWZpbHRlciIsInNwZWVkIiwib3B0Iiwic3BlZWRzIiwiZmFkZVRvIiwidG8iLCJhbmltYXRlIiwib3B0YWxsIiwiZG9BbmltYXRpb24iLCJmaW5pc2giLCJzdG9wUXVldWUiLCJ0aW1lcnMiLCJjc3NGbiIsInNsaWRlRG93biIsInNsaWRlVXAiLCJzbGlkZVRvZ2dsZSIsImZhZGVJbiIsImZhZGVPdXQiLCJmYWRlVG9nZ2xlIiwic2xvdyIsImZhc3QiLCJkZWxheSIsInRpbWUiLCJ0aW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiY2hlY2tPbiIsIm9wdFNlbGVjdGVkIiwicmFkaW9WYWx1ZSIsImJvb2xIb29rIiwicmVtb3ZlQXR0ciIsIm5UeXBlIiwiYXR0ckhvb2tzIiwiYm9vbCIsImF0dHJOYW1lcyIsImdldHRlciIsImxvd2VyY2FzZU5hbWUiLCJyZm9jdXNhYmxlIiwicmNsaWNrYWJsZSIsInJlbW92ZVByb3AiLCJwcm9wRml4IiwidGFiaW5kZXgiLCJzdHJpcEFuZENvbGxhcHNlIiwiZ2V0Q2xhc3MiLCJjbGFzc2VzVG9BcnJheSIsImFkZENsYXNzIiwiY2xhc3NOYW1lcyIsImN1clZhbHVlIiwiZmluYWxWYWx1ZSIsInJlbW92ZUNsYXNzIiwidG9nZ2xlQ2xhc3MiLCJzdGF0ZVZhbCIsImlzVmFsaWRWYWx1ZSIsImhhc0NsYXNzIiwicnJldHVybiIsInZhbEhvb2tzIiwib3B0aW9uU2V0IiwiZm9jdXNpbiIsInJmb2N1c01vcnBoIiwic3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2siLCJvbmx5SGFuZGxlcnMiLCJidWJibGVUeXBlIiwib250eXBlIiwibGFzdEVsZW1lbnQiLCJldmVudFBhdGgiLCJwYXJlbnRXaW5kb3ciLCJzaW11bGF0ZSIsInRyaWdnZXJIYW5kbGVyIiwiYXR0YWNoZXMiLCJycXVlcnkiLCJwYXJzZVhNTCIsInBhcnNlckVycm9yRWxlbSIsIkRPTVBhcnNlciIsInBhcnNlRnJvbVN0cmluZyIsInJicmFja2V0IiwickNSTEYiLCJyc3VibWl0dGVyVHlwZXMiLCJyc3VibWl0dGFibGUiLCJidWlsZFBhcmFtcyIsInRyYWRpdGlvbmFsIiwicGFyYW0iLCJzIiwidmFsdWVPckZ1bmN0aW9uIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic2VyaWFsaXplIiwic2VyaWFsaXplQXJyYXkiLCJyMjAiLCJyaGFzaCIsInJhbnRpQ2FjaGUiLCJyaGVhZGVycyIsInJsb2NhbFByb3RvY29sIiwicm5vQ29udGVudCIsInJwcm90b2NvbCIsInRyYW5zcG9ydHMiLCJhbGxUeXBlcyIsIm9yaWdpbkFuY2hvciIsImFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyIsInN0cnVjdHVyZSIsImRhdGFUeXBlRXhwcmVzc2lvbiIsImRhdGFUeXBlIiwiZGF0YVR5cGVzIiwiaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMiLCJqcVhIUiIsImluc3BlY3RlZCIsInNlZWtpbmdUcmFuc3BvcnQiLCJpbnNwZWN0IiwicHJlZmlsdGVyT3JGYWN0b3J5IiwiZGF0YVR5cGVPclRyYW5zcG9ydCIsImFqYXhFeHRlbmQiLCJmbGF0T3B0aW9ucyIsImFqYXhTZXR0aW5ncyIsImFqYXhIYW5kbGVSZXNwb25zZXMiLCJyZXNwb25zZXMiLCJjdCIsImZpbmFsRGF0YVR5cGUiLCJmaXJzdERhdGFUeXBlIiwibWltZVR5cGUiLCJnZXRSZXNwb25zZUhlYWRlciIsImNvbnZlcnRlcnMiLCJhamF4Q29udmVydCIsInJlc3BvbnNlIiwiaXNTdWNjZXNzIiwiY29udjIiLCJjdXJyZW50IiwiY29udiIsInJlc3BvbnNlRmllbGRzIiwiZGF0YUZpbHRlciIsImFjdGl2ZSIsImxhc3RNb2RpZmllZCIsImV0YWciLCJ1cmwiLCJpc0xvY2FsIiwicHJvdG9jb2wiLCJwcm9jZXNzRGF0YSIsImFzeW5jIiwiY29udGVudFR5cGUiLCJhY2NlcHRzIiwianNvbiIsImFqYXhTZXR1cCIsInNldHRpbmdzIiwiYWpheFByZWZpbHRlciIsImFqYXhUcmFuc3BvcnQiLCJhamF4IiwidHJhbnNwb3J0IiwiY2FjaGVVUkwiLCJyZXNwb25zZUhlYWRlcnNTdHJpbmciLCJyZXNwb25zZUhlYWRlcnMiLCJ0aW1lb3V0VGltZXIiLCJ1cmxBbmNob3IiLCJmaXJlR2xvYmFscyIsInVuY2FjaGVkIiwiY2FsbGJhY2tDb250ZXh0IiwiZ2xvYmFsRXZlbnRDb250ZXh0IiwiY29tcGxldGVEZWZlcnJlZCIsInN0YXR1c0NvZGUiLCJyZXF1ZXN0SGVhZGVycyIsInJlcXVlc3RIZWFkZXJzTmFtZXMiLCJzdHJBYm9ydCIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInNldFJlcXVlc3RIZWFkZXIiLCJvdmVycmlkZU1pbWVUeXBlIiwic3RhdHVzIiwiYWJvcnQiLCJzdGF0dXNUZXh0IiwiZmluYWxUZXh0IiwiY3Jvc3NEb21haW4iLCJob3N0IiwiaGFzQ29udGVudCIsImlmTW9kaWZpZWQiLCJoZWFkZXJzIiwiYmVmb3JlU2VuZCIsInN1Y2Nlc3MiLCJzZW5kIiwibmF0aXZlU3RhdHVzVGV4dCIsIm1vZGlmaWVkIiwiZ2V0SlNPTiIsImdldFNjcmlwdCIsIndyYXBBbGwiLCJmaXJzdEVsZW1lbnRDaGlsZCIsIndyYXBJbm5lciIsImh0bWxJc0Z1bmN0aW9uIiwidW53cmFwIiwidmlzaWJsZSIsInhociIsIlhNTEh0dHBSZXF1ZXN0IiwieGhyU3VjY2Vzc1N0YXR1cyIsInhoclN1cHBvcnRlZCIsImNvcnMiLCJlcnJvckNhbGxiYWNrIiwib3BlbiIsInVzZXJuYW1lIiwieGhyRmllbGRzIiwib25sb2FkIiwib25lcnJvciIsIm9uYWJvcnQiLCJvbnRpbWVvdXQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZVRleHQiLCJiaW5hcnkiLCJzY3JpcHRBdHRycyIsImNoYXJzZXQiLCJzY3JpcHRDaGFyc2V0IiwiZXZ0Iiwib2xkQ2FsbGJhY2tzIiwicmpzb25wIiwianNvbnAiLCJqc29ucENhbGxiYWNrIiwib3JpZ2luYWxTZXR0aW5ncyIsImNhbGxiYWNrTmFtZSIsIm92ZXJ3cml0dGVuIiwicmVzcG9uc2VDb250YWluZXIiLCJqc29uUHJvcCIsImNyZWF0ZUhUTUxEb2N1bWVudCIsImltcGxlbWVudGF0aW9uIiwia2VlcFNjcmlwdHMiLCJwYXJzZWQiLCJwYXJhbXMiLCJhbmltYXRlZCIsIm9mZnNldCIsInNldE9mZnNldCIsImN1clBvc2l0aW9uIiwiY3VyTGVmdCIsImN1ckNTU1RvcCIsImN1clRvcCIsImN1ck9mZnNldCIsImN1ckNTU0xlZnQiLCJjYWxjdWxhdGVQb3NpdGlvbiIsImN1ckVsZW0iLCJ1c2luZyIsInJlY3QiLCJ3aW4iLCJwYWdlWU9mZnNldCIsInBhZ2VYT2Zmc2V0Iiwib2Zmc2V0UGFyZW50IiwicGFyZW50T2Zmc2V0Iiwic2Nyb2xsVG8iLCJIZWlnaHQiLCJXaWR0aCIsImRlZmF1bHRFeHRyYSIsImZ1bmNOYW1lIiwidW5iaW5kIiwiZGVsZWdhdGUiLCJ1bmRlbGVnYXRlIiwiaG92ZXIiLCJmbk92ZXIiLCJmbk91dCIsInByb3h5IiwiaG9sZFJlYWR5IiwiaG9sZCIsInBhcnNlSlNPTiIsImlzTnVtZXJpYyIsImlzTmFOIiwidHJpbSIsImRlZmluZSIsImFtZCIsIl9qUXVlcnkiLCJfJCIsIiQiLCJub0NvbmZsaWN0IiwiZ2V0V2luZG93IiwiaXNFbGVtZW50IiwiT3duRWxlbWVudCIsIkVsZW1lbnQiLCJpc0hUTUxFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJpc1NoYWRvd1Jvb3QiLCJTaGFkb3dSb290IiwibWluIiwiZ2V0VUFTdHJpbmciLCJ1YURhdGEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnREYXRhIiwiYnJhbmRzIiwiYnJhbmQiLCJ1c2VyQWdlbnQiLCJpc0xheW91dFZpZXdwb3J0IiwiZWxlbWVudCIsImluY2x1ZGVTY2FsZSIsImlzRml4ZWRTdHJhdGVneSIsImNsaWVudFJlY3QiLCJzY2FsZVgiLCJzY2FsZVkiLCJ2aXN1YWxWaWV3cG9ydCIsImFkZFZpc3VhbE9mZnNldHMiLCJ4Iiwib2Zmc2V0TGVmdCIsInkiLCJvZmZzZXRUb3AiLCJib3R0b20iLCJnZXRXaW5kb3dTY3JvbGwiLCJnZXRIVE1MRWxlbWVudFNjcm9sbCIsImdldE5vZGVTY3JvbGwiLCJnZXROb2RlTmFtZSIsImdldERvY3VtZW50RWxlbWVudCIsImdldFdpbmRvd1Njcm9sbEJhclgiLCJpc1Njcm9sbFBhcmVudCIsImlzRWxlbWVudFNjYWxlZCIsImdldENvbXBvc2l0ZVJlY3QiLCJlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCIsImlzRml4ZWQiLCJpc09mZnNldFBhcmVudEFuRWxlbWVudCIsIm9mZnNldFBhcmVudElzU2NhbGVkIiwic2Nyb2xsIiwib2Zmc2V0cyIsImNsaWVudExlZnQiLCJjbGllbnRUb3AiLCJnZXRMYXlvdXRSZWN0IiwiYWJzIiwiZ2V0UGFyZW50Tm9kZSIsImFzc2lnbmVkU2xvdCIsImdldFNjcm9sbFBhcmVudCIsImxpc3RTY3JvbGxQYXJlbnRzIiwic2Nyb2xsUGFyZW50IiwiaXNCb2R5IiwiX2VsZW1lbnQkb3duZXJEb2N1bWVuIiwidXBkYXRlZExpc3QiLCJpc1RhYmxlRWxlbWVudCIsImdldFRydWVPZmZzZXRQYXJlbnQiLCJnZXRDb250YWluaW5nQmxvY2siLCJpc0ZpcmVmb3giLCJpc0lFIiwiZWxlbWVudENzcyIsImN1cnJlbnROb2RlIiwidHJhbnNmb3JtIiwicGVyc3BlY3RpdmUiLCJjb250YWluIiwid2lsbENoYW5nZSIsImdldE9mZnNldFBhcmVudCIsImF1dG8iLCJiYXNlUGxhY2VtZW50cyIsImNsaXBwaW5nUGFyZW50cyIsInZpZXdwb3J0IiwicG9wcGVyIiwicmVmZXJlbmNlIiwidmFyaWF0aW9uUGxhY2VtZW50cyIsInJlZHVjZSIsImFjYyIsInBsYWNlbWVudCIsInBsYWNlbWVudHMiLCJiZWZvcmVSZWFkIiwicmVhZCIsImFmdGVyUmVhZCIsImJlZm9yZU1haW4iLCJtYWluIiwiYWZ0ZXJNYWluIiwiYmVmb3JlV3JpdGUiLCJ3cml0ZSIsImFmdGVyV3JpdGUiLCJtb2RpZmllclBoYXNlcyIsIm9yZGVyIiwibW9kaWZpZXJzIiwiTWFwIiwidmlzaXRlZCIsIlNldCIsImZvckVhY2giLCJtb2RpZmllciIsInJlcXVpcmVzIiwicmVxdWlyZXNJZkV4aXN0cyIsImRlcCIsImRlcE1vZGlmaWVyIiwib3JkZXJNb2RpZmllcnMiLCJvcmRlcmVkTW9kaWZpZXJzIiwicGhhc2UiLCJkZWJvdW5jZSIsInBlbmRpbmciLCJQcm9taXNlIiwiZm9ybWF0Iiwic3RyIiwiYyIsIklOVkFMSURfTU9ESUZJRVJfRVJST1IiLCJNSVNTSU5HX0RFUEVOREVOQ1lfRVJST1IiLCJWQUxJRF9QUk9QRVJUSUVTIiwidmFsaWRhdGVNb2RpZmllcnMiLCJlbmFibGVkIiwiZWZmZWN0IiwicmVxdWlyZW1lbnQiLCJtb2QiLCJ1bmlxdWVCeSIsImlkZW50aWZpZXJzIiwiZ2V0QmFzZVBsYWNlbWVudCIsIm1lcmdlQnlOYW1lIiwibWVyZ2VkIiwiZXhpc3RpbmciLCJnZXRWaWV3cG9ydFJlY3QiLCJzdHJhdGVneSIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwibGF5b3V0Vmlld3BvcnQiLCJnZXREb2N1bWVudFJlY3QiLCJ3aW5TY3JvbGwiLCJzY3JvbGxXaWR0aCIsInNjcm9sbEhlaWdodCIsImRpcmVjdGlvbiIsImNoaWxkIiwicm9vdE5vZGUiLCJpc1NhbWVOb2RlIiwicmVjdFRvQ2xpZW50UmVjdCIsImdldElubmVyQm91bmRpbmdDbGllbnRSZWN0IiwiZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUiLCJjbGlwcGluZ1BhcmVudCIsImdldENsaXBwaW5nUGFyZW50cyIsImNhbkVzY2FwZUNsaXBwaW5nIiwiY2xpcHBlckVsZW1lbnQiLCJnZXRDbGlwcGluZ1JlY3QiLCJib3VuZGFyeSIsInJvb3RCb3VuZGFyeSIsIm1haW5DbGlwcGluZ1BhcmVudHMiLCJmaXJzdENsaXBwaW5nUGFyZW50IiwiY2xpcHBpbmdSZWN0IiwiYWNjUmVjdCIsImdldFZhcmlhdGlvbiIsImdldE1haW5BeGlzRnJvbVBsYWNlbWVudCIsImNvbXB1dGVPZmZzZXRzIiwiYmFzZVBsYWNlbWVudCIsInZhcmlhdGlvbiIsImNvbW1vblgiLCJjb21tb25ZIiwibWFpbkF4aXMiLCJnZXRGcmVzaFNpZGVPYmplY3QiLCJtZXJnZVBhZGRpbmdPYmplY3QiLCJwYWRkaW5nT2JqZWN0IiwiZXhwYW5kVG9IYXNoTWFwIiwiaGFzaE1hcCIsImRldGVjdE92ZXJmbG93IiwiZWxlbWVudENvbnRleHQiLCJhbHRCb3VuZGFyeSIsImFsdENvbnRleHQiLCJwb3BwZXJSZWN0IiwicmVjdHMiLCJjbGlwcGluZ0NsaWVudFJlY3QiLCJjb250ZXh0RWxlbWVudCIsInJlZmVyZW5jZUNsaWVudFJlY3QiLCJwb3BwZXJPZmZzZXRzIiwicG9wcGVyQ2xpZW50UmVjdCIsImVsZW1lbnRDbGllbnRSZWN0Iiwib3ZlcmZsb3dPZmZzZXRzIiwib2Zmc2V0RGF0YSIsIm1vZGlmaWVyc0RhdGEiLCJtdWx0aXBseSIsImF4aXMiLCJJTlZBTElEX0VMRU1FTlRfRVJST1IiLCJJTkZJTklURV9MT09QX0VSUk9SIiwiREVGQVVMVF9PUFRJT05TIiwiYXJlVmFsaWRFbGVtZW50cyIsInNvbWUiLCJwb3BwZXJHZW5lcmF0b3IiLCJnZW5lcmF0b3JPcHRpb25zIiwiZGVmYXVsdE1vZGlmaWVycyIsImRlZmF1bHRPcHRpb25zIiwiY3JlYXRlUG9wcGVyIiwiZWZmZWN0Q2xlYW51cEZucyIsImlzRGVzdHJveWVkIiwiaW5zdGFuY2UiLCJzZXRPcHRpb25zIiwic2V0T3B0aW9uc0FjdGlvbiIsImNsZWFudXBNb2RpZmllckVmZmVjdHMiLCJzY3JvbGxQYXJlbnRzIiwiZmxpcE1vZGlmaWVyIiwibWFyZ2luVG9wIiwibWFyZ2luUmlnaHQiLCJtYXJnaW5Cb3R0b20iLCJydW5Nb2RpZmllckVmZmVjdHMiLCJ1cGRhdGUiLCJmb3JjZVVwZGF0ZSIsIl9fZGVidWdfbG9vcHNfXyIsImRlc3Ryb3kiLCJvbkZpcnN0VXBkYXRlIiwiY2xlYW51cEZuIiwibm9vcEZuIiwicGFzc2l2ZSIsInJlc2l6ZSIsInVuc2V0U2lkZXMiLCJyb3VuZE9mZnNldHNCeURQUiIsImRwciIsImRldmljZVBpeGVsUmF0aW8iLCJtYXBUb1N0eWxlcyIsImdwdUFjY2VsZXJhdGlvbiIsImFkYXB0aXZlIiwicm91bmRPZmZzZXRzIiwiaGFzWCIsImhhc1kiLCJzaWRlWCIsInNpZGVZIiwiaGVpZ2h0UHJvcCIsIndpZHRoUHJvcCIsImNvbW1vblN0eWxlcyIsImNvbXB1dGVTdHlsZXMiLCJ0cmFuc2l0aW9uUHJvcGVydHkiLCJwcm9wZXJ0eSIsImFycm93IiwiYXBwbHlTdHlsZXMiLCJhc3NpZ24iLCJpbml0aWFsU3R5bGVzIiwic3R5bGVQcm9wZXJ0aWVzIiwiYXR0cmlidXRlIiwiZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkiLCJpbnZlcnREaXN0YW5jZSIsInNraWRkaW5nIiwiZGlzdGFuY2UiLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsImdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50IiwiY29tcHV0ZUF1dG9QbGFjZW1lbnQiLCJmbGlwVmFyaWF0aW9ucyIsImFsbG93ZWRBdXRvUGxhY2VtZW50cyIsImFsbFBsYWNlbWVudHMiLCJhbGxvd2VkUGxhY2VtZW50cyIsIm92ZXJmbG93cyIsImdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzIiwib3Bwb3NpdGVQbGFjZW1lbnQiLCJmbGlwIiwiX3NraXAiLCJjaGVja01haW5BeGlzIiwiYWx0QXhpcyIsImNoZWNrQWx0QXhpcyIsInNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyIsImZhbGxiYWNrUGxhY2VtZW50cyIsInByZWZlcnJlZFBsYWNlbWVudCIsImlzQmFzZVBsYWNlbWVudCIsInJlZmVyZW5jZVJlY3QiLCJjaGVja3NNYXAiLCJtYWtlRmFsbGJhY2tDaGVja3MiLCJmaXJzdEZpdHRpbmdQbGFjZW1lbnQiLCJpc1N0YXJ0VmFyaWF0aW9uIiwiaXNWZXJ0aWNhbCIsIm1haW5WYXJpYXRpb25TaWRlIiwiYWx0VmFyaWF0aW9uU2lkZSIsImNoZWNrcyIsImV2ZXJ5IiwibnVtYmVyT2ZDaGVja3MiLCJmaXR0aW5nUGxhY2VtZW50IiwiZ2V0QWx0QXhpcyIsIndpdGhpbiIsIm1hdGhNYXgiLCJtYXRoTWluIiwid2l0aGluTWF4Q2xhbXAiLCJwcmV2ZW50T3ZlcmZsb3ciLCJ0ZXRoZXIiLCJ0ZXRoZXJPZmZzZXQiLCJ0ZXRoZXJPZmZzZXRWYWx1ZSIsIm5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZSIsIm9mZnNldE1vZGlmaWVyU3RhdGUiLCJtYWluU2lkZSIsImFsdFNpZGUiLCJhZGRpdGl2ZSIsIm1pbkxlbiIsIm1heExlbiIsImFycm93RWxlbWVudCIsImFycm93UmVjdCIsImFycm93UGFkZGluZ09iamVjdCIsImFycm93UGFkZGluZ01pbiIsImFycm93UGFkZGluZ01heCIsImFycm93TGVuIiwibWluT2Zmc2V0IiwibWF4T2Zmc2V0IiwiYXJyb3dPZmZzZXRQYXJlbnQiLCJjbGllbnRPZmZzZXQiLCJvZmZzZXRNb2RpZmllclZhbHVlIiwidGV0aGVyTWluIiwidGV0aGVyTWF4IiwicHJldmVudGVkT2Zmc2V0IiwiaXNPcmlnaW5TaWRlIiwidG9QYWRkaW5nT2JqZWN0IiwibWluUHJvcCIsIm1heFByb3AiLCJlbmREaWZmIiwic3RhcnREaWZmIiwiY2xpZW50U2l6ZSIsImNlbnRlclRvUmVmZXJlbmNlIiwiY2VudGVyIiwiYXhpc1Byb3AiLCJjZW50ZXJPZmZzZXQiLCJxdWVyeVNlbGVjdG9yIiwiZ2V0U2lkZU9mZnNldHMiLCJwcmV2ZW50ZWRPZmZzZXRzIiwiaXNBbnlTaWRlRnVsbHlDbGlwcGVkIiwic2lkZSIsInJlZmVyZW5jZU92ZXJmbG93IiwicG9wcGVyQWx0T3ZlcmZsb3ciLCJyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMiLCJwb3BwZXJFc2NhcGVPZmZzZXRzIiwiaXNSZWZlcmVuY2VIaWRkZW4iLCJoYXNQb3BwZXJFc2NhcGVkIiwiZXZlbnRMaXN0ZW5lcnMiLCJNQVhfVUlEIiwiTUlMTElTRUNPTkRTX01VTFRJUExJRVIiLCJUUkFOU0lUSU9OX0VORCIsImdldFVJRCIsImZsb29yIiwiZ2V0U2VsZWN0b3IiLCJocmVmQXR0cmlidXRlIiwiaW5jbHVkZXMiLCJzdGFydHNXaXRoIiwiZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCIsImdldEVsZW1lbnRGcm9tU2VsZWN0b3IiLCJnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCIsInRyYW5zaXRpb25EdXJhdGlvbiIsInRyYW5zaXRpb25EZWxheSIsImZsb2F0VHJhbnNpdGlvbkR1cmF0aW9uIiwiTnVtYmVyIiwiZmxvYXRUcmFuc2l0aW9uRGVsYXkiLCJ0cmlnZ2VyVHJhbnNpdGlvbkVuZCIsImRpc3BhdGNoRXZlbnQiLCJnZXRFbGVtZW50IiwiaXNWaXNpYmxlIiwiZWxlbWVudElzVmlzaWJsZSIsImNsb3NlZERldGFpbHMiLCJzdW1tYXJ5IiwiTm9kZSIsIkVMRU1FTlRfTk9ERSIsImNsYXNzTGlzdCIsImhhc0F0dHJpYnV0ZSIsImZpbmRTaGFkb3dSb290IiwiYXR0YWNoU2hhZG93IiwicmVmbG93IiwiZ2V0alF1ZXJ5IiwiRE9NQ29udGVudExvYWRlZENhbGxiYWNrcyIsIm9uRE9NQ29udGVudExvYWRlZCIsImlzUlRMIiwiZGVmaW5lSlF1ZXJ5UGx1Z2luIiwicGx1Z2luIiwiTkFNRSIsIkpRVUVSWV9OT19DT05GTElDVCIsImpRdWVyeUludGVyZmFjZSIsIkNvbnN0cnVjdG9yIiwiZXhlY3V0ZSIsImV4ZWN1dGVBZnRlclRyYW5zaXRpb24iLCJ0cmFuc2l0aW9uRWxlbWVudCIsIndhaXRGb3JUcmFuc2l0aW9uIiwiZHVyYXRpb25QYWRkaW5nIiwiZW11bGF0ZWREdXJhdGlvbiIsImNhbGxlZCIsImdldE5leHRBY3RpdmVFbGVtZW50Iiwic2hvdWxkR2V0TmV4dCIsImlzQ3ljbGVBbGxvd2VkIiwibGlzdExlbmd0aCIsIm5hbWVzcGFjZVJlZ2V4Iiwic3RyaXBOYW1lUmVnZXgiLCJzdHJpcFVpZFJlZ2V4IiwiZXZlbnRSZWdpc3RyeSIsInVpZEV2ZW50IiwiY3VzdG9tRXZlbnRzIiwibmF0aXZlRXZlbnRzIiwibWFrZUV2ZW50VWlkIiwiZ2V0RWxlbWVudEV2ZW50cyIsImJvb3RzdHJhcEhhbmRsZXIiLCJoeWRyYXRlT2JqIiwib25lT2ZmIiwiRXZlbnRIYW5kbGVyIiwiYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIiLCJkb21FbGVtZW50cyIsImRvbUVsZW1lbnQiLCJmaW5kSGFuZGxlciIsImNhbGxhYmxlIiwiZGVsZWdhdGlvblNlbGVjdG9yIiwibm9ybWFsaXplUGFyYW1ldGVycyIsIm9yaWdpbmFsVHlwZUV2ZW50IiwiZGVsZWdhdGlvbkZ1bmN0aW9uIiwiaXNEZWxlZ2F0ZWQiLCJ0eXBlRXZlbnQiLCJnZXRUeXBlRXZlbnQiLCJhZGRIYW5kbGVyIiwid3JhcEZ1bmN0aW9uIiwicHJldmlvdXNGdW5jdGlvbiIsInJlbW92ZUhhbmRsZXIiLCJCb29sZWFuIiwicmVtb3ZlTmFtZXNwYWNlZEhhbmRsZXJzIiwic3RvcmVFbGVtZW50RXZlbnQiLCJoYW5kbGVyS2V5IiwiaW5OYW1lc3BhY2UiLCJpc05hbWVzcGFjZSIsImVsZW1lbnRFdmVudCIsImtleUhhbmRsZXJzIiwialF1ZXJ5RXZlbnQiLCJuYXRpdmVEaXNwYXRjaCIsIm1ldGEiLCJfdW51c2VkIiwiZW50cmllcyIsImVsZW1lbnRNYXAiLCJpbnN0YW5jZU1hcCIsInNpemUiLCJmcm9tIiwibm9ybWFsaXplRGF0YSIsImRlY29kZVVSSUNvbXBvbmVudCIsIm5vcm1hbGl6ZURhdGFLZXkiLCJjaHIiLCJNYW5pcHVsYXRvciIsInNldERhdGFBdHRyaWJ1dGUiLCJyZW1vdmVEYXRhQXR0cmlidXRlIiwiZ2V0RGF0YUF0dHJpYnV0ZXMiLCJic0tleXMiLCJkYXRhc2V0IiwicHVyZUtleSIsImNoYXJBdCIsImdldERhdGFBdHRyaWJ1dGUiLCJDb25maWciLCJfZ2V0Q29uZmlnIiwiY29uZmlnIiwiX21lcmdlQ29uZmlnT2JqIiwiX2NvbmZpZ0FmdGVyTWVyZ2UiLCJfdHlwZUNoZWNrQ29uZmlnIiwianNvbkNvbmZpZyIsIkRlZmF1bHQiLCJjb25maWdUeXBlcyIsIkRlZmF1bHRUeXBlIiwiZXhwZWN0ZWRUeXBlcyIsInZhbHVlVHlwZSIsIlZFUlNJT04iLCJCYXNlQ29tcG9uZW50IiwiX2VsZW1lbnQiLCJfY29uZmlnIiwiREFUQV9LRVkiLCJkaXNwb3NlIiwiRVZFTlRfS0VZIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInByb3BlcnR5TmFtZSIsIl9xdWV1ZUNhbGxiYWNrIiwiaXNBbmltYXRlZCIsImdldEluc3RhbmNlIiwiZW5hYmxlRGlzbWlzc1RyaWdnZXIiLCJjb21wb25lbnQiLCJjbGlja0V2ZW50IiwidGFnTmFtZSIsImdldE9yQ3JlYXRlSW5zdGFuY2UiLCJFVkVOVF9DTE9TRSIsIkVWRU5UX0NMT1NFRCIsIkNMQVNTX05BTUVfRkFERSIsIkNMQVNTX05BTUVfU0hPVyIsIkFsZXJ0IiwiY2xvc2UiLCJjbG9zZUV2ZW50IiwiX2Rlc3Ryb3lFbGVtZW50IiwiREFUQV9BUElfS0VZIiwiQ0xBU1NfTkFNRV9BQ1RJVkUiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSIsIkVWRU5UX0NMSUNLX0RBVEFfQVBJIiwiQnV0dG9uIiwiU2VsZWN0b3JFbmdpbmUiLCJmaW5kT25lIiwiYW5jZXN0b3IiLCJwcmV2aW91cyIsInByZXZpb3VzRWxlbWVudFNpYmxpbmciLCJuZXh0RWxlbWVudFNpYmxpbmciLCJmb2N1c2FibGVDaGlsZHJlbiIsImZvY3VzYWJsZXMiLCJFVkVOVF9UT1VDSFNUQVJUIiwiRVZFTlRfVE9VQ0hNT1ZFIiwiRVZFTlRfVE9VQ0hFTkQiLCJFVkVOVF9QT0lOVEVSRE9XTiIsIkVWRU5UX1BPSU5URVJVUCIsIlBPSU5URVJfVFlQRV9UT1VDSCIsIlBPSU5URVJfVFlQRV9QRU4iLCJDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQiLCJTV0lQRV9USFJFU0hPTEQiLCJlbmRDYWxsYmFjayIsImxlZnRDYWxsYmFjayIsInJpZ2h0Q2FsbGJhY2siLCJTd2lwZSIsImlzU3VwcG9ydGVkIiwiX2RlbHRhWCIsIl9zdXBwb3J0UG9pbnRlckV2ZW50cyIsIlBvaW50ZXJFdmVudCIsIl9pbml0RXZlbnRzIiwiX3N0YXJ0IiwiX2V2ZW50SXNQb2ludGVyUGVuVG91Y2giLCJfZW5kIiwiX2hhbmRsZVN3aXBlIiwiX21vdmUiLCJhYnNEZWx0YVgiLCJtYXhUb3VjaFBvaW50cyIsIkFSUk9XX0xFRlRfS0VZIiwiQVJST1dfUklHSFRfS0VZIiwiVE9VQ0hFVkVOVF9DT01QQVRfV0FJVCIsIk9SREVSX05FWFQiLCJPUkRFUl9QUkVWIiwiRElSRUNUSU9OX0xFRlQiLCJESVJFQ1RJT05fUklHSFQiLCJFVkVOVF9TTElERSIsIkVWRU5UX1NMSUQiLCJFVkVOVF9LRVlET1dOIiwiRVZFTlRfTU9VU0VFTlRFUiIsIkVWRU5UX01PVVNFTEVBVkUiLCJFVkVOVF9EUkFHX1NUQVJUIiwiRVZFTlRfTE9BRF9EQVRBX0FQSSIsIkNMQVNTX05BTUVfQ0FST1VTRUwiLCJDTEFTU19OQU1FX1NMSURFIiwiQ0xBU1NfTkFNRV9FTkQiLCJDTEFTU19OQU1FX1NUQVJUIiwiQ0xBU1NfTkFNRV9ORVhUIiwiQ0xBU1NfTkFNRV9QUkVWIiwiU0VMRUNUT1JfQUNUSVZFIiwiU0VMRUNUT1JfSVRFTSIsIlNFTEVDVE9SX0FDVElWRV9JVEVNIiwiU0VMRUNUT1JfSVRFTV9JTUciLCJTRUxFQ1RPUl9JTkRJQ0FUT1JTIiwiU0VMRUNUT1JfREFUQV9TTElERSIsIlNFTEVDVE9SX0RBVEFfUklERSIsIktFWV9UT19ESVJFQ1RJT04iLCJrZXlib2FyZCIsInBhdXNlIiwicmlkZSIsInRvdWNoIiwiQ2Fyb3VzZWwiLCJfaW50ZXJ2YWwiLCJfYWN0aXZlRWxlbWVudCIsIl9pc1NsaWRpbmciLCJ0b3VjaFRpbWVvdXQiLCJfc3dpcGVIZWxwZXIiLCJfaW5kaWNhdG9yc0VsZW1lbnQiLCJfYWRkRXZlbnRMaXN0ZW5lcnMiLCJjeWNsZSIsIl9zbGlkZSIsIm5leHRXaGVuVmlzaWJsZSIsIl9jbGVhckludGVydmFsIiwiX3VwZGF0ZUludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJfbWF5YmVFbmFibGVDeWNsZSIsIml0ZW1zIiwiX2dldEl0ZW1zIiwiYWN0aXZlSW5kZXgiLCJfZ2V0SXRlbUluZGV4IiwiX2dldEFjdGl2ZSIsImRlZmF1bHRJbnRlcnZhbCIsIl9rZXlkb3duIiwiX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMiLCJpbWciLCJlbmRDYWxsQmFjayIsInN3aXBlQ29uZmlnIiwiX2RpcmVjdGlvblRvT3JkZXIiLCJfc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudCIsImFjdGl2ZUluZGljYXRvciIsIm5ld0FjdGl2ZUluZGljYXRvciIsImVsZW1lbnRJbnRlcnZhbCIsImlzTmV4dCIsIm5leHRFbGVtZW50IiwibmV4dEVsZW1lbnRJbmRleCIsInRyaWdnZXJFdmVudCIsImV2ZW50TmFtZSIsIl9vcmRlclRvRGlyZWN0aW9uIiwic2xpZGVFdmVudCIsImlzQ3ljbGluZyIsImRpcmVjdGlvbmFsQ2xhc3NOYW1lIiwib3JkZXJDbGFzc05hbWUiLCJjb21wbGV0ZUNhbGxCYWNrIiwiX2lzQW5pbWF0ZWQiLCJjbGVhckludGVydmFsIiwiY2Fyb3VzZWwiLCJzbGlkZUluZGV4IiwiY2Fyb3VzZWxzIiwiRVZFTlRfU0hPVyIsIkVWRU5UX1NIT1dOIiwiRVZFTlRfSElERSIsIkVWRU5UX0hJRERFTiIsIkNMQVNTX05BTUVfQ09MTEFQU0UiLCJDTEFTU19OQU1FX0NPTExBUFNJTkciLCJDTEFTU19OQU1FX0NPTExBUFNFRCIsIkNMQVNTX05BTUVfREVFUEVSX0NISUxEUkVOIiwiQ0xBU1NfTkFNRV9IT1JJWk9OVEFMIiwiV0lEVEgiLCJIRUlHSFQiLCJTRUxFQ1RPUl9BQ1RJVkVTIiwiQ29sbGFwc2UiLCJfaXNUcmFuc2l0aW9uaW5nIiwiX3RyaWdnZXJBcnJheSIsInRvZ2dsZUxpc3QiLCJmaWx0ZXJFbGVtZW50IiwiZm91bmRFbGVtZW50IiwiX2luaXRpYWxpemVDaGlsZHJlbiIsIl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MiLCJfaXNTaG93biIsImFjdGl2ZUNoaWxkcmVuIiwiX2dldEZpcnN0TGV2ZWxDaGlsZHJlbiIsInN0YXJ0RXZlbnQiLCJhY3RpdmVJbnN0YW5jZSIsIl9nZXREaW1lbnNpb24iLCJjYXBpdGFsaXplZERpbWVuc2lvbiIsInNjcm9sbFNpemUiLCJ0cmlnZ2VyQXJyYXkiLCJpc09wZW4iLCJzZWxlY3RvckVsZW1lbnRzIiwiRVNDQVBFX0tFWSIsIlRBQl9LRVkiLCJBUlJPV19VUF9LRVkiLCJBUlJPV19ET1dOX0tFWSIsIlJJR0hUX01PVVNFX0JVVFRPTiIsIkVWRU5UX0tFWURPV05fREFUQV9BUEkiLCJFVkVOVF9LRVlVUF9EQVRBX0FQSSIsIkNMQVNTX05BTUVfRFJPUFVQIiwiQ0xBU1NfTkFNRV9EUk9QRU5EIiwiQ0xBU1NfTkFNRV9EUk9QU1RBUlQiLCJDTEFTU19OQU1FX0RST1BVUF9DRU5URVIiLCJDTEFTU19OQU1FX0RST1BET1dOX0NFTlRFUiIsIlNFTEVDVE9SX0RBVEFfVE9HR0xFX1NIT1dOIiwiU0VMRUNUT1JfTUVOVSIsIlNFTEVDVE9SX05BVkJBUiIsIlNFTEVDVE9SX05BVkJBUl9OQVYiLCJTRUxFQ1RPUl9WSVNJQkxFX0lURU1TIiwiUExBQ0VNRU5UX1RPUCIsIlBMQUNFTUVOVF9UT1BFTkQiLCJQTEFDRU1FTlRfQk9UVE9NIiwiUExBQ0VNRU5UX0JPVFRPTUVORCIsIlBMQUNFTUVOVF9SSUdIVCIsIlBMQUNFTUVOVF9MRUZUIiwiUExBQ0VNRU5UX1RPUENFTlRFUiIsIlBMQUNFTUVOVF9CT1RUT01DRU5URVIiLCJhdXRvQ2xvc2UiLCJwb3BwZXJDb25maWciLCJEcm9wZG93biIsIl9wb3BwZXIiLCJfcGFyZW50IiwiX21lbnUiLCJfaW5OYXZiYXIiLCJfZGV0ZWN0TmF2YmFyIiwic2hvd0V2ZW50IiwiX2NyZWF0ZVBvcHBlciIsIl9jb21wbGV0ZUhpZGUiLCJoaWRlRXZlbnQiLCJQb3BwZXIiLCJyZWZlcmVuY2VFbGVtZW50IiwiX2dldFBvcHBlckNvbmZpZyIsIl9nZXRQbGFjZW1lbnQiLCJwYXJlbnREcm9wZG93biIsImlzRW5kIiwiX2dldE9mZnNldCIsInBvcHBlckRhdGEiLCJkZWZhdWx0QnNQb3BwZXJDb25maWciLCJfc2VsZWN0TWVudUl0ZW0iLCJvcGVuVG9nZ2xlcyIsImNvbXBvc2VkUGF0aCIsImlzTWVudVRhcmdldCIsImlzSW5wdXQiLCJpc0VzY2FwZUV2ZW50IiwiaXNVcE9yRG93bkV2ZW50IiwiZ2V0VG9nZ2xlQnV0dG9uIiwiZGF0YUFwaUtleWRvd25IYW5kbGVyIiwiY2xlYXJNZW51cyIsIlNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQiLCJTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCIsIlBST1BFUlRZX1BBRERJTkciLCJQUk9QRVJUWV9NQVJHSU4iLCJTY3JvbGxCYXJIZWxwZXIiLCJnZXRXaWR0aCIsImRvY3VtZW50V2lkdGgiLCJpbm5lcldpZHRoIiwiX2Rpc2FibGVPdmVyRmxvdyIsIl9zZXRFbGVtZW50QXR0cmlidXRlcyIsImNhbGN1bGF0ZWRWYWx1ZSIsIl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzIiwiaXNPdmVyZmxvd2luZyIsIl9zYXZlSW5pdGlhbEF0dHJpYnV0ZSIsInN0eWxlUHJvcGVydHkiLCJzY3JvbGxiYXJXaWR0aCIsIm1hbmlwdWxhdGlvbkNhbGxCYWNrIiwiX2FwcGx5TWFuaXB1bGF0aW9uQ2FsbGJhY2siLCJhY3R1YWxWYWx1ZSIsInJlbW92ZVByb3BlcnR5IiwiY2FsbEJhY2siLCJFVkVOVF9NT1VTRURPV04iLCJjbGlja0NhbGxiYWNrIiwicm9vdEVsZW1lbnQiLCJCYWNrZHJvcCIsIl9pc0FwcGVuZGVkIiwiX2FwcGVuZCIsIl9nZXRFbGVtZW50IiwiX2VtdWxhdGVBbmltYXRpb24iLCJiYWNrZHJvcCIsIkVWRU5UX0ZPQ1VTSU4iLCJFVkVOVF9LRVlET1dOX1RBQiIsIlRBQl9OQVZfRk9SV0FSRCIsIlRBQl9OQVZfQkFDS1dBUkQiLCJhdXRvZm9jdXMiLCJ0cmFwRWxlbWVudCIsIkZvY3VzVHJhcCIsIl9pc0FjdGl2ZSIsIl9sYXN0VGFiTmF2RGlyZWN0aW9uIiwiYWN0aXZhdGUiLCJfaGFuZGxlRm9jdXNpbiIsIl9oYW5kbGVLZXlkb3duIiwiZGVhY3RpdmF0ZSIsIkVWRU5UX0hJREVfUFJFVkVOVEVEIiwiRVZFTlRfUkVTSVpFIiwiRVZFTlRfQ0xJQ0tfRElTTUlTUyIsIkVWRU5UX01PVVNFRE9XTl9ESVNNSVNTIiwiRVZFTlRfS0VZRE9XTl9ESVNNSVNTIiwiQ0xBU1NfTkFNRV9PUEVOIiwiQ0xBU1NfTkFNRV9TVEFUSUMiLCJPUEVOX1NFTEVDVE9SIiwiU0VMRUNUT1JfRElBTE9HIiwiU0VMRUNUT1JfTU9EQUxfQk9EWSIsIk1vZGFsIiwiX2RpYWxvZyIsIl9iYWNrZHJvcCIsIl9pbml0aWFsaXplQmFja0Ryb3AiLCJfZm9jdXN0cmFwIiwiX2luaXRpYWxpemVGb2N1c1RyYXAiLCJfc2Nyb2xsQmFyIiwiX2FkanVzdERpYWxvZyIsIl9zaG93RWxlbWVudCIsIl9oaWRlTW9kYWwiLCJodG1sRWxlbWVudCIsImhhbmRsZVVwZGF0ZSIsIm1vZGFsQm9keSIsInRyYW5zaXRpb25Db21wbGV0ZSIsIl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uIiwiZXZlbnQyIiwiX3Jlc2V0QWRqdXN0bWVudHMiLCJpc01vZGFsT3ZlcmZsb3dpbmciLCJpbml0aWFsT3ZlcmZsb3dZIiwiaXNCb2R5T3ZlcmZsb3dpbmciLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImFscmVhZHlPcGVuIiwiQ0xBU1NfTkFNRV9TSE9XSU5HIiwiQ0xBU1NfTkFNRV9ISURJTkciLCJDTEFTU19OQU1FX0JBQ0tEUk9QIiwiT2ZmY2FudmFzIiwiY29tcGxldGVDYWxsYmFjayIsInVyaUF0dHJpYnV0ZXMiLCJBUklBX0FUVFJJQlVURV9QQVRURVJOIiwiU0FGRV9VUkxfUEFUVEVSTiIsIkRBVEFfVVJMX1BBVFRFUk4iLCJhbGxvd2VkQXR0cmlidXRlIiwiYWxsb3dlZEF0dHJpYnV0ZUxpc3QiLCJhdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRlUmVnZXgiLCJyZWdleCIsIkRlZmF1bHRBbGxvd2xpc3QiLCJhcmVhIiwiYnIiLCJlbSIsImhyIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2IiwibGkiLCJvbCIsInByZSIsInNtYWxsIiwic3BhbiIsInN1YiIsInN1cCIsInN0cm9uZyIsInUiLCJ1bCIsInNhbml0aXplSHRtbCIsInVuc2FmZUh0bWwiLCJhbGxvd0xpc3QiLCJzYW5pdGl6ZUZ1bmN0aW9uIiwiZG9tUGFyc2VyIiwiY3JlYXRlZERvY3VtZW50IiwiZWxlbWVudE5hbWUiLCJhdHRyaWJ1dGVMaXN0IiwiYWxsb3dlZEF0dHJpYnV0ZXMiLCJleHRyYUNsYXNzIiwic2FuaXRpemUiLCJzYW5pdGl6ZUZuIiwidGVtcGxhdGUiLCJEZWZhdWx0Q29udGVudFR5cGUiLCJlbnRyeSIsIlRlbXBsYXRlRmFjdG9yeSIsImdldENvbnRlbnQiLCJfcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24iLCJjaGFuZ2VDb250ZW50IiwiX2NoZWNrQ29udGVudCIsInRvSHRtbCIsInRlbXBsYXRlV3JhcHBlciIsIl9tYXliZVNhbml0aXplIiwiX3NldENvbnRlbnQiLCJ0ZW1wbGF0ZUVsZW1lbnQiLCJfcHV0RWxlbWVudEluVGVtcGxhdGUiLCJESVNBTExPV0VEX0FUVFJJQlVURVMiLCJDTEFTU19OQU1FX01PREFMIiwiU0VMRUNUT1JfVE9PTFRJUF9JTk5FUiIsIlNFTEVDVE9SX01PREFMIiwiRVZFTlRfTU9EQUxfSElERSIsIlRSSUdHRVJfSE9WRVIiLCJUUklHR0VSX0ZPQ1VTIiwiVFJJR0dFUl9DTElDSyIsIlRSSUdHRVJfTUFOVUFMIiwiRVZFTlRfSU5TRVJURUQiLCJFVkVOVF9DTElDSyIsIkVWRU5UX0ZPQ1VTT1VUIiwiQXR0YWNobWVudE1hcCIsIkFVVE8iLCJUT1AiLCJSSUdIVCIsIkJPVFRPTSIsIkxFRlQiLCJjdXN0b21DbGFzcyIsInRpdGxlIiwiVG9vbHRpcCIsIl9pc0VuYWJsZWQiLCJfdGltZW91dCIsIl9pc0hvdmVyZWQiLCJfYWN0aXZlVHJpZ2dlciIsIl90ZW1wbGF0ZUZhY3RvcnkiLCJfbmV3Q29udGVudCIsInRpcCIsIl9zZXRMaXN0ZW5lcnMiLCJfZml4VGl0bGUiLCJlbmFibGUiLCJ0b2dnbGVFbmFibGVkIiwiX2xlYXZlIiwiX2VudGVyIiwiX2hpZGVNb2RhbEhhbmRsZXIiLCJfZGlzcG9zZVBvcHBlciIsIl9pc1dpdGhDb250ZW50Iiwic2hhZG93Um9vdCIsImlzSW5UaGVEb20iLCJfZ2V0VGlwRWxlbWVudCIsIl9pc1dpdGhBY3RpdmVUcmlnZ2VyIiwiX2dldFRpdGxlIiwiX2NyZWF0ZVRpcEVsZW1lbnQiLCJfZ2V0Q29udGVudEZvclRlbXBsYXRlIiwiX2dldFRlbXBsYXRlRmFjdG9yeSIsInRpcElkIiwic2V0Q29udGVudCIsIl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQiLCJfZ2V0RGVsZWdhdGVDb25maWciLCJhdHRhY2htZW50IiwidHJpZ2dlcnMiLCJldmVudEluIiwiZXZlbnRPdXQiLCJfc2V0VGltZW91dCIsImRhdGFBdHRyaWJ1dGVzIiwiZGF0YUF0dHJpYnV0ZSIsIlNFTEVDVE9SX1RJVExFIiwiU0VMRUNUT1JfQ09OVEVOVCIsIlBvcG92ZXIiLCJfZ2V0Q29udGVudCIsIkVWRU5UX0FDVElWQVRFIiwiQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNIiwiU0VMRUNUT1JfREFUQV9TUFkiLCJTRUxFQ1RPUl9UQVJHRVRfTElOS1MiLCJTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUCIsIlNFTEVDVE9SX05BVl9MSU5LUyIsIlNFTEVDVE9SX05BVl9JVEVNUyIsIlNFTEVDVE9SX0xJU1RfSVRFTVMiLCJTRUxFQ1RPUl9MSU5LX0lURU1TIiwiU0VMRUNUT1JfRFJPUERPV04iLCJTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUiLCJyb290TWFyZ2luIiwic21vb3RoU2Nyb2xsIiwidGhyZXNob2xkIiwiU2Nyb2xsU3B5IiwiX3RhcmdldExpbmtzIiwiX29ic2VydmFibGVTZWN0aW9ucyIsIl9yb290RWxlbWVudCIsIl9hY3RpdmVUYXJnZXQiLCJfb2JzZXJ2ZXIiLCJfcHJldmlvdXNTY3JvbGxEYXRhIiwidmlzaWJsZUVudHJ5VG9wIiwicGFyZW50U2Nyb2xsVG9wIiwicmVmcmVzaCIsIl9pbml0aWFsaXplVGFyZ2V0c0FuZE9ic2VydmFibGVzIiwiX21heWJlRW5hYmxlU21vb3RoU2Nyb2xsIiwiZGlzY29ubmVjdCIsIl9nZXROZXdPYnNlcnZlciIsInNlY3Rpb24iLCJvYnNlcnZlIiwib2JzZXJ2YWJsZVNlY3Rpb24iLCJiZWhhdmlvciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiX29ic2VydmVyQ2FsbGJhY2siLCJ0YXJnZXRFbGVtZW50IiwiX3Byb2Nlc3MiLCJ1c2VyU2Nyb2xsc0Rvd24iLCJpc0ludGVyc2VjdGluZyIsIl9jbGVhckFjdGl2ZUNsYXNzIiwiZW50cnlJc0xvd2VyVGhhblByZXZpb3VzIiwidGFyZ2V0TGlua3MiLCJhbmNob3IiLCJfYWN0aXZhdGVQYXJlbnRzIiwibGlzdEdyb3VwIiwiYWN0aXZlTm9kZXMiLCJzcHkiLCJDTEFTU19EUk9QRE9XTiIsIlNFTEVDVE9SX0RST1BET1dOX01FTlUiLCJOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFIiwiU0VMRUNUT1JfVEFCX1BBTkVMIiwiU0VMRUNUT1JfT1VURVIiLCJTRUxFQ1RPUl9JTk5FUiIsIlNFTEVDVE9SX0lOTkVSX0VMRU0iLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRV9BQ1RJVkUiLCJUYWIiLCJfc2V0SW5pdGlhbEF0dHJpYnV0ZXMiLCJfZ2V0Q2hpbGRyZW4iLCJpbm5lckVsZW0iLCJfZWxlbUlzQWN0aXZlIiwiX2dldEFjdGl2ZUVsZW0iLCJfZGVhY3RpdmF0ZSIsIl9hY3RpdmF0ZSIsInJlbGF0ZWRFbGVtIiwiX3RvZ2dsZURyb3BEb3duIiwibmV4dEFjdGl2ZUVsZW1lbnQiLCJwcmV2ZW50U2Nyb2xsIiwiX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzIiwiX3NldEluaXRpYWxBdHRyaWJ1dGVzT25DaGlsZCIsIl9nZXRJbm5lckVsZW1lbnQiLCJpc0FjdGl2ZSIsIm91dGVyRWxlbSIsIl9nZXRPdXRlckVsZW1lbnQiLCJfc2V0SW5pdGlhbEF0dHJpYnV0ZXNPblRhcmdldFBhbmVsIiwiRVZFTlRfTU9VU0VPVkVSIiwiRVZFTlRfTU9VU0VPVVQiLCJDTEFTU19OQU1FX0hJREUiLCJhdXRvaGlkZSIsIlRvYXN0IiwiX2hhc01vdXNlSW50ZXJhY3Rpb24iLCJfaGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiIsIl9jbGVhclRpbWVvdXQiLCJfbWF5YmVTY2hlZHVsZUhpZGUiLCJpc1Nob3duIiwiX29uSW50ZXJhY3Rpb24iLCJpc0ludGVyYWN0aW5nIiwidG9nZ2xlQ29ubmVjdGlvblN0cmluZ0FuZFByZWZpeCIsImNoYW5nZSIsInJlZnJlc2hEZXNjcmlwdGlvbiIsInJlY2lwZU5hbWUiLCJyZWNpcGVEaXNwbGF5TmFtZSIsInJlY2lwZURlc2NyaXB0aW9uIiwic2V0TG9jYWxpemF0aW9uVXJsIiwiY3VsdHVyZXNMaXN0IiwidG9nZ2xlUGFzc3dvcmRWaXNpYmlsaXR5IiwicGFzc3dvcmRDdGwiLCJ0b2dnbGVQYXNzd29yZEN0bCIsImljb24iLCJzdHJlbmd0aCIsIm1pbkxlbmd0aCIsInVwcGVyQ2FzZSIsImxvd2VyQ2FzZSIsIm51bWJlcnMiLCJzcGVjaWFsY2hhcnMiLCJjYXBpdGFsbGV0dGVycyIsImxvd2VybGV0dGVycyIsIm51bWJlciIsInNwZWNpYWxjaGFyIiwidmFsaWQiLCJjcmVhdGVQcm9ncmVzc0JhciIsImdldFBlcmNlbnRhZ2UiLCJ0b0ZpeGVkIiwiZ2V0TGV2ZWwiLCJjaGVja1N0cmVuZ3RoIiwidG90YWwiLCJwZXJjZW50YWdlIiwibGV2ZWwiLCJkYXRhVHJhbnNmZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtB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RCxDQUFiO0lBQ0gsQ0FGRDtJQUdBLEtBQUs0M0IsSUFBTCxDQUFVLE1BQVYsRUFBa0IsVUFBVXJTLEtBQVYsRUFBaUI7TUFDL0JxZ0QsYUFBYSxDQUFDcmdELEtBQUssQ0FBQzBDLGFBQU4sQ0FBb0IrOUMsWUFBcEIsQ0FBaUNubUQsT0FBakMsQ0FBeUMsTUFBekMsQ0FBRCxDQUFiO0lBQ0gsQ0FGRDtJQUlBLEtBQUt2SCxPQUFMLENBQWEsTUFBYixFQUFxQjZNLEVBQXJCLENBQXdCLFFBQXhCLEVBQWtDLFlBQVk7TUFDMUMsSUFBSSxDQUFDb2dELEtBQUwsRUFBWTtRQUNSaGdELEtBQUssQ0FBQ2dDLGNBQU47TUFDSDtJQUNKLENBSkQ7RUFLSCxDQW5GRDtBQW9GSCxDQXRGQSxFQXNGQzNtQixNQXRGRCxDQUFEIiwiZmlsZSI6InNldHVwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjYuMVxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDIyLTA4LTI2VDE3OjUyWlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCB0cmFjLTE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgZmxhdCA9IGFyci5mbGF0ID8gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRyZXR1cm4gYXJyLmZsYXQuY2FsbCggYXJyYXkgKTtcbn0gOiBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdHJldHVybiBhcnIuY29uY2F0LmFwcGx5KCBbXSwgYXJyYXkgKTtcbn07XG5cblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTU3LCBGaXJlZm94IDw9NTJcblx0XHQvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcblx0XHQvLyAoaS5lLiwgYHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9iamVjdFwiICkgPT09IFwiZnVuY3Rpb25cImApLlxuXHRcdC8vIFdlIGRvbid0IHdhbnQgdG8gY2xhc3NpZnkgKmFueSogRE9NIG5vZGUgYXMgYSBmdW5jdGlvbi5cblx0XHQvLyBTdXBwb3J0OiBRdFdlYiA8PTMuOC41LCBXZWJLaXQgPD01MzQuMzQsIHdraHRtbHRvcGRmIHRvb2wgPD0wLjEyLjVcblx0XHQvLyBQbHVzIGZvciBvbGQgV2ViS2l0LCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgY29sbGVjdGlvbnNcblx0XHQvLyAoZS5nLiwgYHR5cGVvZiBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRpdlwiKSA9PT0gXCJmdW5jdGlvblwiYCkuIChnaC00NzU2KVxuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iai5ub2RlVHlwZSAhPT0gXCJudW1iZXJcIiAmJlxuXHRcdFx0dHlwZW9mIG9iai5pdGVtICE9PSBcImZ1bmN0aW9uXCI7XG5cdH07XG5cblxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuXG5cblx0dmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XG5cdFx0dHlwZTogdHJ1ZSxcblx0XHRzcmM6IHRydWUsXG5cdFx0bm9uY2U6IHRydWUsXG5cdFx0bm9Nb2R1bGU6IHRydWVcblx0fTtcblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBub2RlLCBkb2MgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIGksIHZhbCxcblx0XHRcdHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0aWYgKCBub2RlICkge1xuXHRcdFx0Zm9yICggaSBpbiBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNjQrLCBFZGdlIDE4K1xuXHRcdFx0XHQvLyBTb21lIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIFwibm9uY2VcIiBwcm9wZXJ0eSBvbiBzY3JpcHRzLlxuXHRcdFx0XHQvLyBPbiB0aGUgb3RoZXIgaGFuZCwganVzdCB1c2luZyBgZ2V0QXR0cmlidXRlYCBpcyBub3QgZW5vdWdoIGFzXG5cdFx0XHRcdC8vIHRoZSBgbm9uY2VgIGF0dHJpYnV0ZSBpcyByZXNldCB0byBhbiBlbXB0eSBzdHJpbmcgd2hlbmV2ZXIgaXRcblx0XHRcdFx0Ly8gYmVjb21lcyBicm93c2luZy1jb250ZXh0IGNvbm5lY3RlZC5cblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvaHRtbC9pc3N1ZXMvMjM2OVxuXHRcdFx0XHQvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jbm9uY2UtYXR0cmlidXRlc1xuXHRcdFx0XHQvLyBUaGUgYG5vZGUuZ2V0QXR0cmlidXRlYCBjaGVjayB3YXMgYWRkZWQgZm9yIHRoZSBzYWtlIG9mXG5cdFx0XHRcdC8vIGBqUXVlcnkuZ2xvYmFsRXZhbGAgc28gdGhhdCBpdCBjYW4gZmFrZSBhIG5vbmNlLWNvbnRhaW5pbmcgbm9kZVxuXHRcdFx0XHQvLyB2aWEgYW4gb2JqZWN0LlxuXHRcdFx0XHR2YWwgPSBub2RlWyBpIF0gfHwgbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoIGkgKTtcblx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZSggaSwgdmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG5cblxuZnVuY3Rpb24gdG9UeXBlKCBvYmogKSB7XG5cdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdHR5cGVvZiBvYmo7XG59XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIzLjYuMVwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXZlbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkuZ3JlcCggdGhpcywgZnVuY3Rpb24oIF9lbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICggaSArIDEgKSAlIDI7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0b2RkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5ncmVwKCB0aGlzLCBmdW5jdGlvbiggX2VsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gaSAlIDI7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IE9iamVjdC5wcm90b3R5cGUgcG9sbHV0aW9uXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8IHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblx0XHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSBwcm9wZXIgdHlwZSBmb3IgdGhlIHNvdXJjZSB2YWx1ZVxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgJiYgIUFycmF5LmlzQXJyYXkoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBbXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhY29weUlzQXJyYXkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0ge307XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIHByb3ZpZGVkIGNvbnRleHQ7IGZhbGxzIGJhY2sgdG8gdGhlIGdsb2JhbCBvbmVcblx0Ly8gaWYgbm90IHNwZWNpZmllZC5cblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUsIG9wdGlvbnMsIGRvYyApIHtcblx0XHRET01FdmFsKCBjb2RlLCB7IG5vbmNlOiBvcHRpb25zICYmIG9wdGlvbnMubm9uY2UgfSwgZG9jICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gZmxhdCggcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0XHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0gdG9UeXBlKCBvYmogKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIG9iaiApIHx8IGlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy42XG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanMuZm91bmRhdGlvbi9cbiAqXG4gKiBEYXRlOiAyMDIxLTAyLTE2XG4gKi9cbiggZnVuY3Rpb24oIHdpbmRvdyApIHtcbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICgge30gKS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hOYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbIGkgXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufFwiICtcblx0XHRcImlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXN5bnRheC0zLyNpZGVudC10b2tlbi1kaWFncmFtXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIj98XFxcXFxcXFxbXlxcXFxyXFxcXG5cXFxcZl18W1xcXFx3LV18W15cXDAtXFxcXHg3Zl0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdXG5cdFx0Ly8gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgK1xuXHRcdHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblxuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblxuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArXG5cdFx0d2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXCIgKSxcblx0cmRlc2NlbmQgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCJ8PlwiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmh0bWwgPSAvSFRNTCQvaSxcblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblxuXHQvLyBDU1MgZXNjYXBlc1xuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98XFxcXFxcXFwoW15cXFxcclxcXFxuXFxcXGZdKVwiLCBcImdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggZXNjYXBlLCBub25IZXggKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGUuc2xpY2UoIDEgKSAtIDB4MTAwMDA7XG5cblx0XHRyZXR1cm4gbm9uSGV4ID9cblxuXHRcdFx0Ly8gU3RyaXAgdGhlIGJhY2tzbGFzaCBwcmVmaXggZnJvbSBhIG5vbi1oZXggZXNjYXBlIHNlcXVlbmNlXG5cdFx0XHRub25IZXggOlxuXG5cdFx0XHQvLyBSZXBsYWNlIGEgaGV4YWRlY2ltYWwgZXNjYXBlIHNlcXVlbmNlIHdpdGggdGhlIGVuY29kZWQgVW5pY29kZSBjb2RlIHBvaW50XG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExK1xuXHRcdFx0Ly8gRm9yIHZhbHVlcyBvdXRzaWRlIHRoZSBCYXNpYyBNdWx0aWxpbmd1YWwgUGxhbmUgKEJNUCksIG1hbnVhbGx5IGNvbnN0cnVjdCBhXG5cdFx0XHQvLyBzdXJyb2dhdGUgcGFpclxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cblx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG5cdHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcblx0ZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdFx0aWYgKCBhc0NvZGVQb2ludCApIHtcblxuXHRcdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0XHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArXG5cdFx0XHRcdGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFwiIFwiO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0XHRyZXR1cm4gXCJcXFxcXCIgKyBjaDtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fSxcblxuXHRpbkRpc2FibGVkRmllbGRzZXQgPSBhZGRDb21iaW5hdG9yKFxuXHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImZpZWxkc2V0XCI7XG5cdFx0fSxcblx0XHR7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfVxuXHQpO1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoIGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkgKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaE5hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKCBlbHMgKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKCB0YXJnZXRbIGorKyBdID0gZWxzWyBpKysgXSApICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmICggbWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkgKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoICggbSA9IG1hdGNoWyAxIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoIGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkgKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWyAyIF0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoICggbSA9IG1hdGNoWyAzIF0gKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoICFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApICkgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA4IG9ubHlcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0KCBub2RlVHlwZSAhPT0gMSB8fCBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSApIHtcblxuXHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblxuXHRcdFx0XHQvLyBxU0EgY29uc2lkZXJzIGVsZW1lbnRzIG91dHNpZGUgYSBzY29waW5nIHJvb3Qgd2hlbiBldmFsdWF0aW5nIGNoaWxkIG9yXG5cdFx0XHRcdC8vIGRlc2NlbmRhbnQgY29tYmluYXRvcnMsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQuXG5cdFx0XHRcdC8vIEluIHN1Y2ggY2FzZXMsIHdlIHdvcmsgYXJvdW5kIHRoZSBiZWhhdmlvciBieSBwcmVmaXhpbmcgZXZlcnkgc2VsZWN0b3IgaW4gdGhlXG5cdFx0XHRcdC8vIGxpc3Qgd2l0aCBhbiBJRCBzZWxlY3RvciByZWZlcmVuY2luZyB0aGUgc2NvcGUgY29udGV4dC5cblx0XHRcdFx0Ly8gVGhlIHRlY2huaXF1ZSBoYXMgdG8gYmUgdXNlZCBhcyB3ZWxsIHdoZW4gYSBsZWFkaW5nIGNvbWJpbmF0b3IgaXMgdXNlZFxuXHRcdFx0XHQvLyBhcyBzdWNoIHNlbGVjdG9ycyBhcmUgbm90IHJlY29nbml6ZWQgYnkgcXVlcnlTZWxlY3RvckFsbC5cblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgdGVjaG5pcXVlLlxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCByZGVzY2VuZC50ZXN0KCBzZWxlY3RvciApIHx8IHJjb21iaW5hdG9ycy50ZXN0KCBzZWxlY3RvciApICkgKSB7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBXZSBjYW4gdXNlIDpzY29wZSBpbnN0ZWFkIG9mIHRoZSBJRCBoYWNrIGlmIHRoZSBicm93c2VyXG5cdFx0XHRcdFx0Ly8gc3VwcG9ydHMgaXQgJiBpZiB3ZSdyZSBub3QgY2hhbmdpbmcgdGhlIGNvbnRleHQuXG5cdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICE9PSBjb250ZXh0IHx8ICFzdXBwb3J0LnNjb3BlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFx0aWYgKCAoIG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSApICkge1xuXHRcdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKCBuaWQgPSBleHBhbmRvICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1sgaSBdID0gKCBuaWQgPyBcIiNcIiArIG5pZCA6IFwiOnNjb3BlXCIgKSArIFwiIFwiICtcblx0XHRcdFx0XHRcdFx0dG9TZWxlY3RvciggZ3JvdXBzWyBpIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuICggY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSApO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImZpZWxkc2V0XCIgKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdCggXCJ8XCIgKSxcblx0XHRpID0gYXJyLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFyclsgaSBdIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoICggY3VyID0gY3VyLm5leHRTaWJsaW5nICkgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKCBuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIiApICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBkaXNhYmxlZCB0cnVlIGZvciA6ZGlzYWJsZWQ7IGZhbHNlIGZvciA6ZW5hYmxlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZGlzYWJsZWQgKSB7XG5cblx0Ly8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXG5cdFx0aWYgKCBcImZvcm1cIiBpbiBlbGVtICkge1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XG5cdFx0XHQvLyAqIGxpc3RlZCBmb3JtLWFzc29jaWF0ZWQgZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBmaWVsZHNldFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcblx0XHRcdC8vICogb3B0aW9uIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxuXHRcdFx0Ly8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFwiZm9ybVwiIHByb3BlcnR5LlxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gT3B0aW9uIGVsZW1lbnRzIGRlZmVyIHRvIGEgcGFyZW50IG9wdGdyb3VwIGlmIHByZXNlbnRcblx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDYgLSAxMVxuXHRcdFx0XHQvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fFxuXG5cdFx0XHRcdFx0Ly8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcblx0XHRcdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdFx0XHRlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxuXHRcdFx0XHRcdGluRGlzYWJsZWRGaWVsZHNldCggZWxlbSApID09PSBkaXNhYmxlZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXG5cdFx0Ly8gVHJ5IHRvIHdpbm5vdyBvdXQgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSBkaXNhYmxlZCBiZWZvcmUgdHJ1c3RpbmcgdGhlIGRpc2FibGVkIHByb3BlcnR5LlxuXHRcdC8vIFNvbWUgdmljdGltcyBnZXQgY2F1Z2h0IGluIG91ciBuZXQgKGxhYmVsLCBsZWdlbmQsIG1lbnUsIHRyYWNrKSwgYnV0IGl0IHNob3VsZG4ndFxuXHRcdC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxuXHRcdH0gZWxzZSBpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdH1cblxuXHRcdC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKCBqID0gbWF0Y2hJbmRleGVzWyBpIF0gKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbIGogXSA9ICEoIG1hdGNoZXNbIGogXSA9IHNlZWRbIGogXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbmFtZXNwYWNlID0gZWxlbSAmJiBlbGVtLm5hbWVzcGFjZVVSSSxcblx0XHRkb2NFbGVtID0gZWxlbSAmJiAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkuZG9jdW1lbnRFbGVtZW50O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHQvLyBBc3N1bWUgSFRNTCB3aGVuIGRvY3VtZW50RWxlbWVudCBkb2Vzbid0IHlldCBleGlzdCwgc3VjaCBhcyBpbnNpZGUgbG9hZGluZyBpZnJhbWVzXG5cdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC80ODMzXG5cdHJldHVybiAhcmh0bWwudGVzdCggbmFtZXNwYWNlIHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5ub2RlTmFtZSB8fCBcIkhUTUxcIiApO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggZG9jID09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4K1xuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggcHJlZmVycmVkRG9jICE9IGRvY3VtZW50ICYmXG5cdFx0KCBzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldyApICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSAxMSssIEVkZ2UgMTIgLSAxOCssIENocm9tZSA8PTE2IC0gMjUgb25seSwgRmlyZWZveCA8PTMuNiAtIDMxIG9ubHksXG5cdC8vIFNhZmFyaSA0IC0gNSBvbmx5LCBPcGVyYSA8PTExLjYgLSAxMi54IG9ubHlcblx0Ly8gSUUvRWRnZSAmIG9sZGVyIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIDpzY29wZSBwc2V1ZG8tY2xhc3MuXG5cdC8vIFN1cHBvcnQ6IFNhZmFyaSA2LjAgb25seVxuXHQvLyBTYWZhcmkgNi4wIHN1cHBvcnRzIDpzY29wZSBidXQgaXQncyBhbiBhbGlhcyBvZiA6cm9vdCB0aGVyZS5cblx0c3VwcG9ydC5zY29wZSA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXHRcdHJldHVybiB0eXBlb2YgZWwucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0IWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOnNjb3BlIGZpZWxkc2V0IGRpdlwiICkubGVuZ3RoO1xuXHR9ICk7XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKCBcImNsYXNzTmFtZVwiICk7XG5cdH0gKTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudCggXCJcIiApICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCIqXCIgKS5sZW5ndGg7XG5cdH0gKTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9ICk7XG5cblx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmlsdGVyWyBcIklEXCIgXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kWyBcIklEXCIgXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIGVsZW0gPyBbIGVsZW0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0RXhwci5maWx0ZXJbIFwiSURcIiBdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZFsgXCJJRFwiIF0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbm9kZSwgaSwgZWxlbXMsXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFsgXCJUQUdcIiBdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IHJlc3VsdHNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbIFwiQ0xBU1NcIiBdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoICggc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSApICkge1xuXG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdFx0XHR2YXIgaW5wdXQ7XG5cblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIlttc2FsbG93Y2FwdHVyZV49JyddXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbc2VsZWN0ZWRdXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwifj1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHRcdC8vIElFIDExL0VkZ2UgZG9uJ3QgZmluZCBlbGVtZW50cyBvbiBhIGBbbmFtZT0nJ11gIHF1ZXJ5IGluIHNvbWUgY2FzZXMuXG5cdFx0XHQvLyBBZGRpbmcgYSB0ZW1wb3JhcnkgYXR0cmlidXRlIHRvIHRoZSBkb2N1bWVudCBiZWZvcmUgdGhlIHNlbGVjdGlvbiB3b3Jrc1xuXHRcdFx0Ly8gYXJvdW5kIHRoZSBpc3N1ZS5cblx0XHRcdC8vIEludGVyZXN0aW5nbHksIElFIDEwICYgb2xkZXIgZG9uJ3Qgc2VlbSB0byBoYXZlIHRoZSBpc3N1ZS5cblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIlwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW25hbWU9JyddXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqbmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKj1cIiArXG5cdFx0XHRcdFx0d2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmNoZWNrZWRcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmNoZWNrZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiLiMuK1srfl1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9My42IC0gNSBvbmx5XG5cdFx0XHQvLyBPbGQgRmlyZWZveCBkb2Vzbid0IHRocm93IG9uIGEgYmFkbHktZXNjYXBlZCBpZGVudGlmaWVyLlxuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbCggXCJcXFxcXFxmXCIgKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIltcXFxcclxcXFxuXFxcXGZdXCIgKTtcblx0XHR9ICk7XG5cblx0XHRhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltuYW1lPWRdXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmVuYWJsZWRcIiApLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpkaXNhYmxlZFwiICkubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IE9wZXJhIDEwIC0gMTEgb25seVxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiKiw6eFwiICk7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCIsLio6XCIgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoICggbWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yICkgKSApICkge1xuXG5cdFx0YXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGVsLCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oIFwifFwiICkgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbiggXCJ8XCIgKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSApO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoICggYiA9IGIucGFyZW50Tm9kZSApICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCggIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSApICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRpZiAoIGEgPT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09IHByZWZlcnJlZERvYyAmJlxuXHRcdFx0XHRjb250YWlucyggcHJlZmVycmVkRG9jLCBhICkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdGlmICggYiA9PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT0gcHJlZmVycmVkRG9jICYmXG5cdFx0XHRcdGNvbnRhaW5zKCBwcmVmZXJyZWREb2MsIGIgKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cblx0XHRcdHJldHVybiBhID09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKCBjdXIgPSBjdXIucGFyZW50Tm9kZSApICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGN1ci5wYXJlbnROb2RlICkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbIGkgXSA9PT0gYnBbIGkgXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFsgaSBdLCBicFsgaSBdICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cblx0XHRcdGFwWyBpIF0gPT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbIGkgXSA9PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHRzZXREb2N1bWVudCggZWxlbSApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXG5cdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIGV4cHIsIHRydWUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQoIHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApICkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oIHNlbCApIHtcblx0cmV0dXJuICggc2VsICsgXCJcIiApLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoICggZWxlbSA9IHJlc3VsdHNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKCBub2RlID0gZWxlbVsgaSsrIF0gKSApIHtcblxuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbIDEgXSA9IG1hdGNoWyAxIF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWyAzIF0gPSAoIG1hdGNoWyAzIF0gfHwgbWF0Y2hbIDQgXSB8fFxuXHRcdFx0XHRtYXRjaFsgNSBdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWyAyIF0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbIDMgXSA9IFwiIFwiICsgbWF0Y2hbIDMgXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsgMSBdID0gbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWyAxIF0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblxuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbIDAgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbIDQgXSA9ICsoIG1hdGNoWyA0IF0gP1xuXHRcdFx0XHRcdG1hdGNoWyA1IF0gKyAoIG1hdGNoWyA2IF0gfHwgMSApIDpcblx0XHRcdFx0XHQyICogKCBtYXRjaFsgMyBdID09PSBcImV2ZW5cIiB8fCBtYXRjaFsgMyBdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbIDUgXSA9ICsoICggbWF0Y2hbIDcgXSArIG1hdGNoWyA4IF0gKSB8fCBtYXRjaFsgMyBdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFsgNiBdICYmIG1hdGNoWyAyIF07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByWyBcIkNISUxEXCIgXS50ZXN0KCBtYXRjaFsgMCBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRtYXRjaFsgMiBdID0gbWF0Y2hbIDQgXSB8fCBtYXRjaFsgNSBdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoIGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApICkgJiZcblxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KCBleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGggKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFsgMCBdID0gbWF0Y2hbIDAgXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWyAyIF0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQoIHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcdFx0XCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkgKSAmJiBjbGFzc0NhY2hlKFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdChcblx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHxcblx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fFxuXHRcdFx0XHRcdFx0XHRcdFwiXCJcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIF9hcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSBub2RlWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8ICggbm9kZVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdCggb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KCBkaWZmID0gbm9kZUluZGV4ID0gMCApIHx8IHN0YXJ0LnBvcCgpICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAoIG5vZGVbIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdCggb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdCggZGlmZiA9IG5vZGVJbmRleCA9IDAgKSB8fCBzdGFydC5wb3AoKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCBub2RlWyBleHBhbmRvIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkWyBpIF0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbIGkgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblxuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gdW5tYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaSBdID0gISggbWF0Y2hlc1sgaSBdID0gZWxlbSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFsgMCBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblxuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdCggbGFuZyB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoIGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBcInhtbDpsYW5nXCIgKSB8fCBlbGVtLmdldEF0dHJpYnV0ZSggXCJsYW5nXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKCBlbGVtID0gZWxlbS5wYXJlbnROb2RlICkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmXG5cdFx0XHRcdCggIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkgKSAmJlxuXHRcdFx0XHQhISggZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCApO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXG5cdFx0XCJkaXNhYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkICkgfHxcblx0XHRcdFx0KCBub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQgKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1sgXCJlbXB0eVwiIF0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoIGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSApID09IG51bGwgfHxcblx0XHRcdFx0XHRhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0gKSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggX21hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0gKSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIF9tYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSApLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgP1xuXHRcdFx0XHRhcmd1bWVudCArIGxlbmd0aCA6XG5cdFx0XHRcdGFyZ3VtZW50ID4gbGVuZ3RoID9cblx0XHRcdFx0XHRsZW5ndGggOlxuXHRcdFx0XHRcdGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1sgXCJudGhcIiBdID0gRXhwci5wc2V1ZG9zWyBcImVxXCIgXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKCBtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApICkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWyAwIF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKCB0b2tlbnMgPSBbXSApICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoICggbWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSApICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCgge1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbIDAgXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSApO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKCBtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkgKSAmJiAoICFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KCBtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSApICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCgge1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1sgaSBdLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8ICggZWxlbVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKCBvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBrZXkgXSApICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuICggbmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAoIG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzWyBpIF0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbIDAgXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1sgaSBdLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoIGVsZW0gPSB1bm1hdGNoZWRbIGkgXSApICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyhcblx0XHRcdFx0c2VsZWN0b3IgfHwgXCIqXCIsXG5cdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsXG5cdFx0XHRcdFtdXG5cdFx0XHQpLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICggZWxlbSA9IHRlbXBbIGkgXSApICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbIGkgXSBdID0gISggbWF0Y2hlckluWyBwb3N0TWFwWyBpIF0gXSA9IGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblxuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IG1hdGNoZXJPdXRbIGkgXSApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKCBtYXRjaGVySW5bIGkgXSA9IGVsZW0gKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAoIG1hdGNoZXJPdXQgPSBbXSApLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBtYXRjaGVyT3V0WyBpIF0gKSAmJlxuXHRcdFx0XHRcdFx0KCB0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFsgaSBdICkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFsgdGVtcCBdID0gISggcmVzdWx0c1sgdGVtcCBdID0gZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgMCBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbIFwiIFwiIF0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdCggY2hlY2tDb250ZXh0ID0gY29udGV4dCApLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKCBtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyBpIF0udHlwZSBdICkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvciggZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIgKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1sgaSBdLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zWyBpIF0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyBqIF0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cblx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdHRva2Vuc1xuXHRcdFx0XHRcdFx0LnNsaWNlKCAwLCBpIC0gMSApXG5cdFx0XHRcdFx0XHQuY29uY2F0KCB7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSApXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAoIHRva2VucyA9IHRva2Vucy5zbGljZSggaiApICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kWyBcIlRBR1wiIF0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKCBkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSApLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKCBlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSApICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKCBtYXRjaGVyID0gc2V0TWF0Y2hlcnNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblxuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKCB1bm1hdGNoZWRbIGkgXSB8fCBzZXRNYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkWyBpIF0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblxuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFsgaSBdICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKFxuXHRcdFx0c2VsZWN0b3IsXG5cdFx0XHRtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKVxuXHRcdCk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoICggc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvciApICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbIDAgXSA9IG1hdGNoWyAwIF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICggdG9rZW4gPSB0b2tlbnNbIDAgXSApLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIDEgXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFsgXCJJRFwiIF0oIHRva2VuLm1hdGNoZXNbIDAgXVxuXHRcdFx0XHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSwgY29udGV4dCApIHx8IFtdIClbIDAgXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbIFwibmVlZHNDb250ZXh0XCIgXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1sgaSBdO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICggdHlwZSA9IHRva2VuLnR5cGUgKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKCBmaW5kID0gRXhwci5maW5kWyB0eXBlIF0gKSApIHtcblxuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoIHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbIDAgXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1sgMCBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHRcblx0XHRcdFx0KSApICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KCBcIlwiICkuc29ydCggc29ydE9yZGVyICkuam9pbiggXCJcIiApID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZmllbGRzZXRcIiApICkgJiAxO1xufSApO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcImhyZWZcIiApID09PSBcIiNcIjtcbn0gKSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0gKTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59ICkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgX25hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSApO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0cmV0dXJuIGVsLmdldEF0dHJpYnV0ZSggXCJkaXNhYmxlZFwiICkgPT0gbnVsbDtcbn0gKSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0KCB2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSApICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0gKTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSApKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cblx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn1cbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSApO1xuXG5cblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNpbmdsZSBlbGVtZW50XG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBBcnJheWxpa2Ugb2YgZWxlbWVudHMgKGpRdWVyeSwgYXJndW1lbnRzLCBBcnJheSlcblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBGaWx0ZXJlZCBkaXJlY3RseSBmb3IgYm90aCBzaW1wbGUgYW5kIGNvbXBsZXggc2VsZWN0b3JzXG5cdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdGlmICggZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCByZXQsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIHJldCApIDogcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICh0cmFjLTk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICh0cmFjLTExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0aWYgKCBlbGVtLmNvbnRlbnREb2N1bWVudCAhPSBudWxsICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExK1xuXHRcdFx0Ly8gPG9iamVjdD4gZWxlbWVudHMgd2l0aCBubyBgZGF0YWAgYXR0cmlidXRlIGhhcyBhbiBvYmplY3Rcblx0XHRcdC8vIGBjb250ZW50RG9jdW1lbnRgIHdpdGggYSBgbnVsbGAgcHJvdG90eXBlLlxuXHRcdFx0Z2V0UHJvdG8oIGVsZW0uY29udGVudERvY3VtZW50ICkgKSB7XG5cblx0XHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcblx0XHQvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcblx0XHQvLyBkb24ndCBzdXBwb3J0IGl0LlxuXHRcdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuXHRcdFx0ZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggX2ksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBpc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMyBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9jayxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBwcmltYXJ5IERlZmVycmVkXG5cdFx0XHRwcmltYXJ5ID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdHByaW1hcnkucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIHByaW1hcnkuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgcHJpbWFyeS5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBwcmltYXJ5LnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBwcmltYXJ5LnRoZW4oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIHByaW1hcnkucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByaW1hcnkucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdHdpbmRvdy5jb25zb2xlLndhcm4oIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjaywgc3RhY2sgKTtcblx0fVxufTtcblxuXG5cblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cblxuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlIHRyYWMtNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XG5cbi8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbi8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG4vLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDEwIG9ubHlcbi8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxufSBlbHNlIHtcblxuXHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xufVxuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIHRvVHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwgX2tleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggY2hhaW5hYmxlICkge1xuXHRcdHJldHVybiBlbGVtcztcblx0fVxuXG5cdC8vIEdldHNcblx0aWYgKCBidWxrICkge1xuXHRcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xuXHR9XG5cblx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcblxuXG4vLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcbnZhciBybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2c7XG5cbi8vIFVzZWQgYnkgY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuZnVuY3Rpb24gZmNhbWVsQ2FzZSggX2FsbCwgbGV0dGVyICkge1xuXHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcbi8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICh0cmFjLTk1NzIpXG5mdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG59XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSB0cmFjLTgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggZGF0YSApIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cblx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGNhbWVsQ2FzZSgga2V5ICkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSxcblx0XHRcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGtleSApICkge1xuXG5cdFx0XHRcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxuXHRcdFx0XHRrZXkgPSBrZXkubWFwKCBjYW1lbENhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSA9IGNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRrZXkgPSBrZXkgaW4gY2FjaGUgP1xuXHRcdFx0XHRcdFsga2V5IF0gOlxuXHRcdFx0XHRcdCgga2V5Lm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10gKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IGtleS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGdldERhdGEoIGRhdGEgKSB7XG5cdGlmICggZGF0YSA9PT0gXCJ0cnVlXCIgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwiZmFsc2VcIiApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwibnVsbFwiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0aWYgKCBkYXRhID09PSArZGF0YSArIFwiXCIgKSB7XG5cdFx0cmV0dXJuICtkYXRhO1xuXHR9XG5cblx0aWYgKCByYnJhY2UudGVzdCggZGF0YSApICkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICk7XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBnZXREYXRhKCBkYXRhICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICh0cmFjLTE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG52YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuXHR2YXIgaXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cdFx0fSxcblx0XHRjb21wb3NlZCA9IHsgY29tcG9zZWQ6IHRydWUgfTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrLCBpT1MgMTAuMCAtIDEwLjIgb25seVxuXHQvLyBDaGVjayBhdHRhY2htZW50IGFjcm9zcyBzaGFkb3cgRE9NIGJvdW5kYXJpZXMgd2hlbiBwb3NzaWJsZSAoZ2gtMzUwNClcblx0Ly8gU3VwcG9ydDogaU9TIDEwLjAtMTAuMiBvbmx5XG5cdC8vIEVhcmx5IGlPUyAxMCB2ZXJzaW9ucyBzdXBwb3J0IGBhdHRhY2hTaGFkb3dgIGJ1dCBub3QgYGdldFJvb3ROb2RlYCxcblx0Ly8gbGVhZGluZyB0byBlcnJvcnMuIFdlIG5lZWQgdG8gY2hlY2sgZm9yIGBnZXRSb290Tm9kZWAuXG5cdGlmICggZG9jdW1lbnRFbGVtZW50LmdldFJvb3ROb2RlICkge1xuXHRcdGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Um9vdE5vZGUoIGNvbXBvc2VkICkgPT09IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHR9O1xuXHR9XG52YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cblx0XHQvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxuXHRcdHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcblx0XHRcdC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xuXHRcdFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0aXNBdHRhY2hlZCggZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLCBzY2FsZSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSBlbGVtLm5vZGVUeXBlICYmXG5cdFx0XHQoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdFx0Ly8gSGFsdmUgdGhlIGl0ZXJhdGlvbiB0YXJnZXQgdmFsdWUgdG8gcHJldmVudCBpbnRlcmZlcmVuY2UgZnJvbSBDU1MgdXBwZXIgYm91bmRzIChnaC0yMTQ0KVxuXHRcdGluaXRpYWwgPSBpbml0aWFsIC8gMjtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0d2hpbGUgKCBtYXhJdGVyYXRpb25zLS0gKSB7XG5cblx0XHRcdC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXG5cdFx0XHQvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cdFx0XHRpZiAoICggMSAtIHNjYWxlICkgKiAoIDEgLSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSApICkgPD0gMCApIHtcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuXHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKikvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICh0cmFjLTExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAodHJhYy0xNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdC8vIElFIDw9OSByZXBsYWNlcyA8b3B0aW9uPiB0YWdzIHdpdGggdGhlaXIgY29udGVudHMgd2hlbiBpbnNlcnRlZCBvdXRzaWRlIG9mXG5cdC8vIHRoZSBzZWxlY3QgZWxlbWVudC5cblx0ZGl2LmlubmVySFRNTCA9IFwiPG9wdGlvbj48L29wdGlvbj5cIjtcblx0c3VwcG9ydC5vcHRpb24gPSAhIWRpdi5sYXN0Q2hpbGQ7XG59ICkoKTtcblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAodHJhYy0xMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuaWYgKCAhc3VwcG9ydC5vcHRpb24gKSB7XG5cdHdyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbiA9IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXTtcbn1cblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKHRyYWMtMTUxNTEpXG5cdHZhciByZXQ7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXQgPSBbXTtcblx0fVxuXG5cdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgYXR0YWNoZWQsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCB0b1R5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICh0cmFjLTEyMzkyKVxuXHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdGkgPSAwO1xuXHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG5cdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4Nylcblx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcblx0XHRcdGlmICggaWdub3JlZCApIHtcblx0XHRcdFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRhdHRhY2hlZCA9IGlzQXR0YWNoZWQoIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggYXR0YWNoZWQgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbnZhciBydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcbi8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzLCBleGNlcHQgd2hlbiB0aGV5IGFyZSBuby1vcC5cbi8vIFNvIGV4cGVjdCBmb2N1cyB0byBiZSBzeW5jaHJvbm91cyB3aGVuIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgYWN0aXZlLFxuLy8gYW5kIGJsdXIgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBub3QgYWxyZWFkeSBhY3RpdmUuXG4vLyAoZm9jdXMgYW5kIGJsdXIgYXJlIGFsd2F5cyBzeW5jaHJvbm91cyBpbiBvdGhlciBzdXBwb3J0ZWQgYnJvd3NlcnMsXG4vLyB0aGlzIGp1c3QgZGVmaW5lcyB3aGVuIHdlIGNhbiBjb3VudCBvbiBpdCkuXG5mdW5jdGlvbiBleHBlY3RTeW5jKCBlbGVtLCB0eXBlICkge1xuXHRyZXR1cm4gKCBlbGVtID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICkgPT09ICggdHlwZSA9PT0gXCJmb2N1c1wiICk7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBBY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gdGhyb3cgdW5leHBlY3RlZGx5XG4vLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzOTNcbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gT25seSBhdHRhY2ggZXZlbnRzIHRvIG9iamVjdHMgdGhhdCBhY2NlcHQgZGF0YVxuXHRcdGlmICggIWFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXG5cdFx0Ly8gRXZhbHVhdGUgYWdhaW5zdCBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBlbGVtIGlzIGEgbm9uLWVsZW1lbnQgbm9kZSAoZS5nLiwgZG9jdW1lbnQpXG5cdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZG9jdW1lbnRFbGVtZW50LCBzZWxlY3RvciApO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSBPYmplY3QuY3JlYXRlKCBudWxsICk7XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXG5cblx0XHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdFx0ZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApLFxuXG5cdFx0XHRoYW5kbGVycyA9IChcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwgT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHQpWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGUgZXZlbnQgaXMgbmFtZXNwYWNlZCwgdGhlbiBlYWNoIGhhbmRsZXIgaXMgb25seSBpbnZva2VkIGlmIGl0IGlzXG5cdFx0XHRcdC8vIHNwZWNpYWxseSB1bml2ZXJzYWwgb3IgaXRzIG5hbWVzcGFjZXMgYXJlIGEgc3VwZXJzZXQgb2YgdGhlIGV2ZW50J3MuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgaGFuZGxlT2JqLm5hbWVzcGFjZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0XHRldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRjdXIubm9kZVR5cGUgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHQhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICh0cmFjLTEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAodHJhYy02OTExLCB0cmFjLTgxNjUsIHRyYWMtMTEzODIsIHRyYWMtMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAodHJhYy0xMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0Y3VyID0gdGhpcztcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBpc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCB0byBlbnN1cmUgY29ycmVjdCBzdGF0ZSBmb3IgY2hlY2thYmxlIGlucHV0c1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0Ly8gZGF0YVByaXYuc2V0KCBlbCwgXCJjbGlja1wiLCAuLi4gKVxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiLCByZXR1cm5UcnVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlcmluZyBhIGNsaWNrXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIHN1cHByZXNzIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0Ly8gQWxzbyBwcmV2ZW50IGl0IGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0XHRyZXR1cm4gcmNoZWNrYWJsZVR5cGUudGVzdCggdGFyZ2V0LnR5cGUgKSAmJlxuXHRcdFx0XHRcdHRhcmdldC5jbGljayAmJiBub2RlTmFtZSggdGFyZ2V0LCBcImlucHV0XCIgKSAmJlxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGFyZ2V0LCBcImNsaWNrXCIgKSB8fFxuXHRcdFx0XHRcdG5vZGVOYW1lKCB0YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gRW5zdXJlIHRoZSBwcmVzZW5jZSBvZiBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGhhbmRsZXMgbWFudWFsbHktdHJpZ2dlcmVkXG4vLyBzeW50aGV0aWMgZXZlbnRzIGJ5IGludGVycnVwdGluZyBwcm9ncmVzcyB1bnRpbCByZWludm9rZWQgaW4gcmVzcG9uc2UgdG9cbi8vICpuYXRpdmUqIGV2ZW50cyB0aGF0IGl0IGZpcmVzIGRpcmVjdGx5LCBlbnN1cmluZyB0aGF0IHN0YXRlIGNoYW5nZXMgaGF2ZVxuLy8gYWxyZWFkeSBvY2N1cnJlZCBiZWZvcmUgb3RoZXIgbGlzdGVuZXJzIGFyZSBpbnZva2VkLlxuZnVuY3Rpb24gbGV2ZXJhZ2VOYXRpdmUoIGVsLCB0eXBlLCBleHBlY3RTeW5jICkge1xuXG5cdC8vIE1pc3NpbmcgZXhwZWN0U3luYyBpbmRpY2F0ZXMgYSB0cmlnZ2VyIGNhbGwsIHdoaWNoIG11c3QgZm9yY2Ugc2V0dXAgdGhyb3VnaCBqUXVlcnkuZXZlbnQuYWRkXG5cdGlmICggIWV4cGVjdFN5bmMgKSB7XG5cdFx0aWYgKCBkYXRhUHJpdi5nZXQoIGVsLCB0eXBlICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCByZXR1cm5UcnVlICk7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlZ2lzdGVyIHRoZSBjb250cm9sbGVyIGFzIGEgc3BlY2lhbCB1bml2ZXJzYWwgaGFuZGxlciBmb3IgYWxsIGV2ZW50IG5hbWVzcGFjZXNcblx0ZGF0YVByaXYuc2V0KCBlbCwgdHlwZSwgZmFsc2UgKTtcblx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHtcblx0XHRuYW1lc3BhY2U6IGZhbHNlLFxuXHRcdGhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBub3RBc3luYywgcmVzdWx0LFxuXHRcdFx0XHRzYXZlZCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRpZiAoICggZXZlbnQuaXNUcmlnZ2VyICYgMSApICYmIHRoaXNbIHR5cGUgXSApIHtcblxuXHRcdFx0XHQvLyBJbnRlcnJ1cHQgcHJvY2Vzc2luZyBvZiB0aGUgb3V0ZXIgc3ludGhldGljIC50cmlnZ2VyKCllZCBldmVudFxuXHRcdFx0XHQvLyBTYXZlZCBkYXRhIHNob3VsZCBiZSBmYWxzZSBpbiBzdWNoIGNhc2VzLCBidXQgbWlnaHQgYmUgYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdFxuXHRcdFx0XHQvLyBmcm9tIGFuIGFzeW5jIG5hdGl2ZSBoYW5kbGVyIChnaC00MzUwKVxuXHRcdFx0XHRpZiAoICFzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBhcmd1bWVudHMgZm9yIHVzZSB3aGVuIGhhbmRsaW5nIHRoZSBpbm5lciBuYXRpdmUgZXZlbnRcblx0XHRcdFx0XHQvLyBUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgYXJndW1lbnQgKGFuIGV2ZW50IG9iamVjdCksIHNvIHRoaXMgYXJyYXlcblx0XHRcdFx0XHQvLyB3aWxsIG5vdCBiZSBjb25mdXNlZCB3aXRoIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3QuXG5cdFx0XHRcdFx0c2F2ZWQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHNhdmVkICk7XG5cblx0XHRcdFx0XHQvLyBUcmlnZ2VyIHRoZSBuYXRpdmUgZXZlbnQgYW5kIGNhcHR1cmUgaXRzIHJlc3VsdFxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdC8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzXG5cdFx0XHRcdFx0bm90QXN5bmMgPSBleHBlY3RTeW5jKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0dGhpc1sgdHlwZSBdKCk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0IHx8IG5vdEFzeW5jICkge1xuXHRcdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBmYWxzZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYW5jZWwgdGhlIG91dGVyIHN5bnRoZXRpYyBldmVudFxuXHRcdFx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgODYrXG5cdFx0XHRcdFx0XHQvLyBJbiBDaHJvbWUsIGlmIGFuIGVsZW1lbnQgaGF2aW5nIGEgZm9jdXNvdXQgaGFuZGxlciBpcyBibHVycmVkIGJ5XG5cdFx0XHRcdFx0XHQvLyBjbGlja2luZyBvdXRzaWRlIG9mIGl0LCBpdCBpbnZva2VzIHRoZSBoYW5kbGVyIHN5bmNocm9ub3VzbHkuIElmXG5cdFx0XHRcdFx0XHQvLyB0aGF0IGhhbmRsZXIgY2FsbHMgYC5yZW1vdmUoKWAgb24gdGhlIGVsZW1lbnQsIHRoZSBkYXRhIGlzIGNsZWFyZWQsXG5cdFx0XHRcdFx0XHQvLyBsZWF2aW5nIGByZXN1bHRgIHVuZGVmaW5lZC4gV2UgbmVlZCB0byBndWFyZCBhZ2FpbnN0IHRoaXMuXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0ICYmIHJlc3VsdC52YWx1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgZm9yIGFuIGV2ZW50IHdpdGggYSBidWJibGluZyBzdXJyb2dhdGVcblx0XHRcdFx0Ly8gKGZvY3VzIG9yIGJsdXIpLCBhc3N1bWUgdGhhdCB0aGUgc3Vycm9nYXRlIGFscmVhZHkgcHJvcGFnYXRlZCBmcm9tIHRyaWdnZXJpbmcgdGhlXG5cdFx0XHRcdC8vIG5hdGl2ZSBldmVudCBhbmQgcHJldmVudCB0aGF0IGZyb20gaGFwcGVuaW5nIGFnYWluIGhlcmUuXG5cdFx0XHRcdC8vIFRoaXMgdGVjaG5pY2FsbHkgZ2V0cyB0aGUgb3JkZXJpbmcgd3Jvbmcgdy5yLnQuIHRvIGAudHJpZ2dlcigpYCAoaW4gd2hpY2ggdGhlXG5cdFx0XHRcdC8vIGJ1YmJsaW5nIHN1cnJvZ2F0ZSBwcm9wYWdhdGVzICphZnRlciogdGhlIG5vbi1idWJibGluZyBiYXNlKSwgYnV0IHRoYXQgc2VlbXNcblx0XHRcdFx0Ly8gbGVzcyBiYWQgdGhhbiBkdXBsaWNhdGlvbi5cblx0XHRcdFx0fSBlbHNlIGlmICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9ICkuZGVsZWdhdGVUeXBlICkge1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBuYXRpdmUgZXZlbnQgdHJpZ2dlcmVkIGFib3ZlLCBldmVyeXRoaW5nIGlzIG5vdyBpbiBvcmRlclxuXHRcdFx0Ly8gRmlyZSBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgd2l0aCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0Ly8gLi4uYW5kIGNhcHR1cmUgdGhlIHJlc3VsdFxuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHtcblx0XHRcdFx0XHR2YWx1ZTogalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdFx0Ly8gRXh0ZW5kIHdpdGggdGhlIHByb3RvdHlwZSB0byByZXNldCB0aGUgYWJvdmUgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcblx0XHRcdFx0XHRcdGpRdWVyeS5leHRlbmQoIHNhdmVkWyAwIF0sIGpRdWVyeS5FdmVudC5wcm90b3R5cGUgKSxcblx0XHRcdFx0XHRcdHNhdmVkLnNsaWNlKCAxICksXG5cdFx0XHRcdFx0XHR0aGlzXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gQWJvcnQgaGFuZGxpbmcgb2YgdGhlIG5hdGl2ZSBldmVudFxuXHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICh0cmFjLTUwNCwgdHJhYy0xMzE0Mylcblx0XHR0aGlzLnRhcmdldCA9ICggc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkgP1xuXHRcdFx0c3JjLnRhcmdldC5wYXJlbnROb2RlIDpcblx0XHRcdHNyYy50YXJnZXQ7XG5cblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcblx0XHR0aGlzLnJlbGF0ZWRUYXJnZXQgPSBzcmMucmVsYXRlZFRhcmdldDtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc1NpbXVsYXRlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcbmpRdWVyeS5lYWNoKCB7XG5cdGFsdEtleTogdHJ1ZSxcblx0YnViYmxlczogdHJ1ZSxcblx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0Y2hhbmdlZFRvdWNoZXM6IHRydWUsXG5cdGN0cmxLZXk6IHRydWUsXG5cdGRldGFpbDogdHJ1ZSxcblx0ZXZlbnRQaGFzZTogdHJ1ZSxcblx0bWV0YUtleTogdHJ1ZSxcblx0cGFnZVg6IHRydWUsXG5cdHBhZ2VZOiB0cnVlLFxuXHRzaGlmdEtleTogdHJ1ZSxcblx0dmlldzogdHJ1ZSxcblx0XCJjaGFyXCI6IHRydWUsXG5cdGNvZGU6IHRydWUsXG5cdGNoYXJDb2RlOiB0cnVlLFxuXHRrZXk6IHRydWUsXG5cdGtleUNvZGU6IHRydWUsXG5cdGJ1dHRvbjogdHJ1ZSxcblx0YnV0dG9uczogdHJ1ZSxcblx0Y2xpZW50WDogdHJ1ZSxcblx0Y2xpZW50WTogdHJ1ZSxcblx0b2Zmc2V0WDogdHJ1ZSxcblx0b2Zmc2V0WTogdHJ1ZSxcblx0cG9pbnRlcklkOiB0cnVlLFxuXHRwb2ludGVyVHlwZTogdHJ1ZSxcblx0c2NyZWVuWDogdHJ1ZSxcblx0c2NyZWVuWTogdHJ1ZSxcblx0dGFyZ2V0VG91Y2hlczogdHJ1ZSxcblx0dG9FbGVtZW50OiB0cnVlLFxuXHR0b3VjaGVzOiB0cnVlLFxuXHR3aGljaDogdHJ1ZVxufSwgalF1ZXJ5LmV2ZW50LmFkZFByb3AgKTtcblxualF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIHR5cGUsIGRlbGVnYXRlVHlwZSApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSA9IHtcblxuXHRcdC8vIFV0aWxpemUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJmb2N1c1wiLCAuLi4gKVxuXHRcdFx0Ly8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImJsdXJcIiwgLi4uIClcblx0XHRcdGxldmVyYWdlTmF0aXZlKCB0aGlzLCB0eXBlLCBleHBlY3RTeW5jICk7XG5cblx0XHRcdC8vIFJldHVybiBmYWxzZSB0byBhbGxvdyBub3JtYWwgcHJvY2Vzc2luZyBpbiB0aGUgY2FsbGVyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJcblx0XHRcdGxldmVyYWdlTmF0aXZlKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdC8vIFJldHVybiBub24tZmFsc2UgdG8gYWxsb3cgbm9ybWFsIGV2ZW50LXBhdGggcHJvcGFnYXRpb25cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBTdXBwcmVzcyBuYXRpdmUgZm9jdXMgb3IgYmx1ciBpZiB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlXG5cdFx0Ly8gYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG5cdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGV2ZW50LnRhcmdldCwgdHlwZSApO1xuXHRcdH0sXG5cblx0XHRkZWxlZ2F0ZVR5cGU6IGRlbGVnYXRlVHlwZVxuXHR9O1xufSApO1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzIG9ubHlcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8IVxcW0NEQVRBXFxbfFxcXVxcXT5cXHMqJC9nO1xuXG4vLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSApIHtcblxuXHRcdHJldHVybiBqUXVlcnkoIGVsZW0gKS5jaGlsZHJlbiggXCJ0Ym9keVwiIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdGlmICggKCBlbGVtLnR5cGUgfHwgXCJcIiApLnNsaWNlKCAwLCA1ICkgPT09IFwidHJ1ZS9cIiApIHtcblx0XHRlbGVtLnR5cGUgPSBlbGVtLnR5cGUuc2xpY2UoIDUgKTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YVByaXYuZ2V0KCBzcmMgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZGVzdCwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGZsYXQoIGFyZ3MgKTtcblxuXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuXHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gfHxcblx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAodHJhYy04MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICYmICggbm9kZS50eXBlIHx8IFwiXCIgKS50b0xvd2VyQ2FzZSgpICAhPT0gXCJtb2R1bGVcIiApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCAmJiAhbm9kZS5ub01vZHVsZSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRub25jZTogbm9kZS5ub25jZSB8fCBub2RlLmdldEF0dHJpYnV0ZSggXCJub25jZVwiIClcblx0XHRcdFx0XHRcdFx0XHR9LCBkb2MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBVbndyYXAgYSBDREFUQSBzZWN0aW9uIGNvbnRhaW5pbmcgc2NyaXB0IGNvbnRlbnRzLiBUaGlzIHNob3VsZG4ndCBiZVxuXHRcdFx0XHRcdFx0XHQvLyBuZWVkZWQgYXMgaW4gWE1MIGRvY3VtZW50cyB0aGV5J3JlIGFscmVhZHkgbm90IHZpc2libGUgd2hlblxuXHRcdFx0XHRcdFx0XHQvLyBpbnNwZWN0aW5nIGVsZW1lbnQgY29udGVudHMgYW5kIGluIEhUTUwgZG9jdW1lbnRzIHRoZXkgaGF2ZSBub1xuXHRcdFx0XHRcdFx0XHQvLyBtZWFuaW5nIGJ1dCB3ZSdyZSBwcmVzZXJ2aW5nIHRoYXQgbG9naWMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBjb21wbGV0ZWx5IGluIDQuMC4gU2VlIGdoLTQ5MDQuXG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIG5vZGUsIGRvYyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgaXNBdHRhY2hlZCggbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWw7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGlzQXR0YWNoZWQoIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIHJjdXN0b21Qcm9wID0gL14tLS87XG5cblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKHRyYWMtMTUwOTgsIHRyYWMtMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmNhbGwoIGVsZW0gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxudmFyIHJib3hTdHlsZSA9IG5ldyBSZWdFeHAoIGNzc0V4cGFuZC5qb2luKCBcInxcIiApLCBcImlcIiApO1xuXG52YXIgd2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIjtcblxuXG52YXIgcnRyaW1DU1MgPSBuZXcgUmVnRXhwKFxuXHRcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLFxuXHRcImdcIlxuKTtcblxuXG5cblxuKCBmdW5jdGlvbigpIHtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG5cdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7XCIgK1xuXHRcdFx0XCJtYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIjtcblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OnNjcm9sbDtcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ3aWR0aDo2MCU7dG9wOjElXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUubWFyZ2luTGVmdCApID09PSAxMjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIFNhZmFyaSA8PTkuMSAtIDEwLjEsIGlPUyA8PTcuMCAtIDkuM1xuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5yaWdodCA9IFwiNjAlXCI7XG5cdFx0cGl4ZWxCb3hTdHlsZXNWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLnJpZ2h0ICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0XHQvLyBEZXRlY3QgbWlzcmVwb3J0aW5nIG9mIGNvbnRlbnQgZGltZW5zaW9ucyBmb3IgYm94LXNpemluZzpib3JkZXItYm94IGVsZW1lbnRzXG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLndpZHRoICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG92ZXJmbG93OnNjcm9sbCBzY3Jld2luZXNzIChnaC0zNjk5KVxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTY0XG5cdFx0Ly8gRG9uJ3QgZ2V0IHRyaWNrZWQgd2hlbiB6b29tIGFmZmVjdHMgb2Zmc2V0V2lkdGggKGdoLTQwMjkpXG5cdFx0ZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdHNjcm9sbGJveFNpemVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdi5vZmZzZXRXaWR0aCAvIDMgKSA9PT0gMTI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuXHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRkaXYgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gcm91bmRQaXhlbE1lYXN1cmVzKCBtZWFzdXJlICkge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKCBwYXJzZUZsb2F0KCBtZWFzdXJlICkgKTtcblx0fVxuXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgc2Nyb2xsYm94U2l6ZVZhbCwgcGl4ZWxCb3hTdHlsZXNWYWwsXG5cdFx0cmVsaWFibGVUckRpbWVuc2lvbnNWYWwsIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICh0cmFjLTg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsQm94U3R5bGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XG5cdFx0fSxcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9LFxuXHRcdHNjcm9sbGJveFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xuXHRcdH0sXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcblx0XHQvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cblx0XHQvLyBCZWhhdmlvciBpbiBJRSA5IGlzIG1vcmUgc3VidGxlIHRoYW4gaW4gbmV3ZXIgdmVyc2lvbnMgJiBpdCBwYXNzZXNcblx0XHQvLyBzb21lIHZlcnNpb25zIG9mIHRoaXMgdGVzdDsgbWFrZSBzdXJlIG5vdCB0byBtYWtlIGl0IHBhc3MgdGhlcmUhXG5cdFx0Ly9cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDcwK1xuXHRcdC8vIE9ubHkgRmlyZWZveCBpbmNsdWRlcyBib3JkZXIgd2lkdGhzXG5cdFx0Ly8gaW4gY29tcHV0ZWQgZGltZW5zaW9ucy4gKGdoLTQ1MjkpXG5cdFx0cmVsaWFibGVUckRpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRhYmxlLCB0ciwgdHJDaGlsZCwgdHJTdHlsZTtcblx0XHRcdGlmICggcmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRhYmxlXCIgKTtcblx0XHRcdFx0dHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRyXCIgKTtcblx0XHRcdFx0dHJDaGlsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHRcdFx0XHR0YWJsZS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O2JvcmRlci1jb2xsYXBzZTpzZXBhcmF0ZVwiO1xuXHRcdFx0XHR0ci5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MXB4IHNvbGlkXCI7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDg2K1xuXHRcdFx0XHQvLyBIZWlnaHQgc2V0IHRocm91Z2ggY3NzVGV4dCBkb2VzIG5vdCBnZXQgYXBwbGllZC5cblx0XHRcdFx0Ly8gQ29tcHV0ZWQgaGVpZ2h0IHRoZW4gY29tZXMgYmFjayBhcyAwLlxuXHRcdFx0XHR0ci5zdHlsZS5oZWlnaHQgPSBcIjFweFwiO1xuXHRcdFx0XHR0ckNoaWxkLnN0eWxlLmhlaWdodCA9IFwiOXB4XCI7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA4IENocm9tZSA4Nitcblx0XHRcdFx0Ly8gSW4gb3VyIGJvZHlCYWNrZ3JvdW5kLmh0bWwgaWZyYW1lLFxuXHRcdFx0XHQvLyBkaXNwbGF5IGZvciBhbGwgZGl2IGVsZW1lbnRzIGlzIHNldCB0byBcImlubGluZVwiLFxuXHRcdFx0XHQvLyB3aGljaCBjYXVzZXMgYSBwcm9ibGVtIG9ubHkgaW4gQW5kcm9pZCA4IENocm9tZSA4Ni5cblx0XHRcdFx0Ly8gRW5zdXJpbmcgdGhlIGRpdiBpcyBkaXNwbGF5OiBibG9ja1xuXHRcdFx0XHQvLyBnZXRzIGFyb3VuZCB0aGlzIGlzc3VlLlxuXHRcdFx0XHR0ckNoaWxkLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cblx0XHRcdFx0ZG9jdW1lbnRFbGVtZW50XG5cdFx0XHRcdFx0LmFwcGVuZENoaWxkKCB0YWJsZSApXG5cdFx0XHRcdFx0LmFwcGVuZENoaWxkKCB0ciApXG5cdFx0XHRcdFx0LmFwcGVuZENoaWxkKCB0ckNoaWxkICk7XG5cblx0XHRcdFx0dHJTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCB0ciApO1xuXHRcdFx0XHRyZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCA9ICggcGFyc2VJbnQoIHRyU3R5bGUuaGVpZ2h0LCAxMCApICtcblx0XHRcdFx0XHRwYXJzZUludCggdHJTdHlsZS5ib3JkZXJUb3BXaWR0aCwgMTAgKSArXG5cdFx0XHRcdFx0cGFyc2VJbnQoIHRyU3R5bGUuYm9yZGVyQm90dG9tV2lkdGgsIDEwICkgKSA9PT0gdHIub2Zmc2V0SGVpZ2h0O1xuXG5cdFx0XHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggdGFibGUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApLFxuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcblx0XHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG5cdFx0Ly8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuXHRcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxuXHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksIHRyYWMtMTI1MzcpXG5cdC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKGdoLTMxNDQpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHQvLyB0cmltIHdoaXRlc3BhY2UgZm9yIGN1c3RvbSBwcm9wZXJ0eSAoaXNzdWUgZ2gtNDkyNilcblx0XHRpZiAoIGlzQ3VzdG9tUHJvcCApIHtcblxuXHRcdFx0Ly8gcnRyaW0gdHJlYXRzIFUrMDAwRCBDQVJSSUFHRSBSRVRVUk4gYW5kIFUrMDAwQyBGT1JNIEZFRURcblx0XHRcdC8vIGFzIHdoaXRlc3BhY2Ugd2hpbGUgQ1NTIGRvZXMgbm90LCBidXQgdGhpcyBpcyBub3QgYSBwcm9ibGVtXG5cdFx0XHQvLyBiZWNhdXNlIENTUyBwcmVwcm9jZXNzaW5nIHJlcGxhY2VzIHRoZW0gd2l0aCBVKzAwMEEgTElORSBGRUVEXG5cdFx0XHQvLyAod2hpY2ggKmlzKiBDU1Mgd2hpdGVzcGFjZSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3Mtc3ludGF4LTMvI2lucHV0LXByZXByb2Nlc3Npbmdcblx0XHRcdHJldCA9IHJldC5yZXBsYWNlKCBydHJpbUNTUywgXCIkMVwiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWlzQXR0YWNoZWQoIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxCb3hTdHlsZXMoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcmJveFN0eWxlLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyIGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZSxcblx0dmVuZG9yUHJvcHMgPSB7fTtcblxuLy8gUmV0dXJuIGEgdmVuZG9yLXByZWZpeGVkIHByb3BlcnR5IG9yIHVuZGVmaW5lZFxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbi8vIFJldHVybiBhIHBvdGVudGlhbGx5LW1hcHBlZCBqUXVlcnkuY3NzUHJvcHMgb3IgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiBmaW5hbFByb3BOYW1lKCBuYW1lICkge1xuXHR2YXIgZmluYWwgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXSB8fCB2ZW5kb3JQcm9wc1sgbmFtZSBdO1xuXG5cdGlmICggZmluYWwgKSB7XG5cdFx0cmV0dXJuIGZpbmFsO1xuXHR9XG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cdHJldHVybiB2ZW5kb3JQcm9wc1sgbmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB8fCBuYW1lO1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9O1xuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggX2VsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYm94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIGJveCwgaXNCb3JkZXJCb3gsIHN0eWxlcywgY29tcHV0ZWRWYWwgKSB7XG5cdHZhciBpID0gZGltZW5zaW9uID09PSBcIndpZHRoXCIgPyAxIDogMCxcblx0XHRleHRyYSA9IDAsXG5cdFx0ZGVsdGEgPSAwO1xuXG5cdC8vIEFkanVzdG1lbnQgbWF5IG5vdCBiZSBuZWNlc3Nhcnlcblx0aWYgKCBib3ggPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpblxuXHRcdGlmICggYm94ID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgYm94ICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBjb250ZW50LWJveCwgd2UncmUgc2Vla2luZyBcInBhZGRpbmdcIiBvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCJcblx0XHRpZiAoICFpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gQWRkIHBhZGRpbmdcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBGb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiLCBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEJ1dCBzdGlsbCBrZWVwIHRyYWNrIG9mIGl0IG90aGVyd2lzZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXh0cmEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBib3JkZXItYm94IChjb250ZW50ICsgcGFkZGluZyArIGJvcmRlciksIHdlJ3JlIHNlZWtpbmcgXCJjb250ZW50XCIgb3Jcblx0XHQvLyBcInBhZGRpbmdcIiBvciBcIm1hcmdpblwiXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiLCBzdWJ0cmFjdCBwYWRkaW5nXG5cdFx0XHRpZiAoIGJveCA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIgb3IgXCJwYWRkaW5nXCIsIHN1YnRyYWN0IGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWNjb3VudCBmb3IgcG9zaXRpdmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlciB3aGVuIHJlcXVlc3RlZCBieSBwcm92aWRpbmcgY29tcHV0ZWRWYWxcblx0aWYgKCAhaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCApIHtcblxuXHRcdC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyBhIHJvdW5kZWQgc3VtIG9mIGNvbnRlbnQsIHBhZGRpbmcsIHNjcm9sbCBndXR0ZXIsIGFuZCBib3JkZXJcblx0XHQvLyBBc3N1bWluZyBpbnRlZ2VyIHNjcm9sbCBndXR0ZXIsIHN1YnRyYWN0IHRoZSByZXN0IGFuZCByb3VuZCBkb3duXG5cdFx0ZGVsdGEgKz0gTWF0aC5tYXgoIDAsIE1hdGguY2VpbChcblx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRjb21wdXRlZFZhbCAtXG5cdFx0XHRkZWx0YSAtXG5cdFx0XHRleHRyYSAtXG5cdFx0XHQwLjVcblxuXHRcdC8vIElmIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyB1bmtub3duLCB0aGVuIHdlIGNhbid0IGRldGVybWluZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyXG5cdFx0Ly8gVXNlIGFuIGV4cGxpY2l0IHplcm8gdG8gYXZvaWQgTmFOIChnaC0zOTY0KVxuXHRcdCkgKSB8fCAwO1xuXHR9XG5cblx0cmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggY29tcHV0ZWQgc3R5bGVcblx0dmFyIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXG5cdFx0Ly8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtNDMyMikuXG5cdFx0Ly8gRmFrZSBjb250ZW50LWJveCB1bnRpbCB3ZSBrbm93IGl0J3MgbmVlZGVkIHRvIGtub3cgdGhlIHRydWUgdmFsdWUuXG5cdFx0Ym94U2l6aW5nTmVlZGVkID0gIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCBleHRyYSxcblx0XHRpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3gsXG5cblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIGRpbWVuc2lvbiwgc3R5bGVzICksXG5cdFx0b2Zmc2V0UHJvcCA9IFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICk7XG5cblx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxuXHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRpZiAoICFleHRyYSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXHRcdHZhbCA9IFwiYXV0b1wiO1xuXHR9XG5cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBVc2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciB3aGVuIGJveCBzaXppbmcgaXMgdW5yZWxpYWJsZS5cblx0Ly8gSW4gdGhvc2UgY2FzZXMsIHRoZSBjb21wdXRlZCB2YWx1ZSBjYW4gYmUgdHJ1c3RlZCB0byBiZSBib3JkZXItYm94LlxuXHRpZiAoICggIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSAmJiBpc0JvcmRlckJveCB8fFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTAgLSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHQvLyBJRS9FZGdlIG1pc3JlcG9ydCBgZ2V0Q29tcHV0ZWRTdHlsZWAgb2YgdGFibGUgcm93cyB3aXRoIHdpZHRoL2hlaWdodFxuXHRcdC8vIHNldCBpbiBDU1Mgd2hpbGUgYG9mZnNldCpgIHByb3BlcnRpZXMgcmVwb3J0IGNvcnJlY3QgdmFsdWVzLlxuXHRcdC8vIEludGVyZXN0aW5nbHksIGluIHNvbWUgY2FzZXMgSUUgOSBkb2Vzbid0IHN1ZmZlciBmcm9tIHRoaXMgaXNzdWUuXG5cdFx0IXN1cHBvcnQucmVsaWFibGVUckRpbWVuc2lvbnMoKSAmJiBub2RlTmFtZSggZWxlbSwgXCJ0clwiICkgfHxcblxuXHRcdC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxuXHRcdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0XHR2YWwgPT09IFwiYXV0b1wiIHx8XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcblx0XHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIG1pc3JlcG9ydGVkIGlubGluZSBkaW1lbnNpb25zIChnaC0zNjAyKVxuXHRcdCFwYXJzZUZsb2F0KCB2YWwgKSAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImlubGluZVwiICkgJiZcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGUgZWxlbWVudCBpcyB2aXNpYmxlICYgY29ubmVjdGVkXG5cdFx0ZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHRcdC8vIFdoZXJlIGF2YWlsYWJsZSwgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGFwcHJveGltYXRlIGJvcmRlciBib3ggZGltZW5zaW9ucy5cblx0XHQvLyBXaGVyZSBub3QgYXZhaWxhYmxlIChlLmcuLCBTVkcpLCBhc3N1bWUgdW5yZWxpYWJsZSBib3gtc2l6aW5nIGFuZCBpbnRlcnByZXQgdGhlXG5cdFx0Ly8gcmV0cmlldmVkIHZhbHVlIGFzIGEgY29udGVudCBib3ggZGltZW5zaW9uLlxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBvZmZzZXRQcm9wIGluIGVsZW07XG5cdFx0aWYgKCB2YWx1ZUlzQm9yZGVyQm94ICkge1xuXHRcdFx0dmFsID0gZWxlbVsgb2Zmc2V0UHJvcCBdO1xuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBcIlwiIGFuZCBhdXRvXG5cdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cblx0Ly8gQWRqdXN0IGZvciB0aGUgZWxlbWVudCdzIGJveCBtb2RlbFxuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdGVsZW0sXG5cdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzLFxuXG5cdFx0XHQvLyBQcm92aWRlIHRoZSBjdXJyZW50IGNvbXB1dGVkIHNpemUgdG8gcmVxdWVzdCBzY3JvbGwgZ3V0dGVyIGNhbGN1bGF0aW9uIChnaC0zNTg5KVxuXHRcdFx0dmFsXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJncmlkQXJlYVwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtblwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtbkVuZFwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtblN0YXJ0XCI6IHRydWUsXG5cdFx0XCJncmlkUm93XCI6IHRydWUsXG5cdFx0XCJncmlkUm93RW5kXCI6IHRydWUsXG5cdFx0XCJncmlkUm93U3RhcnRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICh0cmFjLTczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyB0cmFjLTkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAodHJhYy03MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdC8vIFRoZSBpc0N1c3RvbVByb3AgY2hlY2sgY2FuIGJlIHJlbW92ZWQgaW4galF1ZXJ5IDQuMCB3aGVuIHdlIG9ubHkgYXV0by1hcHBlbmRcblx0XHRcdC8vIFwicHhcIiB0byBhIGZldyBoYXJkY29kZWQgdmFsdWVzLlxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICYmICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdFx0c3R5bGUuc2V0UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIF9pLCBkaW1lbnNpb24gKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cblx0XHRcdFx0Ly8gT25seSByZWFkIHN0eWxlcy5wb3NpdGlvbiBpZiB0aGUgdGVzdCBoYXMgYSBjaGFuY2UgdG8gZmFpbFxuXHRcdFx0XHQvLyB0byBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LlxuXHRcdFx0XHRzY3JvbGxib3hTaXplQnVnZ3kgPSAhc3VwcG9ydC5zY3JvbGxib3hTaXplKCkgJiZcblx0XHRcdFx0XHRzdHlsZXMucG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIixcblxuXHRcdFx0XHQvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC0zOTkxKVxuXHRcdFx0XHRib3hTaXppbmdOZWVkZWQgPSBzY3JvbGxib3hTaXplQnVnZ3kgfHwgZXh0cmEsXG5cdFx0XHRcdGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSA/XG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRcdGRpbWVuc2lvbixcblx0XHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdFx0aXNCb3JkZXJCb3gsXG5cdFx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0XHQpIDpcblx0XHRcdFx0XHQwO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB1bnJlbGlhYmxlIGJvcmRlci1ib3ggZGltZW5zaW9ucyBieSBjb21wYXJpbmcgb2Zmc2V0KiB0byBjb21wdXRlZCBhbmRcblx0XHRcdC8vIGZha2luZyBhIGNvbnRlbnQtYm94IHRvIGdldCBib3JkZXIgYW5kIHBhZGRpbmcgKGdoLTM2OTkpXG5cdFx0XHRpZiAoIGlzQm9yZGVyQm94ICYmIHNjcm9sbGJveFNpemVCdWdneSApIHtcblx0XHRcdFx0c3VidHJhY3QgLT0gTWF0aC5jZWlsKFxuXHRcdFx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggc3R5bGVzWyBkaW1lbnNpb24gXSApIC1cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgXCJib3JkZXJcIiwgZmFsc2UsIHN0eWxlcyApIC1cblx0XHRcdFx0XHQwLjVcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIGRpbWVuc2lvbiApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoIHByZWZpeCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdIHx8XG5cdFx0XHRcdFx0dHdlZW4uZWxlbS5zdHlsZVsgZmluYWxQcm9wTmFtZSggdHdlZW4ucHJvcCApIF0gIT0gbnVsbCApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xuXHRcdC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRcdC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuXHRcdFx0XHRpZiAoICFoaWRkZW4gKSB7XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXG5cdFx0cHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRcdHByb3BUd2Vlbi5zdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0gY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKHRyYWMtMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdHJlc3VsdC5zdG9wLmJpbmQoIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdGFuaW1hdGlvblxuXHRcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0cmV0dXJuIGFuaW1hdGlvbjtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRpc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuXHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IERhdGUubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aW5Qcm9ncmVzcyA9IHRydWU7XG5cdHNjaGVkdWxlKCk7XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpblByb2dyZXNzID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cblx0XHRcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwgKHRyYWMtMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHR9XG5cdHJldHVybiBbXTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc05hbWVzLCBjdXIsIGN1clZhbHVlLCBjbGFzc05hbWUsIGksIGZpbmFsVmFsdWU7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3NOYW1lcy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRjdXIgPSB0aGlzLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpIF07XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXNzTmFtZSArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhc3NOYW1lICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc05hbWVzLCBjdXIsIGN1clZhbHVlLCBjbGFzc05hbWUsIGksIGZpbmFsVmFsdWU7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzTmFtZXMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSB0aGlzLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhc3NOYW1lICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGFzc05hbWUgKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciBjbGFzc05hbWVzLCBjbGFzc05hbWUsIGksIHNlbGYsXG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlLFxuXHRcdFx0aXNWYWxpZFZhbHVlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzVmFsaWRWYWx1ZSApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBjbGFzc05hbWVzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBnZXRDbGFzcyggZWxlbSApICkgKyBcIiBcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgdmFsdWVJc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICh0cmFjLTE0Njg2LCB0cmFjLTE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLCBpLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdFx0aSA9IG1heDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBvbmUgPyBpbmRleCA6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAodHJhYy0yNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH07XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCwgbGFzdEVsZW1lbnQsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKHRyYWMtOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKHRyYWMtOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRsYXN0RWxlbWVudCA9IGN1cjtcblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwgT2JqZWN0LmNyZWF0ZSggbnVsbCApIClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAodHJhYy02MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBIYW5kbGU6IHJlZ3VsYXIgbm9kZXMgKHZpYSBgdGhpcy5vd25lckRvY3VtZW50YCksIHdpbmRvd1xuXHRcdFx0XHQvLyAodmlhIGB0aGlzLmRvY3VtZW50YCkgJiBkb2N1bWVudCAodmlhIGB0aGlzYCkuXG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSB7IGd1aWQ6IERhdGUubm93KCkgfTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sLCBwYXJzZXJFcnJvckVsZW07XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHt9XG5cblx0cGFyc2VyRXJyb3JFbGVtID0geG1sICYmIHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiIClbIDAgXTtcblx0aWYgKCAheG1sIHx8IHBhcnNlckVycm9yRWxlbSApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgKFxuXHRcdFx0cGFyc2VyRXJyb3JFbGVtID9cblx0XHRcdFx0alF1ZXJ5Lm1hcCggcGFyc2VyRXJyb3JFbGVtLmNoaWxkTm9kZXMsIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWwudGV4dENvbnRlbnQ7XG5cdFx0XHRcdH0gKS5qb2luKCBcIlxcblwiICkgOlxuXHRcdFx0XHRkYXRhXG5cdFx0KSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgdG9UeXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcblx0XHRcdHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uKCkgOlxuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb247XG5cblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgK1xuXHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHR9O1xuXG5cdGlmICggYSA9PSBudWxsICkge1xuXHRcdHJldHVybiBcIlwiO1xuXHR9XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9ICkubWFwKCBmdW5jdGlvbiggX2ksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cjIwID0gLyUyMC9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vIHRyYWMtNzY1MywgdHJhYy04MTI1LCB0cmFjLTgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKHRyYWMtMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5vcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgdHJhYy05ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcblx0XHRcdGNvbXBsZXRlZCxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG5cdFx0XHR1bmNhY2hlZCxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSA9XG5cdFx0XHRcdFx0XHRcdFx0XHQoIHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSB8fCBbXSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5jb25jYXQoIG1hdGNoWyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2guam9pbiggXCIsIFwiICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAodHJhYy0xMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCB0cmFjLTEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9ICggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0dXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcblx0XHRcdC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAodHJhYy0xNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSAmJiAoIHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vIHRyYWMtOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UuZ3VpZCsrICkgK1xuXHRcdFx0XHRcdHVuY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG5cdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxuXHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG5cdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVc2UgYSBub29wIGNvbnZlcnRlciBmb3IgbWlzc2luZyBzY3JpcHQgYnV0IG5vdCBpZiBqc29ucFxuXHRcdFx0aWYgKCAhaXNTdWNjZXNzICYmXG5cdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBcInNjcmlwdFwiLCBzLmRhdGFUeXBlcyApID4gLTEgJiZcblx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIFwianNvblwiLCBzLmRhdGFUeXBlcyApIDwgMCApIHtcblx0XHRcdFx0cy5jb252ZXJ0ZXJzWyBcInRleHQgc2NyaXB0XCIgXSA9IGZ1bmN0aW9uKCkge307XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIF9pLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0dmFyIGk7XG5cdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdGlmICggaS50b0xvd2VyQ2FzZSgpID09PSBcImNvbnRlbnQtdHlwZVwiICkge1xuXHRcdFx0cy5jb250ZW50VHlwZSA9IHMuaGVhZGVyc1sgaSBdIHx8IFwiXCI7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCwgb3B0aW9ucywgZG9jICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAodHJhYy0xMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXG5cdFx0Ly8gT25seSBldmFsdWF0ZSB0aGUgcmVzcG9uc2UgaWYgaXQgaXMgc3VjY2Vzc2Z1bCAoZ2gtNDEyNilcblx0XHQvLyBkYXRhRmlsdGVyIGlzIG5vdCBpbnZva2VkIGZvciBmYWlsdXJlIHJlc3BvbnNlcywgc28gdXNpbmcgaXQgaW5zdGVhZFxuXHRcdC8vIG9mIHRoZSBkZWZhdWx0IGNvbnZlcnRlciBpcyBrbHVkZ3kgYnV0IGl0IHdvcmtzLlxuXHRcdGNvbnZlcnRlcnM6IHtcblx0XHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oKSB7fVxuXHRcdH0sXG5cdFx0ZGF0YUZpbHRlcjogZnVuY3Rpb24oIHJlc3BvbnNlICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHJlc3BvbnNlLCBvcHRpb25zLCBkb2MgKTtcblx0XHR9XG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGh0bWxJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gdHJhYy0xNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID1cblx0XHRcdFx0XHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgdHJhYy04NjA1LCB0cmFjLTE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IHhoci5vbnRpbWVvdXQgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyB0cmFjLTE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcblx0fVxufSApO1xuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIG9yIGZvcmNlZC1ieS1hdHRycyByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gfHwgcy5zY3JpcHRBdHRycyApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApXG5cdFx0XHRcdFx0LmF0dHIoIHMuc2NyaXB0QXR0cnMgfHwge30gKVxuXHRcdFx0XHRcdC5wcm9wKCB7IGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCwgc3JjOiBzLnVybCB9IClcblx0XHRcdFx0XHQub24oIFwibG9hZCBlcnJvclwiLCBjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UuZ3VpZCsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0gaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBpc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0Ly8gb2Zmc2V0KCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgYm9yZGVyIGJveCB0byB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgcmVjdCwgd2luLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiAoZGlzcGxheTogbm9uZSkgZWxlbWVudHMgKGdoLTIzMTApXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxuXHRcdC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxuXHRcdGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0XHQvLyBHZXQgZG9jdW1lbnQtcmVsYXRpdmUgcG9zaXRpb24gYnkgYWRkaW5nIHZpZXdwb3J0IHNjcm9sbCB0byB2aWV3cG9ydC1yZWxhdGl2ZSBnQkNSXG5cdFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0d2luID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0LFxuXHRcdFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0XG5cdFx0fTtcblx0fSxcblxuXHQvLyBwb3NpdGlvbigpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIG1hcmdpbiBib3ggdG8gaXRzIG9mZnNldCBwYXJlbnQncyBwYWRkaW5nIGJveFxuXHQvLyBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBiZWhhdmlvciBvZiBDU1MgYWJzb2x1dGUgcG9zaXRpb25pbmdcblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsIGRvYyxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gcG9zaXRpb246Zml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHRoZSB2aWV3cG9ydCwgd2hpY2ggaXRzZWxmIGFsd2F5cyBoYXMgemVybyBvZmZzZXRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBwb3NpdGlvbjpmaXhlZCBpbXBsaWVzIGF2YWlsYWJpbGl0eSBvZiBnZXRCb3VuZGluZ0NsaWVudFJlY3Rcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdGhlICpyZWFsKiBvZmZzZXQgcGFyZW50LCB3aGljaCBjYW4gYmUgdGhlIGRvY3VtZW50IG9yIGl0cyByb290IGVsZW1lbnRcblx0XHRcdC8vIHdoZW4gYSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudCBpcyBpZGVudGlmaWVkXG5cdFx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiZcblx0XHRcdFx0KCBvZmZzZXRQYXJlbnQgPT09IGRvYy5ib2R5IHx8IG9mZnNldFBhcmVudCA9PT0gZG9jLmRvY3VtZW50RWxlbWVudCApICYmXG5cdFx0XHRcdGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09IGVsZW0gJiYgb2Zmc2V0UGFyZW50Lm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIEluY29ycG9yYXRlIGJvcmRlcnMgaW50byBpdHMgb2Zmc2V0LCBzaW5jZSB0aGV5IGFyZSBvdXRzaWRlIGl0cyBjb250ZW50IG9yaWdpblxuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBqUXVlcnkoIG9mZnNldFBhcmVudCApLm9mZnNldCgpO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXG5cdFx0XHQvLyBDb2FsZXNjZSBkb2N1bWVudHMgYW5kIHdpbmRvd3Ncblx0XHRcdHZhciB3aW47XG5cdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW07XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtLmRlZmF1bHRWaWV3O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggX2ksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHtcblx0XHRwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLFxuXHRcdGNvbnRlbnQ6IHR5cGUsXG5cdFx0XCJcIjogXCJvdXRlclwiICsgbmFtZVxuXHR9LCBmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBfaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH0sXG5cblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKFxuXHQoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXG5cdFx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0XHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0XHR9O1xuXHR9XG4pO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcbi8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuLy8gUmVxdWlyZSB0aGF0IHRoZSBcIndoaXRlc3BhY2UgcnVuXCIgc3RhcnRzIGZyb20gYSBub24td2hpdGVzcGFjZVxuLy8gdG8gYXZvaWQgTyhOXjIpIGJlaGF2aW9yIHdoZW4gdGhlIGVuZ2luZSB3b3VsZCB0cnkgbWF0Y2hpbmcgXCJcXHMrJFwiIGF0IGVhY2ggc3BhY2UgcG9zaXRpb24uXG52YXIgcnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3woW15cXHNcXHVGRUZGXFx4QTBdKVtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxuLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG4vLyBhcmd1bWVudHMuXG4vLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXG4vLyBIb3dldmVyLCBpdCBpcyBub3Qgc2xhdGVkIGZvciByZW1vdmFsIGFueSB0aW1lIHNvb25cbmpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdGNvbnRleHQgPSBmbjtcblx0XHRmbiA9IHRtcDtcblx0fVxuXG5cdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdGlmICggIWlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNpbXVsYXRlZCBiaW5kXG5cdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0fTtcblxuXHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0cmV0dXJuIHByb3h5O1xufTtcblxualF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuXHRpZiAoIGhvbGQgKSB7XG5cdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHR9XG59O1xualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5qUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcbmpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmpRdWVyeS5pc1dpbmRvdyA9IGlzV2luZG93O1xualF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbmpRdWVyeS50eXBlID0gdG9UeXBlO1xuXG5qUXVlcnkubm93ID0gRGF0ZS5ub3c7XG5cbmpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiggb2JqICkge1xuXG5cdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xufTtcblxualF1ZXJ5LnRyaW0gPSBmdW5jdGlvbiggdGV4dCApIHtcblx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XCJcIiA6XG5cdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKTtcbn07XG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKHRyYWMtNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKHRyYWMtMTM1NjYpXG5pZiAoIHR5cGVvZiBub0dsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgV2luZG93IH0gZnJvbSAnLi4vdHlwZXMnO1xuZGVjbGFyZSBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZTogTm9kZSB8IFdpbmRvdyk6IFdpbmRvdztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgIGNvbnN0IG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSAnLi9nZXRXaW5kb3cnO1xuXG5kZWNsYXJlIGZ1bmN0aW9uIGlzRWxlbWVudChub2RlOiBtaXhlZCk6IGJvb2xlYW4gJWNoZWNrcyhub2RlIGluc3RhbmNlb2ZcbiAgRWxlbWVudCk7XG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICBjb25zdCBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxuZGVjbGFyZSBmdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGU6IG1peGVkKTogYm9vbGVhbiAlY2hlY2tzKG5vZGUgaW5zdGFuY2VvZlxuICBIVE1MRWxlbWVudCk7XG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGUpIHtcbiAgY29uc3QgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuZGVjbGFyZSBmdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZTogbWl4ZWQpOiBib29sZWFuICVjaGVja3Mobm9kZSBpbnN0YW5jZW9mXG4gIFNoYWRvd1Jvb3QpO1xuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cblxuZXhwb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfTtcbiIsIi8vIEBmbG93XG5leHBvcnQgY29uc3QgbWF4ID0gTWF0aC5tYXg7XG5leHBvcnQgY29uc3QgbWluID0gTWF0aC5taW47XG5leHBvcnQgY29uc3Qgcm91bmQgPSBNYXRoLnJvdW5kO1xuIiwiLy8gQGZsb3dcbnR5cGUgTmF2aWdhdG9yID0gTmF2aWdhdG9yICYgeyB1c2VyQWdlbnREYXRhPzogTmF2aWdhdG9yVUFEYXRhIH07XG5cbmludGVyZmFjZSBOYXZpZ2F0b3JVQURhdGEge1xuICBicmFuZHM6IEFycmF5PHsgYnJhbmQ6IHN0cmluZywgdmVyc2lvbjogc3RyaW5nIH0+O1xuICBtb2JpbGU6IGJvb2xlYW47XG4gIHBsYXRmb3JtOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFVBU3RyaW5nKCk6IHN0cmluZyB7XG4gIGNvbnN0IHVhRGF0YSA9IChuYXZpZ2F0b3I6IE5hdmlnYXRvcikudXNlckFnZW50RGF0YTtcblxuICBpZiAodWFEYXRhPy5icmFuZHMpIHtcbiAgICByZXR1cm4gdWFEYXRhLmJyYW5kc1xuICAgICAgLm1hcCgoaXRlbSkgPT4gYCR7aXRlbS5icmFuZH0vJHtpdGVtLnZlcnNpb259YClcbiAgICAgIC5qb2luKCcgJyk7XG4gIH1cblxuICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgZ2V0VUFTdHJpbmcgZnJvbSAnLi4vdXRpbHMvdXNlckFnZW50JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNMYXlvdXRWaWV3cG9ydCgpIHtcbiAgcmV0dXJuICEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgQ2xpZW50UmVjdE9iamVjdCwgVmlydHVhbEVsZW1lbnQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQgfSBmcm9tICcuL2luc3RhbmNlT2YnO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tICcuLi91dGlscy9tYXRoJztcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSAnLi9nZXRXaW5kb3cnO1xuaW1wb3J0IGlzTGF5b3V0Vmlld3BvcnQgZnJvbSAnLi9pc0xheW91dFZpZXdwb3J0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KFxuICBlbGVtZW50OiBFbGVtZW50IHwgVmlydHVhbEVsZW1lbnQsXG4gIGluY2x1ZGVTY2FsZTogYm9vbGVhbiA9IGZhbHNlLFxuICBpc0ZpeGVkU3RyYXRlZ3k6IGJvb2xlYW4gPSBmYWxzZVxuKTogQ2xpZW50UmVjdE9iamVjdCB7XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBsZXQgc2NhbGVYID0gMTtcbiAgbGV0IHNjYWxlWSA9IDE7XG5cbiAgaWYgKGluY2x1ZGVTY2FsZSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgc2NhbGVYID1cbiAgICAgIChlbGVtZW50OiBIVE1MRWxlbWVudCkub2Zmc2V0V2lkdGggPiAwXG4gICAgICAgID8gcm91bmQoY2xpZW50UmVjdC53aWR0aCkgLyAoZWxlbWVudDogSFRNTEVsZW1lbnQpLm9mZnNldFdpZHRoIHx8IDFcbiAgICAgICAgOiAxO1xuICAgIHNjYWxlWSA9XG4gICAgICAoZWxlbWVudDogSFRNTEVsZW1lbnQpLm9mZnNldEhlaWdodCA+IDBcbiAgICAgICAgPyByb3VuZChjbGllbnRSZWN0LmhlaWdodCkgLyAoZWxlbWVudDogSFRNTEVsZW1lbnQpLm9mZnNldEhlaWdodCB8fCAxXG4gICAgICAgIDogMTtcbiAgfVxuXG4gIGNvbnN0IHsgdmlzdWFsVmlld3BvcnQgfSA9IGlzRWxlbWVudChlbGVtZW50KSA/IGdldFdpbmRvdyhlbGVtZW50KSA6IHdpbmRvdztcbiAgY29uc3QgYWRkVmlzdWFsT2Zmc2V0cyA9ICFpc0xheW91dFZpZXdwb3J0KCkgJiYgaXNGaXhlZFN0cmF0ZWd5O1xuXG4gIGNvbnN0IHggPVxuICAgIChjbGllbnRSZWN0LmxlZnQgK1xuICAgICAgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0IDogMCkpIC9cbiAgICBzY2FsZVg7XG4gIGNvbnN0IHkgPVxuICAgIChjbGllbnRSZWN0LnRvcCArXG4gICAgICAoYWRkVmlzdWFsT2Zmc2V0cyAmJiB2aXN1YWxWaWV3cG9ydCA/IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcCA6IDApKSAvXG4gICAgc2NhbGVZO1xuICBjb25zdCB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGggLyBzY2FsZVg7XG4gIGNvbnN0IGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0IC8gc2NhbGVZO1xuXG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogeCArIHdpZHRoLFxuICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICBsZWZ0OiB4LFxuICAgIHgsXG4gICAgeSxcbiAgfTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gJy4vZ2V0V2luZG93JztcbmltcG9ydCB0eXBlIHsgV2luZG93IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZTogTm9kZSB8IFdpbmRvdykge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3cobm9kZSk7XG4gIGNvbnN0IHNjcm9sbExlZnQgPSB3aW4ucGFnZVhPZmZzZXQ7XG4gIGNvbnN0IHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcblxuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wLFxuICB9O1xufVxuIiwiLy8gQGZsb3dcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRTY3JvbGwoZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcCxcbiAgfTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gJy4vZ2V0V2luZG93U2Nyb2xsJztcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSAnLi9nZXRXaW5kb3cnO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gJy4vaW5zdGFuY2VPZic7XG5pbXBvcnQgZ2V0SFRNTEVsZW1lbnRTY3JvbGwgZnJvbSAnLi9nZXRIVE1MRWxlbWVudFNjcm9sbCc7XG5pbXBvcnQgdHlwZSB7IFdpbmRvdyB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChub2RlOiBOb2RlIHwgV2luZG93KSB7XG4gIGlmIChub2RlID09PSBnZXRXaW5kb3cobm9kZSkgfHwgIWlzSFRNTEVsZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gZ2V0V2luZG93U2Nyb2xsKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRIVE1MRWxlbWVudFNjcm9sbChub2RlKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgV2luZG93IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlTmFtZShlbGVtZW50OiA/Tm9kZSB8IFdpbmRvdyk6ID9zdHJpbmcge1xuICByZXR1cm4gZWxlbWVudCA/IChlbGVtZW50Lm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tICcuL2luc3RhbmNlT2YnO1xuaW1wb3J0IHR5cGUgeyBXaW5kb3cgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChcbiAgZWxlbWVudDogRWxlbWVudCB8IFdpbmRvd1xuKTogSFRNTEVsZW1lbnQge1xuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gIHJldHVybiAoXG4gICAgKGlzRWxlbWVudChlbGVtZW50KVxuICAgICAgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnRcbiAgICAgIDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICAgIGVsZW1lbnQuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudFxuICApLmRvY3VtZW50RWxlbWVudDtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gJy4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0JztcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSAnLi9nZXREb2N1bWVudEVsZW1lbnQnO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tICcuL2dldFdpbmRvd1Njcm9sbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudDogRWxlbWVudCk6IG51bWJlciB7XG4gIC8vIElmIDxodG1sPiBoYXMgYSBDU1Mgd2lkdGggZ3JlYXRlciB0aGFuIHRoZSB2aWV3cG9ydCwgdGhlbiB0aGlzIHdpbGwgYmVcbiAgLy8gaW5jb3JyZWN0IGZvciBSVEwuXG4gIC8vIFBvcHBlciAxIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UgYW5kIG5ldmVyIGhhZCBhIGJ1ZyByZXBvcnQgc28gbGV0J3MgYXNzdW1lXG4gIC8vIGl0J3Mgbm90IGFuIGlzc3VlLiBJIGRvbid0IHRoaW5rIGFueW9uZSBldmVyIHNwZWNpZmllcyB3aWR0aCBvbiA8aHRtbD5cbiAgLy8gYW55d2F5LlxuICAvLyBCcm93c2VycyB3aGVyZSB0aGUgbGVmdCBzY3JvbGxiYXIgZG9lc24ndCBjYXVzZSBhbiBpc3N1ZSByZXBvcnQgYDBgIGZvclxuICAvLyB0aGlzIChlLmcuIEVkZ2UgMjAxOSwgSUUxMSwgU2FmYXJpKVxuICByZXR1cm4gKFxuICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgK1xuICAgIGdldFdpbmRvd1Njcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0XG4gICk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tICcuL2dldFdpbmRvdyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoXG4gIGVsZW1lbnQ6IEVsZW1lbnRcbik6IENTU1N0eWxlRGVjbGFyYXRpb24ge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSAnLi9nZXRDb21wdXRlZFN0eWxlJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgLy8gRmlyZWZveCB3YW50cyB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuICBjb25zdCB7IG92ZXJmbG93LCBvdmVyZmxvd1gsIG92ZXJmbG93WSB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbi8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBSZWN0LCBWaXJ0dWFsRWxlbWVudCwgV2luZG93IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tICcuL2dldEJvdW5kaW5nQ2xpZW50UmVjdCc7XG5pbXBvcnQgZ2V0Tm9kZVNjcm9sbCBmcm9tICcuL2dldE5vZGVTY3JvbGwnO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gJy4vZ2V0Tm9kZU5hbWUnO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gJy4vaW5zdGFuY2VPZic7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tICcuL2dldFdpbmRvd1Njcm9sbEJhclgnO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tICcuL2dldERvY3VtZW50RWxlbWVudCc7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSAnLi9pc1Njcm9sbFBhcmVudCc7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gJy4uL3V0aWxzL21hdGgnO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnRTY2FsZWQoZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcbiAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHNjYWxlWCA9IHJvdW5kKHJlY3Qud2lkdGgpIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxO1xuICBjb25zdCBzY2FsZVkgPSByb3VuZChyZWN0LmhlaWdodCkgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxO1xuXG4gIHJldHVybiBzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxO1xufVxuXG4vLyBSZXR1cm5zIHRoZSBjb21wb3NpdGUgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuXG4vLyBDb21wb3NpdGUgbWVhbnMgaXQgdGFrZXMgaW50byBhY2NvdW50IHRyYW5zZm9ybXMgYXMgd2VsbCBhcyBsYXlvdXQuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDb21wb3NpdGVSZWN0KFxuICBlbGVtZW50T3JWaXJ0dWFsRWxlbWVudDogRWxlbWVudCB8IFZpcnR1YWxFbGVtZW50LFxuICBvZmZzZXRQYXJlbnQ6IEVsZW1lbnQgfCBXaW5kb3csXG4gIGlzRml4ZWQ6IGJvb2xlYW4gPSBmYWxzZVxuKTogUmVjdCB7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBvZmZzZXRQYXJlbnRJc1NjYWxlZCA9XG4gICAgaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzRWxlbWVudFNjYWxlZChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChcbiAgICBlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCxcbiAgICBvZmZzZXRQYXJlbnRJc1NjYWxlZCxcbiAgICBpc0ZpeGVkXG4gICk7XG5cbiAgbGV0IHNjcm9sbCA9IHsgc2Nyb2xsTGVmdDogMCwgc2Nyb2xsVG9wOiAwIH07XG4gIGxldCBvZmZzZXRzID0geyB4OiAwLCB5OiAwIH07XG5cbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICghaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpKSB7XG4gICAgaWYgKFxuICAgICAgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcbiAgICAgIGlzU2Nyb2xsUGFyZW50KGRvY3VtZW50RWxlbWVudClcbiAgICApIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBvZmZzZXRzID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XG4gICAgICBvZmZzZXRzLnggKz0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgKz0gb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXG4gIH07XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBSZWN0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tICcuL2dldEJvdW5kaW5nQ2xpZW50UmVjdCc7XG5cbi8vIFJldHVybnMgdGhlIGxheW91dCByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC4gTGF5b3V0XG4vLyBtZWFucyBpdCBkb2Vzbid0IHRha2UgaW50byBhY2NvdW50IHRyYW5zZm9ybXMuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRMYXlvdXRSZWN0KGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogUmVjdCB7XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7XG5cbiAgLy8gVXNlIHRoZSBjbGllbnRSZWN0IHNpemVzIGlmIGl0J3Mgbm90IGJlZW4gdHJhbnNmb3JtZWQuXG4gIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTIyM1xuICBsZXQgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICBsZXQgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3Qud2lkdGggLSB3aWR0aCkgPD0gMSkge1xuICAgIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aDtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LmhlaWdodCAtIGhlaWdodCkgPD0gMSkge1xuICAgIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBlbGVtZW50Lm9mZnNldExlZnQsXG4gICAgeTogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICB9O1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tICcuL2dldE5vZGVOYW1lJztcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSAnLi9nZXREb2N1bWVudEVsZW1lbnQnO1xuaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSAnLi9pbnN0YW5jZU9mJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50OiBOb2RlIHwgU2hhZG93Um9vdCk6IE5vZGUge1xuICBpZiAoZ2V0Tm9kZU5hbWUoZWxlbWVudCkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICAvLyB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICBlbGVtZW50LmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxuICAgIGVsZW1lbnQucGFyZW50Tm9kZSB8fCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgIChpc1NoYWRvd1Jvb3QoZWxlbWVudCkgPyBlbGVtZW50Lmhvc3QgOiBudWxsKSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IEhUTUxFbGVtZW50IGlzIGEgTm9kZVxuICAgIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSAvLyBmYWxsYmFja1xuICApO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gJy4vZ2V0UGFyZW50Tm9kZSc7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSAnLi9pc1Njcm9sbFBhcmVudCc7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSAnLi9nZXROb2RlTmFtZSc7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSAnLi9pbnN0YW5jZU9mJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KG5vZGU6IE5vZGUpOiBIVE1MRWxlbWVudCB7XG4gIGlmIChbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmRleE9mKGdldE5vZGVOYW1lKG5vZGUpKSA+PSAwKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIGlmIChpc0hUTUxFbGVtZW50KG5vZGUpICYmIGlzU2Nyb2xsUGFyZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUobm9kZSkpO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRTY3JvbGxQYXJlbnQgZnJvbSAnLi9nZXRTY3JvbGxQYXJlbnQnO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSAnLi9nZXRQYXJlbnROb2RlJztcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSAnLi9nZXRXaW5kb3cnO1xuaW1wb3J0IHR5cGUgeyBXaW5kb3csIFZpc3VhbFZpZXdwb3J0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gJy4vaXNTY3JvbGxQYXJlbnQnO1xuXG4vKlxuZ2l2ZW4gYSBET00gZWxlbWVudCwgcmV0dXJuIHRoZSBsaXN0IG9mIGFsbCBzY3JvbGwgcGFyZW50cywgdXAgdGhlIGxpc3Qgb2YgYW5jZXNvcnNcbnVudGlsIHdlIGdldCB0byB0aGUgdG9wIHdpbmRvdyBvYmplY3QuIFRoaXMgbGlzdCBpcyB3aGF0IHdlIGF0dGFjaCBzY3JvbGwgbGlzdGVuZXJzXG50bywgYmVjYXVzZSBpZiBhbnkgb2YgdGhlc2UgcGFyZW50IGVsZW1lbnRzIHNjcm9sbCwgd2UnbGwgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlXG5yZWZlcmVuY2UgZWxlbWVudCdzIHBvc2l0aW9uLlxuKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxpc3RTY3JvbGxQYXJlbnRzKFxuICBlbGVtZW50OiBOb2RlLFxuICBsaXN0OiBBcnJheTxFbGVtZW50IHwgV2luZG93PiA9IFtdXG4pOiBBcnJheTxFbGVtZW50IHwgV2luZG93IHwgVmlzdWFsVmlld3BvcnQ+IHtcbiAgY29uc3Qgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpO1xuICBjb25zdCBpc0JvZHkgPSBzY3JvbGxQYXJlbnQgPT09IGVsZW1lbnQub3duZXJEb2N1bWVudD8uYm9keTtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KHNjcm9sbFBhcmVudCk7XG4gIGNvbnN0IHRhcmdldCA9IGlzQm9keVxuICAgID8gW3dpbl0uY29uY2F0KFxuICAgICAgICB3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sXG4gICAgICAgIGlzU2Nyb2xsUGFyZW50KHNjcm9sbFBhcmVudCkgPyBzY3JvbGxQYXJlbnQgOiBbXVxuICAgICAgKVxuICAgIDogc2Nyb2xsUGFyZW50O1xuICBjb25zdCB1cGRhdGVkTGlzdCA9IGxpc3QuY29uY2F0KHRhcmdldCk7XG5cbiAgcmV0dXJuIGlzQm9keVxuICAgID8gdXBkYXRlZExpc3RcbiAgICA6IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBpc0JvZHkgdGVsbHMgdXMgdGFyZ2V0IHdpbGwgYmUgYW4gSFRNTEVsZW1lbnQgaGVyZVxuICAgICAgdXBkYXRlZExpc3QuY29uY2F0KGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUodGFyZ2V0KSkpO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tICcuL2dldE5vZGVOYW1lJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudDogRWxlbWVudCk6IGJvb2xlYW4ge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpID49IDA7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tICcuL2dldFdpbmRvdyc7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSAnLi9nZXROb2RlTmFtZSc7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tICcuL2dldENvbXB1dGVkU3R5bGUnO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCwgaXNTaGFkb3dSb290IH0gZnJvbSAnLi9pbnN0YW5jZU9mJztcbmltcG9ydCBpc1RhYmxlRWxlbWVudCBmcm9tICcuL2lzVGFibGVFbGVtZW50JztcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gJy4vZ2V0UGFyZW50Tm9kZSc7XG5pbXBvcnQgZ2V0VUFTdHJpbmcgZnJvbSAnLi4vdXRpbHMvdXNlckFnZW50JztcblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50OiBFbGVtZW50KTogP0VsZW1lbnQge1xuICBpZiAoXG4gICAgIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICAgIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCdcbiAgKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59XG5cbi8vIGAub2Zmc2V0UGFyZW50YCByZXBvcnRzIGBudWxsYCBmb3IgZml4ZWQgZWxlbWVudHMsIHdoaWxlIGFic29sdXRlIGVsZW1lbnRzXG4vLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50OiBFbGVtZW50KSB7XG4gIGNvbnN0IGlzRmlyZWZveCA9IC9maXJlZm94L2kudGVzdChnZXRVQVN0cmluZygpKTtcbiAgY29uc3QgaXNJRSA9IC9UcmlkZW50L2kudGVzdChnZXRVQVN0cmluZygpKTtcblxuICBpZiAoaXNJRSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgLy8gSW4gSUUgOSwgMTAgYW5kIDExIGZpeGVkIGVsZW1lbnRzIGNvbnRhaW5pbmcgYmxvY2sgaXMgYWx3YXlzIGVzdGFibGlzaGVkIGJ5IHRoZSB2aWV3cG9ydFxuICAgIGNvbnN0IGVsZW1lbnRDc3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIGlmIChlbGVtZW50Q3NzLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBsZXQgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gIGlmIChpc1NoYWRvd1Jvb3QoY3VycmVudE5vZGUpKSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5ob3N0O1xuICB9XG5cbiAgd2hpbGUgKFxuICAgIGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmXG4gICAgWydodG1sJywgJ2JvZHknXS5pbmRleE9mKGdldE5vZGVOYW1lKGN1cnJlbnROb2RlKSkgPCAwXG4gICkge1xuICAgIGNvbnN0IGNzcyA9IGdldENvbXB1dGVkU3R5bGUoY3VycmVudE5vZGUpO1xuXG4gICAgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XG4gICAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuICAgIGlmIChcbiAgICAgIGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fFxuICAgICAgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHxcbiAgICAgIGNzcy5jb250YWluID09PSAncGFpbnQnIHx8XG4gICAgICBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fFxuICAgICAgKGlzRmlyZWZveCAmJiBjc3Mud2lsbENoYW5nZSA9PT0gJ2ZpbHRlcicpIHx8XG4gICAgICAoaXNGaXJlZm94ICYmIGNzcy5maWx0ZXIgJiYgY3NzLmZpbHRlciAhPT0gJ25vbmUnKVxuICAgICkge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudDogRWxlbWVudCkge1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coZWxlbWVudCk7XG5cbiAgbGV0IG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCk7XG5cbiAgd2hpbGUgKFxuICAgIG9mZnNldFBhcmVudCAmJlxuICAgIGlzVGFibGVFbGVtZW50KG9mZnNldFBhcmVudCkgJiZcbiAgICBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnXG4gICkge1xuICAgIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIGlmIChcbiAgICBvZmZzZXRQYXJlbnQgJiZcbiAgICAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2h0bWwnIHx8XG4gICAgICAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmXG4gICAgICAgIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpKVxuICApIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkgfHwgd2luZG93O1xufVxuIiwiLy8gQGZsb3dcbmV4cG9ydCBjb25zdCB0b3A6ICd0b3AnID0gJ3RvcCc7XG5leHBvcnQgY29uc3QgYm90dG9tOiAnYm90dG9tJyA9ICdib3R0b20nO1xuZXhwb3J0IGNvbnN0IHJpZ2h0OiAncmlnaHQnID0gJ3JpZ2h0JztcbmV4cG9ydCBjb25zdCBsZWZ0OiAnbGVmdCcgPSAnbGVmdCc7XG5leHBvcnQgY29uc3QgYXV0bzogJ2F1dG8nID0gJ2F1dG8nO1xuZXhwb3J0IHR5cGUgQmFzZVBsYWNlbWVudCA9XG4gIHwgdHlwZW9mIHRvcFxuICB8IHR5cGVvZiBib3R0b21cbiAgfCB0eXBlb2YgcmlnaHRcbiAgfCB0eXBlb2YgbGVmdDtcbmV4cG9ydCBjb25zdCBiYXNlUGxhY2VtZW50czogQXJyYXk8QmFzZVBsYWNlbWVudD4gPSBbdG9wLCBib3R0b20sIHJpZ2h0LCBsZWZ0XTtcblxuZXhwb3J0IGNvbnN0IHN0YXJ0OiAnc3RhcnQnID0gJ3N0YXJ0JztcbmV4cG9ydCBjb25zdCBlbmQ6ICdlbmQnID0gJ2VuZCc7XG5leHBvcnQgdHlwZSBWYXJpYXRpb24gPSB0eXBlb2Ygc3RhcnQgfCB0eXBlb2YgZW5kO1xuXG5leHBvcnQgY29uc3QgY2xpcHBpbmdQYXJlbnRzOiAnY2xpcHBpbmdQYXJlbnRzJyA9ICdjbGlwcGluZ1BhcmVudHMnO1xuZXhwb3J0IGNvbnN0IHZpZXdwb3J0OiAndmlld3BvcnQnID0gJ3ZpZXdwb3J0JztcbmV4cG9ydCB0eXBlIEJvdW5kYXJ5ID0gRWxlbWVudCB8IEFycmF5PEVsZW1lbnQ+IHwgdHlwZW9mIGNsaXBwaW5nUGFyZW50cztcbmV4cG9ydCB0eXBlIFJvb3RCb3VuZGFyeSA9IHR5cGVvZiB2aWV3cG9ydCB8ICdkb2N1bWVudCc7XG5cbmV4cG9ydCBjb25zdCBwb3BwZXI6ICdwb3BwZXInID0gJ3BvcHBlcic7XG5leHBvcnQgY29uc3QgcmVmZXJlbmNlOiAncmVmZXJlbmNlJyA9ICdyZWZlcmVuY2UnO1xuZXhwb3J0IHR5cGUgQ29udGV4dCA9IHR5cGVvZiBwb3BwZXIgfCB0eXBlb2YgcmVmZXJlbmNlO1xuXG5leHBvcnQgdHlwZSBWYXJpYXRpb25QbGFjZW1lbnQgPVxuICB8ICd0b3Atc3RhcnQnXG4gIHwgJ3RvcC1lbmQnXG4gIHwgJ2JvdHRvbS1zdGFydCdcbiAgfCAnYm90dG9tLWVuZCdcbiAgfCAncmlnaHQtc3RhcnQnXG4gIHwgJ3JpZ2h0LWVuZCdcbiAgfCAnbGVmdC1zdGFydCdcbiAgfCAnbGVmdC1lbmQnO1xuZXhwb3J0IHR5cGUgQXV0b1BsYWNlbWVudCA9ICdhdXRvJyB8ICdhdXRvLXN0YXJ0JyB8ICdhdXRvLWVuZCc7XG5leHBvcnQgdHlwZSBDb21wdXRlZFBsYWNlbWVudCA9IFZhcmlhdGlvblBsYWNlbWVudCB8IEJhc2VQbGFjZW1lbnQ7XG5leHBvcnQgdHlwZSBQbGFjZW1lbnQgPSBBdXRvUGxhY2VtZW50IHwgQmFzZVBsYWNlbWVudCB8IFZhcmlhdGlvblBsYWNlbWVudDtcblxuZXhwb3J0IGNvbnN0IHZhcmlhdGlvblBsYWNlbWVudHM6IEFycmF5PFZhcmlhdGlvblBsYWNlbWVudD4gPSBiYXNlUGxhY2VtZW50cy5yZWR1Y2UoXG4gIChhY2M6IEFycmF5PFZhcmlhdGlvblBsYWNlbWVudD4sIHBsYWNlbWVudDogQmFzZVBsYWNlbWVudCkgPT5cbiAgICBhY2MuY29uY2F0KFsoYCR7cGxhY2VtZW50fS0ke3N0YXJ0fWA6IGFueSksIChgJHtwbGFjZW1lbnR9LSR7ZW5kfWA6IGFueSldKSxcbiAgW11cbik7XG5leHBvcnQgY29uc3QgcGxhY2VtZW50czogQXJyYXk8UGxhY2VtZW50PiA9IFsuLi5iYXNlUGxhY2VtZW50cywgYXV0b10ucmVkdWNlKFxuICAoXG4gICAgYWNjOiBBcnJheTxQbGFjZW1lbnQ+LFxuICAgIHBsYWNlbWVudDogQmFzZVBsYWNlbWVudCB8IHR5cGVvZiBhdXRvXG4gICk6IEFycmF5PFBsYWNlbWVudD4gPT5cbiAgICBhY2MuY29uY2F0KFtcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIChgJHtwbGFjZW1lbnR9LSR7c3RhcnR9YDogYW55KSxcbiAgICAgIChgJHtwbGFjZW1lbnR9LSR7ZW5kfWA6IGFueSksXG4gICAgXSksXG4gIFtdXG4pO1xuXG4vLyBtb2RpZmllcnMgdGhhdCBuZWVkIHRvIHJlYWQgdGhlIERPTVxuZXhwb3J0IGNvbnN0IGJlZm9yZVJlYWQ6ICdiZWZvcmVSZWFkJyA9ICdiZWZvcmVSZWFkJztcbmV4cG9ydCBjb25zdCByZWFkOiAncmVhZCcgPSAncmVhZCc7XG5leHBvcnQgY29uc3QgYWZ0ZXJSZWFkOiAnYWZ0ZXJSZWFkJyA9ICdhZnRlclJlYWQnO1xuLy8gcHVyZS1sb2dpYyBtb2RpZmllcnNcbmV4cG9ydCBjb25zdCBiZWZvcmVNYWluOiAnYmVmb3JlTWFpbicgPSAnYmVmb3JlTWFpbic7XG5leHBvcnQgY29uc3QgbWFpbjogJ21haW4nID0gJ21haW4nO1xuZXhwb3J0IGNvbnN0IGFmdGVyTWFpbjogJ2FmdGVyTWFpbicgPSAnYWZ0ZXJNYWluJztcbi8vIG1vZGlmaWVyIHdpdGggdGhlIHB1cnBvc2UgdG8gd3JpdGUgdG8gdGhlIERPTSAob3Igd3JpdGUgaW50byBhIGZyYW1ld29yayBzdGF0ZSlcbmV4cG9ydCBjb25zdCBiZWZvcmVXcml0ZTogJ2JlZm9yZVdyaXRlJyA9ICdiZWZvcmVXcml0ZSc7XG5leHBvcnQgY29uc3Qgd3JpdGU6ICd3cml0ZScgPSAnd3JpdGUnO1xuZXhwb3J0IGNvbnN0IGFmdGVyV3JpdGU6ICdhZnRlcldyaXRlJyA9ICdhZnRlcldyaXRlJztcbmV4cG9ydCBjb25zdCBtb2RpZmllclBoYXNlczogQXJyYXk8TW9kaWZpZXJQaGFzZXM+ID0gW1xuICBiZWZvcmVSZWFkLFxuICByZWFkLFxuICBhZnRlclJlYWQsXG4gIGJlZm9yZU1haW4sXG4gIG1haW4sXG4gIGFmdGVyTWFpbixcbiAgYmVmb3JlV3JpdGUsXG4gIHdyaXRlLFxuICBhZnRlcldyaXRlLFxuXTtcblxuZXhwb3J0IHR5cGUgTW9kaWZpZXJQaGFzZXMgPVxuICB8IHR5cGVvZiBiZWZvcmVSZWFkXG4gIHwgdHlwZW9mIHJlYWRcbiAgfCB0eXBlb2YgYWZ0ZXJSZWFkXG4gIHwgdHlwZW9mIGJlZm9yZU1haW5cbiAgfCB0eXBlb2YgbWFpblxuICB8IHR5cGVvZiBhZnRlck1haW5cbiAgfCB0eXBlb2YgYmVmb3JlV3JpdGVcbiAgfCB0eXBlb2Ygd3JpdGVcbiAgfCB0eXBlb2YgYWZ0ZXJXcml0ZTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IE1vZGlmaWVyIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgbW9kaWZpZXJQaGFzZXMgfSBmcm9tICcuLi9lbnVtcyc7XG5cbi8vIHNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk4NzUyNTVcbmZ1bmN0aW9uIG9yZGVyKG1vZGlmaWVycykge1xuICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gIG1vZGlmaWVycy5mb3JFYWNoKG1vZGlmaWVyID0+IHtcbiAgICBtYXAuc2V0KG1vZGlmaWVyLm5hbWUsIG1vZGlmaWVyKTtcbiAgfSk7XG5cbiAgLy8gT24gdmlzaXRpbmcgb2JqZWN0LCBjaGVjayBmb3IgaXRzIGRlcGVuZGVuY2llcyBhbmQgdmlzaXQgdGhlbSByZWN1cnNpdmVseVxuICBmdW5jdGlvbiBzb3J0KG1vZGlmaWVyOiBNb2RpZmllcjxhbnksIGFueT4pIHtcbiAgICB2aXNpdGVkLmFkZChtb2RpZmllci5uYW1lKTtcblxuICAgIGNvbnN0IHJlcXVpcmVzID0gW1xuICAgICAgLi4uKG1vZGlmaWVyLnJlcXVpcmVzIHx8IFtdKSxcbiAgICAgIC4uLihtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzIHx8IFtdKSxcbiAgICBdO1xuXG4gICAgcmVxdWlyZXMuZm9yRWFjaChkZXAgPT4ge1xuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhkZXApKSB7XG4gICAgICAgIGNvbnN0IGRlcE1vZGlmaWVyID0gbWFwLmdldChkZXApO1xuXG4gICAgICAgIGlmIChkZXBNb2RpZmllcikge1xuICAgICAgICAgIHNvcnQoZGVwTW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXN1bHQucHVzaChtb2RpZmllcik7XG4gIH1cblxuICBtb2RpZmllcnMuZm9yRWFjaChtb2RpZmllciA9PiB7XG4gICAgaWYgKCF2aXNpdGVkLmhhcyhtb2RpZmllci5uYW1lKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIHZpc2l0ZWQgb2JqZWN0XG4gICAgICBzb3J0KG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG9yZGVyTW9kaWZpZXJzKFxuICBtb2RpZmllcnM6IEFycmF5PE1vZGlmaWVyPGFueSwgYW55Pj5cbik6IEFycmF5PE1vZGlmaWVyPGFueSwgYW55Pj4ge1xuICAvLyBvcmRlciBiYXNlZCBvbiBkZXBlbmRlbmNpZXNcbiAgY29uc3Qgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyKG1vZGlmaWVycyk7XG5cbiAgLy8gb3JkZXIgYmFzZWQgb24gcGhhc2VcbiAgcmV0dXJuIG1vZGlmaWVyUGhhc2VzLnJlZHVjZSgoYWNjLCBwaGFzZSkgPT4ge1xuICAgIHJldHVybiBhY2MuY29uY2F0KFxuICAgICAgb3JkZXJlZE1vZGlmaWVycy5maWx0ZXIobW9kaWZpZXIgPT4gbW9kaWZpZXIucGhhc2UgPT09IHBoYXNlKVxuICAgICk7XG4gIH0sIFtdKTtcbn1cbiIsIi8vIEBmbG93XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlYm91bmNlPFQ+KGZuOiBGdW5jdGlvbik6ICgpID0+IFByb21pc2U8VD4ge1xuICBsZXQgcGVuZGluZztcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSBuZXcgUHJvbWlzZTxUPihyZXNvbHZlID0+IHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKGZuKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9O1xufVxuIiwiLy8gQGZsb3dcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9ybWF0KHN0cjogc3RyaW5nLCAuLi5hcmdzOiBBcnJheTxzdHJpbmc+KSB7XG4gIHJldHVybiBbLi4uYXJnc10ucmVkdWNlKChwLCBjKSA9PiBwLnJlcGxhY2UoLyVzLywgYyksIHN0cik7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IGZvcm1hdCBmcm9tICcuL2Zvcm1hdCc7XG5pbXBvcnQgeyBtb2RpZmllclBoYXNlcyB9IGZyb20gJy4uL2VudW1zJztcblxuY29uc3QgSU5WQUxJRF9NT0RJRklFUl9FUlJPUiA9XG4gICdQb3BwZXI6IG1vZGlmaWVyIFwiJXNcIiBwcm92aWRlZCBhbiBpbnZhbGlkICVzIHByb3BlcnR5LCBleHBlY3RlZCAlcyBidXQgZ290ICVzJztcbmNvbnN0IE1JU1NJTkdfREVQRU5ERU5DWV9FUlJPUiA9XG4gICdQb3BwZXI6IG1vZGlmaWVyIFwiJXNcIiByZXF1aXJlcyBcIiVzXCIsIGJ1dCBcIiVzXCIgbW9kaWZpZXIgaXMgbm90IGF2YWlsYWJsZSc7XG5jb25zdCBWQUxJRF9QUk9QRVJUSUVTID0gW1xuICAnbmFtZScsXG4gICdlbmFibGVkJyxcbiAgJ3BoYXNlJyxcbiAgJ2ZuJyxcbiAgJ2VmZmVjdCcsXG4gICdyZXF1aXJlcycsXG4gICdvcHRpb25zJyxcbl07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZhbGlkYXRlTW9kaWZpZXJzKG1vZGlmaWVyczogQXJyYXk8YW55Pik6IHZvaWQge1xuICBtb2RpZmllcnMuZm9yRWFjaCgobW9kaWZpZXIpID0+IHtcbiAgICBbLi4uT2JqZWN0LmtleXMobW9kaWZpZXIpLCAuLi5WQUxJRF9QUk9QRVJUSUVTXVxuICAgICAgLy8gSUUxMS1jb21wYXRpYmxlIHJlcGxhY2VtZW50IGZvciBgbmV3IFNldChpdGVyYWJsZSlgXG4gICAgICAuZmlsdGVyKCh2YWx1ZSwgaW5kZXgsIHNlbGYpID0+IHNlbGYuaW5kZXhPZih2YWx1ZSkgPT09IGluZGV4KVxuICAgICAgLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllci5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIGZvcm1hdChcbiAgICAgICAgICAgICAgICAgIElOVkFMSURfTU9ESUZJRVJfRVJST1IsXG4gICAgICAgICAgICAgICAgICBTdHJpbmcobW9kaWZpZXIubmFtZSksXG4gICAgICAgICAgICAgICAgICAnXCJuYW1lXCInLFxuICAgICAgICAgICAgICAgICAgJ1wic3RyaW5nXCInLFxuICAgICAgICAgICAgICAgICAgYFwiJHtTdHJpbmcobW9kaWZpZXIubmFtZSl9XCJgXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZW5hYmxlZCc6XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWVyLmVuYWJsZWQgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIGZvcm1hdChcbiAgICAgICAgICAgICAgICAgIElOVkFMSURfTU9ESUZJRVJfRVJST1IsXG4gICAgICAgICAgICAgICAgICBtb2RpZmllci5uYW1lLFxuICAgICAgICAgICAgICAgICAgJ1wiZW5hYmxlZFwiJyxcbiAgICAgICAgICAgICAgICAgICdcImJvb2xlYW5cIicsXG4gICAgICAgICAgICAgICAgICBgXCIke1N0cmluZyhtb2RpZmllci5lbmFibGVkKX1cImBcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdwaGFzZSc6XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJQaGFzZXMuaW5kZXhPZihtb2RpZmllci5waGFzZSkgPCAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgZm9ybWF0KFxuICAgICAgICAgICAgICAgICAgSU5WQUxJRF9NT0RJRklFUl9FUlJPUixcbiAgICAgICAgICAgICAgICAgIG1vZGlmaWVyLm5hbWUsXG4gICAgICAgICAgICAgICAgICAnXCJwaGFzZVwiJyxcbiAgICAgICAgICAgICAgICAgIGBlaXRoZXIgJHttb2RpZmllclBoYXNlcy5qb2luKCcsICcpfWAsXG4gICAgICAgICAgICAgICAgICBgXCIke1N0cmluZyhtb2RpZmllci5waGFzZSl9XCJgXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZm4nOlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllci5mbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIGZvcm1hdChcbiAgICAgICAgICAgICAgICAgIElOVkFMSURfTU9ESUZJRVJfRVJST1IsXG4gICAgICAgICAgICAgICAgICBtb2RpZmllci5uYW1lLFxuICAgICAgICAgICAgICAgICAgJ1wiZm5cIicsXG4gICAgICAgICAgICAgICAgICAnXCJmdW5jdGlvblwiJyxcbiAgICAgICAgICAgICAgICAgIGBcIiR7U3RyaW5nKG1vZGlmaWVyLmZuKX1cImBcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdlZmZlY3QnOlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBtb2RpZmllci5lZmZlY3QgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICB0eXBlb2YgbW9kaWZpZXIuZWZmZWN0ICE9PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBmb3JtYXQoXG4gICAgICAgICAgICAgICAgICBJTlZBTElEX01PRElGSUVSX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZXIubmFtZSxcbiAgICAgICAgICAgICAgICAgICdcImVmZmVjdFwiJyxcbiAgICAgICAgICAgICAgICAgICdcImZ1bmN0aW9uXCInLFxuICAgICAgICAgICAgICAgICAgYFwiJHtTdHJpbmcobW9kaWZpZXIuZm4pfVwiYFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3JlcXVpcmVzJzpcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbW9kaWZpZXIucmVxdWlyZXMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShtb2RpZmllci5yZXF1aXJlcylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIGZvcm1hdChcbiAgICAgICAgICAgICAgICAgIElOVkFMSURfTU9ESUZJRVJfRVJST1IsXG4gICAgICAgICAgICAgICAgICBtb2RpZmllci5uYW1lLFxuICAgICAgICAgICAgICAgICAgJ1wicmVxdWlyZXNcIicsXG4gICAgICAgICAgICAgICAgICAnXCJhcnJheVwiJyxcbiAgICAgICAgICAgICAgICAgIGBcIiR7U3RyaW5nKG1vZGlmaWVyLnJlcXVpcmVzKX1cImBcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyZXF1aXJlc0lmRXhpc3RzJzpcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIGZvcm1hdChcbiAgICAgICAgICAgICAgICAgIElOVkFMSURfTU9ESUZJRVJfRVJST1IsXG4gICAgICAgICAgICAgICAgICBtb2RpZmllci5uYW1lLFxuICAgICAgICAgICAgICAgICAgJ1wicmVxdWlyZXNJZkV4aXN0c1wiJyxcbiAgICAgICAgICAgICAgICAgICdcImFycmF5XCInLFxuICAgICAgICAgICAgICAgICAgYFwiJHtTdHJpbmcobW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cyl9XCJgXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnb3B0aW9ucyc6XG4gICAgICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgYFBvcHBlckpTOiBhbiBpbnZhbGlkIHByb3BlcnR5IGhhcyBiZWVuIHByb3ZpZGVkIHRvIHRoZSBcIiR7XG4gICAgICAgICAgICAgICAgbW9kaWZpZXIubmFtZVxuICAgICAgICAgICAgICB9XCIgbW9kaWZpZXIsIHZhbGlkIHByb3BlcnRpZXMgYXJlICR7VkFMSURfUFJPUEVSVElFUy5tYXAoXG4gICAgICAgICAgICAgICAgKHMpID0+IGBcIiR7c31cImBcbiAgICAgICAgICAgICAgKS5qb2luKCcsICcpfTsgYnV0IFwiJHtrZXl9XCIgd2FzIHByb3ZpZGVkLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBtb2RpZmllci5yZXF1aXJlcyAmJlxuICAgICAgICAgIG1vZGlmaWVyLnJlcXVpcmVzLmZvckVhY2goKHJlcXVpcmVtZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzLmZpbmQoKG1vZCkgPT4gbW9kLm5hbWUgPT09IHJlcXVpcmVtZW50KSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgZm9ybWF0KFxuICAgICAgICAgICAgICAgICAgTUlTU0lOR19ERVBFTkRFTkNZX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgU3RyaW5nKG1vZGlmaWVyLm5hbWUpLFxuICAgICAgICAgICAgICAgICAgcmVxdWlyZW1lbnQsXG4gICAgICAgICAgICAgICAgICByZXF1aXJlbWVudFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICB9KTtcbn1cbiIsIi8vIEBmbG93XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVuaXF1ZUJ5PFQ+KGFycjogQXJyYXk8VD4sIGZuOiBUID0+IGFueSk6IEFycmF5PFQ+IHtcbiAgY29uc3QgaWRlbnRpZmllcnMgPSBuZXcgU2V0KCk7XG5cbiAgcmV0dXJuIGFyci5maWx0ZXIoaXRlbSA9PiB7XG4gICAgY29uc3QgaWRlbnRpZmllciA9IGZuKGl0ZW0pO1xuXG4gICAgaWYgKCFpZGVudGlmaWVycy5oYXMoaWRlbnRpZmllcikpIHtcbiAgICAgIGlkZW50aWZpZXJzLmFkZChpZGVudGlmaWVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHsgdHlwZSBCYXNlUGxhY2VtZW50LCB0eXBlIFBsYWNlbWVudCwgYXV0byB9IGZyb20gJy4uL2VudW1zJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChcbiAgcGxhY2VtZW50OiBQbGFjZW1lbnQgfCB0eXBlb2YgYXV0b1xuKTogQmFzZVBsYWNlbWVudCB7XG4gIHJldHVybiAocGxhY2VtZW50LnNwbGl0KCctJylbMF06IGFueSk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBNb2RpZmllciB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VCeU5hbWUoXG4gIG1vZGlmaWVyczogQXJyYXk8JFNoYXBlPE1vZGlmaWVyPGFueSwgYW55Pj4+XG4pOiBBcnJheTwkU2hhcGU8TW9kaWZpZXI8YW55LCBhbnk+Pj4ge1xuICBjb25zdCBtZXJnZWQgPSBtb2RpZmllcnMucmVkdWNlKChtZXJnZWQsIGN1cnJlbnQpID0+IHtcbiAgICBjb25zdCBleGlzdGluZyA9IG1lcmdlZFtjdXJyZW50Lm5hbWVdO1xuICAgIG1lcmdlZFtjdXJyZW50Lm5hbWVdID0gZXhpc3RpbmdcbiAgICAgID8ge1xuICAgICAgICAgIC4uLmV4aXN0aW5nLFxuICAgICAgICAgIC4uLmN1cnJlbnQsXG4gICAgICAgICAgb3B0aW9uczogeyAuLi5leGlzdGluZy5vcHRpb25zLCAuLi5jdXJyZW50Lm9wdGlvbnMgfSxcbiAgICAgICAgICBkYXRhOiB7IC4uLmV4aXN0aW5nLmRhdGEsIC4uLmN1cnJlbnQuZGF0YSB9LFxuICAgICAgICB9XG4gICAgICA6IGN1cnJlbnQ7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfSwge30pO1xuXG4gIC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZXJnZWQpLm1hcChrZXkgPT4gbWVyZ2VkW2tleV0pO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSAnLi9nZXRXaW5kb3cnO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tICcuL2dldERvY3VtZW50RWxlbWVudCc7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tICcuL2dldFdpbmRvd1Njcm9sbEJhclgnO1xuaW1wb3J0IGlzTGF5b3V0Vmlld3BvcnQgZnJvbSAnLi9pc0xheW91dFZpZXdwb3J0JztcbmltcG9ydCB0eXBlIHsgUG9zaXRpb25pbmdTdHJhdGVneSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KFxuICBlbGVtZW50OiBFbGVtZW50LFxuICBzdHJhdGVneTogUG9zaXRpb25pbmdTdHJhdGVneVxuKSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgY29uc3QgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG5cbiAgbGV0IHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgbGV0IGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcblxuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcblxuICAgIGNvbnN0IGxheW91dFZpZXdwb3J0ID0gaXNMYXlvdXRWaWV3cG9ydCgpO1xuXG4gICAgaWYgKGxheW91dFZpZXdwb3J0IHx8ICghbGF5b3V0Vmlld3BvcnQgJiYgc3RyYXRlZ3kgPT09ICdmaXhlZCcpKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeDogeCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCksXG4gICAgeSxcbiAgfTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IFJlY3QgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gJy4vZ2V0RG9jdW1lbnRFbGVtZW50JztcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gJy4vZ2V0Q29tcHV0ZWRTdHlsZSc7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tICcuL2dldFdpbmRvd1Njcm9sbEJhclgnO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tICcuL2dldFdpbmRvd1Njcm9sbCc7XG5pbXBvcnQgeyBtYXggfSBmcm9tICcuLi91dGlscy9tYXRoJztcblxuLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogUmVjdCB7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHdpblNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbChlbGVtZW50KTtcbiAgY29uc3QgYm9keSA9IGVsZW1lbnQub3duZXJEb2N1bWVudD8uYm9keTtcblxuICBjb25zdCB3aWR0aCA9IG1heChcbiAgICBodG1sLnNjcm9sbFdpZHRoLFxuICAgIGh0bWwuY2xpZW50V2lkdGgsXG4gICAgYm9keSA/IGJvZHkuc2Nyb2xsV2lkdGggOiAwLFxuICAgIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMFxuICApO1xuICBjb25zdCBoZWlnaHQgPSBtYXgoXG4gICAgaHRtbC5zY3JvbGxIZWlnaHQsXG4gICAgaHRtbC5jbGllbnRIZWlnaHQsXG4gICAgYm9keSA/IGJvZHkuc2Nyb2xsSGVpZ2h0IDogMCxcbiAgICBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwXG4gICk7XG5cbiAgbGV0IHggPSAtd2luU2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICBjb25zdCB5ID0gLXdpblNjcm9sbC5zY3JvbGxUb3A7XG5cbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCwgeCwgeSB9O1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB7IGlzU2hhZG93Um9vdCB9IGZyb20gJy4vaW5zdGFuY2VPZic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudDogRWxlbWVudCwgY2hpbGQ6IEVsZW1lbnQpIHtcbiAgY29uc3Qgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpO1xuXG4gIC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgbGV0IG5leHQgPSBjaGlsZDtcbiAgICBkbyB7XG4gICAgICBpZiAobmV4dCAmJiBwYXJlbnQuaXNTYW1lTm9kZShuZXh0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cbiAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgIH0gd2hpbGUgKG5leHQpO1xuICB9XG5cbiAgLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBSZWN0LCBDbGllbnRSZWN0T2JqZWN0IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3Q6IFJlY3QpOiBDbGllbnRSZWN0T2JqZWN0IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5yZWN0LFxuICAgIGxlZnQ6IHJlY3QueCxcbiAgICB0b3A6IHJlY3QueSxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0LFxuICB9O1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgQ2xpZW50UmVjdE9iamVjdCwgUG9zaXRpb25pbmdTdHJhdGVneSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB0eXBlIHsgQm91bmRhcnksIFJvb3RCb3VuZGFyeSB9IGZyb20gJy4uL2VudW1zJztcbmltcG9ydCB7IHZpZXdwb3J0IH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IGdldFZpZXdwb3J0UmVjdCBmcm9tICcuL2dldFZpZXdwb3J0UmVjdCc7XG5pbXBvcnQgZ2V0RG9jdW1lbnRSZWN0IGZyb20gJy4vZ2V0RG9jdW1lbnRSZWN0JztcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tICcuL2xpc3RTY3JvbGxQYXJlbnRzJztcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSAnLi9nZXRPZmZzZXRQYXJlbnQnO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tICcuL2dldERvY3VtZW50RWxlbWVudCc7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tICcuL2dldENvbXB1dGVkU3R5bGUnO1xuaW1wb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50IH0gZnJvbSAnLi9pbnN0YW5jZU9mJztcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSAnLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QnO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSAnLi9nZXRQYXJlbnROb2RlJztcbmltcG9ydCBjb250YWlucyBmcm9tICcuL2NvbnRhaW5zJztcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tICcuL2dldE5vZGVOYW1lJztcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gJy4uL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QnO1xuaW1wb3J0IHsgbWF4LCBtaW4gfSBmcm9tICcuLi91dGlscy9tYXRoJztcblxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoXG4gIGVsZW1lbnQ6IEVsZW1lbnQsXG4gIHN0cmF0ZWd5OiBQb3NpdGlvbmluZ1N0cmF0ZWd5XG4pIHtcbiAgY29uc3QgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBmYWxzZSwgc3RyYXRlZ3kgPT09ICdmaXhlZCcpO1xuXG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcblxuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoXG4gIGVsZW1lbnQ6IEVsZW1lbnQsXG4gIGNsaXBwaW5nUGFyZW50OiBFbGVtZW50IHwgUm9vdEJvdW5kYXJ5LFxuICBzdHJhdGVneTogUG9zaXRpb25pbmdTdHJhdGVneVxuKTogQ2xpZW50UmVjdE9iamVjdCB7XG4gIHJldHVybiBjbGlwcGluZ1BhcmVudCA9PT0gdmlld3BvcnRcbiAgICA/IHJlY3RUb0NsaWVudFJlY3QoZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSlcbiAgICA6IGlzRWxlbWVudChjbGlwcGluZ1BhcmVudClcbiAgICA/IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSlcbiAgICA6IHJlY3RUb0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkpO1xufVxuXG4vLyBBIFwiY2xpcHBpbmcgcGFyZW50XCIgaXMgYW4gb3ZlcmZsb3dhYmxlIGNvbnRhaW5lciB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgb3ZlcmZsb3dpbmcgZWxlbWVudHMgd2l0aCBhIHBvc2l0aW9uIGRpZmZlcmVudCBmcm9tXG4vLyBgaW5pdGlhbGBcbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50OiBFbGVtZW50KTogQXJyYXk8RWxlbWVudD4ge1xuICBjb25zdCBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgY29uc3QgY2FuRXNjYXBlQ2xpcHBpbmcgPVxuICAgIFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24pID49IDA7XG4gIGNvbnN0IGNsaXBwZXJFbGVtZW50ID1cbiAgICBjYW5Fc2NhcGVDbGlwcGluZyAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpXG4gICAgICA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KVxuICAgICAgOiBlbGVtZW50O1xuXG4gIGlmICghaXNFbGVtZW50KGNsaXBwZXJFbGVtZW50KSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG4gIHJldHVybiBjbGlwcGluZ1BhcmVudHMuZmlsdGVyKFxuICAgIChjbGlwcGluZ1BhcmVudCkgPT5cbiAgICAgIGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgJiZcbiAgICAgIGNvbnRhaW5zKGNsaXBwaW5nUGFyZW50LCBjbGlwcGVyRWxlbWVudCkgJiZcbiAgICAgIGdldE5vZGVOYW1lKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknXG4gICk7XG59XG5cbi8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2Zcbi8vIGNsaXBwaW5nIHBhcmVudHNcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChcbiAgZWxlbWVudDogRWxlbWVudCxcbiAgYm91bmRhcnk6IEJvdW5kYXJ5LFxuICByb290Qm91bmRhcnk6IFJvb3RCb3VuZGFyeSxcbiAgc3RyYXRlZ3k6IFBvc2l0aW9uaW5nU3RyYXRlZ3lcbik6IENsaWVudFJlY3RPYmplY3Qge1xuICBjb25zdCBtYWluQ2xpcHBpbmdQYXJlbnRzID1cbiAgICBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nUGFyZW50cydcbiAgICAgID8gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpXG4gICAgICA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIGNvbnN0IGNsaXBwaW5nUGFyZW50cyA9IFsuLi5tYWluQ2xpcHBpbmdQYXJlbnRzLCByb290Qm91bmRhcnldO1xuICBjb25zdCBmaXJzdENsaXBwaW5nUGFyZW50ID0gY2xpcHBpbmdQYXJlbnRzWzBdO1xuXG4gIGNvbnN0IGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSA9PiB7XG4gICAgY29uc3QgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSk7XG5cbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuXG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSk7XG5cbiAgY2xpcHBpbmdSZWN0LndpZHRoID0gY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC5oZWlnaHQgPSBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgY2xpcHBpbmdSZWN0LnggPSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LnkgPSBjbGlwcGluZ1JlY3QudG9wO1xuXG4gIHJldHVybiBjbGlwcGluZ1JlY3Q7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHsgdHlwZSBWYXJpYXRpb24sIHR5cGUgUGxhY2VtZW50IH0gZnJvbSAnLi4vZW51bXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWYXJpYXRpb24ocGxhY2VtZW50OiBQbGFjZW1lbnQpOiA/VmFyaWF0aW9uIHtcbiAgcmV0dXJuIChwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTogYW55KTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IFBsYWNlbWVudCB9IGZyb20gJy4uL2VudW1zJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KFxuICBwbGFjZW1lbnQ6IFBsYWNlbWVudFxuKTogJ3gnIHwgJ3knIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSA+PSAwID8gJ3gnIDogJ3knO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gJy4vZ2V0QmFzZVBsYWNlbWVudCc7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gJy4vZ2V0VmFyaWF0aW9uJztcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSAnLi9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQnO1xuaW1wb3J0IHR5cGUge1xuICBSZWN0LFxuICBQb3NpdGlvbmluZ1N0cmF0ZWd5LFxuICBPZmZzZXRzLFxuICBDbGllbnRSZWN0T2JqZWN0LFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHN0YXJ0LCBlbmQsIHR5cGUgUGxhY2VtZW50IH0gZnJvbSAnLi4vZW51bXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyh7XG4gIHJlZmVyZW5jZSxcbiAgZWxlbWVudCxcbiAgcGxhY2VtZW50LFxufToge1xuICByZWZlcmVuY2U6IFJlY3QgfCBDbGllbnRSZWN0T2JqZWN0LFxuICBlbGVtZW50OiBSZWN0IHwgQ2xpZW50UmVjdE9iamVjdCxcbiAgc3RyYXRlZ3k6IFBvc2l0aW9uaW5nU3RyYXRlZ3ksXG4gIHBsYWNlbWVudD86IFBsYWNlbWVudCxcbn0pOiBPZmZzZXRzIHtcbiAgY29uc3QgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudCA/IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA6IG51bGw7XG4gIGNvbnN0IHZhcmlhdGlvbiA9IHBsYWNlbWVudCA/IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIDogbnVsbDtcbiAgY29uc3QgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICBjb25zdCBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGVsZW1lbnQuaGVpZ2h0IC8gMjtcblxuICBsZXQgb2Zmc2V0cztcbiAgc3dpdGNoIChiYXNlUGxhY2VtZW50KSB7XG4gICAgY2FzZSB0b3A6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGVsZW1lbnQuaGVpZ2h0LFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYm90dG9tOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0LFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWSxcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIGxlZnQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGVsZW1lbnQud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vblksXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54LFxuICAgICAgICB5OiByZWZlcmVuY2UueSxcbiAgICAgIH07XG4gIH1cblxuICBjb25zdCBtYWluQXhpcyA9IGJhc2VQbGFjZW1lbnRcbiAgICA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KVxuICAgIDogbnVsbDtcblxuICBpZiAobWFpbkF4aXMgIT0gbnVsbCkge1xuICAgIGNvbnN0IGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICBzd2l0Y2ggKHZhcmlhdGlvbikge1xuICAgICAgY2FzZSBzdGFydDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPVxuICAgICAgICAgIG9mZnNldHNbbWFpbkF4aXNdIC0gKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZW5kOlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9XG4gICAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IFNpZGVPYmplY3QgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEZyZXNoU2lkZU9iamVjdCgpOiBTaWRlT2JqZWN0IHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDAsXG4gIH07XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBTaWRlT2JqZWN0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tICcuL2dldEZyZXNoU2lkZU9iamVjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChcbiAgcGFkZGluZ09iamVjdDogJFNoYXBlPFNpZGVPYmplY3Q+XG4pOiBTaWRlT2JqZWN0IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5nZXRGcmVzaFNpZGVPYmplY3QoKSxcbiAgICAuLi5wYWRkaW5nT2JqZWN0LFxuICB9O1xufVxuIiwiLy8gQGZsb3dcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwPFxuICBUOiBudW1iZXIgfCBzdHJpbmcgfCBib29sZWFuLFxuICBLOiBzdHJpbmdcbj4odmFsdWU6IFQsIGtleXM6IEFycmF5PEs+KTogeyBba2V5OiBzdHJpbmddOiBUIH0ge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoKGhhc2hNYXAsIGtleSkgPT4ge1xuICAgIGhhc2hNYXBba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBoYXNoTWFwO1xuICB9LCB7fSk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBTdGF0ZSwgU2lkZU9iamVjdCwgUGFkZGluZywgUG9zaXRpb25pbmdTdHJhdGVneSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB0eXBlIHsgUGxhY2VtZW50LCBCb3VuZGFyeSwgUm9vdEJvdW5kYXJ5LCBDb250ZXh0IH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IGdldENsaXBwaW5nUmVjdCBmcm9tICcuLi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0JztcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSAnLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudCc7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gJy4uL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QnO1xuaW1wb3J0IGNvbXB1dGVPZmZzZXRzIGZyb20gJy4vY29tcHV0ZU9mZnNldHMnO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSAnLi9yZWN0VG9DbGllbnRSZWN0JztcbmltcG9ydCB7XG4gIGNsaXBwaW5nUGFyZW50cyxcbiAgcmVmZXJlbmNlLFxuICBwb3BwZXIsXG4gIGJvdHRvbSxcbiAgdG9wLFxuICByaWdodCxcbiAgYmFzZVBsYWNlbWVudHMsXG4gIHZpZXdwb3J0LFxufSBmcm9tICcuLi9lbnVtcyc7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tICcuLi9kb20tdXRpbHMvaW5zdGFuY2VPZic7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gJy4vbWVyZ2VQYWRkaW5nT2JqZWN0JztcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSAnLi9leHBhbmRUb0hhc2hNYXAnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBPcHRpb25zID0ge1xuICBwbGFjZW1lbnQ6IFBsYWNlbWVudCxcbiAgc3RyYXRlZ3k6IFBvc2l0aW9uaW5nU3RyYXRlZ3ksXG4gIGJvdW5kYXJ5OiBCb3VuZGFyeSxcbiAgcm9vdEJvdW5kYXJ5OiBSb290Qm91bmRhcnksXG4gIGVsZW1lbnRDb250ZXh0OiBDb250ZXh0LFxuICBhbHRCb3VuZGFyeTogYm9vbGVhbixcbiAgcGFkZGluZzogUGFkZGluZyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KFxuICBzdGF0ZTogU3RhdGUsXG4gIG9wdGlvbnM6ICRTaGFwZTxPcHRpb25zPiA9IHt9XG4pOiBTaWRlT2JqZWN0IHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCA9IHN0YXRlLnBsYWNlbWVudCxcbiAgICBzdHJhdGVneSA9IHN0YXRlLnN0cmF0ZWd5LFxuICAgIGJvdW5kYXJ5ID0gY2xpcHBpbmdQYXJlbnRzLFxuICAgIHJvb3RCb3VuZGFyeSA9IHZpZXdwb3J0LFxuICAgIGVsZW1lbnRDb250ZXh0ID0gcG9wcGVyLFxuICAgIGFsdEJvdW5kYXJ5ID0gZmFsc2UsXG4gICAgcGFkZGluZyA9IDAsXG4gIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBtZXJnZVBhZGRpbmdPYmplY3QoXG4gICAgdHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInXG4gICAgICA/IHBhZGRpbmdcbiAgICAgIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKVxuICApO1xuXG4gIGNvbnN0IGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcmVmZXJlbmNlIDogcG9wcGVyO1xuXG4gIGNvbnN0IHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIGNvbnN0IGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG5cbiAgY29uc3QgY2xpcHBpbmdDbGllbnRSZWN0ID0gZ2V0Q2xpcHBpbmdSZWN0KFxuICAgIGlzRWxlbWVudChlbGVtZW50KVxuICAgICAgPyBlbGVtZW50XG4gICAgICA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgZ2V0RG9jdW1lbnRFbGVtZW50KHN0YXRlLmVsZW1lbnRzLnBvcHBlciksXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHN0cmF0ZWd5XG4gICk7XG5cbiAgY29uc3QgcmVmZXJlbmNlQ2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChzdGF0ZS5lbGVtZW50cy5yZWZlcmVuY2UpO1xuXG4gIGNvbnN0IHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50LFxuICB9KTtcblxuICBjb25zdCBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdCh7XG4gICAgLi4ucG9wcGVyUmVjdCxcbiAgICAuLi5wb3BwZXJPZmZzZXRzLFxuICB9KTtcblxuICBjb25zdCBlbGVtZW50Q2xpZW50UmVjdCA9XG4gICAgZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHBvcHBlckNsaWVudFJlY3QgOiByZWZlcmVuY2VDbGllbnRSZWN0O1xuXG4gIC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcbiAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxuICBjb25zdCBvdmVyZmxvd09mZnNldHMgPSB7XG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgYm90dG9tOlxuICAgICAgZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC1cbiAgICAgIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gK1xuICAgICAgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxuICAgIHJpZ2h0OlxuICAgICAgZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0LFxuICB9O1xuXG4gIGNvbnN0IG9mZnNldERhdGEgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDtcblxuICAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XG4gIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcbiAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XG5cbiAgICBPYmplY3Qua2V5cyhvdmVyZmxvd09mZnNldHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XG4gICAgICBjb25zdCBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcbiAgICAgIG92ZXJmbG93T2Zmc2V0c1trZXldICs9IG9mZnNldFtheGlzXSAqIG11bHRpcGx5O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7XG4gIFN0YXRlLFxuICBPcHRpb25zR2VuZXJpYyxcbiAgTW9kaWZpZXIsXG4gIEluc3RhbmNlLFxuICBWaXJ0dWFsRWxlbWVudCxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgZ2V0Q29tcG9zaXRlUmVjdCBmcm9tICcuL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0JztcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gJy4vZG9tLXV0aWxzL2dldExheW91dFJlY3QnO1xuaW1wb3J0IGxpc3RTY3JvbGxQYXJlbnRzIGZyb20gJy4vZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzJztcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSAnLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50JztcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gJy4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUnO1xuaW1wb3J0IG9yZGVyTW9kaWZpZXJzIGZyb20gJy4vdXRpbHMvb3JkZXJNb2RpZmllcnMnO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJy4vdXRpbHMvZGVib3VuY2UnO1xuaW1wb3J0IHZhbGlkYXRlTW9kaWZpZXJzIGZyb20gJy4vdXRpbHMvdmFsaWRhdGVNb2RpZmllcnMnO1xuaW1wb3J0IHVuaXF1ZUJ5IGZyb20gJy4vdXRpbHMvdW5pcXVlQnknO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSAnLi91dGlscy9nZXRCYXNlUGxhY2VtZW50JztcbmltcG9ydCBtZXJnZUJ5TmFtZSBmcm9tICcuL3V0aWxzL21lcmdlQnlOYW1lJztcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tICcuL3V0aWxzL2RldGVjdE92ZXJmbG93JztcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gJy4vZG9tLXV0aWxzL2luc3RhbmNlT2YnO1xuaW1wb3J0IHsgYXV0byB9IGZyb20gJy4vZW51bXMnO1xuXG5jb25zdCBJTlZBTElEX0VMRU1FTlRfRVJST1IgPVxuICAnUG9wcGVyOiBJbnZhbGlkIHJlZmVyZW5jZSBvciBwb3BwZXIgYXJndW1lbnQgcHJvdmlkZWQuIFRoZXkgbXVzdCBiZSBlaXRoZXIgYSBET00gZWxlbWVudCBvciB2aXJ0dWFsIGVsZW1lbnQuJztcbmNvbnN0IElORklOSVRFX0xPT1BfRVJST1IgPVxuICAnUG9wcGVyOiBBbiBpbmZpbml0ZSBsb29wIGluIHRoZSBtb2RpZmllcnMgY3ljbGUgaGFzIGJlZW4gZGV0ZWN0ZWQhIFRoZSBjeWNsZSBoYXMgYmVlbiBpbnRlcnJ1cHRlZCB0byBwcmV2ZW50IGEgYnJvd3NlciBjcmFzaC4nO1xuXG5jb25zdCBERUZBVUxUX09QVElPTlM6IE9wdGlvbnNHZW5lcmljPGFueT4gPSB7XG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxufTtcblxudHlwZSBQb3BwZXJHZW5lcmF0b3JBcmdzID0ge1xuICBkZWZhdWx0TW9kaWZpZXJzPzogQXJyYXk8TW9kaWZpZXI8YW55LCBhbnk+PixcbiAgZGVmYXVsdE9wdGlvbnM/OiAkU2hhcGU8T3B0aW9uc0dlbmVyaWM8YW55Pj4sXG59O1xuXG5mdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKC4uLmFyZ3M6IEFycmF5PGFueT4pOiBib29sZWFuIHtcbiAgcmV0dXJuICFhcmdzLnNvbWUoXG4gICAgKGVsZW1lbnQpID0+XG4gICAgICAhKGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnM6IFBvcHBlckdlbmVyYXRvckFyZ3MgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZGVmYXVsdE1vZGlmaWVycyA9IFtdLFxuICAgIGRlZmF1bHRPcHRpb25zID0gREVGQVVMVF9PUFRJT05TLFxuICB9ID0gZ2VuZXJhdG9yT3B0aW9ucztcblxuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUG9wcGVyPFRNb2RpZmllcjogJFNoYXBlPE1vZGlmaWVyPGFueSwgYW55Pj4+KFxuICAgIHJlZmVyZW5jZTogRWxlbWVudCB8IFZpcnR1YWxFbGVtZW50LFxuICAgIHBvcHBlcjogSFRNTEVsZW1lbnQsXG4gICAgb3B0aW9uczogJFNoYXBlPE9wdGlvbnNHZW5lcmljPFRNb2RpZmllcj4+ID0gZGVmYXVsdE9wdGlvbnNcbiAgKTogSW5zdGFuY2Uge1xuICAgIGxldCBzdGF0ZTogJFNoYXBlPFN0YXRlPiA9IHtcbiAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgIG9wdGlvbnM6IHsgLi4uREVGQVVMVF9PUFRJT05TLCAuLi5kZWZhdWx0T3B0aW9ucyB9LFxuICAgICAgbW9kaWZpZXJzRGF0YToge30sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlcixcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHN0eWxlczoge30sXG4gICAgfTtcblxuICAgIGxldCBlZmZlY3RDbGVhbnVwRm5zOiBBcnJheTwoKSA9PiB2b2lkPiA9IFtdO1xuICAgIGxldCBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgaW5zdGFuY2UgPSB7XG4gICAgICBzdGF0ZSxcbiAgICAgIHNldE9wdGlvbnMoc2V0T3B0aW9uc0FjdGlvbikge1xuICAgICAgICBjb25zdCBvcHRpb25zID1cbiAgICAgICAgICB0eXBlb2Ygc2V0T3B0aW9uc0FjdGlvbiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBzZXRPcHRpb25zQWN0aW9uKHN0YXRlLm9wdGlvbnMpXG4gICAgICAgICAgICA6IHNldE9wdGlvbnNBY3Rpb247XG5cbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuXG4gICAgICAgIHN0YXRlLm9wdGlvbnMgPSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVtleHBvbmVudGlhbC1zcHJlYWRdXG4gICAgICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAgICAgLi4uc3RhdGUub3B0aW9ucyxcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9O1xuXG4gICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBpc0VsZW1lbnQocmVmZXJlbmNlKVxuICAgICAgICAgICAgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UpXG4gICAgICAgICAgICA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudFxuICAgICAgICAgICAgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpXG4gICAgICAgICAgICA6IFtdLFxuICAgICAgICAgIHBvcHBlcjogbGlzdFNjcm9sbFBhcmVudHMocG9wcGVyKSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBPcmRlcnMgdGhlIG1vZGlmaWVycyBiYXNlZCBvbiB0aGVpciBkZXBlbmRlbmNpZXMgYW5kIGBwaGFzZWBcbiAgICAgICAgLy8gcHJvcGVydGllc1xuICAgICAgICBjb25zdCBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJNb2RpZmllcnMoXG4gICAgICAgICAgbWVyZ2VCeU5hbWUoWy4uLmRlZmF1bHRNb2RpZmllcnMsIC4uLnN0YXRlLm9wdGlvbnMubW9kaWZpZXJzXSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBTdHJpcCBvdXQgZGlzYWJsZWQgbW9kaWZpZXJzXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcigobSkgPT4gbS5lbmFibGVkKTtcblxuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgcHJvdmlkZWQgbW9kaWZpZXJzIHNvIHRoYXQgdGhlIGNvbnN1bWVyIHdpbGwgZ2V0IHdhcm5lZFxuICAgICAgICAvLyBpZiBvbmUgb2YgdGhlIG1vZGlmaWVycyBpcyBpbnZhbGlkIGZvciBhbnkgcmVhc29uXG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgY29uc3QgbW9kaWZpZXJzID0gdW5pcXVlQnkoXG4gICAgICAgICAgICBbLi4ub3JkZXJlZE1vZGlmaWVycywgLi4uc3RhdGUub3B0aW9ucy5tb2RpZmllcnNdLFxuICAgICAgICAgICAgKHsgbmFtZSB9KSA9PiBuYW1lXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHZhbGlkYXRlTW9kaWZpZXJzKG1vZGlmaWVycyk7XG5cbiAgICAgICAgICBpZiAoZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5vcHRpb25zLnBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICAgICAgICAgIGNvbnN0IGZsaXBNb2RpZmllciA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZmluZChcbiAgICAgICAgICAgICAgKHsgbmFtZSB9KSA9PiBuYW1lID09PSAnZmxpcCdcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmICghZmxpcE1vZGlmaWVyKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgJ1BvcHBlcjogXCJhdXRvXCIgcGxhY2VtZW50cyByZXF1aXJlIHRoZSBcImZsaXBcIiBtb2RpZmllciBiZScsXG4gICAgICAgICAgICAgICAgICAncHJlc2VudCBhbmQgZW5hYmxlZCB0byB3b3JrLicsXG4gICAgICAgICAgICAgICAgXS5qb2luKCcgJylcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBtYXJnaW5Ub3AsXG4gICAgICAgICAgICBtYXJnaW5SaWdodCxcbiAgICAgICAgICAgIG1hcmdpbkJvdHRvbSxcbiAgICAgICAgICAgIG1hcmdpbkxlZnQsXG4gICAgICAgICAgfSA9IGdldENvbXB1dGVkU3R5bGUocG9wcGVyKTtcblxuICAgICAgICAgIC8vIFdlIG5vIGxvbmdlciB0YWtlIGludG8gYWNjb3VudCBgbWFyZ2luc2Agb24gdGhlIHBvcHBlciwgYW5kIGl0IGNhblxuICAgICAgICAgIC8vIGNhdXNlIGJ1Z3Mgd2l0aCBwb3NpdGlvbmluZywgc28gd2UnbGwgd2FybiB0aGUgY29uc3VtZXJcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBbbWFyZ2luVG9wLCBtYXJnaW5SaWdodCwgbWFyZ2luQm90dG9tLCBtYXJnaW5MZWZ0XS5zb21lKChtYXJnaW4pID0+XG4gICAgICAgICAgICAgIHBhcnNlRmxvYXQobWFyZ2luKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ1BvcHBlcjogQ1NTIFwibWFyZ2luXCIgc3R5bGVzIGNhbm5vdCBiZSB1c2VkIHRvIGFwcGx5IHBhZGRpbmcnLFxuICAgICAgICAgICAgICAgICdiZXR3ZWVuIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgZWxlbWVudCBvciBib3VuZGFyeS4nLFxuICAgICAgICAgICAgICAgICdUbyByZXBsaWNhdGUgbWFyZ2luLCB1c2UgdGhlIGBvZmZzZXRgIG1vZGlmaWVyLCBhcyB3ZWxsIGFzJyxcbiAgICAgICAgICAgICAgICAndGhlIGBwYWRkaW5nYCBvcHRpb24gaW4gdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIGFuZCBgZmxpcGAnLFxuICAgICAgICAgICAgICAgICdtb2RpZmllcnMuJyxcbiAgICAgICAgICAgICAgXS5qb2luKCcgJylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcnVuTW9kaWZpZXJFZmZlY3RzKCk7XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgfSxcblxuICAgICAgLy8gU3luYyB1cGRhdGUg4oCTIGl0IHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkLCBldmVuIGlmIG5vdCBuZWNlc3NhcnkuIFRoaXNcbiAgICAgIC8vIGlzIHVzZWZ1bCBmb3IgbG93IGZyZXF1ZW5jeSB1cGRhdGVzIHdoZXJlIHN5bmMgYmVoYXZpb3Igc2ltcGxpZmllcyB0aGVcbiAgICAgIC8vIGxvZ2ljLlxuICAgICAgLy8gRm9yIGhpZ2ggZnJlcXVlbmN5IHVwZGF0ZXMgKGUuZy4gYHJlc2l6ZWAgYW5kIGBzY3JvbGxgIGV2ZW50cyksIGFsd2F5c1xuICAgICAgLy8gcHJlZmVyIHRoZSBhc3luYyBQb3BwZXIjdXBkYXRlIG1ldGhvZFxuICAgICAgZm9yY2VVcGRhdGUoKSB7XG4gICAgICAgIGlmIChpc0Rlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgcmVmZXJlbmNlLCBwb3BwZXIgfSA9IHN0YXRlLmVsZW1lbnRzO1xuXG4gICAgICAgIC8vIERvbid0IHByb2NlZWQgaWYgYHJlZmVyZW5jZWAgb3IgYHBvcHBlcmAgYXJlIG5vdCB2YWxpZCBlbGVtZW50c1xuICAgICAgICAvLyBhbnltb3JlXG4gICAgICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTlZBTElEX0VMRU1FTlRfRVJST1IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdG9yZSB0aGUgcmVmZXJlbmNlIGFuZCBwb3BwZXIgcmVjdHMgdG8gYmUgcmVhZCBieSBtb2RpZmllcnNcbiAgICAgICAgc3RhdGUucmVjdHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBnZXRDb21wb3NpdGVSZWN0KFxuICAgICAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICAgICAgZ2V0T2Zmc2V0UGFyZW50KHBvcHBlciksXG4gICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnXG4gICAgICAgICAgKSxcbiAgICAgICAgICBwb3BwZXI6IGdldExheW91dFJlY3QocG9wcGVyKSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXNldCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUuIFRoZVxuICAgICAgICAvLyBtb3N0IGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0aGUgYGZsaXBgIG1vZGlmaWVyIGNoYW5naW5nIHRoZVxuICAgICAgICAvLyBwbGFjZW1lbnQsIHdoaWNoIHRoZW4gbmVlZHMgdG8gcmUtcnVuIGFsbCB0aGUgbW9kaWZpZXJzLCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBsb2dpYyB3YXMgcHJldmlvdXNseSByYW4gZm9yIHRoZSBwcmV2aW91cyBwbGFjZW1lbnQgYW5kIGlzIHRoZXJlZm9yZVxuICAgICAgICAvLyBzdGFsZS9pbmNvcnJlY3RcbiAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcblxuICAgICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDtcblxuICAgICAgICAvLyBPbiBlYWNoIHVwZGF0ZSBjeWNsZSwgdGhlIGBtb2RpZmllcnNEYXRhYCBwcm9wZXJ0eSBmb3IgZWFjaCBtb2RpZmllclxuICAgICAgICAvLyBpcyBmaWxsZWQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhIHNwZWNpZmllZCBieSB0aGUgbW9kaWZpZXIuIFRoaXMgbWVhbnNcbiAgICAgICAgLy8gaXQgZG9lc24ndCBwZXJzaXN0IGFuZCBpcyBmcmVzaCBvbiBlYWNoIHVwZGF0ZS5cbiAgICAgICAgLy8gVG8gZW5zdXJlIHBlcnNpc3RlbnQgZGF0YSwgdXNlIGAke25hbWV9I3BlcnNpc3RlbnRgXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChcbiAgICAgICAgICAobW9kaWZpZXIpID0+XG4gICAgICAgICAgICAoc3RhdGUubW9kaWZpZXJzRGF0YVttb2RpZmllci5uYW1lXSA9IHtcbiAgICAgICAgICAgICAgLi4ubW9kaWZpZXIuZGF0YSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IF9fZGVidWdfbG9vcHNfXyA9IDA7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICBfX2RlYnVnX2xvb3BzX18gKz0gMTtcbiAgICAgICAgICAgIGlmIChfX2RlYnVnX2xvb3BzX18gPiAxMDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTkZJTklURV9MT09QX0VSUk9SKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHsgZm4sIG9wdGlvbnMgPSB7fSwgbmFtZSB9ID0gc3RhdGUub3JkZXJlZE1vZGlmaWVyc1tpbmRleF07XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IGZuKHsgc3RhdGUsIG9wdGlvbnMsIG5hbWUsIGluc3RhbmNlIH0pIHx8IHN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLy8gQXN5bmMgYW5kIG9wdGltaXN0aWNhbGx5IG9wdGltaXplZCB1cGRhdGUg4oCTIGl0IHdpbGwgbm90IGJlIGV4ZWN1dGVkIGlmXG4gICAgICAvLyBub3QgbmVjZXNzYXJ5IChkZWJvdW5jZWQgdG8gcnVuIGF0IG1vc3Qgb25jZS1wZXItdGljaylcbiAgICAgIHVwZGF0ZTogZGVib3VuY2U8JFNoYXBlPFN0YXRlPj4oXG4gICAgICAgICgpID0+XG4gICAgICAgICAgbmV3IFByb21pc2U8JFNoYXBlPFN0YXRlPj4oKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgICB9KVxuICAgICAgKSxcblxuICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBpc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9LFxuICAgIH07XG5cbiAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICBjb25zb2xlLmVycm9yKElOVkFMSURfRUxFTUVOVF9FUlJPUik7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKS50aGVuKChzdGF0ZSkgPT4ge1xuICAgICAgaWYgKCFpc0Rlc3Ryb3llZCAmJiBvcHRpb25zLm9uRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgYmVmb3JlIHRoZSBmaXJzdFxuICAgIC8vIHVwZGF0ZSBjeWNsZSBydW5zLiBUaGV5IHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHVwZGF0ZVxuICAgIC8vIGN5Y2xlLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgbW9kaWZpZXIgYWRkcyBzb21lIHBlcnNpc3RlbnQgZGF0YSB0aGF0XG4gICAgLy8gb3RoZXIgbW9kaWZpZXJzIG5lZWQgdG8gdXNlLCBidXQgdGhlIG1vZGlmaWVyIGlzIHJ1biBhZnRlciB0aGUgZGVwZW5kZW50XG4gICAgLy8gb25lLlxuICAgIGZ1bmN0aW9uIHJ1bk1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaCgoeyBuYW1lLCBvcHRpb25zID0ge30sIGVmZmVjdCB9KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29uc3QgY2xlYW51cEZuID0gZWZmZWN0KHsgc3RhdGUsIG5hbWUsIGluc3RhbmNlLCBvcHRpb25zIH0pO1xuICAgICAgICAgIGNvbnN0IG5vb3BGbiA9ICgpID0+IHt9O1xuICAgICAgICAgIGVmZmVjdENsZWFudXBGbnMucHVzaChjbGVhbnVwRm4gfHwgbm9vcEZuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICAgICAgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVBvcHBlciA9IHBvcHBlckdlbmVyYXRvcigpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgeyBkZXRlY3RPdmVyZmxvdyB9O1xuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgTW9kaWZpZXJBcmd1bWVudHMsIE1vZGlmaWVyIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tICcuLi9kb20tdXRpbHMvZ2V0V2luZG93JztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgT3B0aW9ucyA9IHtcbiAgc2Nyb2xsOiBib29sZWFuLFxuICByZXNpemU6IGJvb2xlYW4sXG59O1xuXG5jb25zdCBwYXNzaXZlID0geyBwYXNzaXZlOiB0cnVlIH07XG5cbmZ1bmN0aW9uIGVmZmVjdCh7IHN0YXRlLCBpbnN0YW5jZSwgb3B0aW9ucyB9OiBNb2RpZmllckFyZ3VtZW50czxPcHRpb25zPikge1xuICBjb25zdCB7IHNjcm9sbCA9IHRydWUsIHJlc2l6ZSA9IHRydWUgfSA9IG9wdGlvbnM7XG5cbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KHN0YXRlLmVsZW1lbnRzLnBvcHBlcik7XG4gIGNvbnN0IHNjcm9sbFBhcmVudHMgPSBbXG4gICAgLi4uc3RhdGUuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsXG4gICAgLi4uc3RhdGUuc2Nyb2xsUGFyZW50cy5wb3BwZXIsXG4gIF07XG5cbiAgaWYgKHNjcm9sbCkge1xuICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChzY3JvbGxQYXJlbnQgPT4ge1xuICAgICAgc2Nyb2xsUGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocmVzaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gIH1cblxuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmIChzY3JvbGwpIHtcbiAgICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChzY3JvbGxQYXJlbnQgPT4ge1xuICAgICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgRXZlbnRMaXN0ZW5lcnNNb2RpZmllciA9IE1vZGlmaWVyPCdldmVudExpc3RlbmVycycsIE9wdGlvbnM+O1xuZXhwb3J0IGRlZmF1bHQgKHtcbiAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiAoKSA9PiB7fSxcbiAgZWZmZWN0LFxuICBkYXRhOiB7fSxcbn06IEV2ZW50TGlzdGVuZXJzTW9kaWZpZXIpO1xuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgTW9kaWZpZXJBcmd1bWVudHMsIE1vZGlmaWVyIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IGNvbXB1dGVPZmZzZXRzIGZyb20gJy4uL3V0aWxzL2NvbXB1dGVPZmZzZXRzJztcblxuZnVuY3Rpb24gcG9wcGVyT2Zmc2V0cyh7IHN0YXRlLCBuYW1lIH06IE1vZGlmaWVyQXJndW1lbnRzPHt8fH0+KSB7XG4gIC8vIE9mZnNldHMgYXJlIHRoZSBhY3R1YWwgcG9zaXRpb24gdGhlIHBvcHBlciBuZWVkcyB0byBoYXZlIHRvIGJlXG4gIC8vIHByb3Blcmx5IHBvc2l0aW9uZWQgbmVhciBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVGhpcyBpcyB0aGUgbW9zdCBiYXNpYyBwbGFjZW1lbnQsIGFuZCB3aWxsIGJlIGFkanVzdGVkIGJ5XG4gIC8vIHRoZSBtb2RpZmllcnMgaW4gdGhlIG5leHQgc3RlcFxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogc3RhdGUucmVjdHMucmVmZXJlbmNlLFxuICAgIGVsZW1lbnQ6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudCxcbiAgfSk7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB0eXBlIFBvcHBlck9mZnNldHNNb2RpZmllciA9IE1vZGlmaWVyPCdwb3BwZXJPZmZzZXRzJywge3x8fT47XG5leHBvcnQgZGVmYXVsdCAoe1xuICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAncmVhZCcsXG4gIGZuOiBwb3BwZXJPZmZzZXRzLFxuICBkYXRhOiB7fSxcbn06IFBvcHBlck9mZnNldHNNb2RpZmllcik7XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUge1xuICBQb3NpdGlvbmluZ1N0cmF0ZWd5LFxuICBPZmZzZXRzLFxuICBNb2RpZmllcixcbiAgTW9kaWZpZXJBcmd1bWVudHMsXG4gIFJlY3QsXG4gIFdpbmRvdyxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgdHlwZSBCYXNlUGxhY2VtZW50LFxuICB0eXBlIFZhcmlhdGlvbixcbiAgdG9wLFxuICBsZWZ0LFxuICByaWdodCxcbiAgYm90dG9tLFxuICBlbmQsXG59IGZyb20gJy4uL2VudW1zJztcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSAnLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudCc7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gJy4uL2RvbS11dGlscy9nZXRXaW5kb3cnO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tICcuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50JztcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gJy4uL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlJztcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gJy4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQnO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tICcuLi91dGlscy9nZXRWYXJpYXRpb24nO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tICcuLi91dGlscy9tYXRoJztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgUm91bmRPZmZzZXRzID0gKFxuICBvZmZzZXRzOiAkU2hhcGU8eyB4OiBudW1iZXIsIHk6IG51bWJlciwgY2VudGVyT2Zmc2V0OiBudW1iZXIgfT5cbikgPT4gT2Zmc2V0cztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgT3B0aW9ucyA9IHtcbiAgZ3B1QWNjZWxlcmF0aW9uOiBib29sZWFuLFxuICBhZGFwdGl2ZTogYm9vbGVhbixcbiAgcm91bmRPZmZzZXRzPzogYm9vbGVhbiB8IFJvdW5kT2Zmc2V0cyxcbn07XG5cbmNvbnN0IHVuc2V0U2lkZXMgPSB7XG4gIHRvcDogJ2F1dG8nLFxuICByaWdodDogJ2F1dG8nLFxuICBib3R0b206ICdhdXRvJyxcbiAgbGVmdDogJ2F1dG8nLFxufTtcblxuLy8gUm91bmQgdGhlIG9mZnNldHMgdG8gdGhlIG5lYXJlc3Qgc3VpdGFibGUgc3VicGl4ZWwgYmFzZWQgb24gdGhlIERQUi5cbi8vIFpvb21pbmcgY2FuIGNoYW5nZSB0aGUgRFBSLCBidXQgaXQgc2VlbXMgdG8gcmVwb3J0IGEgdmFsdWUgdGhhdCB3aWxsXG4vLyBjbGVhbmx5IGRpdmlkZSB0aGUgdmFsdWVzIGludG8gdGhlIGFwcHJvcHJpYXRlIHN1YnBpeGVscy5cbmZ1bmN0aW9uIHJvdW5kT2Zmc2V0c0J5RFBSKHsgeCwgeSB9KTogT2Zmc2V0cyB7XG4gIGNvbnN0IHdpbjogV2luZG93ID0gd2luZG93O1xuICBjb25zdCBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuXG4gIHJldHVybiB7XG4gICAgeDogcm91bmQoeCAqIGRwcikgLyBkcHIgfHwgMCxcbiAgICB5OiByb3VuZCh5ICogZHByKSAvIGRwciB8fCAwLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9TdHlsZXMoe1xuICBwb3BwZXIsXG4gIHBvcHBlclJlY3QsXG4gIHBsYWNlbWVudCxcbiAgdmFyaWF0aW9uLFxuICBvZmZzZXRzLFxuICBwb3NpdGlvbixcbiAgZ3B1QWNjZWxlcmF0aW9uLFxuICBhZGFwdGl2ZSxcbiAgcm91bmRPZmZzZXRzLFxuICBpc0ZpeGVkLFxufToge1xuICBwb3BwZXI6IEhUTUxFbGVtZW50LFxuICBwb3BwZXJSZWN0OiBSZWN0LFxuICBwbGFjZW1lbnQ6IEJhc2VQbGFjZW1lbnQsXG4gIHZhcmlhdGlvbjogP1ZhcmlhdGlvbixcbiAgb2Zmc2V0czogJFNoYXBlPHsgeDogbnVtYmVyLCB5OiBudW1iZXIsIGNlbnRlck9mZnNldDogbnVtYmVyIH0+LFxuICBwb3NpdGlvbjogUG9zaXRpb25pbmdTdHJhdGVneSxcbiAgZ3B1QWNjZWxlcmF0aW9uOiBib29sZWFuLFxuICBhZGFwdGl2ZTogYm9vbGVhbixcbiAgcm91bmRPZmZzZXRzOiBib29sZWFuIHwgUm91bmRPZmZzZXRzLFxuICBpc0ZpeGVkOiBib29sZWFuLFxufSkge1xuICBsZXQgeyB4ID0gMCwgeSA9IDAgfSA9IG9mZnNldHM7XG5cbiAgKHsgeCwgeSB9ID1cbiAgICB0eXBlb2Ygcm91bmRPZmZzZXRzID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHJvdW5kT2Zmc2V0cyh7IHgsIHkgfSlcbiAgICAgIDogeyB4LCB5IH0pO1xuXG4gIGNvbnN0IGhhc1ggPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd4Jyk7XG4gIGNvbnN0IGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XG5cbiAgbGV0IHNpZGVYOiBzdHJpbmcgPSBsZWZ0O1xuICBsZXQgc2lkZVk6IHN0cmluZyA9IHRvcDtcblxuICBjb25zdCB3aW46IFdpbmRvdyA9IHdpbmRvdztcblxuICBpZiAoYWRhcHRpdmUpIHtcbiAgICBsZXQgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XG4gICAgbGV0IGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcbiAgICBsZXQgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcblxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcblxuICAgICAgaWYgKFxuICAgICAgICBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gIT09ICdzdGF0aWMnICYmXG4gICAgICAgIHBvc2l0aW9uID09PSAnYWJzb2x1dGUnXG4gICAgICApIHtcbiAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhc3RdOiBmb3JjZSB0eXBlIHJlZmluZW1lbnQsIHdlIGNvbXBhcmUgb2Zmc2V0UGFyZW50IHdpdGggd2luZG93IGFib3ZlLCBidXQgRmxvdyBkb2Vzbid0IGRldGVjdCBpdFxuICAgIG9mZnNldFBhcmVudCA9IChvZmZzZXRQYXJlbnQ6IEVsZW1lbnQpO1xuXG4gICAgaWYgKFxuICAgICAgcGxhY2VtZW50ID09PSB0b3AgfHxcbiAgICAgICgocGxhY2VtZW50ID09PSBsZWZ0IHx8IHBsYWNlbWVudCA9PT0gcmlnaHQpICYmIHZhcmlhdGlvbiA9PT0gZW5kKVxuICAgICkge1xuICAgICAgc2lkZVkgPSBib3R0b207XG4gICAgICBjb25zdCBvZmZzZXRZID1cbiAgICAgICAgaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnRcbiAgICAgICAgICA/IHdpbi52aXN1YWxWaWV3cG9ydC5oZWlnaHRcbiAgICAgICAgICA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICAgICAgb2Zmc2V0UGFyZW50W2hlaWdodFByb3BdO1xuICAgICAgeSAtPSBvZmZzZXRZIC0gcG9wcGVyUmVjdC5oZWlnaHQ7XG4gICAgICB5ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBwbGFjZW1lbnQgPT09IGxlZnQgfHxcbiAgICAgICgocGxhY2VtZW50ID09PSB0b3AgfHwgcGxhY2VtZW50ID09PSBib3R0b20pICYmIHZhcmlhdGlvbiA9PT0gZW5kKVxuICAgICkge1xuICAgICAgc2lkZVggPSByaWdodDtcbiAgICAgIGNvbnN0IG9mZnNldFggPVxuICAgICAgICBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydFxuICAgICAgICAgID8gd2luLnZpc3VhbFZpZXdwb3J0LndpZHRoXG4gICAgICAgICAgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgICAgICAgIG9mZnNldFBhcmVudFt3aWR0aFByb3BdO1xuICAgICAgeCAtPSBvZmZzZXRYIC0gcG9wcGVyUmVjdC53aWR0aDtcbiAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNvbW1vblN0eWxlcyA9IHtcbiAgICBwb3NpdGlvbixcbiAgICAuLi4oYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyksXG4gIH07XG5cbiAgKHsgeCwgeSB9ID1cbiAgICByb3VuZE9mZnNldHMgPT09IHRydWVcbiAgICAgID8gcm91bmRPZmZzZXRzQnlEUFIoeyB4LCB5IH0pXG4gICAgICA6IHsgeCwgeSB9KTtcblxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvbW1vblN0eWxlcyxcbiAgICAgIFtzaWRlWV06IGhhc1kgPyAnMCcgOiAnJyxcbiAgICAgIFtzaWRlWF06IGhhc1ggPyAnMCcgOiAnJyxcbiAgICAgIC8vIExheWVyIGFjY2VsZXJhdGlvbiBjYW4gZGlzYWJsZSBzdWJwaXhlbCByZW5kZXJpbmcgd2hpY2ggY2F1c2VzIHNsaWdodGx5XG4gICAgICAvLyBibHVycnkgdGV4dCBvbiBsb3cgUFBJIGRpc3BsYXlzLCBzbyB3ZSB3YW50IHRvIHVzZSAyRCB0cmFuc2Zvcm1zXG4gICAgICAvLyBpbnN0ZWFkXG4gICAgICB0cmFuc2Zvcm06XG4gICAgICAgICh3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxXG4gICAgICAgICAgPyBgdHJhbnNsYXRlKCR7eH1weCwgJHt5fXB4KWBcbiAgICAgICAgICA6IGB0cmFuc2xhdGUzZCgke3h9cHgsICR7eX1weCwgMClgLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLmNvbW1vblN0eWxlcyxcbiAgICBbc2lkZVldOiBoYXNZID8gYCR7eX1weGAgOiAnJyxcbiAgICBbc2lkZVhdOiBoYXNYID8gYCR7eH1weGAgOiAnJyxcbiAgICB0cmFuc2Zvcm06ICcnLFxuICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU3R5bGVzKHsgc3RhdGUsIG9wdGlvbnMgfTogTW9kaWZpZXJBcmd1bWVudHM8T3B0aW9ucz4pIHtcbiAgY29uc3Qge1xuICAgIGdwdUFjY2VsZXJhdGlvbiA9IHRydWUsXG4gICAgYWRhcHRpdmUgPSB0cnVlLFxuICAgIC8vIGRlZmF1bHRzIHRvIHVzZSBidWlsdGluIGByb3VuZE9mZnNldHNCeURQUmBcbiAgICByb3VuZE9mZnNldHMgPSB0cnVlLFxuICB9ID0gb3B0aW9ucztcblxuICBpZiAoX19ERVZfXykge1xuICAgIGNvbnN0IHRyYW5zaXRpb25Qcm9wZXJ0eSA9XG4gICAgICBnZXRDb21wdXRlZFN0eWxlKHN0YXRlLmVsZW1lbnRzLnBvcHBlcikudHJhbnNpdGlvblByb3BlcnR5IHx8ICcnO1xuXG4gICAgaWYgKFxuICAgICAgYWRhcHRpdmUgJiZcbiAgICAgIFsndHJhbnNmb3JtJywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLnNvbWUoXG4gICAgICAgIChwcm9wZXJ0eSkgPT4gdHJhbnNpdGlvblByb3BlcnR5LmluZGV4T2YocHJvcGVydHkpID49IDBcbiAgICAgIClcbiAgICApIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgW1xuICAgICAgICAgICdQb3BwZXI6IERldGVjdGVkIENTUyB0cmFuc2l0aW9ucyBvbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvbGxvd2luZycsXG4gICAgICAgICAgJ0NTUyBwcm9wZXJ0aWVzOiBcInRyYW5zZm9ybVwiLCBcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLicsXG4gICAgICAgICAgJ1xcblxcbicsXG4gICAgICAgICAgJ0Rpc2FibGUgdGhlIFwiY29tcHV0ZVN0eWxlc1wiIG1vZGlmaWVyXFwncyBgYWRhcHRpdmVgIG9wdGlvbiB0byBhbGxvdycsXG4gICAgICAgICAgJ2ZvciBzbW9vdGggdHJhbnNpdGlvbnMsIG9yIHJlbW92ZSB0aGVzZSBwcm9wZXJ0aWVzIGZyb20gdGhlIENTUycsXG4gICAgICAgICAgJ3RyYW5zaXRpb24gZGVjbGFyYXRpb24gb24gdGhlIHBvcHBlciBlbGVtZW50IGlmIG9ubHkgdHJhbnNpdGlvbmluZycsXG4gICAgICAgICAgJ29wYWNpdHkgb3IgYmFja2dyb3VuZC1jb2xvciBmb3IgZXhhbXBsZS4nLFxuICAgICAgICAgICdcXG5cXG4nLFxuICAgICAgICAgICdXZSByZWNvbW1lbmQgdXNpbmcgdGhlIHBvcHBlciBlbGVtZW50IGFzIGEgd3JhcHBlciBhcm91bmQgYW4gaW5uZXInLFxuICAgICAgICAgICdlbGVtZW50IHRoYXQgY2FuIGhhdmUgYW55IENTUyBwcm9wZXJ0eSB0cmFuc2l0aW9uZWQgZm9yIGFuaW1hdGlvbnMuJyxcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHZhcmlhdGlvbjogZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiBzdGF0ZS5lbGVtZW50cy5wb3BwZXIsXG4gICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbixcbiAgICBpc0ZpeGVkOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnLFxuICB9O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5wb3BwZXIgPSB7XG4gICAgICAuLi5zdGF0ZS5zdHlsZXMucG9wcGVyLFxuICAgICAgLi4ubWFwVG9TdHlsZXMoe1xuICAgICAgICAuLi5jb21tb25TdHlsZXMsXG4gICAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcbiAgICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICAgIGFkYXB0aXZlLFxuICAgICAgICByb3VuZE9mZnNldHMsXG4gICAgICB9KSxcbiAgICB9O1xuICB9XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3cgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5hcnJvdyA9IHtcbiAgICAgIC4uLnN0YXRlLnN0eWxlcy5hcnJvdyxcbiAgICAgIC4uLm1hcFRvU3R5bGVzKHtcbiAgICAgICAgLi4uY29tbW9uU3R5bGVzLFxuICAgICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93LFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgICByb3VuZE9mZnNldHMsXG4gICAgICB9KSxcbiAgICB9O1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSB7XG4gICAgLi4uc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsXG4gICAgJ2RhdGEtcG9wcGVyLXBsYWNlbWVudCc6IHN0YXRlLnBsYWNlbWVudCxcbiAgfTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgQ29tcHV0ZVN0eWxlc01vZGlmaWVyID0gTW9kaWZpZXI8J2NvbXB1dGVTdHlsZXMnLCBPcHRpb25zPjtcbmV4cG9ydCBkZWZhdWx0ICh7XG4gIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gIGZuOiBjb21wdXRlU3R5bGVzLFxuICBkYXRhOiB7fSxcbn06IENvbXB1dGVTdHlsZXNNb2RpZmllcik7XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBNb2RpZmllciwgTW9kaWZpZXJBcmd1bWVudHMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSAnLi4vZG9tLXV0aWxzL2dldE5vZGVOYW1lJztcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tICcuLi9kb20tdXRpbHMvaW5zdGFuY2VPZic7XG5cbi8vIFRoaXMgbW9kaWZpZXIgdGFrZXMgdGhlIHN0eWxlcyBwcmVwYXJlZCBieSB0aGUgYGNvbXB1dGVTdHlsZXNgIG1vZGlmaWVyXG4vLyBhbmQgYXBwbGllcyB0aGVtIHRvIHRoZSBIVE1MRWxlbWVudHMgc3VjaCBhcyBwb3BwZXIgYW5kIGFycm93XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGVzKHsgc3RhdGUgfTogTW9kaWZpZXJBcmd1bWVudHM8e3x8fT4pIHtcbiAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICBjb25zdCBzdHlsZSA9IHN0YXRlLnN0eWxlc1tuYW1lXSB8fCB7fTtcblxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgIGNvbnN0IGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTtcblxuICAgIC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0byBleHRlbmQgdGhpcyBwcm9wZXJ0eSwgYnV0IGl0J3MgdGhlIG1vc3RcbiAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuXG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoeyBzdGF0ZSB9OiBNb2RpZmllckFyZ3VtZW50czx7fHx9Pikge1xuICBjb25zdCBpbml0aWFsU3R5bGVzID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAnMCcsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIG1hcmdpbjogJzAnLFxuICAgIH0sXG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIH0sXG4gICAgcmVmZXJlbmNlOiB7fSxcbiAgfTtcblxuICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgaW5pdGlhbFN0eWxlcy5wb3BwZXIpO1xuICBzdGF0ZS5zdHlsZXMgPSBpbml0aWFsU3R5bGVzO1xuXG4gIGlmIChzdGF0ZS5lbGVtZW50cy5hcnJvdykge1xuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMuYXJyb3cuc3R5bGUsIGluaXRpYWxTdHlsZXMuYXJyb3cpO1xuICB9XG5cbiAgcmV0dXJuICgpID0+IHtcbiAgICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG5cbiAgICAgIGNvbnN0IHN0eWxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKFxuICAgICAgICBzdGF0ZS5zdHlsZXMuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICA/IHN0YXRlLnN0eWxlc1tuYW1lXVxuICAgICAgICAgIDogaW5pdGlhbFN0eWxlc1tuYW1lXVxuICAgICAgKTtcblxuICAgICAgLy8gU2V0IGFsbCB2YWx1ZXMgdG8gYW4gZW1wdHkgc3RyaW5nIHRvIHVuc2V0IHRoZW1cbiAgICAgIGNvbnN0IHN0eWxlID0gc3R5bGVQcm9wZXJ0aWVzLnJlZHVjZSgoc3R5bGUsIHByb3BlcnR5KSA9PiB7XG4gICAgICAgIHN0eWxlW3Byb3BlcnR5XSA9ICcnO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9LCB7fSk7XG5cbiAgICAgIC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuXG4gICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKChhdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBBcHBseVN0eWxlc01vZGlmaWVyID0gTW9kaWZpZXI8J2FwcGx5U3R5bGVzJywge3x8fT47XG5leHBvcnQgZGVmYXVsdCAoe1xuICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGFwcGx5U3R5bGVzLFxuICBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ2NvbXB1dGVTdHlsZXMnXSxcbn06IEFwcGx5U3R5bGVzTW9kaWZpZXIpO1xuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgUGxhY2VtZW50IH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IHR5cGUgeyBNb2RpZmllckFyZ3VtZW50cywgTW9kaWZpZXIsIFJlY3QsIE9mZnNldHMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tICcuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50JztcbmltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIHBsYWNlbWVudHMgfSBmcm9tICcuLi9lbnVtcyc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB0eXBlIE9mZnNldHNGdW5jdGlvbiA9ICh7XG4gIHBvcHBlcjogUmVjdCxcbiAgcmVmZXJlbmNlOiBSZWN0LFxuICBwbGFjZW1lbnQ6IFBsYWNlbWVudCxcbn0pID0+IFs/bnVtYmVyLCA/bnVtYmVyXTtcblxudHlwZSBPZmZzZXQgPSBPZmZzZXRzRnVuY3Rpb24gfCBbP251bWJlciwgP251bWJlcl07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB0eXBlIE9wdGlvbnMgPSB7XG4gIG9mZnNldDogT2Zmc2V0LFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKFxuICBwbGFjZW1lbnQ6IFBsYWNlbWVudCxcbiAgcmVjdHM6IHsgcG9wcGVyOiBSZWN0LCByZWZlcmVuY2U6IFJlY3QgfSxcbiAgb2Zmc2V0OiBPZmZzZXRcbik6IE9mZnNldHMge1xuICBjb25zdCBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBpbnZlcnREaXN0YW5jZSA9IFtsZWZ0LCB0b3BdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IC0xIDogMTtcblxuICBsZXQgW3NraWRkaW5nLCBkaXN0YW5jZV0gPVxuICAgIHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbidcbiAgICAgID8gb2Zmc2V0KHtcbiAgICAgICAgICAuLi5yZWN0cyxcbiAgICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIH0pXG4gICAgICA6IG9mZnNldDtcblxuICBza2lkZGluZyA9IHNraWRkaW5nIHx8IDA7XG4gIGRpc3RhbmNlID0gKGRpc3RhbmNlIHx8IDApICogaW52ZXJ0RGlzdGFuY2U7XG5cbiAgcmV0dXJuIFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwXG4gICAgPyB7IHg6IGRpc3RhbmNlLCB5OiBza2lkZGluZyB9XG4gICAgOiB7IHg6IHNraWRkaW5nLCB5OiBkaXN0YW5jZSB9O1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoeyBzdGF0ZSwgb3B0aW9ucywgbmFtZSB9OiBNb2RpZmllckFyZ3VtZW50czxPcHRpb25zPikge1xuICBjb25zdCB7IG9mZnNldCA9IFswLCAwXSB9ID0gb3B0aW9ucztcblxuICBjb25zdCBkYXRhID0gcGxhY2VtZW50cy5yZWR1Y2UoKGFjYywgcGxhY2VtZW50KSA9PiB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHN0YXRlLnJlY3RzLCBvZmZzZXQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcblxuICBjb25zdCB7IHgsIHkgfSA9IGRhdGFbc3RhdGUucGxhY2VtZW50XTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSB4O1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IHk7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgT2Zmc2V0TW9kaWZpZXIgPSBNb2RpZmllcjwnb2Zmc2V0JywgT3B0aW9ucz47XG5leHBvcnQgZGVmYXVsdCAoe1xuICBuYW1lOiAnb2Zmc2V0JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICBmbjogb2Zmc2V0LFxufTogT2Zmc2V0TW9kaWZpZXIpO1xuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgUGxhY2VtZW50IH0gZnJvbSAnLi4vZW51bXMnO1xuXG5jb25zdCBoYXNoID0geyBsZWZ0OiAncmlnaHQnLCByaWdodDogJ2xlZnQnLCBib3R0b206ICd0b3AnLCB0b3A6ICdib3R0b20nIH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudDogUGxhY2VtZW50KTogUGxhY2VtZW50IHtcbiAgcmV0dXJuIChwbGFjZW1lbnQucmVwbGFjZShcbiAgICAvbGVmdHxyaWdodHxib3R0b218dG9wL2csXG4gICAgbWF0Y2hlZCA9PiBoYXNoW21hdGNoZWRdXG4gICk6IGFueSk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBQbGFjZW1lbnQgfSBmcm9tICcuLi9lbnVtcyc7XG5cbmNvbnN0IGhhc2ggPSB7IHN0YXJ0OiAnZW5kJywgZW5kOiAnc3RhcnQnIH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KFxuICBwbGFjZW1lbnQ6IFBsYWNlbWVudFxuKTogUGxhY2VtZW50IHtcbiAgcmV0dXJuIChwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIG1hdGNoZWQgPT4gaGFzaFttYXRjaGVkXSk6IGFueSk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBTdGF0ZSwgUGFkZGluZyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB0eXBlIHtcbiAgUGxhY2VtZW50LFxuICBDb21wdXRlZFBsYWNlbWVudCxcbiAgQm91bmRhcnksXG4gIFJvb3RCb3VuZGFyeSxcbn0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tICcuL2dldFZhcmlhdGlvbic7XG5pbXBvcnQge1xuICB2YXJpYXRpb25QbGFjZW1lbnRzLFxuICBiYXNlUGxhY2VtZW50cyxcbiAgcGxhY2VtZW50cyBhcyBhbGxQbGFjZW1lbnRzLFxufSBmcm9tICcuLi9lbnVtcyc7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSAnLi9kZXRlY3RPdmVyZmxvdyc7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tICcuL2dldEJhc2VQbGFjZW1lbnQnO1xuXG50eXBlIE9wdGlvbnMgPSB7XG4gIHBsYWNlbWVudDogUGxhY2VtZW50LFxuICBwYWRkaW5nOiBQYWRkaW5nLFxuICBib3VuZGFyeTogQm91bmRhcnksXG4gIHJvb3RCb3VuZGFyeTogUm9vdEJvdW5kYXJ5LFxuICBmbGlwVmFyaWF0aW9uczogYm9vbGVhbixcbiAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzPzogQXJyYXk8UGxhY2VtZW50Pixcbn07XG5cbnR5cGUgT3ZlcmZsb3dzTWFwID0geyBbQ29tcHV0ZWRQbGFjZW1lbnRdOiBudW1iZXIgfTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoXG4gIHN0YXRlOiAkU2hhcGU8U3RhdGU+LFxuICBvcHRpb25zOiBPcHRpb25zID0ge31cbik6IEFycmF5PENvbXB1dGVkUGxhY2VtZW50PiB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQsXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmcsXG4gICAgZmxpcFZhcmlhdGlvbnMsXG4gICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gYWxsUGxhY2VtZW50cyxcbiAgfSA9IG9wdGlvbnM7XG5cbiAgY29uc3QgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG5cbiAgY29uc3QgcGxhY2VtZW50cyA9IHZhcmlhdGlvblxuICAgID8gZmxpcFZhcmlhdGlvbnNcbiAgICAgID8gdmFyaWF0aW9uUGxhY2VtZW50c1xuICAgICAgOiB2YXJpYXRpb25QbGFjZW1lbnRzLmZpbHRlcihcbiAgICAgICAgICAocGxhY2VtZW50KSA9PiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gdmFyaWF0aW9uXG4gICAgICAgIClcbiAgICA6IGJhc2VQbGFjZW1lbnRzO1xuXG4gIGxldCBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMuZmlsdGVyKFxuICAgIChwbGFjZW1lbnQpID0+IGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMFxuICApO1xuXG4gIGlmIChhbGxvd2VkUGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG5cbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgW1xuICAgICAgICAgICdQb3BwZXI6IFRoZSBgYWxsb3dlZEF1dG9QbGFjZW1lbnRzYCBvcHRpb24gZGlkIG5vdCBhbGxvdyBhbnknLFxuICAgICAgICAgICdwbGFjZW1lbnRzLiBFbnN1cmUgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbiBtYXRjaGVzIHRoZSB2YXJpYXRpb24nLFxuICAgICAgICAgICdvZiB0aGUgYWxsb3dlZCBwbGFjZW1lbnRzLicsXG4gICAgICAgICAgJ0ZvciBleGFtcGxlLCBcImF1dG9cIiBjYW5ub3QgYmUgdXNlZCB0byBhbGxvdyBcImJvdHRvbS1zdGFydFwiLicsXG4gICAgICAgICAgJ1VzZSBcImF1dG8tc3RhcnRcIiBpbnN0ZWFkLicsXG4gICAgICAgIF0uam9pbignICcpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdOiBGbG93IHNlZW1zIHRvIGhhdmUgcHJvYmxlbXMgd2l0aCB0d28gYXJyYXkgdW5pb25zLi4uXG4gIGNvbnN0IG92ZXJmbG93czogT3ZlcmZsb3dzTWFwID0gYWxsb3dlZFBsYWNlbWVudHMucmVkdWNlKChhY2MsIHBsYWNlbWVudCkgPT4ge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyxcbiAgICB9KVtnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCldO1xuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyhvdmVyZmxvd3MpLnNvcnQoKGEsIGIpID0+IG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXSk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBQbGFjZW1lbnQsIEJvdW5kYXJ5LCBSb290Qm91bmRhcnkgfSBmcm9tICcuLi9lbnVtcyc7XG5pbXBvcnQgdHlwZSB7IE1vZGlmaWVyQXJndW1lbnRzLCBNb2RpZmllciwgUGFkZGluZyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBnZXRPcHBvc2l0ZVBsYWNlbWVudCBmcm9tICcuLi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudCc7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tICcuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50JztcbmltcG9ydCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudCBmcm9tICcuLi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudCc7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSAnLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cnO1xuaW1wb3J0IGNvbXB1dGVBdXRvUGxhY2VtZW50IGZyb20gJy4uL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50JztcbmltcG9ydCB7IGJvdHRvbSwgdG9wLCBzdGFydCwgcmlnaHQsIGxlZnQsIGF1dG8gfSBmcm9tICcuLi9lbnVtcyc7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gJy4uL3V0aWxzL2dldFZhcmlhdGlvbic7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB0eXBlIE9wdGlvbnMgPSB7XG4gIG1haW5BeGlzOiBib29sZWFuLFxuICBhbHRBeGlzOiBib29sZWFuLFxuICBmYWxsYmFja1BsYWNlbWVudHM6IEFycmF5PFBsYWNlbWVudD4sXG4gIHBhZGRpbmc6IFBhZGRpbmcsXG4gIGJvdW5kYXJ5OiBCb3VuZGFyeSxcbiAgcm9vdEJvdW5kYXJ5OiBSb290Qm91bmRhcnksXG4gIGFsdEJvdW5kYXJ5OiBib29sZWFuLFxuICBmbGlwVmFyaWF0aW9uczogYm9vbGVhbixcbiAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBBcnJheTxQbGFjZW1lbnQ+LFxufTtcblxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocGxhY2VtZW50OiBQbGFjZW1lbnQpOiBBcnJheTxQbGFjZW1lbnQ+IHtcbiAgaWYgKGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0bykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICByZXR1cm4gW1xuICAgIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCksXG4gICAgb3Bwb3NpdGVQbGFjZW1lbnQsXG4gICAgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpLFxuICBdO1xufVxuXG5mdW5jdGlvbiBmbGlwKHsgc3RhdGUsIG9wdGlvbnMsIG5hbWUgfTogTW9kaWZpZXJBcmd1bWVudHM8T3B0aW9ucz4pIHtcbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB7XG4gICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgIGFsdEF4aXM6IGNoZWNrQWx0QXhpcyA9IHRydWUsXG4gICAgZmFsbGJhY2tQbGFjZW1lbnRzOiBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMsXG4gICAgcGFkZGluZyxcbiAgICBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnksXG4gICAgYWx0Qm91bmRhcnksXG4gICAgZmxpcFZhcmlhdGlvbnMgPSB0cnVlLFxuICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyxcbiAgfSA9IG9wdGlvbnM7XG5cbiAgY29uc3QgcHJlZmVycmVkUGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7XG4gIGNvbnN0IGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCk7XG4gIGNvbnN0IGlzQmFzZVBsYWNlbWVudCA9IGJhc2VQbGFjZW1lbnQgPT09IHByZWZlcnJlZFBsYWNlbWVudDtcblxuICBjb25zdCBmYWxsYmFja1BsYWNlbWVudHMgPVxuICAgIHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fFxuICAgIChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBWYXJpYXRpb25zXG4gICAgICA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpXVxuICAgICAgOiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwcmVmZXJyZWRQbGFjZW1lbnQpKTtcblxuICBjb25zdCBwbGFjZW1lbnRzID0gW3ByZWZlcnJlZFBsYWNlbWVudCwgLi4uZmFsbGJhY2tQbGFjZW1lbnRzXS5yZWR1Y2UoXG4gICAgKGFjYywgcGxhY2VtZW50KSA9PiB7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChcbiAgICAgICAgZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvXG4gICAgICAgICAgPyBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgICAgICByb290Qm91bmRhcnksXG4gICAgICAgICAgICAgIHBhZGRpbmcsXG4gICAgICAgICAgICAgIGZsaXBWYXJpYXRpb25zLFxuICAgICAgICAgICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIDogcGxhY2VtZW50XG4gICAgICApO1xuICAgIH0sXG4gICAgW11cbiAgKTtcblxuICBjb25zdCByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICBjb25zdCBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuXG4gIGNvbnN0IGNoZWNrc01hcCA9IG5ldyBNYXAoKTtcbiAgbGV0IG1ha2VGYWxsYmFja0NoZWNrcyA9IHRydWU7XG4gIGxldCBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzWzBdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGxhY2VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XG4gICAgY29uc3QgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgICBjb25zdCBpc1N0YXJ0VmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHN0YXJ0O1xuICAgIGNvbnN0IGlzVmVydGljYWwgPSBbdG9wLCBib3R0b21dLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICBjb25zdCBsZW4gPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gICAgY29uc3Qgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcsXG4gICAgfSk7XG5cbiAgICBsZXQgbWFpblZhcmlhdGlvblNpZGU6IGFueSA9IGlzVmVydGljYWxcbiAgICAgID8gaXNTdGFydFZhcmlhdGlvblxuICAgICAgICA/IHJpZ2h0XG4gICAgICAgIDogbGVmdFxuICAgICAgOiBpc1N0YXJ0VmFyaWF0aW9uXG4gICAgICA/IGJvdHRvbVxuICAgICAgOiB0b3A7XG5cbiAgICBpZiAocmVmZXJlbmNlUmVjdFtsZW5dID4gcG9wcGVyUmVjdFtsZW5dKSB7XG4gICAgICBtYWluVmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB9XG5cbiAgICBjb25zdCBhbHRWYXJpYXRpb25TaWRlOiBhbnkgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG5cbiAgICBjb25zdCBjaGVja3MgPSBbXTtcblxuICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1tiYXNlUGxhY2VtZW50XSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChcbiAgICAgICAgb3ZlcmZsb3dbbWFpblZhcmlhdGlvblNpZGVdIDw9IDAsXG4gICAgICAgIG92ZXJmbG93W2FsdFZhcmlhdGlvblNpZGVdIDw9IDBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrcy5ldmVyeSgoY2hlY2spID0+IGNoZWNrKSkge1xuICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgbWFrZUZhbGxiYWNrQ2hlY2tzID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjaGVja3NNYXAuc2V0KHBsYWNlbWVudCwgY2hlY2tzKTtcbiAgfVxuXG4gIGlmIChtYWtlRmFsbGJhY2tDaGVja3MpIHtcbiAgICAvLyBgMmAgbWF5IGJlIGRlc2lyZWQgaW4gc29tZSBjYXNlcyDigJMgcmVzZWFyY2ggbGF0ZXJcbiAgICBjb25zdCBudW1iZXJPZkNoZWNrcyA9IGZsaXBWYXJpYXRpb25zID8gMyA6IDE7XG5cbiAgICBmb3IgKGxldCBpID0gbnVtYmVyT2ZDaGVja3M7IGkgPiAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoKHBsYWNlbWVudCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja3MgPSBjaGVja3NNYXAuZ2V0KHBsYWNlbWVudCk7XG4gICAgICAgIGlmIChjaGVja3MpIHtcbiAgICAgICAgICByZXR1cm4gY2hlY2tzLnNsaWNlKDAsIGkpLmV2ZXJ5KChjaGVjaykgPT4gY2hlY2spO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gZml0dGluZ1BsYWNlbWVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnBsYWNlbWVudCAhPT0gZmlyc3RGaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCA9IHRydWU7XG4gICAgc3RhdGUucGxhY2VtZW50ID0gZmlyc3RGaXR0aW5nUGxhY2VtZW50O1xuICAgIHN0YXRlLnJlc2V0ID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBGbGlwTW9kaWZpZXIgPSBNb2RpZmllcjwnZmxpcCcsIE9wdGlvbnM+O1xuZXhwb3J0IGRlZmF1bHQgKHtcbiAgbmFtZTogJ2ZsaXAnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogZmxpcCxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcbiAgZGF0YTogeyBfc2tpcDogZmFsc2UgfSxcbn06IEZsaXBNb2RpZmllcik7XG4iLCIvLyBAZmxvd1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRBbHRBeGlzKGF4aXM6ICd4JyB8ICd5Jyk6ICd4JyB8ICd5JyB7XG4gIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHsgbWF4IGFzIG1hdGhNYXgsIG1pbiBhcyBtYXRoTWluIH0gZnJvbSAnLi9tYXRoJztcblxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhpbihtaW46IG51bWJlciwgdmFsdWU6IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gbWF0aE1heChtaW4sIG1hdGhNaW4odmFsdWUsIG1heCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2l0aGluTWF4Q2xhbXAobWluOiBudW1iZXIsIHZhbHVlOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gIGNvbnN0IHYgPSB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KTtcbiAgcmV0dXJuIHYgPiBtYXggPyBtYXggOiB2O1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgc3RhcnQgfSBmcm9tICcuLi9lbnVtcyc7XG5pbXBvcnQgdHlwZSB7IFBsYWNlbWVudCwgQm91bmRhcnksIFJvb3RCb3VuZGFyeSB9IGZyb20gJy4uL2VudW1zJztcbmltcG9ydCB0eXBlIHsgUmVjdCwgTW9kaWZpZXJBcmd1bWVudHMsIE1vZGlmaWVyLCBQYWRkaW5nIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSAnLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudCc7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gJy4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudCc7XG5pbXBvcnQgZ2V0QWx0QXhpcyBmcm9tICcuLi91dGlscy9nZXRBbHRBeGlzJztcbmltcG9ydCB7IHdpdGhpbiwgd2l0aGluTWF4Q2xhbXAgfSBmcm9tICcuLi91dGlscy93aXRoaW4nO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSAnLi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QnO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tICcuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50JztcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tICcuLi91dGlscy9kZXRlY3RPdmVyZmxvdyc7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gJy4uL3V0aWxzL2dldFZhcmlhdGlvbic7XG5pbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gJy4uL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdCc7XG5pbXBvcnQgeyBtaW4gYXMgbWF0aE1pbiwgbWF4IGFzIG1hdGhNYXggfSBmcm9tICcuLi91dGlscy9tYXRoJztcblxudHlwZSBUZXRoZXJPZmZzZXQgPVxuICB8ICgoe1xuICAgICAgcG9wcGVyOiBSZWN0LFxuICAgICAgcmVmZXJlbmNlOiBSZWN0LFxuICAgICAgcGxhY2VtZW50OiBQbGFjZW1lbnQsXG4gICAgfSkgPT4gbnVtYmVyIHwgeyBtYWluQXhpczogbnVtYmVyLCBhbHRBeGlzOiBudW1iZXIgfSlcbiAgfCBudW1iZXJcbiAgfCB7IG1haW5BeGlzOiBudW1iZXIsIGFsdEF4aXM6IG51bWJlciB9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBPcHRpb25zID0ge1xuICAvKiBQcmV2ZW50cyBib3VuZGFyaWVzIG92ZXJmbG93IG9uIHRoZSBtYWluIGF4aXMgKi9cbiAgbWFpbkF4aXM6IGJvb2xlYW4sXG4gIC8qIFByZXZlbnRzIGJvdW5kYXJpZXMgb3ZlcmZsb3cgb24gdGhlIGFsdGVybmF0ZSBheGlzICovXG4gIGFsdEF4aXM6IGJvb2xlYW4sXG4gIC8qIFRoZSBhcmVhIHRvIGNoZWNrIHRoZSBwb3BwZXIgaXMgb3ZlcmZsb3dpbmcgaW4gKi9cbiAgYm91bmRhcnk6IEJvdW5kYXJ5LFxuICAvKiBJZiB0aGUgcG9wcGVyIGlzIG5vdCBvdmVyZmxvd2luZyB0aGUgbWFpbiBhcmVhLCBmYWxsYmFjayB0byB0aGlzIG9uZSAqL1xuICByb290Qm91bmRhcnk6IFJvb3RCb3VuZGFyeSxcbiAgLyogVXNlIHRoZSByZWZlcmVuY2UncyBcImNsaXBwaW5nUGFyZW50c1wiIGJvdW5kYXJ5IGNvbnRleHQgKi9cbiAgYWx0Qm91bmRhcnk6IGJvb2xlYW4sXG4gIC8qKlxuICAgKiBBbGxvd3MgdGhlIHBvcHBlciB0byBvdmVyZmxvdyBmcm9tIGl0cyBib3VuZGFyaWVzIHRvIGtlZXAgaXQgbmVhciBpdHNcbiAgICogcmVmZXJlbmNlIGVsZW1lbnRcbiAgICovXG4gIHRldGhlcjogYm9vbGVhbixcbiAgLyogT2Zmc2V0cyB3aGVuIHRoZSBgdGV0aGVyYCBvcHRpb24gc2hvdWxkIGFjdGl2YXRlICovXG4gIHRldGhlck9mZnNldDogVGV0aGVyT2Zmc2V0LFxuICAvKiBTZXRzIGEgcGFkZGluZyB0byB0aGUgcHJvdmlkZWQgYm91bmRhcnkgKi9cbiAgcGFkZGluZzogUGFkZGluZyxcbn07XG5cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyh7IHN0YXRlLCBvcHRpb25zLCBuYW1lIH06IE1vZGlmaWVyQXJndW1lbnRzPE9wdGlvbnM+KSB7XG4gIGNvbnN0IHtcbiAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgYWx0QXhpczogY2hlY2tBbHRBeGlzID0gZmFsc2UsXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIGFsdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmcsXG4gICAgdGV0aGVyID0gdHJ1ZSxcbiAgICB0ZXRoZXJPZmZzZXQgPSAwLFxuICB9ID0gb3B0aW9ucztcblxuICBjb25zdCBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmcsXG4gICAgYWx0Qm91bmRhcnksXG4gIH0pO1xuICBjb25zdCBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICBjb25zdCB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KTtcbiAgY29uc3QgaXNCYXNlUGxhY2VtZW50ID0gIXZhcmlhdGlvbjtcbiAgY29uc3QgbWFpbkF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIGNvbnN0IGFsdEF4aXMgPSBnZXRBbHRBeGlzKG1haW5BeGlzKTtcbiAgY29uc3QgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgY29uc3QgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgY29uc3QgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgY29uc3QgdGV0aGVyT2Zmc2V0VmFsdWUgPVxuICAgIHR5cGVvZiB0ZXRoZXJPZmZzZXQgPT09ICdmdW5jdGlvbidcbiAgICAgID8gdGV0aGVyT2Zmc2V0KHtcbiAgICAgICAgICAuLi5zdGF0ZS5yZWN0cyxcbiAgICAgICAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudCxcbiAgICAgICAgfSlcbiAgICAgIDogdGV0aGVyT2Zmc2V0O1xuICBjb25zdCBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUgPVxuICAgIHR5cGVvZiB0ZXRoZXJPZmZzZXRWYWx1ZSA9PT0gJ251bWJlcidcbiAgICAgID8geyBtYWluQXhpczogdGV0aGVyT2Zmc2V0VmFsdWUsIGFsdEF4aXM6IHRldGhlck9mZnNldFZhbHVlIH1cbiAgICAgIDogeyBtYWluQXhpczogMCwgYWx0QXhpczogMCwgLi4udGV0aGVyT2Zmc2V0VmFsdWUgfTtcbiAgY29uc3Qgb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0XG4gICAgPyBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldFtzdGF0ZS5wbGFjZW1lbnRdXG4gICAgOiBudWxsO1xuXG4gIGNvbnN0IGRhdGEgPSB7IHg6IDAsIHk6IDAgfTtcblxuICBpZiAoIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgIGNvbnN0IG1haW5TaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gICAgY29uc3QgYWx0U2lkZSA9IG1haW5BeGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgICBjb25zdCBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIGNvbnN0IG9mZnNldCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdO1xuXG4gICAgY29uc3QgbWluID0gb2Zmc2V0ICsgb3ZlcmZsb3dbbWFpblNpZGVdO1xuICAgIGNvbnN0IG1heCA9IG9mZnNldCAtIG92ZXJmbG93W2FsdFNpZGVdO1xuXG4gICAgY29uc3QgYWRkaXRpdmUgPSB0ZXRoZXIgPyAtcG9wcGVyUmVjdFtsZW5dIC8gMiA6IDA7XG5cbiAgICBjb25zdCBtaW5MZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gcmVmZXJlbmNlUmVjdFtsZW5dIDogcG9wcGVyUmVjdFtsZW5dO1xuICAgIGNvbnN0IG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTtcblxuICAgIC8vIFdlIG5lZWQgdG8gaW5jbHVkZSB0aGUgYXJyb3cgaW4gdGhlIGNhbGN1bGF0aW9uIHNvIHRoZSBhcnJvdyBkb2Vzbid0IGdvXG4gICAgLy8gb3V0c2lkZSB0aGUgcmVmZXJlbmNlIGJvdW5kc1xuICAgIGNvbnN0IGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICAgIGNvbnN0IGFycm93UmVjdCA9XG4gICAgICB0ZXRoZXIgJiYgYXJyb3dFbGVtZW50XG4gICAgICAgID8gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpXG4gICAgICAgIDogeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgY29uc3QgYXJyb3dQYWRkaW5nT2JqZWN0ID0gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddXG4gICAgICA/IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXS5wYWRkaW5nXG4gICAgICA6IGdldEZyZXNoU2lkZU9iamVjdCgpO1xuICAgIGNvbnN0IGFycm93UGFkZGluZ01pbiA9IGFycm93UGFkZGluZ09iamVjdFttYWluU2lkZV07XG4gICAgY29uc3QgYXJyb3dQYWRkaW5nTWF4ID0gYXJyb3dQYWRkaW5nT2JqZWN0W2FsdFNpZGVdO1xuXG4gICAgLy8gSWYgdGhlIHJlZmVyZW5jZSBsZW5ndGggaXMgc21hbGxlciB0aGFuIHRoZSBhcnJvdyBsZW5ndGgsIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXG4gICAgLy8gYW5kIG5lYXIgdGhlIGVkZ2Ugb2YgYSBib3VuZGFyeSwgdGhlIHBvcHBlciBjYW4gb3ZlcmZsb3cgZXZlbiBpZiB0aGVcbiAgICAvLyByZWZlcmVuY2UgaXMgbm90IG92ZXJmbG93aW5nIGFzIHdlbGwgKGUuZy4gdmlydHVhbCBlbGVtZW50cyB3aXRoIG5vXG4gICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxuICAgIGNvbnN0IGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xuXG4gICAgY29uc3QgbWluT2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50XG4gICAgICA/IHJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgLVxuICAgICAgICBhZGRpdGl2ZSAtXG4gICAgICAgIGFycm93TGVuIC1cbiAgICAgICAgYXJyb3dQYWRkaW5nTWluIC1cbiAgICAgICAgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzXG4gICAgICA6IG1pbkxlbiAtXG4gICAgICAgIGFycm93TGVuIC1cbiAgICAgICAgYXJyb3dQYWRkaW5nTWluIC1cbiAgICAgICAgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgIGNvbnN0IG1heE9mZnNldCA9IGlzQmFzZVBsYWNlbWVudFxuICAgICAgPyAtcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiArXG4gICAgICAgIGFkZGl0aXZlICtcbiAgICAgICAgYXJyb3dMZW4gK1xuICAgICAgICBhcnJvd1BhZGRpbmdNYXggK1xuICAgICAgICBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXNcbiAgICAgIDogbWF4TGVuICtcbiAgICAgICAgYXJyb3dMZW4gK1xuICAgICAgICBhcnJvd1BhZGRpbmdNYXggK1xuICAgICAgICBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG5cbiAgICBjb25zdCBhcnJvd09mZnNldFBhcmVudCA9XG4gICAgICBzdGF0ZS5lbGVtZW50cy5hcnJvdyAmJiBnZXRPZmZzZXRQYXJlbnQoc3RhdGUuZWxlbWVudHMuYXJyb3cpO1xuICAgIGNvbnN0IGNsaWVudE9mZnNldCA9IGFycm93T2Zmc2V0UGFyZW50XG4gICAgICA/IG1haW5BeGlzID09PSAneSdcbiAgICAgICAgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRUb3AgfHwgMFxuICAgICAgICA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudExlZnQgfHwgMFxuICAgICAgOiAwO1xuXG4gICAgY29uc3Qgb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IG9mZnNldE1vZGlmaWVyU3RhdGU/LlttYWluQXhpc10gPz8gMDtcbiAgICBjb25zdCB0ZXRoZXJNaW4gPSBvZmZzZXQgKyBtaW5PZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlIC0gY2xpZW50T2Zmc2V0O1xuICAgIGNvbnN0IHRldGhlck1heCA9IG9mZnNldCArIG1heE9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWU7XG5cbiAgICBjb25zdCBwcmV2ZW50ZWRPZmZzZXQgPSB3aXRoaW4oXG4gICAgICB0ZXRoZXIgPyBtYXRoTWluKG1pbiwgdGV0aGVyTWluKSA6IG1pbixcbiAgICAgIG9mZnNldCxcbiAgICAgIHRldGhlciA/IG1hdGhNYXgobWF4LCB0ZXRoZXJNYXgpIDogbWF4XG4gICAgKTtcblxuICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0IC0gb2Zmc2V0O1xuICB9XG5cbiAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgIGNvbnN0IG1haW5TaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IHRvcCA6IGxlZnQ7XG4gICAgY29uc3QgYWx0U2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBib3R0b20gOiByaWdodDtcbiAgICBjb25zdCBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdO1xuXG4gICAgY29uc3QgbGVuID0gYWx0QXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgY29uc3QgbWluID0gb2Zmc2V0ICsgb3ZlcmZsb3dbbWFpblNpZGVdO1xuICAgIGNvbnN0IG1heCA9IG9mZnNldCAtIG92ZXJmbG93W2FsdFNpZGVdO1xuXG4gICAgY29uc3QgaXNPcmlnaW5TaWRlID0gW3RvcCwgbGVmdF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgICBjb25zdCBvZmZzZXRNb2RpZmllclZhbHVlID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZT8uW2FsdEF4aXNdID8/IDA7XG4gICAgY29uc3QgdGV0aGVyTWluID0gaXNPcmlnaW5TaWRlXG4gICAgICA/IG1pblxuICAgICAgOiBvZmZzZXQgLVxuICAgICAgICByZWZlcmVuY2VSZWN0W2xlbl0gLVxuICAgICAgICBwb3BwZXJSZWN0W2xlbl0gLVxuICAgICAgICBvZmZzZXRNb2RpZmllclZhbHVlICtcbiAgICAgICAgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLmFsdEF4aXM7XG4gICAgY29uc3QgdGV0aGVyTWF4ID0gaXNPcmlnaW5TaWRlXG4gICAgICA/IG9mZnNldCArXG4gICAgICAgIHJlZmVyZW5jZVJlY3RbbGVuXSArXG4gICAgICAgIHBvcHBlclJlY3RbbGVuXSAtXG4gICAgICAgIG9mZnNldE1vZGlmaWVyVmFsdWUgLVxuICAgICAgICBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpc1xuICAgICAgOiBtYXg7XG5cbiAgICBjb25zdCBwcmV2ZW50ZWRPZmZzZXQgPVxuICAgICAgdGV0aGVyICYmIGlzT3JpZ2luU2lkZVxuICAgICAgICA/IHdpdGhpbk1heENsYW1wKHRldGhlck1pbiwgb2Zmc2V0LCB0ZXRoZXJNYXgpXG4gICAgICAgIDogd2l0aGluKHRldGhlciA/IHRldGhlck1pbiA6IG1pbiwgb2Zmc2V0LCB0ZXRoZXIgPyB0ZXRoZXJNYXggOiBtYXgpO1xuXG4gICAgcG9wcGVyT2Zmc2V0c1thbHRBeGlzXSA9IHByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW2FsdEF4aXNdID0gcHJldmVudGVkT2Zmc2V0IC0gb2Zmc2V0O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB0eXBlIFByZXZlbnRPdmVyZmxvd01vZGlmaWVyID0gTW9kaWZpZXI8J3ByZXZlbnRPdmVyZmxvdycsIE9wdGlvbnM+O1xuZXhwb3J0IGRlZmF1bHQgKHtcbiAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J10sXG59OiBQcmV2ZW50T3ZlcmZsb3dNb2RpZmllcik7XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBNb2RpZmllciwgTW9kaWZpZXJBcmd1bWVudHMsIFBhZGRpbmcsIFJlY3QgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgdHlwZSB7IFBsYWNlbWVudCB9IGZyb20gJy4uL2VudW1zJztcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gJy4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQnO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSAnLi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QnO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gJy4uL2RvbS11dGlscy9jb250YWlucyc7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gJy4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQnO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tICcuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQnO1xuaW1wb3J0IHsgd2l0aGluIH0gZnJvbSAnLi4vdXRpbHMvd2l0aGluJztcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSAnLi4vdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0JztcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSAnLi4vdXRpbHMvZXhwYW5kVG9IYXNoTWFwJztcbmltcG9ydCB7IGxlZnQsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdG9wLCBib3R0b20gfSBmcm9tICcuLi9lbnVtcyc7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSAnLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBPcHRpb25zID0ge1xuICBlbGVtZW50OiBIVE1MRWxlbWVudCB8IHN0cmluZyB8IG51bGwsXG4gIHBhZGRpbmc6XG4gICAgfCBQYWRkaW5nXG4gICAgfCAoKHt8XG4gICAgICAgIHBvcHBlcjogUmVjdCxcbiAgICAgICAgcmVmZXJlbmNlOiBSZWN0LFxuICAgICAgICBwbGFjZW1lbnQ6IFBsYWNlbWVudCxcbiAgICAgIHx9KSA9PiBQYWRkaW5nKSxcbn07XG5cbmNvbnN0IHRvUGFkZGluZ09iamVjdCA9IChwYWRkaW5nLCBzdGF0ZSkgPT4ge1xuICBwYWRkaW5nID1cbiAgICB0eXBlb2YgcGFkZGluZyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwYWRkaW5nKHsgLi4uc3RhdGUucmVjdHMsIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50IH0pXG4gICAgICA6IHBhZGRpbmc7XG5cbiAgcmV0dXJuIG1lcmdlUGFkZGluZ09iamVjdChcbiAgICB0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcidcbiAgICAgID8gcGFkZGluZ1xuICAgICAgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpXG4gICk7XG59O1xuXG5mdW5jdGlvbiBhcnJvdyh7IHN0YXRlLCBuYW1lLCBvcHRpb25zIH06IE1vZGlmaWVyQXJndW1lbnRzPE9wdGlvbnM+KSB7XG4gIGNvbnN0IGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICBjb25zdCBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICBjb25zdCBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICBjb25zdCBheGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XG4gIGNvbnN0IGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgaWYgKCFhcnJvd0VsZW1lbnQgfHwgIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gdG9QYWRkaW5nT2JqZWN0KG9wdGlvbnMucGFkZGluZywgc3RhdGUpO1xuICBjb25zdCBhcnJvd1JlY3QgPSBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCk7XG4gIGNvbnN0IG1pblByb3AgPSBheGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICBjb25zdCBtYXhQcm9wID0gYXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG5cbiAgY29uc3QgZW5kRGlmZiA9XG4gICAgc3RhdGUucmVjdHMucmVmZXJlbmNlW2xlbl0gK1xuICAgIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXSAtXG4gICAgcG9wcGVyT2Zmc2V0c1theGlzXSAtXG4gICAgc3RhdGUucmVjdHMucG9wcGVyW2xlbl07XG4gIGNvbnN0IHN0YXJ0RGlmZiA9IHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc107XG5cbiAgY29uc3QgYXJyb3dPZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoYXJyb3dFbGVtZW50KTtcbiAgY29uc3QgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50XG4gICAgPyBheGlzID09PSAneSdcbiAgICAgID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDBcbiAgICAgIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggfHwgMFxuICAgIDogMDtcblxuICBjb25zdCBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjtcblxuICAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIHBvcHBlciBpZiB0aGUgY2VudGVyIHBvaW50IGlzXG4gIC8vIG91dHNpZGUgb2YgdGhlIHBvcHBlciBib3VuZHNcbiAgY29uc3QgbWluID0gcGFkZGluZ09iamVjdFttaW5Qcm9wXTtcbiAgY29uc3QgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93UmVjdFtsZW5dIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcbiAgY29uc3QgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd1JlY3RbbGVuXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgY29uc3Qgb2Zmc2V0ID0gd2l0aGluKG1pbiwgY2VudGVyLCBtYXgpO1xuXG4gIC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cbiAgY29uc3QgYXhpc1Byb3A6IHN0cmluZyA9IGF4aXM7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSB7XG4gICAgW2F4aXNQcm9wXTogb2Zmc2V0LFxuICAgIGNlbnRlck9mZnNldDogb2Zmc2V0IC0gY2VudGVyLFxuICB9O1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoeyBzdGF0ZSwgb3B0aW9ucyB9OiBNb2RpZmllckFyZ3VtZW50czxPcHRpb25zPikge1xuICBsZXQgeyBlbGVtZW50OiBhcnJvd0VsZW1lbnQgPSAnW2RhdGEtcG9wcGVyLWFycm93XScgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKGFycm93RWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ1NTIHNlbGVjdG9yXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGFycm93RWxlbWVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFtcbiAgICAgICAgICAnUG9wcGVyOiBcImFycm93XCIgZWxlbWVudCBtdXN0IGJlIGFuIEhUTUxFbGVtZW50IChub3QgYW4gU1ZHRWxlbWVudCkuJyxcbiAgICAgICAgICAnVG8gdXNlIGFuIFNWRyBhcnJvdywgd3JhcCBpdCBpbiBhbiBIVE1MRWxlbWVudCB0aGF0IHdpbGwgYmUgdXNlZCBhcycsXG4gICAgICAgICAgJ3RoZSBhcnJvdy4nLFxuICAgICAgICBdLmpvaW4oJyAnKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnRhaW5zKHN0YXRlLmVsZW1lbnRzLnBvcHBlciwgYXJyb3dFbGVtZW50KSkge1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBbXG4gICAgICAgICAgJ1BvcHBlcjogXCJhcnJvd1wiIG1vZGlmaWVyXFwncyBgZWxlbWVudGAgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBwb3BwZXInLFxuICAgICAgICAgICdlbGVtZW50LicsXG4gICAgICAgIF0uam9pbignICcpXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0YXRlLmVsZW1lbnRzLmFycm93ID0gYXJyb3dFbGVtZW50O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBBcnJvd01vZGlmaWVyID0gTW9kaWZpZXI8J2Fycm93JywgT3B0aW9ucz47XG5leHBvcnQgZGVmYXVsdCAoe1xuICBuYW1lOiAnYXJyb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogYXJyb3csXG4gIGVmZmVjdCxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxufTogQXJyb3dNb2RpZmllcik7XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUge1xuICBNb2RpZmllckFyZ3VtZW50cyxcbiAgTW9kaWZpZXIsXG4gIFJlY3QsXG4gIFNpZGVPYmplY3QsXG4gIE9mZnNldHMsXG59IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCB9IGZyb20gJy4uL2VudW1zJztcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tICcuLi91dGlscy9kZXRlY3RPdmVyZmxvdyc7XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKFxuICBvdmVyZmxvdzogU2lkZU9iamVjdCxcbiAgcmVjdDogUmVjdCxcbiAgcHJldmVudGVkT2Zmc2V0czogT2Zmc2V0cyA9IHsgeDogMCwgeTogMCB9XG4pOiBTaWRlT2JqZWN0IHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0IC0gcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGggKyBwcmV2ZW50ZWRPZmZzZXRzLngsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCArIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aCAtIHByZXZlbnRlZE9mZnNldHMueCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93OiBTaWRlT2JqZWN0KTogYm9vbGVhbiB7XG4gIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5zb21lKChzaWRlKSA9PiBvdmVyZmxvd1tzaWRlXSA+PSAwKTtcbn1cblxuZnVuY3Rpb24gaGlkZSh7IHN0YXRlLCBuYW1lIH06IE1vZGlmaWVyQXJndW1lbnRzPHt8fH0+KSB7XG4gIGNvbnN0IHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIGNvbnN0IHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIGNvbnN0IHByZXZlbnRlZE9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnByZXZlbnRPdmVyZmxvdztcblxuICBjb25zdCByZWZlcmVuY2VPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnLFxuICB9KTtcbiAgY29uc3QgcG9wcGVyQWx0T3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGFsdEJvdW5kYXJ5OiB0cnVlLFxuICB9KTtcblxuICBjb25zdCByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhcbiAgICByZWZlcmVuY2VPdmVyZmxvdyxcbiAgICByZWZlcmVuY2VSZWN0XG4gICk7XG4gIGNvbnN0IHBvcHBlckVzY2FwZU9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhcbiAgICBwb3BwZXJBbHRPdmVyZmxvdyxcbiAgICBwb3BwZXJSZWN0LFxuICAgIHByZXZlbnRlZE9mZnNldHNcbiAgKTtcblxuICBjb25zdCBpc1JlZmVyZW5jZUhpZGRlbiA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMpO1xuICBjb25zdCBoYXNQb3BwZXJFc2NhcGVkID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHBvcHBlckVzY2FwZU9mZnNldHMpO1xuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSB7XG4gICAgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzLFxuICAgIHBvcHBlckVzY2FwZU9mZnNldHMsXG4gICAgaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgaGFzUG9wcGVyRXNjYXBlZCxcbiAgfTtcblxuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IHtcbiAgICAuLi5zdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlcixcbiAgICAnZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbic6IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgICdkYXRhLXBvcHBlci1lc2NhcGVkJzogaGFzUG9wcGVyRXNjYXBlZCxcbiAgfTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgSGlkZU1vZGlmaWVyID0gTW9kaWZpZXI8J2hpZGUnLCB7fHx9PjtcbmV4cG9ydCBkZWZhdWx0ICh7XG4gIG5hbWU6ICdoaWRlJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXSxcbiAgZm46IGhpZGUsXG59OiBIaWRlTW9kaWZpZXIpO1xuIiwiLy8gQGZsb3dcbmltcG9ydCB7IHBvcHBlckdlbmVyYXRvciwgZGV0ZWN0T3ZlcmZsb3cgfSBmcm9tICcuL2NyZWF0ZVBvcHBlcic7XG5cbmltcG9ydCBldmVudExpc3RlbmVycyBmcm9tICcuL21vZGlmaWVycy9ldmVudExpc3RlbmVycyc7XG5pbXBvcnQgcG9wcGVyT2Zmc2V0cyBmcm9tICcuL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzJztcbmltcG9ydCBjb21wdXRlU3R5bGVzIGZyb20gJy4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMnO1xuaW1wb3J0IGFwcGx5U3R5bGVzIGZyb20gJy4vbW9kaWZpZXJzL2FwcGx5U3R5bGVzJztcblxuZXhwb3J0IHR5cGUgKiBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgZGVmYXVsdE1vZGlmaWVycyA9IFtcbiAgZXZlbnRMaXN0ZW5lcnMsXG4gIHBvcHBlck9mZnNldHMsXG4gIGNvbXB1dGVTdHlsZXMsXG4gIGFwcGx5U3R5bGVzLFxuXTtcblxuY29uc3QgY3JlYXRlUG9wcGVyID0gcG9wcGVyR2VuZXJhdG9yKHsgZGVmYXVsdE1vZGlmaWVycyB9KTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHsgY3JlYXRlUG9wcGVyLCBwb3BwZXJHZW5lcmF0b3IsIGRlZmF1bHRNb2RpZmllcnMsIGRldGVjdE92ZXJmbG93IH07XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHsgcG9wcGVyR2VuZXJhdG9yLCBkZXRlY3RPdmVyZmxvdyB9IGZyb20gJy4vY3JlYXRlUG9wcGVyJztcblxuaW1wb3J0IGV2ZW50TGlzdGVuZXJzIGZyb20gJy4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzJztcbmltcG9ydCBwb3BwZXJPZmZzZXRzIGZyb20gJy4vbW9kaWZpZXJzL3BvcHBlck9mZnNldHMnO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSAnLi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcyc7XG5pbXBvcnQgYXBwbHlTdHlsZXMgZnJvbSAnLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMnO1xuaW1wb3J0IG9mZnNldCBmcm9tICcuL21vZGlmaWVycy9vZmZzZXQnO1xuaW1wb3J0IGZsaXAgZnJvbSAnLi9tb2RpZmllcnMvZmxpcCc7XG5pbXBvcnQgcHJldmVudE92ZXJmbG93IGZyb20gJy4vbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdyc7XG5pbXBvcnQgYXJyb3cgZnJvbSAnLi9tb2RpZmllcnMvYXJyb3cnO1xuaW1wb3J0IGhpZGUgZnJvbSAnLi9tb2RpZmllcnMvaGlkZSc7XG5cbmV4cG9ydCB0eXBlICogZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGRlZmF1bHRNb2RpZmllcnMgPSBbXG4gIGV2ZW50TGlzdGVuZXJzLFxuICBwb3BwZXJPZmZzZXRzLFxuICBjb21wdXRlU3R5bGVzLFxuICBhcHBseVN0eWxlcyxcbiAgb2Zmc2V0LFxuICBmbGlwLFxuICBwcmV2ZW50T3ZlcmZsb3csXG4gIGFycm93LFxuICBoaWRlLFxuXTtcblxuY29uc3QgY3JlYXRlUG9wcGVyID0gcG9wcGVyR2VuZXJhdG9yKHsgZGVmYXVsdE1vZGlmaWVycyB9KTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHsgY3JlYXRlUG9wcGVyLCBwb3BwZXJHZW5lcmF0b3IsIGRlZmF1bHRNb2RpZmllcnMsIGRldGVjdE92ZXJmbG93IH07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIgYXMgY3JlYXRlUG9wcGVyTGl0ZSB9IGZyb20gJy4vcG9wcGVyLWxpdGUnO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0ICogZnJvbSAnLi9tb2RpZmllcnMnO1xuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4yLjIpOiB1dGlsL2luZGV4LmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgTUFYX1VJRCA9IDFfMDAwXzAwMFxuY29uc3QgTUlMTElTRUNPTkRTX01VTFRJUExJRVIgPSAxMDAwXG5jb25zdCBUUkFOU0lUSU9OX0VORCA9ICd0cmFuc2l0aW9uZW5kJ1xuXG4vLyBTaG91dC1vdXQgQW5ndXMgQ3JvbGwgKGh0dHBzOi8vZ29vLmdsL3B4d1FHcClcbmNvbnN0IHRvVHlwZSA9IG9iamVjdCA9PiB7XG4gIGlmIChvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYCR7b2JqZWN0fWBcbiAgfVxuXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KS5tYXRjaCgvXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKVxufVxuXG4vKipcbiAqIFB1YmxpYyBVdGlsIEFQSVxuICovXG5cbmNvbnN0IGdldFVJRCA9IHByZWZpeCA9PiB7XG4gIGRvIHtcbiAgICBwcmVmaXggKz0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTUFYX1VJRClcbiAgfSB3aGlsZSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocHJlZml4KSlcblxuICByZXR1cm4gcHJlZml4XG59XG5cbmNvbnN0IGdldFNlbGVjdG9yID0gZWxlbWVudCA9PiB7XG4gIGxldCBzZWxlY3RvciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLXRhcmdldCcpXG5cbiAgaWYgKCFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gJyMnKSB7XG4gICAgbGV0IGhyZWZBdHRyaWJ1dGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpXG5cbiAgICAvLyBUaGUgb25seSB2YWxpZCBjb250ZW50IHRoYXQgY291bGQgZG91YmxlIGFzIGEgc2VsZWN0b3IgYXJlIElEcyBvciBjbGFzc2VzLFxuICAgIC8vIHNvIGV2ZXJ5dGhpbmcgc3RhcnRpbmcgd2l0aCBgI2Agb3IgYC5gLiBJZiBhIFwicmVhbFwiIFVSTCBpcyB1c2VkIGFzIHRoZSBzZWxlY3RvcixcbiAgICAvLyBgZG9jdW1lbnQucXVlcnlTZWxlY3RvcmAgd2lsbCByaWdodGZ1bGx5IGNvbXBsYWluIGl0IGlzIGludmFsaWQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9pc3N1ZXMvMzIyNzNcbiAgICBpZiAoIWhyZWZBdHRyaWJ1dGUgfHwgKCFocmVmQXR0cmlidXRlLmluY2x1ZGVzKCcjJykgJiYgIWhyZWZBdHRyaWJ1dGUuc3RhcnRzV2l0aCgnLicpKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyBKdXN0IGluIGNhc2Ugc29tZSBDTVMgcHV0cyBvdXQgYSBmdWxsIFVSTCB3aXRoIHRoZSBhbmNob3IgYXBwZW5kZWRcbiAgICBpZiAoaHJlZkF0dHJpYnV0ZS5pbmNsdWRlcygnIycpICYmICFocmVmQXR0cmlidXRlLnN0YXJ0c1dpdGgoJyMnKSkge1xuICAgICAgaHJlZkF0dHJpYnV0ZSA9IGAjJHtocmVmQXR0cmlidXRlLnNwbGl0KCcjJylbMV19YFxuICAgIH1cblxuICAgIHNlbGVjdG9yID0gaHJlZkF0dHJpYnV0ZSAmJiBocmVmQXR0cmlidXRlICE9PSAnIycgPyBocmVmQXR0cmlidXRlLnRyaW0oKSA6IG51bGxcbiAgfVxuXG4gIHJldHVybiBzZWxlY3RvclxufVxuXG5jb25zdCBnZXRTZWxlY3RvckZyb21FbGVtZW50ID0gZWxlbWVudCA9PiB7XG4gIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoZWxlbWVudClcblxuICBpZiAoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgPyBzZWxlY3RvciA6IG51bGxcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmNvbnN0IGdldEVsZW1lbnRGcm9tU2VsZWN0b3IgPSBlbGVtZW50ID0+IHtcbiAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihlbGVtZW50KVxuXG4gIHJldHVybiBzZWxlY3RvciA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpIDogbnVsbFxufVxuXG5jb25zdCBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCA9IGVsZW1lbnQgPT4ge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gMFxuICB9XG5cbiAgLy8gR2V0IHRyYW5zaXRpb24tZHVyYXRpb24gb2YgdGhlIGVsZW1lbnRcbiAgbGV0IHsgdHJhbnNpdGlvbkR1cmF0aW9uLCB0cmFuc2l0aW9uRGVsYXkgfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpXG5cbiAgY29uc3QgZmxvYXRUcmFuc2l0aW9uRHVyYXRpb24gPSBOdW1iZXIucGFyc2VGbG9hdCh0cmFuc2l0aW9uRHVyYXRpb24pXG4gIGNvbnN0IGZsb2F0VHJhbnNpdGlvbkRlbGF5ID0gTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KVxuXG4gIC8vIFJldHVybiAwIGlmIGVsZW1lbnQgb3IgdHJhbnNpdGlvbiBkdXJhdGlvbiBpcyBub3QgZm91bmRcbiAgaWYgKCFmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiAmJiAhZmxvYXRUcmFuc2l0aW9uRGVsYXkpIHtcbiAgICByZXR1cm4gMFxuICB9XG5cbiAgLy8gSWYgbXVsdGlwbGUgZHVyYXRpb25zIGFyZSBkZWZpbmVkLCB0YWtlIHRoZSBmaXJzdFxuICB0cmFuc2l0aW9uRHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb24uc3BsaXQoJywnKVswXVxuICB0cmFuc2l0aW9uRGVsYXkgPSB0cmFuc2l0aW9uRGVsYXkuc3BsaXQoJywnKVswXVxuXG4gIHJldHVybiAoTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkR1cmF0aW9uKSArIE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EZWxheSkpICogTUlMTElTRUNPTkRTX01VTFRJUExJRVJcbn1cblxuY29uc3QgdHJpZ2dlclRyYW5zaXRpb25FbmQgPSBlbGVtZW50ID0+IHtcbiAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChUUkFOU0lUSU9OX0VORCkpXG59XG5cbmNvbnN0IGlzRWxlbWVudCA9IG9iamVjdCA9PiB7XG4gIGlmICghb2JqZWN0IHx8IHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAodHlwZW9mIG9iamVjdC5qcXVlcnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0WzBdXG4gIH1cblxuICByZXR1cm4gdHlwZW9mIG9iamVjdC5ub2RlVHlwZSAhPT0gJ3VuZGVmaW5lZCdcbn1cblxuY29uc3QgZ2V0RWxlbWVudCA9IG9iamVjdCA9PiB7XG4gIC8vIGl0J3MgYSBqUXVlcnkgb2JqZWN0IG9yIGEgbm9kZSBlbGVtZW50XG4gIGlmIChpc0VsZW1lbnQob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3QuanF1ZXJ5ID8gb2JqZWN0WzBdIDogb2JqZWN0XG4gIH1cblxuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycgJiYgb2JqZWN0Lmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihvYmplY3QpXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5jb25zdCBpc1Zpc2libGUgPSBlbGVtZW50ID0+IHtcbiAgaWYgKCFpc0VsZW1lbnQoZWxlbWVudCkgfHwgZWxlbWVudC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgZWxlbWVudElzVmlzaWJsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgndmlzaWJpbGl0eScpID09PSAndmlzaWJsZSdcbiAgLy8gSGFuZGxlIGBkZXRhaWxzYCBlbGVtZW50IGFzIGl0cyBjb250ZW50IG1heSBmYWxzaWUgYXBwZWFyIHZpc2libGUgd2hlbiBpdCBpcyBjbG9zZWRcbiAgY29uc3QgY2xvc2VkRGV0YWlscyA9IGVsZW1lbnQuY2xvc2VzdCgnZGV0YWlsczpub3QoW29wZW5dKScpXG5cbiAgaWYgKCFjbG9zZWREZXRhaWxzKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRJc1Zpc2libGVcbiAgfVxuXG4gIGlmIChjbG9zZWREZXRhaWxzICE9PSBlbGVtZW50KSB7XG4gICAgY29uc3Qgc3VtbWFyeSA9IGVsZW1lbnQuY2xvc2VzdCgnc3VtbWFyeScpXG4gICAgaWYgKHN1bW1hcnkgJiYgc3VtbWFyeS5wYXJlbnROb2RlICE9PSBjbG9zZWREZXRhaWxzKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoc3VtbWFyeSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRJc1Zpc2libGVcbn1cblxuY29uc3QgaXNEaXNhYmxlZCA9IGVsZW1lbnQgPT4ge1xuICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmICh0eXBlb2YgZWxlbWVudC5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZWxlbWVudC5kaXNhYmxlZFxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXNhYmxlZCcpICE9PSAnZmFsc2UnXG59XG5cbmNvbnN0IGZpbmRTaGFkb3dSb290ID0gZWxlbWVudCA9PiB7XG4gIGlmICghZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dGFjaFNoYWRvdykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBDYW4gZmluZCB0aGUgc2hhZG93IHJvb3Qgb3RoZXJ3aXNlIGl0J2xsIHJldHVybiB0aGUgZG9jdW1lbnRcbiAgaWYgKHR5cGVvZiBlbGVtZW50LmdldFJvb3ROb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3Qgcm9vdCA9IGVsZW1lbnQuZ2V0Um9vdE5vZGUoKVxuICAgIHJldHVybiByb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHJvb3QgOiBudWxsXG4gIH1cblxuICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICByZXR1cm4gZWxlbWVudFxuICB9XG5cbiAgLy8gd2hlbiB3ZSBkb24ndCBmaW5kIGEgc2hhZG93IHJvb3RcbiAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIGZpbmRTaGFkb3dSb290KGVsZW1lbnQucGFyZW50Tm9kZSlcbn1cblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9XG5cbi8qKlxuICogVHJpY2sgdG8gcmVzdGFydCBhbiBlbGVtZW50J3MgYW5pbWF0aW9uXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB2b2lkXG4gKlxuICogQHNlZSBodHRwczovL3d3dy5jaGFyaXN0aGVvLmlvL2Jsb2cvMjAyMS8wMi9yZXN0YXJ0LWEtY3NzLWFuaW1hdGlvbi13aXRoLWphdmFzY3JpcHQvI3Jlc3RhcnRpbmctYS1jc3MtYW5pbWF0aW9uXG4gKi9cbmNvbnN0IHJlZmxvdyA9IGVsZW1lbnQgPT4ge1xuICBlbGVtZW50Lm9mZnNldEhlaWdodCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xufVxuXG5jb25zdCBnZXRqUXVlcnkgPSAoKSA9PiB7XG4gIGlmICh3aW5kb3cualF1ZXJ5ICYmICFkb2N1bWVudC5ib2R5Lmhhc0F0dHJpYnV0ZSgnZGF0YS1icy1uby1qcXVlcnknKSkge1xuICAgIHJldHVybiB3aW5kb3cualF1ZXJ5XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5jb25zdCBET01Db250ZW50TG9hZGVkQ2FsbGJhY2tzID0gW11cblxuY29uc3Qgb25ET01Db250ZW50TG9hZGVkID0gY2FsbGJhY2sgPT4ge1xuICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgLy8gYWRkIGxpc3RlbmVyIG9uIHRoZSBmaXJzdCBjYWxsIHdoZW4gdGhlIGRvY3VtZW50IGlzIGluIGxvYWRpbmcgc3RhdGVcbiAgICBpZiAoIURPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIERPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MpIHtcbiAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgRE9NQ29udGVudExvYWRlZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKVxuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKClcbiAgfVxufVxuXG5jb25zdCBpc1JUTCA9ICgpID0+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kaXIgPT09ICdydGwnXG5cbmNvbnN0IGRlZmluZUpRdWVyeVBsdWdpbiA9IHBsdWdpbiA9PiB7XG4gIG9uRE9NQ29udGVudExvYWRlZCgoKSA9PiB7XG4gICAgY29uc3QgJCA9IGdldGpRdWVyeSgpXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCQpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBwbHVnaW4uTkFNRVxuICAgICAgY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltuYW1lXVxuICAgICAgJC5mbltuYW1lXSA9IHBsdWdpbi5qUXVlcnlJbnRlcmZhY2VcbiAgICAgICQuZm5bbmFtZV0uQ29uc3RydWN0b3IgPSBwbHVnaW5cbiAgICAgICQuZm5bbmFtZV0ubm9Db25mbGljdCA9ICgpID0+IHtcbiAgICAgICAgJC5mbltuYW1lXSA9IEpRVUVSWV9OT19DT05GTElDVFxuICAgICAgICByZXR1cm4gcGx1Z2luLmpRdWVyeUludGVyZmFjZVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuY29uc3QgZXhlY3V0ZSA9IGNhbGxiYWNrID0+IHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrKClcbiAgfVxufVxuXG5jb25zdCBleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uID0gKGNhbGxiYWNrLCB0cmFuc2l0aW9uRWxlbWVudCwgd2FpdEZvclRyYW5zaXRpb24gPSB0cnVlKSA9PiB7XG4gIGlmICghd2FpdEZvclRyYW5zaXRpb24pIHtcbiAgICBleGVjdXRlKGNhbGxiYWNrKVxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgZHVyYXRpb25QYWRkaW5nID0gNVxuICBjb25zdCBlbXVsYXRlZER1cmF0aW9uID0gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodHJhbnNpdGlvbkVsZW1lbnQpICsgZHVyYXRpb25QYWRkaW5nXG5cbiAgbGV0IGNhbGxlZCA9IGZhbHNlXG5cbiAgY29uc3QgaGFuZGxlciA9ICh7IHRhcmdldCB9KSA9PiB7XG4gICAgaWYgKHRhcmdldCAhPT0gdHJhbnNpdGlvbkVsZW1lbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNhbGxlZCA9IHRydWVcbiAgICB0cmFuc2l0aW9uRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFRSQU5TSVRJT05fRU5ELCBoYW5kbGVyKVxuICAgIGV4ZWN1dGUoY2FsbGJhY2spXG4gIH1cblxuICB0cmFuc2l0aW9uRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFRSQU5TSVRJT05fRU5ELCBoYW5kbGVyKVxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgdHJpZ2dlclRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkVsZW1lbnQpXG4gICAgfVxuICB9LCBlbXVsYXRlZER1cmF0aW9uKVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgcHJldmlvdXMvbmV4dCBlbGVtZW50IG9mIGEgbGlzdC5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBsaXN0ICAgIFRoZSBsaXN0IG9mIGVsZW1lbnRzXG4gKiBAcGFyYW0gYWN0aXZlRWxlbWVudCAgIFRoZSBhY3RpdmUgZWxlbWVudFxuICogQHBhcmFtIHNob3VsZEdldE5leHQgICBDaG9vc2UgdG8gZ2V0IG5leHQgb3IgcHJldmlvdXMgZWxlbWVudFxuICogQHBhcmFtIGlzQ3ljbGVBbGxvd2VkXG4gKiBAcmV0dXJuIHtFbGVtZW50fGVsZW19IFRoZSBwcm9wZXIgZWxlbWVudFxuICovXG5jb25zdCBnZXROZXh0QWN0aXZlRWxlbWVudCA9IChsaXN0LCBhY3RpdmVFbGVtZW50LCBzaG91bGRHZXROZXh0LCBpc0N5Y2xlQWxsb3dlZCkgPT4ge1xuICBjb25zdCBsaXN0TGVuZ3RoID0gbGlzdC5sZW5ndGhcbiAgbGV0IGluZGV4ID0gbGlzdC5pbmRleE9mKGFjdGl2ZUVsZW1lbnQpXG5cbiAgLy8gaWYgdGhlIGVsZW1lbnQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxpc3QgcmV0dXJuIGFuIGVsZW1lbnRcbiAgLy8gZGVwZW5kaW5nIG9uIHRoZSBkaXJlY3Rpb24gYW5kIGlmIGN5Y2xlIGlzIGFsbG93ZWRcbiAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiAhc2hvdWxkR2V0TmV4dCAmJiBpc0N5Y2xlQWxsb3dlZCA/IGxpc3RbbGlzdExlbmd0aCAtIDFdIDogbGlzdFswXVxuICB9XG5cbiAgaW5kZXggKz0gc2hvdWxkR2V0TmV4dCA/IDEgOiAtMVxuXG4gIGlmIChpc0N5Y2xlQWxsb3dlZCkge1xuICAgIGluZGV4ID0gKGluZGV4ICsgbGlzdExlbmd0aCkgJSBsaXN0TGVuZ3RoXG4gIH1cblxuICByZXR1cm4gbGlzdFtNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgbGlzdExlbmd0aCAtIDEpKV1cbn1cblxuZXhwb3J0IHtcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luLFxuICBleGVjdXRlLFxuICBleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uLFxuICBmaW5kU2hhZG93Um9vdCxcbiAgZ2V0RWxlbWVudCxcbiAgZ2V0RWxlbWVudEZyb21TZWxlY3RvcixcbiAgZ2V0alF1ZXJ5LFxuICBnZXROZXh0QWN0aXZlRWxlbWVudCxcbiAgZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCxcbiAgZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQsXG4gIGdldFVJRCxcbiAgaXNEaXNhYmxlZCxcbiAgaXNFbGVtZW50LFxuICBpc1JUTCxcbiAgaXNWaXNpYmxlLFxuICBub29wLFxuICBvbkRPTUNvbnRlbnRMb2FkZWQsXG4gIHJlZmxvdyxcbiAgdHJpZ2dlclRyYW5zaXRpb25FbmQsXG4gIHRvVHlwZVxufVxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4yLjIpOiBkb20vZXZlbnQtaGFuZGxlci5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCB7IGdldGpRdWVyeSB9IGZyb20gJy4uL3V0aWwvaW5kZXgnXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgbmFtZXNwYWNlUmVnZXggPSAvW14uXSooPz1cXC4uKilcXC58LiovXG5jb25zdCBzdHJpcE5hbWVSZWdleCA9IC9cXC4uKi9cbmNvbnN0IHN0cmlwVWlkUmVnZXggPSAvOjpcXGQrJC9cbmNvbnN0IGV2ZW50UmVnaXN0cnkgPSB7fSAvLyBFdmVudHMgc3RvcmFnZVxubGV0IHVpZEV2ZW50ID0gMVxuY29uc3QgY3VzdG9tRXZlbnRzID0ge1xuICBtb3VzZWVudGVyOiAnbW91c2VvdmVyJyxcbiAgbW91c2VsZWF2ZTogJ21vdXNlb3V0J1xufVxuXG5jb25zdCBuYXRpdmVFdmVudHMgPSBuZXcgU2V0KFtcbiAgJ2NsaWNrJyxcbiAgJ2RibGNsaWNrJyxcbiAgJ21vdXNldXAnLFxuICAnbW91c2Vkb3duJyxcbiAgJ2NvbnRleHRtZW51JyxcbiAgJ21vdXNld2hlZWwnLFxuICAnRE9NTW91c2VTY3JvbGwnLFxuICAnbW91c2VvdmVyJyxcbiAgJ21vdXNlb3V0JyxcbiAgJ21vdXNlbW92ZScsXG4gICdzZWxlY3RzdGFydCcsXG4gICdzZWxlY3RlbmQnLFxuICAna2V5ZG93bicsXG4gICdrZXlwcmVzcycsXG4gICdrZXl1cCcsXG4gICdvcmllbnRhdGlvbmNoYW5nZScsXG4gICd0b3VjaHN0YXJ0JyxcbiAgJ3RvdWNobW92ZScsXG4gICd0b3VjaGVuZCcsXG4gICd0b3VjaGNhbmNlbCcsXG4gICdwb2ludGVyZG93bicsXG4gICdwb2ludGVybW92ZScsXG4gICdwb2ludGVydXAnLFxuICAncG9pbnRlcmxlYXZlJyxcbiAgJ3BvaW50ZXJjYW5jZWwnLFxuICAnZ2VzdHVyZXN0YXJ0JyxcbiAgJ2dlc3R1cmVjaGFuZ2UnLFxuICAnZ2VzdHVyZWVuZCcsXG4gICdmb2N1cycsXG4gICdibHVyJyxcbiAgJ2NoYW5nZScsXG4gICdyZXNldCcsXG4gICdzZWxlY3QnLFxuICAnc3VibWl0JyxcbiAgJ2ZvY3VzaW4nLFxuICAnZm9jdXNvdXQnLFxuICAnbG9hZCcsXG4gICd1bmxvYWQnLFxuICAnYmVmb3JldW5sb2FkJyxcbiAgJ3Jlc2l6ZScsXG4gICdtb3ZlJyxcbiAgJ0RPTUNvbnRlbnRMb2FkZWQnLFxuICAncmVhZHlzdGF0ZWNoYW5nZScsXG4gICdlcnJvcicsXG4gICdhYm9ydCcsXG4gICdzY3JvbGwnXG5dKVxuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kc1xuICovXG5cbmZ1bmN0aW9uIG1ha2VFdmVudFVpZChlbGVtZW50LCB1aWQpIHtcbiAgcmV0dXJuICh1aWQgJiYgYCR7dWlkfTo6JHt1aWRFdmVudCsrfWApIHx8IGVsZW1lbnQudWlkRXZlbnQgfHwgdWlkRXZlbnQrK1xufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50RXZlbnRzKGVsZW1lbnQpIHtcbiAgY29uc3QgdWlkID0gbWFrZUV2ZW50VWlkKGVsZW1lbnQpXG5cbiAgZWxlbWVudC51aWRFdmVudCA9IHVpZFxuICBldmVudFJlZ2lzdHJ5W3VpZF0gPSBldmVudFJlZ2lzdHJ5W3VpZF0gfHwge31cblxuICByZXR1cm4gZXZlbnRSZWdpc3RyeVt1aWRdXG59XG5cbmZ1bmN0aW9uIGJvb3RzdHJhcEhhbmRsZXIoZWxlbWVudCwgZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZXIoZXZlbnQpIHtcbiAgICBoeWRyYXRlT2JqKGV2ZW50LCB7IGRlbGVnYXRlVGFyZ2V0OiBlbGVtZW50IH0pXG5cbiAgICBpZiAoaGFuZGxlci5vbmVPZmYpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgZXZlbnQudHlwZSwgZm4pXG4gICAgfVxuXG4gICAgcmV0dXJuIGZuLmFwcGx5KGVsZW1lbnQsIFtldmVudF0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIoZWxlbWVudCwgc2VsZWN0b3IsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgY29uc3QgZG9tRWxlbWVudHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpXG5cbiAgICBmb3IgKGxldCB7IHRhcmdldCB9ID0gZXZlbnQ7IHRhcmdldCAmJiB0YXJnZXQgIT09IHRoaXM7IHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlKSB7XG4gICAgICBmb3IgKGNvbnN0IGRvbUVsZW1lbnQgb2YgZG9tRWxlbWVudHMpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQgIT09IHRhcmdldCkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBoeWRyYXRlT2JqKGV2ZW50LCB7IGRlbGVnYXRlVGFyZ2V0OiB0YXJnZXQgfSlcblxuICAgICAgICBpZiAoaGFuZGxlci5vbmVPZmYpIHtcbiAgICAgICAgICBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsIGV2ZW50LnR5cGUsIHNlbGVjdG9yLCBmbilcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0YXJnZXQsIFtldmVudF0pXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRIYW5kbGVyKGV2ZW50cywgY2FsbGFibGUsIGRlbGVnYXRpb25TZWxlY3RvciA9IG51bGwpIHtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZXZlbnRzKVxuICAgIC5maW5kKGV2ZW50ID0+IGV2ZW50LmNhbGxhYmxlID09PSBjYWxsYWJsZSAmJiBldmVudC5kZWxlZ2F0aW9uU2VsZWN0b3IgPT09IGRlbGVnYXRpb25TZWxlY3Rvcilcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUGFyYW1ldGVycyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKSB7XG4gIGNvbnN0IGlzRGVsZWdhdGVkID0gdHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnXG4gIC8vIHRvZG86IHRvb2x0aXAgcGFzc2VzIGBmYWxzZWAgaW5zdGVhZCBvZiBzZWxlY3Rvciwgc28gd2UgbmVlZCB0byBjaGVja1xuICBjb25zdCBjYWxsYWJsZSA9IGlzRGVsZWdhdGVkID8gZGVsZWdhdGlvbkZ1bmN0aW9uIDogKGhhbmRsZXIgfHwgZGVsZWdhdGlvbkZ1bmN0aW9uKVxuICBsZXQgdHlwZUV2ZW50ID0gZ2V0VHlwZUV2ZW50KG9yaWdpbmFsVHlwZUV2ZW50KVxuXG4gIGlmICghbmF0aXZlRXZlbnRzLmhhcyh0eXBlRXZlbnQpKSB7XG4gICAgdHlwZUV2ZW50ID0gb3JpZ2luYWxUeXBlRXZlbnRcbiAgfVxuXG4gIHJldHVybiBbaXNEZWxlZ2F0ZWQsIGNhbGxhYmxlLCB0eXBlRXZlbnRdXG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXIoZWxlbWVudCwgb3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbiwgb25lT2ZmKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWxUeXBlRXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBsZXQgW2lzRGVsZWdhdGVkLCBjYWxsYWJsZSwgdHlwZUV2ZW50XSA9IG5vcm1hbGl6ZVBhcmFtZXRlcnMob3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbilcblxuICAvLyBpbiBjYXNlIG9mIG1vdXNlZW50ZXIgb3IgbW91c2VsZWF2ZSB3cmFwIHRoZSBoYW5kbGVyIHdpdGhpbiBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGZvciBpdHMgRE9NIHBvc2l0aW9uXG4gIC8vIHRoaXMgcHJldmVudHMgdGhlIGhhbmRsZXIgZnJvbSBiZWluZyBkaXNwYXRjaGVkIHRoZSBzYW1lIHdheSBhcyBtb3VzZW92ZXIgb3IgbW91c2VvdXQgZG9lc1xuICBpZiAob3JpZ2luYWxUeXBlRXZlbnQgaW4gY3VzdG9tRXZlbnRzKSB7XG4gICAgY29uc3Qgd3JhcEZ1bmN0aW9uID0gZm4gPT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIWV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgKGV2ZW50LnJlbGF0ZWRUYXJnZXQgIT09IGV2ZW50LmRlbGVnYXRlVGFyZ2V0ICYmICFldmVudC5kZWxlZ2F0ZVRhcmdldC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkpIHtcbiAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNhbGxhYmxlID0gd3JhcEZ1bmN0aW9uKGNhbGxhYmxlKVxuICB9XG5cbiAgY29uc3QgZXZlbnRzID0gZ2V0RWxlbWVudEV2ZW50cyhlbGVtZW50KVxuICBjb25zdCBoYW5kbGVycyA9IGV2ZW50c1t0eXBlRXZlbnRdIHx8IChldmVudHNbdHlwZUV2ZW50XSA9IHt9KVxuICBjb25zdCBwcmV2aW91c0Z1bmN0aW9uID0gZmluZEhhbmRsZXIoaGFuZGxlcnMsIGNhbGxhYmxlLCBpc0RlbGVnYXRlZCA/IGhhbmRsZXIgOiBudWxsKVxuXG4gIGlmIChwcmV2aW91c0Z1bmN0aW9uKSB7XG4gICAgcHJldmlvdXNGdW5jdGlvbi5vbmVPZmYgPSBwcmV2aW91c0Z1bmN0aW9uLm9uZU9mZiAmJiBvbmVPZmZcblxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgdWlkID0gbWFrZUV2ZW50VWlkKGNhbGxhYmxlLCBvcmlnaW5hbFR5cGVFdmVudC5yZXBsYWNlKG5hbWVzcGFjZVJlZ2V4LCAnJykpXG4gIGNvbnN0IGZuID0gaXNEZWxlZ2F0ZWQgP1xuICAgIGJvb3RzdHJhcERlbGVnYXRpb25IYW5kbGVyKGVsZW1lbnQsIGhhbmRsZXIsIGNhbGxhYmxlKSA6XG4gICAgYm9vdHN0cmFwSGFuZGxlcihlbGVtZW50LCBjYWxsYWJsZSlcblxuICBmbi5kZWxlZ2F0aW9uU2VsZWN0b3IgPSBpc0RlbGVnYXRlZCA/IGhhbmRsZXIgOiBudWxsXG4gIGZuLmNhbGxhYmxlID0gY2FsbGFibGVcbiAgZm4ub25lT2ZmID0gb25lT2ZmXG4gIGZuLnVpZEV2ZW50ID0gdWlkXG4gIGhhbmRsZXJzW3VpZF0gPSBmblxuXG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlRXZlbnQsIGZuLCBpc0RlbGVnYXRlZClcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvblNlbGVjdG9yKSB7XG4gIGNvbnN0IGZuID0gZmluZEhhbmRsZXIoZXZlbnRzW3R5cGVFdmVudF0sIGhhbmRsZXIsIGRlbGVnYXRpb25TZWxlY3RvcilcblxuICBpZiAoIWZuKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZUV2ZW50LCBmbiwgQm9vbGVhbihkZWxlZ2F0aW9uU2VsZWN0b3IpKVxuICBkZWxldGUgZXZlbnRzW3R5cGVFdmVudF1bZm4udWlkRXZlbnRdXG59XG5cbmZ1bmN0aW9uIHJlbW92ZU5hbWVzcGFjZWRIYW5kbGVycyhlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgbmFtZXNwYWNlKSB7XG4gIGNvbnN0IHN0b3JlRWxlbWVudEV2ZW50ID0gZXZlbnRzW3R5cGVFdmVudF0gfHwge31cblxuICBmb3IgKGNvbnN0IGhhbmRsZXJLZXkgb2YgT2JqZWN0LmtleXMoc3RvcmVFbGVtZW50RXZlbnQpKSB7XG4gICAgaWYgKGhhbmRsZXJLZXkuaW5jbHVkZXMobmFtZXNwYWNlKSkge1xuICAgICAgY29uc3QgZXZlbnQgPSBzdG9yZUVsZW1lbnRFdmVudFtoYW5kbGVyS2V5XVxuICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgZXZlbnQuY2FsbGFibGUsIGV2ZW50LmRlbGVnYXRpb25TZWxlY3RvcilcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VHlwZUV2ZW50KGV2ZW50KSB7XG4gIC8vIGFsbG93IHRvIGdldCB0aGUgbmF0aXZlIGV2ZW50cyBmcm9tIG5hbWVzcGFjZWQgZXZlbnRzICgnY2xpY2suYnMuYnV0dG9uJyAtLT4gJ2NsaWNrJylcbiAgZXZlbnQgPSBldmVudC5yZXBsYWNlKHN0cmlwTmFtZVJlZ2V4LCAnJylcbiAgcmV0dXJuIGN1c3RvbUV2ZW50c1tldmVudF0gfHwgZXZlbnRcbn1cblxuY29uc3QgRXZlbnRIYW5kbGVyID0ge1xuICBvbihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKSB7XG4gICAgYWRkSGFuZGxlcihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uLCBmYWxzZSlcbiAgfSxcblxuICBvbmUoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbikge1xuICAgIGFkZEhhbmRsZXIoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbiwgdHJ1ZSlcbiAgfSxcblxuICBvZmYoZWxlbWVudCwgb3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbikge1xuICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxUeXBlRXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBbaXNEZWxlZ2F0ZWQsIGNhbGxhYmxlLCB0eXBlRXZlbnRdID0gbm9ybWFsaXplUGFyYW1ldGVycyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKVxuICAgIGNvbnN0IGluTmFtZXNwYWNlID0gdHlwZUV2ZW50ICE9PSBvcmlnaW5hbFR5cGVFdmVudFxuICAgIGNvbnN0IGV2ZW50cyA9IGdldEVsZW1lbnRFdmVudHMoZWxlbWVudClcbiAgICBjb25zdCBzdG9yZUVsZW1lbnRFdmVudCA9IGV2ZW50c1t0eXBlRXZlbnRdIHx8IHt9XG4gICAgY29uc3QgaXNOYW1lc3BhY2UgPSBvcmlnaW5hbFR5cGVFdmVudC5zdGFydHNXaXRoKCcuJylcblxuICAgIGlmICh0eXBlb2YgY2FsbGFibGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBTaW1wbGVzdCBjYXNlOiBoYW5kbGVyIGlzIHBhc3NlZCwgcmVtb3ZlIHRoYXQgbGlzdGVuZXIgT05MWS5cbiAgICAgIGlmICghT2JqZWN0LmtleXMoc3RvcmVFbGVtZW50RXZlbnQpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgY2FsbGFibGUsIGlzRGVsZWdhdGVkID8gaGFuZGxlciA6IG51bGwpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaXNOYW1lc3BhY2UpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudEV2ZW50IG9mIE9iamVjdC5rZXlzKGV2ZW50cykpIHtcbiAgICAgICAgcmVtb3ZlTmFtZXNwYWNlZEhhbmRsZXJzKGVsZW1lbnQsIGV2ZW50cywgZWxlbWVudEV2ZW50LCBvcmlnaW5hbFR5cGVFdmVudC5zbGljZSgxKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleUhhbmRsZXJzIG9mIE9iamVjdC5rZXlzKHN0b3JlRWxlbWVudEV2ZW50KSkge1xuICAgICAgY29uc3QgaGFuZGxlcktleSA9IGtleUhhbmRsZXJzLnJlcGxhY2Uoc3RyaXBVaWRSZWdleCwgJycpXG5cbiAgICAgIGlmICghaW5OYW1lc3BhY2UgfHwgb3JpZ2luYWxUeXBlRXZlbnQuaW5jbHVkZXMoaGFuZGxlcktleSkpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBzdG9yZUVsZW1lbnRFdmVudFtrZXlIYW5kbGVyc11cbiAgICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgZXZlbnQuY2FsbGFibGUsIGV2ZW50LmRlbGVnYXRpb25TZWxlY3RvcilcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdHJpZ2dlcihlbGVtZW50LCBldmVudCwgYXJncykge1xuICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0ICQgPSBnZXRqUXVlcnkoKVxuICAgIGNvbnN0IHR5cGVFdmVudCA9IGdldFR5cGVFdmVudChldmVudClcbiAgICBjb25zdCBpbk5hbWVzcGFjZSA9IGV2ZW50ICE9PSB0eXBlRXZlbnRcblxuICAgIGxldCBqUXVlcnlFdmVudCA9IG51bGxcbiAgICBsZXQgYnViYmxlcyA9IHRydWVcbiAgICBsZXQgbmF0aXZlRGlzcGF0Y2ggPSB0cnVlXG4gICAgbGV0IGRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZVxuXG4gICAgaWYgKGluTmFtZXNwYWNlICYmICQpIHtcbiAgICAgIGpRdWVyeUV2ZW50ID0gJC5FdmVudChldmVudCwgYXJncylcblxuICAgICAgJChlbGVtZW50KS50cmlnZ2VyKGpRdWVyeUV2ZW50KVxuICAgICAgYnViYmxlcyA9ICFqUXVlcnlFdmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpXG4gICAgICBuYXRpdmVEaXNwYXRjaCA9ICFqUXVlcnlFdmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpXG4gICAgICBkZWZhdWx0UHJldmVudGVkID0galF1ZXJ5RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKClcbiAgICB9XG5cbiAgICBsZXQgZXZ0ID0gbmV3IEV2ZW50KGV2ZW50LCB7IGJ1YmJsZXMsIGNhbmNlbGFibGU6IHRydWUgfSlcbiAgICBldnQgPSBoeWRyYXRlT2JqKGV2dCwgYXJncylcblxuICAgIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKVxuICAgIH1cblxuICAgIGlmIChuYXRpdmVEaXNwYXRjaCkge1xuICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2dClcbiAgICB9XG5cbiAgICBpZiAoZXZ0LmRlZmF1bHRQcmV2ZW50ZWQgJiYgalF1ZXJ5RXZlbnQpIHtcbiAgICAgIGpRdWVyeUV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICB9XG5cbiAgICByZXR1cm4gZXZ0XG4gIH1cbn1cblxuZnVuY3Rpb24gaHlkcmF0ZU9iaihvYmosIG1ldGEpIHtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWV0YSB8fCB7fSkpIHtcbiAgICB0cnkge1xuICAgICAgb2JqW2tleV0gPSB2YWx1ZVxuICAgIH0gY2F0Y2gge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRIYW5kbGVyXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjIuMik6IGRvbS9kYXRhLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBlbGVtZW50TWFwID0gbmV3IE1hcCgpXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc2V0KGVsZW1lbnQsIGtleSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoIWVsZW1lbnRNYXAuaGFzKGVsZW1lbnQpKSB7XG4gICAgICBlbGVtZW50TWFwLnNldChlbGVtZW50LCBuZXcgTWFwKCkpXG4gICAgfVxuXG4gICAgY29uc3QgaW5zdGFuY2VNYXAgPSBlbGVtZW50TWFwLmdldChlbGVtZW50KVxuXG4gICAgLy8gbWFrZSBpdCBjbGVhciB3ZSBvbmx5IHdhbnQgb25lIGluc3RhbmNlIHBlciBlbGVtZW50XG4gICAgLy8gY2FuIGJlIHJlbW92ZWQgbGF0ZXIgd2hlbiBtdWx0aXBsZSBrZXkvaW5zdGFuY2VzIGFyZSBmaW5lIHRvIGJlIHVzZWRcbiAgICBpZiAoIWluc3RhbmNlTWFwLmhhcyhrZXkpICYmIGluc3RhbmNlTWFwLnNpemUgIT09IDApIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmVycm9yKGBCb290c3RyYXAgZG9lc24ndCBhbGxvdyBtb3JlIHRoYW4gb25lIGluc3RhbmNlIHBlciBlbGVtZW50LiBCb3VuZCBpbnN0YW5jZTogJHtBcnJheS5mcm9tKGluc3RhbmNlTWFwLmtleXMoKSlbMF19LmApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpbnN0YW5jZU1hcC5zZXQoa2V5LCBpbnN0YW5jZSlcbiAgfSxcblxuICBnZXQoZWxlbWVudCwga2V5KSB7XG4gICAgaWYgKGVsZW1lbnRNYXAuaGFzKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gZWxlbWVudE1hcC5nZXQoZWxlbWVudCkuZ2V0KGtleSkgfHwgbnVsbFxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG4gIH0sXG5cbiAgcmVtb3ZlKGVsZW1lbnQsIGtleSkge1xuICAgIGlmICghZWxlbWVudE1hcC5oYXMoZWxlbWVudCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbmNlTWFwID0gZWxlbWVudE1hcC5nZXQoZWxlbWVudClcblxuICAgIGluc3RhbmNlTWFwLmRlbGV0ZShrZXkpXG5cbiAgICAvLyBmcmVlIHVwIGVsZW1lbnQgcmVmZXJlbmNlcyBpZiB0aGVyZSBhcmUgbm8gaW5zdGFuY2VzIGxlZnQgZm9yIGFuIGVsZW1lbnRcbiAgICBpZiAoaW5zdGFuY2VNYXAuc2l6ZSA9PT0gMCkge1xuICAgICAgZWxlbWVudE1hcC5kZWxldGUoZWxlbWVudClcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMi4yKTogZG9tL21hbmlwdWxhdG9yLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplRGF0YSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09ICd0cnVlJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAodmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gTnVtYmVyKHZhbHVlKS50b1N0cmluZygpKSB7XG4gICAgcmV0dXJuIE51bWJlcih2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09ICdudWxsJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVEYXRhS2V5KGtleSkge1xuICByZXR1cm4ga2V5LnJlcGxhY2UoL1tBLVpdL2csIGNociA9PiBgLSR7Y2hyLnRvTG93ZXJDYXNlKCl9YClcbn1cblxuY29uc3QgTWFuaXB1bGF0b3IgPSB7XG4gIHNldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwga2V5LCB2YWx1ZSkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGBkYXRhLWJzLSR7bm9ybWFsaXplRGF0YUtleShrZXkpfWAsIHZhbHVlKVxuICB9LFxuXG4gIHJlbW92ZURhdGFBdHRyaWJ1dGUoZWxlbWVudCwga2V5KSB7XG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtYnMtJHtub3JtYWxpemVEYXRhS2V5KGtleSl9YClcbiAgfSxcblxuICBnZXREYXRhQXR0cmlidXRlcyhlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4ge31cbiAgICB9XG5cbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge31cbiAgICBjb25zdCBic0tleXMgPSBPYmplY3Qua2V5cyhlbGVtZW50LmRhdGFzZXQpLmZpbHRlcihrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ2JzJykgJiYgIWtleS5zdGFydHNXaXRoKCdic0NvbmZpZycpKVxuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgYnNLZXlzKSB7XG4gICAgICBsZXQgcHVyZUtleSA9IGtleS5yZXBsYWNlKC9eYnMvLCAnJylcbiAgICAgIHB1cmVLZXkgPSBwdXJlS2V5LmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgcHVyZUtleS5zbGljZSgxLCBwdXJlS2V5Lmxlbmd0aClcbiAgICAgIGF0dHJpYnV0ZXNbcHVyZUtleV0gPSBub3JtYWxpemVEYXRhKGVsZW1lbnQuZGF0YXNldFtrZXldKVxuICAgIH1cblxuICAgIHJldHVybiBhdHRyaWJ1dGVzXG4gIH0sXG5cbiAgZ2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBrZXkpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplRGF0YShlbGVtZW50LmdldEF0dHJpYnV0ZShgZGF0YS1icy0ke25vcm1hbGl6ZURhdGFLZXkoa2V5KX1gKSlcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNYW5pcHVsYXRvclxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4yLjIpOiB1dGlsL2NvbmZpZy5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCB7IGlzRWxlbWVudCwgdG9UeXBlIH0gZnJvbSAnLi9pbmRleCdcbmltcG9ydCBNYW5pcHVsYXRvciBmcm9tICcuLi9kb20vbWFuaXB1bGF0b3InXG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIENvbmZpZyB7XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiB7fVxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBoYXZlIHRvIGltcGxlbWVudCB0aGUgc3RhdGljIG1ldGhvZCBcIk5BTUVcIiwgZm9yIGVhY2ggY29tcG9uZW50IScpXG4gIH1cblxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IHRoaXMuX21lcmdlQ29uZmlnT2JqKGNvbmZpZylcbiAgICBjb25maWcgPSB0aGlzLl9jb25maWdBZnRlck1lcmdlKGNvbmZpZylcbiAgICB0aGlzLl90eXBlQ2hlY2tDb25maWcoY29uZmlnKVxuICAgIHJldHVybiBjb25maWdcbiAgfVxuXG4gIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xuICAgIHJldHVybiBjb25maWdcbiAgfVxuXG4gIF9tZXJnZUNvbmZpZ09iaihjb25maWcsIGVsZW1lbnQpIHtcbiAgICBjb25zdCBqc29uQ29uZmlnID0gaXNFbGVtZW50KGVsZW1lbnQpID8gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCAnY29uZmlnJykgOiB7fSAvLyB0cnkgdG8gcGFyc2VcblxuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsXG4gICAgICAuLi4odHlwZW9mIGpzb25Db25maWcgPT09ICdvYmplY3QnID8ganNvbkNvbmZpZyA6IHt9KSxcbiAgICAgIC4uLihpc0VsZW1lbnQoZWxlbWVudCkgPyBNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyhlbGVtZW50KSA6IHt9KSxcbiAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IHt9KVxuICAgIH1cbiAgfVxuXG4gIF90eXBlQ2hlY2tDb25maWcoY29uZmlnLCBjb25maWdUeXBlcyA9IHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpIHtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIE9iamVjdC5rZXlzKGNvbmZpZ1R5cGVzKSkge1xuICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IGNvbmZpZ1R5cGVzW3Byb3BlcnR5XVxuICAgICAgY29uc3QgdmFsdWUgPSBjb25maWdbcHJvcGVydHldXG4gICAgICBjb25zdCB2YWx1ZVR5cGUgPSBpc0VsZW1lbnQodmFsdWUpID8gJ2VsZW1lbnQnIDogdG9UeXBlKHZhbHVlKVxuXG4gICAgICBpZiAoIW5ldyBSZWdFeHAoZXhwZWN0ZWRUeXBlcykudGVzdCh2YWx1ZVR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgYCR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FLnRvVXBwZXJDYXNlKCl9OiBPcHRpb24gXCIke3Byb3BlcnR5fVwiIHByb3ZpZGVkIHR5cGUgXCIke3ZhbHVlVHlwZX1cIiBidXQgZXhwZWN0ZWQgdHlwZSBcIiR7ZXhwZWN0ZWRUeXBlc31cIi5gXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29uZmlnXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjIuMik6IGJhc2UtY29tcG9uZW50LmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0IERhdGEgZnJvbSAnLi9kb20vZGF0YSdcbmltcG9ydCB7IGV4ZWN1dGVBZnRlclRyYW5zaXRpb24sIGdldEVsZW1lbnQgfSBmcm9tICcuL3V0aWwvaW5kZXgnXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4vZG9tL2V2ZW50LWhhbmRsZXInXG5pbXBvcnQgQ29uZmlnIGZyb20gJy4vdXRpbC9jb25maWcnXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgVkVSU0lPTiA9ICc1LjIuMidcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgQmFzZUNvbXBvbmVudCBleHRlbmRzIENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIHN1cGVyKClcblxuICAgIGVsZW1lbnQgPSBnZXRFbGVtZW50KGVsZW1lbnQpXG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudFxuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpXG5cbiAgICBEYXRhLnNldCh0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZLCB0aGlzKVxuICB9XG5cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgRGF0YS5yZW1vdmUodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSlcbiAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRVZFTlRfS0VZKVxuXG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcbiAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IG51bGxcbiAgICB9XG4gIH1cblxuICBfcXVldWVDYWxsYmFjayhjYWxsYmFjaywgZWxlbWVudCwgaXNBbmltYXRlZCA9IHRydWUpIHtcbiAgICBleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uKGNhbGxiYWNrLCBlbGVtZW50LCBpc0FuaW1hdGVkKVxuICB9XG5cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSB0aGlzLl9tZXJnZUNvbmZpZ09iaihjb25maWcsIHRoaXMuX2VsZW1lbnQpXG4gICAgY29uZmlnID0gdGhpcy5fY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpXG4gICAgdGhpcy5fdHlwZUNoZWNrQ29uZmlnKGNvbmZpZylcbiAgICByZXR1cm4gY29uZmlnXG4gIH1cblxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGdldEluc3RhbmNlKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gRGF0YS5nZXQoZ2V0RWxlbWVudChlbGVtZW50KSwgdGhpcy5EQVRBX0tFWSlcbiAgfVxuXG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UoZWxlbWVudCkgfHwgbmV3IHRoaXMoZWxlbWVudCwgdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgPyBjb25maWcgOiBudWxsKVxuICB9XG5cbiAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgIHJldHVybiBWRVJTSU9OXG4gIH1cblxuICBzdGF0aWMgZ2V0IERBVEFfS0VZKCkge1xuICAgIHJldHVybiBgYnMuJHt0aGlzLk5BTUV9YFxuICB9XG5cbiAgc3RhdGljIGdldCBFVkVOVF9LRVkoKSB7XG4gICAgcmV0dXJuIGAuJHt0aGlzLkRBVEFfS0VZfWBcbiAgfVxuXG4gIHN0YXRpYyBldmVudE5hbWUobmFtZSkge1xuICAgIHJldHVybiBgJHtuYW1lfSR7dGhpcy5FVkVOVF9LRVl9YFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VDb21wb25lbnRcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMi4yKTogdXRpbC9jb21wb25lbnQtZnVuY3Rpb25zLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9kb20vZXZlbnQtaGFuZGxlcidcbmltcG9ydCB7IGdldEVsZW1lbnRGcm9tU2VsZWN0b3IsIGlzRGlzYWJsZWQgfSBmcm9tICcuL2luZGV4J1xuXG5jb25zdCBlbmFibGVEaXNtaXNzVHJpZ2dlciA9IChjb21wb25lbnQsIG1ldGhvZCA9ICdoaWRlJykgPT4ge1xuICBjb25zdCBjbGlja0V2ZW50ID0gYGNsaWNrLmRpc21pc3Mke2NvbXBvbmVudC5FVkVOVF9LRVl9YFxuICBjb25zdCBuYW1lID0gY29tcG9uZW50Lk5BTUVcblxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIGNsaWNrRXZlbnQsIGBbZGF0YS1icy1kaXNtaXNzPVwiJHtuYW1lfVwiXWAsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKSB8fCB0aGlzLmNsb3Nlc3QoYC4ke25hbWV9YClcbiAgICBjb25zdCBpbnN0YW5jZSA9IGNvbXBvbmVudC5nZXRPckNyZWF0ZUluc3RhbmNlKHRhcmdldClcblxuICAgIC8vIE1ldGhvZCBhcmd1bWVudCBpcyBsZWZ0LCBmb3IgQWxlcnQgYW5kIG9ubHksIGFzIGl0IGRvZXNuJ3QgaW1wbGVtZW50IHRoZSAnaGlkZScgbWV0aG9kXG4gICAgaW5zdGFuY2VbbWV0aG9kXSgpXG4gIH0pXG59XG5cbmV4cG9ydCB7XG4gIGVuYWJsZURpc21pc3NUcmlnZ2VyXG59XG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjIuMik6IGFsZXJ0LmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0IHsgZGVmaW5lSlF1ZXJ5UGx1Z2luIH0gZnJvbSAnLi91dGlsL2luZGV4J1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuL2RvbS9ldmVudC1oYW5kbGVyJ1xuaW1wb3J0IEJhc2VDb21wb25lbnQgZnJvbSAnLi9iYXNlLWNvbXBvbmVudCdcbmltcG9ydCB7IGVuYWJsZURpc21pc3NUcmlnZ2VyIH0gZnJvbSAnLi91dGlsL2NvbXBvbmVudC1mdW5jdGlvbnMnXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTkFNRSA9ICdhbGVydCdcbmNvbnN0IERBVEFfS0VZID0gJ2JzLmFsZXJ0J1xuY29uc3QgRVZFTlRfS0VZID0gYC4ke0RBVEFfS0VZfWBcblxuY29uc3QgRVZFTlRfQ0xPU0UgPSBgY2xvc2Uke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9DTE9TRUQgPSBgY2xvc2VkJHtFVkVOVF9LRVl9YFxuY29uc3QgQ0xBU1NfTkFNRV9GQURFID0gJ2ZhZGUnXG5jb25zdCBDTEFTU19OQU1FX1NIT1cgPSAnc2hvdydcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgQWxlcnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUVcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICBjbG9zZSgpIHtcbiAgICBjb25zdCBjbG9zZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfQ0xPU0UpXG5cbiAgICBpZiAoY2xvc2VFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XKVxuXG4gICAgY29uc3QgaXNBbmltYXRlZCA9IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSlcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHRoaXMuX2Rlc3Ryb3lFbGVtZW50KCksIHRoaXMuX2VsZW1lbnQsIGlzQW5pbWF0ZWQpXG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9kZXN0cm95RWxlbWVudCgpIHtcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZSgpXG4gICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfQ0xPU0VEKVxuICAgIHRoaXMuZGlzcG9zZSgpXG4gIH1cblxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBBbGVydC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpXG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgIH1cblxuICAgICAgZGF0YVtjb25maWddKHRoaXMpXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gKi9cblxuZW5hYmxlRGlzbWlzc1RyaWdnZXIoQWxlcnQsICdjbG9zZScpXG5cbi8qKlxuICogalF1ZXJ5XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKEFsZXJ0KVxuXG5leHBvcnQgZGVmYXVsdCBBbGVydFxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4yLjIpOiBidXR0b24uanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgeyBkZWZpbmVKUXVlcnlQbHVnaW4gfSBmcm9tICcuL3V0aWwvaW5kZXgnXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4vZG9tL2V2ZW50LWhhbmRsZXInXG5pbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tICcuL2Jhc2UtY29tcG9uZW50J1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUgPSAnYnV0dG9uJ1xuY29uc3QgREFUQV9LRVkgPSAnYnMuYnV0dG9uJ1xuY29uc3QgRVZFTlRfS0VZID0gYC4ke0RBVEFfS0VZfWBcbmNvbnN0IERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknXG5cbmNvbnN0IENMQVNTX05BTUVfQUNUSVZFID0gJ2FjdGl2ZSdcbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFID0gJ1tkYXRhLWJzLXRvZ2dsZT1cImJ1dHRvblwiXSdcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gYGNsaWNrJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBCdXR0b24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUVcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICB0b2dnbGUoKSB7XG4gICAgLy8gVG9nZ2xlIGNsYXNzIGFuZCBzeW5jIHRoZSBgYXJpYS1wcmVzc2VkYCBhdHRyaWJ1dGUgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBgLnRvZ2dsZSgpYCBtZXRob2RcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1wcmVzc2VkJywgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKENMQVNTX05BTUVfQUNUSVZFKSlcbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IEJ1dHRvbi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpXG5cbiAgICAgIGlmIChjb25maWcgPT09ICd0b2dnbGUnKSB7XG4gICAgICAgIGRhdGFbY29uZmlnXSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gKi9cblxuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUsIGV2ZW50ID0+IHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXG4gIGNvbnN0IGJ1dHRvbiA9IGV2ZW50LnRhcmdldC5jbG9zZXN0KFNFTEVDVE9SX0RBVEFfVE9HR0xFKVxuICBjb25zdCBkYXRhID0gQnV0dG9uLmdldE9yQ3JlYXRlSW5zdGFuY2UoYnV0dG9uKVxuXG4gIGRhdGEudG9nZ2xlKClcbn0pXG5cbi8qKlxuICogalF1ZXJ5XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKEJ1dHRvbilcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjIuMik6IGRvbS9zZWxlY3Rvci1lbmdpbmUuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgeyBpc0Rpc2FibGVkLCBpc1Zpc2libGUgfSBmcm9tICcuLi91dGlsL2luZGV4J1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IFNlbGVjdG9yRW5naW5lID0ge1xuICBmaW5kKHNlbGVjdG9yLCBlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdCguLi5FbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpKVxuICB9LFxuXG4gIGZpbmRPbmUoc2VsZWN0b3IsIGVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3Rvci5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKVxuICB9LFxuXG4gIGNoaWxkcmVuKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdCguLi5lbGVtZW50LmNoaWxkcmVuKS5maWx0ZXIoY2hpbGQgPT4gY2hpbGQubWF0Y2hlcyhzZWxlY3RvcikpXG4gIH0sXG5cbiAgcGFyZW50cyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIGNvbnN0IHBhcmVudHMgPSBbXVxuICAgIGxldCBhbmNlc3RvciA9IGVsZW1lbnQucGFyZW50Tm9kZS5jbG9zZXN0KHNlbGVjdG9yKVxuXG4gICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICBwYXJlbnRzLnB1c2goYW5jZXN0b3IpXG4gICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudE5vZGUuY2xvc2VzdChzZWxlY3RvcilcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50c1xuICB9LFxuXG4gIHByZXYoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICBsZXQgcHJldmlvdXMgPSBlbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmdcblxuICAgIHdoaWxlIChwcmV2aW91cykge1xuICAgICAgaWYgKHByZXZpb3VzLm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgIHJldHVybiBbcHJldmlvdXNdXG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzID0gcHJldmlvdXMucHJldmlvdXNFbGVtZW50U2libGluZ1xuICAgIH1cblxuICAgIHJldHVybiBbXVxuICB9LFxuICAvLyBUT0RPOiB0aGlzIGlzIG5vdyB1bnVzZWQ7IHJlbW92ZSBsYXRlciBhbG9uZyB3aXRoIHByZXYoKVxuICBuZXh0KGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgbGV0IG5leHQgPSBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZ1xuXG4gICAgd2hpbGUgKG5leHQpIHtcbiAgICAgIGlmIChuZXh0Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgIHJldHVybiBbbmV4dF1cbiAgICAgIH1cblxuICAgICAgbmV4dCA9IG5leHQubmV4dEVsZW1lbnRTaWJsaW5nXG4gICAgfVxuXG4gICAgcmV0dXJuIFtdXG4gIH0sXG5cbiAgZm9jdXNhYmxlQ2hpbGRyZW4oZWxlbWVudCkge1xuICAgIGNvbnN0IGZvY3VzYWJsZXMgPSBbXG4gICAgICAnYScsXG4gICAgICAnYnV0dG9uJyxcbiAgICAgICdpbnB1dCcsXG4gICAgICAndGV4dGFyZWEnLFxuICAgICAgJ3NlbGVjdCcsXG4gICAgICAnZGV0YWlscycsXG4gICAgICAnW3RhYmluZGV4XScsXG4gICAgICAnW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl0nXG4gICAgXS5tYXAoc2VsZWN0b3IgPT4gYCR7c2VsZWN0b3J9Om5vdChbdGFiaW5kZXhePVwiLVwiXSlgKS5qb2luKCcsJylcblxuICAgIHJldHVybiB0aGlzLmZpbmQoZm9jdXNhYmxlcywgZWxlbWVudCkuZmlsdGVyKGVsID0+ICFpc0Rpc2FibGVkKGVsKSAmJiBpc1Zpc2libGUoZWwpKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdG9yRW5naW5lXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjIuMik6IHV0aWwvc3dpcGUuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgQ29uZmlnIGZyb20gJy4vY29uZmlnJ1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9kb20vZXZlbnQtaGFuZGxlcidcbmltcG9ydCB7IGV4ZWN1dGUgfSBmcm9tICcuL2luZGV4J1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUgPSAnc3dpcGUnXG5jb25zdCBFVkVOVF9LRVkgPSAnLmJzLnN3aXBlJ1xuY29uc3QgRVZFTlRfVE9VQ0hTVEFSVCA9IGB0b3VjaHN0YXJ0JHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfVE9VQ0hNT1ZFID0gYHRvdWNobW92ZSR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX1RPVUNIRU5EID0gYHRvdWNoZW5kJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfUE9JTlRFUkRPV04gPSBgcG9pbnRlcmRvd24ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9QT0lOVEVSVVAgPSBgcG9pbnRlcnVwJHtFVkVOVF9LRVl9YFxuY29uc3QgUE9JTlRFUl9UWVBFX1RPVUNIID0gJ3RvdWNoJ1xuY29uc3QgUE9JTlRFUl9UWVBFX1BFTiA9ICdwZW4nXG5jb25zdCBDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQgPSAncG9pbnRlci1ldmVudCdcbmNvbnN0IFNXSVBFX1RIUkVTSE9MRCA9IDQwXG5cbmNvbnN0IERlZmF1bHQgPSB7XG4gIGVuZENhbGxiYWNrOiBudWxsLFxuICBsZWZ0Q2FsbGJhY2s6IG51bGwsXG4gIHJpZ2h0Q2FsbGJhY2s6IG51bGxcbn1cblxuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIGVuZENhbGxiYWNrOiAnKGZ1bmN0aW9ufG51bGwpJyxcbiAgbGVmdENhbGxiYWNrOiAnKGZ1bmN0aW9ufG51bGwpJyxcbiAgcmlnaHRDYWxsYmFjazogJyhmdW5jdGlvbnxudWxsKSdcbn1cblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgU3dpcGUgZXh0ZW5kcyBDb25maWcge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnRcblxuICAgIGlmICghZWxlbWVudCB8fCAhU3dpcGUuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZylcbiAgICB0aGlzLl9kZWx0YVggPSAwXG4gICAgdGhpcy5fc3VwcG9ydFBvaW50ZXJFdmVudHMgPSBCb29sZWFuKHdpbmRvdy5Qb2ludGVyRXZlbnQpXG4gICAgdGhpcy5faW5pdEV2ZW50cygpXG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGVcbiAgfVxuXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRVxuICB9XG5cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVkpXG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9zdGFydChldmVudCkge1xuICAgIGlmICghdGhpcy5fc3VwcG9ydFBvaW50ZXJFdmVudHMpIHtcbiAgICAgIHRoaXMuX2RlbHRhWCA9IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WFxuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRJc1BvaW50ZXJQZW5Ub3VjaChldmVudCkpIHtcbiAgICAgIHRoaXMuX2RlbHRhWCA9IGV2ZW50LmNsaWVudFhcbiAgICB9XG4gIH1cblxuICBfZW5kKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2V2ZW50SXNQb2ludGVyUGVuVG91Y2goZXZlbnQpKSB7XG4gICAgICB0aGlzLl9kZWx0YVggPSBldmVudC5jbGllbnRYIC0gdGhpcy5fZGVsdGFYXG4gICAgfVxuXG4gICAgdGhpcy5faGFuZGxlU3dpcGUoKVxuICAgIGV4ZWN1dGUodGhpcy5fY29uZmlnLmVuZENhbGxiYWNrKVxuICB9XG5cbiAgX21vdmUoZXZlbnQpIHtcbiAgICB0aGlzLl9kZWx0YVggPSBldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSA/XG4gICAgICAwIDpcbiAgICAgIGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCAtIHRoaXMuX2RlbHRhWFxuICB9XG5cbiAgX2hhbmRsZVN3aXBlKCkge1xuICAgIGNvbnN0IGFic0RlbHRhWCA9IE1hdGguYWJzKHRoaXMuX2RlbHRhWClcblxuICAgIGlmIChhYnNEZWx0YVggPD0gU1dJUEVfVEhSRVNIT0xEKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBkaXJlY3Rpb24gPSBhYnNEZWx0YVggLyB0aGlzLl9kZWx0YVhcblxuICAgIHRoaXMuX2RlbHRhWCA9IDBcblxuICAgIGlmICghZGlyZWN0aW9uKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBleGVjdXRlKGRpcmVjdGlvbiA+IDAgPyB0aGlzLl9jb25maWcucmlnaHRDYWxsYmFjayA6IHRoaXMuX2NvbmZpZy5sZWZ0Q2FsbGJhY2spXG4gIH1cblxuICBfaW5pdEV2ZW50cygpIHtcbiAgICBpZiAodGhpcy5fc3VwcG9ydFBvaW50ZXJFdmVudHMpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9QT0lOVEVSRE9XTiwgZXZlbnQgPT4gdGhpcy5fc3RhcnQoZXZlbnQpKVxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1BPSU5URVJVUCwgZXZlbnQgPT4gdGhpcy5fZW5kKGV2ZW50KSlcblxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfUE9JTlRFUl9FVkVOVClcbiAgICB9IGVsc2Uge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1RPVUNIU1RBUlQsIGV2ZW50ID0+IHRoaXMuX3N0YXJ0KGV2ZW50KSlcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9UT1VDSE1PVkUsIGV2ZW50ID0+IHRoaXMuX21vdmUoZXZlbnQpKVxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1RPVUNIRU5ELCBldmVudCA9PiB0aGlzLl9lbmQoZXZlbnQpKVxuICAgIH1cbiAgfVxuXG4gIF9ldmVudElzUG9pbnRlclBlblRvdWNoKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX3N1cHBvcnRQb2ludGVyRXZlbnRzICYmIChldmVudC5wb2ludGVyVHlwZSA9PT0gUE9JTlRFUl9UWVBFX1BFTiB8fCBldmVudC5wb2ludGVyVHlwZSA9PT0gUE9JTlRFUl9UWVBFX1RPVUNIKVxuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBpc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDBcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTd2lwZVxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4yLjIpOiBjYXJvdXNlbC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCB7XG4gIGRlZmluZUpRdWVyeVBsdWdpbixcbiAgZ2V0RWxlbWVudEZyb21TZWxlY3RvcixcbiAgZ2V0TmV4dEFjdGl2ZUVsZW1lbnQsXG4gIGlzUlRMLFxuICBpc1Zpc2libGUsXG4gIHJlZmxvdyxcbiAgdHJpZ2dlclRyYW5zaXRpb25FbmRcbn0gZnJvbSAnLi91dGlsL2luZGV4J1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuL2RvbS9ldmVudC1oYW5kbGVyJ1xuaW1wb3J0IE1hbmlwdWxhdG9yIGZyb20gJy4vZG9tL21hbmlwdWxhdG9yJ1xuaW1wb3J0IFNlbGVjdG9yRW5naW5lIGZyb20gJy4vZG9tL3NlbGVjdG9yLWVuZ2luZSdcbmltcG9ydCBTd2lwZSBmcm9tICcuL3V0aWwvc3dpcGUnXG5pbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tICcuL2Jhc2UtY29tcG9uZW50J1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUgPSAnY2Fyb3VzZWwnXG5jb25zdCBEQVRBX0tFWSA9ICdicy5jYXJvdXNlbCdcbmNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJ1xuXG5jb25zdCBBUlJPV19MRUZUX0tFWSA9ICdBcnJvd0xlZnQnXG5jb25zdCBBUlJPV19SSUdIVF9LRVkgPSAnQXJyb3dSaWdodCdcbmNvbnN0IFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgPSA1MDAgLy8gVGltZSBmb3IgbW91c2UgY29tcGF0IGV2ZW50cyB0byBmaXJlIGFmdGVyIHRvdWNoXG5cbmNvbnN0IE9SREVSX05FWFQgPSAnbmV4dCdcbmNvbnN0IE9SREVSX1BSRVYgPSAncHJldidcbmNvbnN0IERJUkVDVElPTl9MRUZUID0gJ2xlZnQnXG5jb25zdCBESVJFQ1RJT05fUklHSFQgPSAncmlnaHQnXG5cbmNvbnN0IEVWRU5UX1NMSURFID0gYHNsaWRlJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0xJRCA9IGBzbGlkJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfS0VZRE9XTiA9IGBrZXlkb3duJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfTU9VU0VFTlRFUiA9IGBtb3VzZWVudGVyJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfTU9VU0VMRUFWRSA9IGBtb3VzZWxlYXZlJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfRFJBR19TVEFSVCA9IGBkcmFnc3RhcnQke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJID0gYGxvYWQke0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gXG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSA9IGBjbGljayR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWBcblxuY29uc3QgQ0xBU1NfTkFNRV9DQVJPVVNFTCA9ICdjYXJvdXNlbCdcbmNvbnN0IENMQVNTX05BTUVfQUNUSVZFID0gJ2FjdGl2ZSdcbmNvbnN0IENMQVNTX05BTUVfU0xJREUgPSAnc2xpZGUnXG5jb25zdCBDTEFTU19OQU1FX0VORCA9ICdjYXJvdXNlbC1pdGVtLWVuZCdcbmNvbnN0IENMQVNTX05BTUVfU1RBUlQgPSAnY2Fyb3VzZWwtaXRlbS1zdGFydCdcbmNvbnN0IENMQVNTX05BTUVfTkVYVCA9ICdjYXJvdXNlbC1pdGVtLW5leHQnXG5jb25zdCBDTEFTU19OQU1FX1BSRVYgPSAnY2Fyb3VzZWwtaXRlbS1wcmV2J1xuXG5jb25zdCBTRUxFQ1RPUl9BQ1RJVkUgPSAnLmFjdGl2ZSdcbmNvbnN0IFNFTEVDVE9SX0lURU0gPSAnLmNhcm91c2VsLWl0ZW0nXG5jb25zdCBTRUxFQ1RPUl9BQ1RJVkVfSVRFTSA9IFNFTEVDVE9SX0FDVElWRSArIFNFTEVDVE9SX0lURU1cbmNvbnN0IFNFTEVDVE9SX0lURU1fSU1HID0gJy5jYXJvdXNlbC1pdGVtIGltZydcbmNvbnN0IFNFTEVDVE9SX0lORElDQVRPUlMgPSAnLmNhcm91c2VsLWluZGljYXRvcnMnXG5jb25zdCBTRUxFQ1RPUl9EQVRBX1NMSURFID0gJ1tkYXRhLWJzLXNsaWRlXSwgW2RhdGEtYnMtc2xpZGUtdG9dJ1xuY29uc3QgU0VMRUNUT1JfREFUQV9SSURFID0gJ1tkYXRhLWJzLXJpZGU9XCJjYXJvdXNlbFwiXSdcblxuY29uc3QgS0VZX1RPX0RJUkVDVElPTiA9IHtcbiAgW0FSUk9XX0xFRlRfS0VZXTogRElSRUNUSU9OX1JJR0hULFxuICBbQVJST1dfUklHSFRfS0VZXTogRElSRUNUSU9OX0xFRlRcbn1cblxuY29uc3QgRGVmYXVsdCA9IHtcbiAgaW50ZXJ2YWw6IDUwMDAsXG4gIGtleWJvYXJkOiB0cnVlLFxuICBwYXVzZTogJ2hvdmVyJyxcbiAgcmlkZTogZmFsc2UsXG4gIHRvdWNoOiB0cnVlLFxuICB3cmFwOiB0cnVlXG59XG5cbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICBpbnRlcnZhbDogJyhudW1iZXJ8Ym9vbGVhbiknLCAvLyBUT0RPOnY2IHJlbW92ZSBib29sZWFuIHN1cHBvcnRcbiAga2V5Ym9hcmQ6ICdib29sZWFuJyxcbiAgcGF1c2U6ICcoc3RyaW5nfGJvb2xlYW4pJyxcbiAgcmlkZTogJyhib29sZWFufHN0cmluZyknLFxuICB0b3VjaDogJ2Jvb2xlYW4nLFxuICB3cmFwOiAnYm9vbGVhbidcbn1cblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgQ2Fyb3VzZWwgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKVxuXG4gICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsXG4gICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IG51bGxcbiAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZVxuICAgIHRoaXMudG91Y2hUaW1lb3V0ID0gbnVsbFxuICAgIHRoaXMuX3N3aXBlSGVscGVyID0gbnVsbFxuXG4gICAgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0lORElDQVRPUlMsIHRoaXMuX2VsZW1lbnQpXG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKVxuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5yaWRlID09PSBDTEFTU19OQU1FX0NBUk9VU0VMKSB7XG4gICAgICB0aGlzLmN5Y2xlKClcbiAgICB9XG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGVcbiAgfVxuXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRVxuICB9XG5cbiAgLy8gUHVibGljXG4gIG5leHQoKSB7XG4gICAgdGhpcy5fc2xpZGUoT1JERVJfTkVYVClcbiAgfVxuXG4gIG5leHRXaGVuVmlzaWJsZSgpIHtcbiAgICAvLyBGSVhNRSBUT0RPIHVzZSBgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlYFxuICAgIC8vIERvbid0IGNhbGwgbmV4dCB3aGVuIHRoZSBwYWdlIGlzbid0IHZpc2libGVcbiAgICAvLyBvciB0aGUgY2Fyb3VzZWwgb3IgaXRzIHBhcmVudCBpc24ndCB2aXNpYmxlXG4gICAgaWYgKCFkb2N1bWVudC5oaWRkZW4gJiYgaXNWaXNpYmxlKHRoaXMuX2VsZW1lbnQpKSB7XG4gICAgICB0aGlzLm5leHQoKVxuICAgIH1cbiAgfVxuXG4gIHByZXYoKSB7XG4gICAgdGhpcy5fc2xpZGUoT1JERVJfUFJFVilcbiAgfVxuXG4gIHBhdXNlKCkge1xuICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgIHRyaWdnZXJUcmFuc2l0aW9uRW5kKHRoaXMuX2VsZW1lbnQpXG4gICAgfVxuXG4gICAgdGhpcy5fY2xlYXJJbnRlcnZhbCgpXG4gIH1cblxuICBjeWNsZSgpIHtcbiAgICB0aGlzLl9jbGVhckludGVydmFsKClcbiAgICB0aGlzLl91cGRhdGVJbnRlcnZhbCgpXG5cbiAgICB0aGlzLl9pbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHRoaXMubmV4dFdoZW5WaXNpYmxlKCksIHRoaXMuX2NvbmZpZy5pbnRlcnZhbClcbiAgfVxuXG4gIF9tYXliZUVuYWJsZUN5Y2xlKCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLnJpZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbmUodGhpcy5fZWxlbWVudCwgRVZFTlRfU0xJRCwgKCkgPT4gdGhpcy5jeWNsZSgpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5jeWNsZSgpXG4gIH1cblxuICB0byhpbmRleCkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fZ2V0SXRlbXMoKVxuICAgIGlmIChpbmRleCA+IGl0ZW1zLmxlbmd0aCAtIDEgfHwgaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICBFdmVudEhhbmRsZXIub25lKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NMSUQsICgpID0+IHRoaXMudG8oaW5kZXgpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZlSW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgodGhpcy5fZ2V0QWN0aXZlKCkpXG4gICAgaWYgKGFjdGl2ZUluZGV4ID09PSBpbmRleCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgb3JkZXIgPSBpbmRleCA+IGFjdGl2ZUluZGV4ID8gT1JERVJfTkVYVCA6IE9SREVSX1BSRVZcblxuICAgIHRoaXMuX3NsaWRlKG9yZGVyLCBpdGVtc1tpbmRleF0pXG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLl9zd2lwZUhlbHBlcikge1xuICAgICAgdGhpcy5fc3dpcGVIZWxwZXIuZGlzcG9zZSgpXG4gICAgfVxuXG4gICAgc3VwZXIuZGlzcG9zZSgpXG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xuICAgIGNvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgPSBjb25maWcuaW50ZXJ2YWxcbiAgICByZXR1cm4gY29uZmlnXG4gIH1cblxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV04sIGV2ZW50ID0+IHRoaXMuX2tleWRvd24oZXZlbnQpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb25maWcucGF1c2UgPT09ICdob3ZlcicpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRUVOVEVSLCAoKSA9PiB0aGlzLnBhdXNlKCkpXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VMRUFWRSwgKCkgPT4gdGhpcy5fbWF5YmVFbmFibGVDeWNsZSgpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb25maWcudG91Y2ggJiYgU3dpcGUuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgdGhpcy5fYWRkVG91Y2hFdmVudExpc3RlbmVycygpXG4gICAgfVxuICB9XG5cbiAgX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgZm9yIChjb25zdCBpbWcgb2YgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JVEVNX0lNRywgdGhpcy5fZWxlbWVudCkpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbihpbWcsIEVWRU5UX0RSQUdfU1RBUlQsIGV2ZW50ID0+IGV2ZW50LnByZXZlbnREZWZhdWx0KCkpXG4gICAgfVxuXG4gICAgY29uc3QgZW5kQ2FsbEJhY2sgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fY29uZmlnLnBhdXNlICE9PSAnaG92ZXInKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCdzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2UsIG1vdXNlZW50ZXIvbGVhdmUgYXJlIGZpcmVkIGFzXG4gICAgICAvLyBwYXJ0IG9mIHRoZSBtb3VzZSBjb21wYXRpYmlsaXR5IGV2ZW50cyBvbiBmaXJzdCB0YXAgLSB0aGUgY2Fyb3VzZWxcbiAgICAgIC8vIHdvdWxkIHN0b3AgY3ljbGluZyB1bnRpbCB1c2VyIHRhcHBlZCBvdXQgb2YgaXQ7XG4gICAgICAvLyBoZXJlLCB3ZSBsaXN0ZW4gZm9yIHRvdWNoZW5kLCBleHBsaWNpdGx5IHBhdXNlIHRoZSBjYXJvdXNlbFxuICAgICAgLy8gKGFzIGlmIGl0J3MgdGhlIHNlY29uZCB0aW1lIHdlIHRhcCBvbiBpdCwgbW91c2VlbnRlciBjb21wYXQgZXZlbnRcbiAgICAgIC8vIGlzIE5PVCBmaXJlZCkgYW5kIGFmdGVyIGEgdGltZW91dCAodG8gYWxsb3cgZm9yIG1vdXNlIGNvbXBhdGliaWxpdHlcbiAgICAgIC8vIGV2ZW50cyB0byBmaXJlKSB3ZSBleHBsaWNpdGx5IHJlc3RhcnQgY3ljbGluZ1xuXG4gICAgICB0aGlzLnBhdXNlKClcbiAgICAgIGlmICh0aGlzLnRvdWNoVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50b3VjaFRpbWVvdXQpXG4gICAgICB9XG5cbiAgICAgIHRoaXMudG91Y2hUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl9tYXliZUVuYWJsZUN5Y2xlKCksIFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgKyB0aGlzLl9jb25maWcuaW50ZXJ2YWwpXG4gICAgfVxuXG4gICAgY29uc3Qgc3dpcGVDb25maWcgPSB7XG4gICAgICBsZWZ0Q2FsbGJhY2s6ICgpID0+IHRoaXMuX3NsaWRlKHRoaXMuX2RpcmVjdGlvblRvT3JkZXIoRElSRUNUSU9OX0xFRlQpKSxcbiAgICAgIHJpZ2h0Q2FsbGJhY2s6ICgpID0+IHRoaXMuX3NsaWRlKHRoaXMuX2RpcmVjdGlvblRvT3JkZXIoRElSRUNUSU9OX1JJR0hUKSksXG4gICAgICBlbmRDYWxsYmFjazogZW5kQ2FsbEJhY2tcbiAgICB9XG5cbiAgICB0aGlzLl9zd2lwZUhlbHBlciA9IG5ldyBTd2lwZSh0aGlzLl9lbGVtZW50LCBzd2lwZUNvbmZpZylcbiAgfVxuXG4gIF9rZXlkb3duKGV2ZW50KSB7XG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBkaXJlY3Rpb24gPSBLRVlfVE9fRElSRUNUSU9OW2V2ZW50LmtleV1cbiAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICB0aGlzLl9zbGlkZSh0aGlzLl9kaXJlY3Rpb25Ub09yZGVyKGRpcmVjdGlvbikpXG4gICAgfVxuICB9XG5cbiAgX2dldEl0ZW1JbmRleChlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEl0ZW1zKCkuaW5kZXhPZihlbGVtZW50KVxuICB9XG5cbiAgX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQoaW5kZXgpIHtcbiAgICBpZiAoIXRoaXMuX2luZGljYXRvcnNFbGVtZW50KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmVJbmRpY2F0b3IgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0FDVElWRSwgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpXG5cbiAgICBhY3RpdmVJbmRpY2F0b3IuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSlcbiAgICBhY3RpdmVJbmRpY2F0b3IucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnKVxuXG4gICAgY29uc3QgbmV3QWN0aXZlSW5kaWNhdG9yID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShgW2RhdGEtYnMtc2xpZGUtdG89XCIke2luZGV4fVwiXWAsIHRoaXMuX2luZGljYXRvcnNFbGVtZW50KVxuXG4gICAgaWYgKG5ld0FjdGl2ZUluZGljYXRvcikge1xuICAgICAgbmV3QWN0aXZlSW5kaWNhdG9yLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgICBuZXdBY3RpdmVJbmRpY2F0b3Iuc2V0QXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnLCAndHJ1ZScpXG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUludGVydmFsKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9hY3RpdmVFbGVtZW50IHx8IHRoaXMuX2dldEFjdGl2ZSgpXG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGVsZW1lbnRJbnRlcnZhbCA9IE51bWJlci5wYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1pbnRlcnZhbCcpLCAxMClcblxuICAgIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCA9IGVsZW1lbnRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsXG4gIH1cblxuICBfc2xpZGUob3JkZXIsIGVsZW1lbnQgPSBudWxsKSB7XG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IHRoaXMuX2dldEFjdGl2ZSgpXG4gICAgY29uc3QgaXNOZXh0ID0gb3JkZXIgPT09IE9SREVSX05FWFRcbiAgICBjb25zdCBuZXh0RWxlbWVudCA9IGVsZW1lbnQgfHwgZ2V0TmV4dEFjdGl2ZUVsZW1lbnQodGhpcy5fZ2V0SXRlbXMoKSwgYWN0aXZlRWxlbWVudCwgaXNOZXh0LCB0aGlzLl9jb25maWcud3JhcClcblxuICAgIGlmIChuZXh0RWxlbWVudCA9PT0gYWN0aXZlRWxlbWVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgbmV4dEVsZW1lbnRJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleChuZXh0RWxlbWVudClcblxuICAgIGNvbnN0IHRyaWdnZXJFdmVudCA9IGV2ZW50TmFtZSA9PiB7XG4gICAgICByZXR1cm4gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgZXZlbnROYW1lLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IG5leHRFbGVtZW50LFxuICAgICAgICBkaXJlY3Rpb246IHRoaXMuX29yZGVyVG9EaXJlY3Rpb24ob3JkZXIpLFxuICAgICAgICBmcm9tOiB0aGlzLl9nZXRJdGVtSW5kZXgoYWN0aXZlRWxlbWVudCksXG4gICAgICAgIHRvOiBuZXh0RWxlbWVudEluZGV4XG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IHNsaWRlRXZlbnQgPSB0cmlnZ2VyRXZlbnQoRVZFTlRfU0xJREUpXG5cbiAgICBpZiAoc2xpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIWFjdGl2ZUVsZW1lbnQgfHwgIW5leHRFbGVtZW50KSB7XG4gICAgICAvLyBTb21lIHdlaXJkbmVzcyBpcyBoYXBwZW5pbmcsIHNvIHdlIGJhaWxcbiAgICAgIC8vIHRvZG86IGNoYW5nZSB0ZXN0cyB0aGF0IHVzZSBlbXB0eSBkaXZzIHRvIGF2b2lkIHRoaXMgY2hlY2tcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGlzQ3ljbGluZyA9IEJvb2xlYW4odGhpcy5faW50ZXJ2YWwpXG4gICAgdGhpcy5wYXVzZSgpXG5cbiAgICB0aGlzLl9pc1NsaWRpbmcgPSB0cnVlXG5cbiAgICB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KG5leHRFbGVtZW50SW5kZXgpXG4gICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IG5leHRFbGVtZW50XG5cbiAgICBjb25zdCBkaXJlY3Rpb25hbENsYXNzTmFtZSA9IGlzTmV4dCA/IENMQVNTX05BTUVfU1RBUlQgOiBDTEFTU19OQU1FX0VORFxuICAgIGNvbnN0IG9yZGVyQ2xhc3NOYW1lID0gaXNOZXh0ID8gQ0xBU1NfTkFNRV9ORVhUIDogQ0xBU1NfTkFNRV9QUkVWXG5cbiAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKG9yZGVyQ2xhc3NOYW1lKVxuXG4gICAgcmVmbG93KG5leHRFbGVtZW50KVxuXG4gICAgYWN0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKGRpcmVjdGlvbmFsQ2xhc3NOYW1lKVxuICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5hZGQoZGlyZWN0aW9uYWxDbGFzc05hbWUpXG5cbiAgICBjb25zdCBjb21wbGV0ZUNhbGxCYWNrID0gKCkgPT4ge1xuICAgICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShkaXJlY3Rpb25hbENsYXNzTmFtZSwgb3JkZXJDbGFzc05hbWUpXG4gICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFKVxuXG4gICAgICBhY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUsIG9yZGVyQ2xhc3NOYW1lLCBkaXJlY3Rpb25hbENsYXNzTmFtZSlcblxuICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2VcblxuICAgICAgdHJpZ2dlckV2ZW50KEVWRU5UX1NMSUQpXG4gICAgfVxuXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZUNhbGxCYWNrLCBhY3RpdmVFbGVtZW50LCB0aGlzLl9pc0FuaW1hdGVkKCkpXG5cbiAgICBpZiAoaXNDeWNsaW5nKSB7XG4gICAgICB0aGlzLmN5Y2xlKClcbiAgICB9XG4gIH1cblxuICBfaXNBbmltYXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TTElERSlcbiAgfVxuXG4gIF9nZXRBY3RpdmUoKSB7XG4gICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfQUNUSVZFX0lURU0sIHRoaXMuX2VsZW1lbnQpXG4gIH1cblxuICBfZ2V0SXRlbXMoKSB7XG4gICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfSVRFTSwgdGhpcy5fZWxlbWVudClcbiAgfVxuXG4gIF9jbGVhckludGVydmFsKCkge1xuICAgIGlmICh0aGlzLl9pbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbClcbiAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIF9kaXJlY3Rpb25Ub09yZGVyKGRpcmVjdGlvbikge1xuICAgIGlmIChpc1JUTCgpKSB7XG4gICAgICByZXR1cm4gZGlyZWN0aW9uID09PSBESVJFQ1RJT05fTEVGVCA/IE9SREVSX1BSRVYgOiBPUkRFUl9ORVhUXG4gICAgfVxuXG4gICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0xFRlQgPyBPUkRFUl9ORVhUIDogT1JERVJfUFJFVlxuICB9XG5cbiAgX29yZGVyVG9EaXJlY3Rpb24ob3JkZXIpIHtcbiAgICBpZiAoaXNSVEwoKSkge1xuICAgICAgcmV0dXJuIG9yZGVyID09PSBPUkRFUl9QUkVWID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFRcbiAgICB9XG5cbiAgICByZXR1cm4gb3JkZXIgPT09IE9SREVSX1BSRVYgPyBESVJFQ1RJT05fUklHSFQgOiBESVJFQ1RJT05fTEVGVFxuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gQ2Fyb3VzZWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpXG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnbnVtYmVyJykge1xuICAgICAgICBkYXRhLnRvKGNvbmZpZylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApXG4gICAgICAgIH1cblxuICAgICAgICBkYXRhW2NvbmZpZ10oKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICovXG5cbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfU0xJREUsIGZ1bmN0aW9uIChldmVudCkge1xuICBjb25zdCB0YXJnZXQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRoaXMpXG5cbiAgaWYgKCF0YXJnZXQgfHwgIXRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9DQVJPVVNFTCkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblxuICBjb25zdCBjYXJvdXNlbCA9IENhcm91c2VsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGFyZ2V0KVxuICBjb25zdCBzbGlkZUluZGV4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtc2xpZGUtdG8nKVxuXG4gIGlmIChzbGlkZUluZGV4KSB7XG4gICAgY2Fyb3VzZWwudG8oc2xpZGVJbmRleClcbiAgICBjYXJvdXNlbC5fbWF5YmVFbmFibGVDeWNsZSgpXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZSh0aGlzLCAnc2xpZGUnKSA9PT0gJ25leHQnKSB7XG4gICAgY2Fyb3VzZWwubmV4dCgpXG4gICAgY2Fyb3VzZWwuX21heWJlRW5hYmxlQ3ljbGUoKVxuICAgIHJldHVyblxuICB9XG5cbiAgY2Fyb3VzZWwucHJldigpXG4gIGNhcm91c2VsLl9tYXliZUVuYWJsZUN5Y2xlKClcbn0pXG5cbkV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX0xPQURfREFUQV9BUEksICgpID0+IHtcbiAgY29uc3QgY2Fyb3VzZWxzID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1JJREUpXG5cbiAgZm9yIChjb25zdCBjYXJvdXNlbCBvZiBjYXJvdXNlbHMpIHtcbiAgICBDYXJvdXNlbC5nZXRPckNyZWF0ZUluc3RhbmNlKGNhcm91c2VsKVxuICB9XG59KVxuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihDYXJvdXNlbClcblxuZXhwb3J0IGRlZmF1bHQgQ2Fyb3VzZWxcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMi4yKTogY29sbGFwc2UuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQge1xuICBkZWZpbmVKUXVlcnlQbHVnaW4sXG4gIGdldEVsZW1lbnQsXG4gIGdldEVsZW1lbnRGcm9tU2VsZWN0b3IsXG4gIGdldFNlbGVjdG9yRnJvbUVsZW1lbnQsXG4gIHJlZmxvd1xufSBmcm9tICcuL3V0aWwvaW5kZXgnXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4vZG9tL2V2ZW50LWhhbmRsZXInXG5pbXBvcnQgU2VsZWN0b3JFbmdpbmUgZnJvbSAnLi9kb20vc2VsZWN0b3ItZW5naW5lJ1xuaW1wb3J0IEJhc2VDb21wb25lbnQgZnJvbSAnLi9iYXNlLWNvbXBvbmVudCdcblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FID0gJ2NvbGxhcHNlJ1xuY29uc3QgREFUQV9LRVkgPSAnYnMuY29sbGFwc2UnXG5jb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSdcblxuY29uc3QgRVZFTlRfU0hPVyA9IGBzaG93JHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0hPV04gPSBgc2hvd24ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9ISURFID0gYGhpZGUke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9ISURERU4gPSBgaGlkZGVuJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkgPSBgY2xpY2ske0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gXG5cbmNvbnN0IENMQVNTX05BTUVfU0hPVyA9ICdzaG93J1xuY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTRSA9ICdjb2xsYXBzZSdcbmNvbnN0IENMQVNTX05BTUVfQ09MTEFQU0lORyA9ICdjb2xsYXBzaW5nJ1xuY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTRUQgPSAnY29sbGFwc2VkJ1xuY29uc3QgQ0xBU1NfTkFNRV9ERUVQRVJfQ0hJTERSRU4gPSBgOnNjb3BlIC4ke0NMQVNTX05BTUVfQ09MTEFQU0V9IC4ke0NMQVNTX05BTUVfQ09MTEFQU0V9YFxuY29uc3QgQ0xBU1NfTkFNRV9IT1JJWk9OVEFMID0gJ2NvbGxhcHNlLWhvcml6b250YWwnXG5cbmNvbnN0IFdJRFRIID0gJ3dpZHRoJ1xuY29uc3QgSEVJR0hUID0gJ2hlaWdodCdcblxuY29uc3QgU0VMRUNUT1JfQUNUSVZFUyA9ICcuY29sbGFwc2Uuc2hvdywgLmNvbGxhcHNlLmNvbGxhcHNpbmcnXG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSA9ICdbZGF0YS1icy10b2dnbGU9XCJjb2xsYXBzZVwiXSdcblxuY29uc3QgRGVmYXVsdCA9IHtcbiAgcGFyZW50OiBudWxsLFxuICB0b2dnbGU6IHRydWVcbn1cblxuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIHBhcmVudDogJyhudWxsfGVsZW1lbnQpJyxcbiAgdG9nZ2xlOiAnYm9vbGVhbidcbn1cblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgQ29sbGFwc2UgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKVxuXG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2VcbiAgICB0aGlzLl90cmlnZ2VyQXJyYXkgPSBbXVxuXG4gICAgY29uc3QgdG9nZ2xlTGlzdCA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9UT0dHTEUpXG5cbiAgICBmb3IgKGNvbnN0IGVsZW0gb2YgdG9nZ2xlTGlzdCkge1xuICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW0pXG4gICAgICBjb25zdCBmaWx0ZXJFbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZChzZWxlY3RvcilcbiAgICAgICAgLmZpbHRlcihmb3VuZEVsZW1lbnQgPT4gZm91bmRFbGVtZW50ID09PSB0aGlzLl9lbGVtZW50KVxuXG4gICAgICBpZiAoc2VsZWN0b3IgIT09IG51bGwgJiYgZmlsdGVyRWxlbWVudC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckFycmF5LnB1c2goZWxlbSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9pbml0aWFsaXplQ2hpbGRyZW4oKVxuXG4gICAgaWYgKCF0aGlzLl9jb25maWcucGFyZW50KSB7XG4gICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy5fdHJpZ2dlckFycmF5LCB0aGlzLl9pc1Nob3duKCkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy50b2dnbGUpIHtcbiAgICAgIHRoaXMudG9nZ2xlKClcbiAgICB9XG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGVcbiAgfVxuXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRVxuICB9XG5cbiAgLy8gUHVibGljXG4gIHRvZ2dsZSgpIHtcbiAgICBpZiAodGhpcy5faXNTaG93bigpKSB7XG4gICAgICB0aGlzLmhpZGUoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3coKVxuICAgIH1cbiAgfVxuXG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCB0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBhY3RpdmVDaGlsZHJlbiA9IFtdXG5cbiAgICAvLyBmaW5kIGFjdGl2ZSBjaGlsZHJlblxuICAgIGlmICh0aGlzLl9jb25maWcucGFyZW50KSB7XG4gICAgICBhY3RpdmVDaGlsZHJlbiA9IHRoaXMuX2dldEZpcnN0TGV2ZWxDaGlsZHJlbihTRUxFQ1RPUl9BQ1RJVkVTKVxuICAgICAgICAuZmlsdGVyKGVsZW1lbnQgPT4gZWxlbWVudCAhPT0gdGhpcy5fZWxlbWVudClcbiAgICAgICAgLm1hcChlbGVtZW50ID0+IENvbGxhcHNlLmdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCwgeyB0b2dnbGU6IGZhbHNlIH0pKVxuICAgIH1cblxuICAgIGlmIChhY3RpdmVDaGlsZHJlbi5sZW5ndGggJiYgYWN0aXZlQ2hpbGRyZW5bMF0uX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1cpXG4gICAgaWYgKHN0YXJ0RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBhY3RpdmVJbnN0YW5jZSBvZiBhY3RpdmVDaGlsZHJlbikge1xuICAgICAgYWN0aXZlSW5zdGFuY2UuaGlkZSgpXG4gICAgfVxuXG4gICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKClcblxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0NPTExBUFNFKVxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNJTkcpXG5cbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAwXG5cbiAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy5fdHJpZ2dlckFycmF5LCB0cnVlKVxuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWVcblxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2VcblxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0lORylcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNFLCBDTEFTU19OQU1FX1NIT1cpXG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9ICcnXG5cbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOKVxuICAgIH1cblxuICAgIGNvbnN0IGNhcGl0YWxpemVkRGltZW5zaW9uID0gZGltZW5zaW9uWzBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoMSlcbiAgICBjb25zdCBzY3JvbGxTaXplID0gYHNjcm9sbCR7Y2FwaXRhbGl6ZWREaW1lbnNpb259YFxuXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdHJ1ZSlcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSBgJHt0aGlzLl9lbGVtZW50W3Njcm9sbFNpemVdfXB4YFxuICB9XG5cbiAgaGlkZSgpIHtcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8ICF0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFKVxuICAgIGlmIChzdGFydEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuX2dldERpbWVuc2lvbigpXG5cbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSBgJHt0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2RpbWVuc2lvbl19cHhgXG5cbiAgICByZWZsb3codGhpcy5fZWxlbWVudClcblxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNJTkcpXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0UsIENMQVNTX05BTUVfU0hPVylcblxuICAgIGZvciAoY29uc3QgdHJpZ2dlciBvZiB0aGlzLl90cmlnZ2VyQXJyYXkpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRyaWdnZXIpXG5cbiAgICAgIGlmIChlbGVtZW50ICYmICF0aGlzLl9pc1Nob3duKGVsZW1lbnQpKSB7XG4gICAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhbdHJpZ2dlcl0sIGZhbHNlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWVcblxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2VcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0NPTExBUFNJTkcpXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTRSlcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTilcbiAgICB9XG5cbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAnJ1xuXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdHJ1ZSlcbiAgfVxuXG4gIF9pc1Nob3duKGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVylcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XG4gICAgY29uZmlnLnRvZ2dsZSA9IEJvb2xlYW4oY29uZmlnLnRvZ2dsZSkgLy8gQ29lcmNlIHN0cmluZyB2YWx1ZXNcbiAgICBjb25maWcucGFyZW50ID0gZ2V0RWxlbWVudChjb25maWcucGFyZW50KVxuICAgIHJldHVybiBjb25maWdcbiAgfVxuXG4gIF9nZXREaW1lbnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfSE9SSVpPTlRBTCkgPyBXSURUSCA6IEhFSUdIVFxuICB9XG5cbiAgX2luaXRpYWxpemVDaGlsZHJlbigpIHtcbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fZ2V0Rmlyc3RMZXZlbENoaWxkcmVuKFNFTEVDVE9SX0RBVEFfVE9HR0xFKVxuXG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZCA9IGdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudClcblxuICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhbZWxlbWVudF0sIHRoaXMuX2lzU2hvd24oc2VsZWN0ZWQpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9nZXRGaXJzdExldmVsQ2hpbGRyZW4oc2VsZWN0b3IpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IFNlbGVjdG9yRW5naW5lLmZpbmQoQ0xBU1NfTkFNRV9ERUVQRVJfQ0hJTERSRU4sIHRoaXMuX2NvbmZpZy5wYXJlbnQpXG4gICAgLy8gcmVtb3ZlIGNoaWxkcmVuIGlmIGdyZWF0ZXIgZGVwdGhcbiAgICByZXR1cm4gU2VsZWN0b3JFbmdpbmUuZmluZChzZWxlY3RvciwgdGhpcy5fY29uZmlnLnBhcmVudCkuZmlsdGVyKGVsZW1lbnQgPT4gIWNoaWxkcmVuLmluY2x1ZGVzKGVsZW1lbnQpKVxuICB9XG5cbiAgX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0cmlnZ2VyQXJyYXksIGlzT3Blbikge1xuICAgIGlmICghdHJpZ2dlckFycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRyaWdnZXJBcnJheSkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKENMQVNTX05BTUVfQ09MTEFQU0VELCAhaXNPcGVuKVxuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBpc09wZW4pXG4gICAgfVxuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgY29uc3QgX2NvbmZpZyA9IHt9XG4gICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnICYmIC9zaG93fGhpZGUvLnRlc3QoY29uZmlnKSkge1xuICAgICAgX2NvbmZpZy50b2dnbGUgPSBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IENvbGxhcHNlLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgX2NvbmZpZylcblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFbY29uZmlnXSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gKi9cblxuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUsIGZ1bmN0aW9uIChldmVudCkge1xuICAvLyBwcmV2ZW50RGVmYXVsdCBvbmx5IGZvciA8YT4gZWxlbWVudHMgKHdoaWNoIGNoYW5nZSB0aGUgVVJMKSBub3QgaW5zaWRlIHRoZSBjb2xsYXBzaWJsZSBlbGVtZW50XG4gIGlmIChldmVudC50YXJnZXQudGFnTmFtZSA9PT0gJ0EnIHx8IChldmVudC5kZWxlZ2F0ZVRhcmdldCAmJiBldmVudC5kZWxlZ2F0ZVRhcmdldC50YWdOYW1lID09PSAnQScpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICB9XG5cbiAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvckZyb21FbGVtZW50KHRoaXMpXG4gIGNvbnN0IHNlbGVjdG9yRWxlbWVudHMgPSBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yKVxuXG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBzZWxlY3RvckVsZW1lbnRzKSB7XG4gICAgQ29sbGFwc2UuZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50LCB7IHRvZ2dsZTogZmFsc2UgfSkudG9nZ2xlKClcbiAgfVxufSlcblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oQ29sbGFwc2UpXG5cbmV4cG9ydCBkZWZhdWx0IENvbGxhcHNlXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjIuMik6IGRyb3Bkb3duLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICogYXMgUG9wcGVyIGZyb20gJ0Bwb3BwZXJqcy9jb3JlJ1xuaW1wb3J0IHtcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luLFxuICBnZXRFbGVtZW50LFxuICBnZXROZXh0QWN0aXZlRWxlbWVudCxcbiAgaXNEaXNhYmxlZCxcbiAgaXNFbGVtZW50LFxuICBpc1JUTCxcbiAgaXNWaXNpYmxlLFxuICBub29wXG59IGZyb20gJy4vdXRpbC9pbmRleCdcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi9kb20vZXZlbnQtaGFuZGxlcidcbmltcG9ydCBNYW5pcHVsYXRvciBmcm9tICcuL2RvbS9tYW5pcHVsYXRvcidcbmltcG9ydCBTZWxlY3RvckVuZ2luZSBmcm9tICcuL2RvbS9zZWxlY3Rvci1lbmdpbmUnXG5pbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tICcuL2Jhc2UtY29tcG9uZW50J1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUgPSAnZHJvcGRvd24nXG5jb25zdCBEQVRBX0tFWSA9ICdicy5kcm9wZG93bidcbmNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJ1xuXG5jb25zdCBFU0NBUEVfS0VZID0gJ0VzY2FwZSdcbmNvbnN0IFRBQl9LRVkgPSAnVGFiJ1xuY29uc3QgQVJST1dfVVBfS0VZID0gJ0Fycm93VXAnXG5jb25zdCBBUlJPV19ET1dOX0tFWSA9ICdBcnJvd0Rvd24nXG5jb25zdCBSSUdIVF9NT1VTRV9CVVRUT04gPSAyIC8vIE1vdXNlRXZlbnQuYnV0dG9uIHZhbHVlIGZvciB0aGUgc2Vjb25kYXJ5IGJ1dHRvbiwgdXN1YWxseSB0aGUgcmlnaHQgYnV0dG9uXG5cbmNvbnN0IEVWRU5UX0hJREUgPSBgaGlkZSR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0hJRERFTiA9IGBoaWRkZW4ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9TSE9XID0gYHNob3cke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9TSE9XTiA9IGBzaG93biR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gYGNsaWNrJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuY29uc3QgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSA9IGBrZXlkb3duJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuY29uc3QgRVZFTlRfS0VZVVBfREFUQV9BUEkgPSBga2V5dXAke0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gXG5cbmNvbnN0IENMQVNTX05BTUVfU0hPVyA9ICdzaG93J1xuY29uc3QgQ0xBU1NfTkFNRV9EUk9QVVAgPSAnZHJvcHVwJ1xuY29uc3QgQ0xBU1NfTkFNRV9EUk9QRU5EID0gJ2Ryb3BlbmQnXG5jb25zdCBDTEFTU19OQU1FX0RST1BTVEFSVCA9ICdkcm9wc3RhcnQnXG5jb25zdCBDTEFTU19OQU1FX0RST1BVUF9DRU5URVIgPSAnZHJvcHVwLWNlbnRlcidcbmNvbnN0IENMQVNTX05BTUVfRFJPUERPV05fQ0VOVEVSID0gJ2Ryb3Bkb3duLWNlbnRlcidcblxuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUgPSAnW2RhdGEtYnMtdG9nZ2xlPVwiZHJvcGRvd25cIl06bm90KC5kaXNhYmxlZCk6bm90KDpkaXNhYmxlZCknXG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRV9TSE9XTiA9IGAke1NFTEVDVE9SX0RBVEFfVE9HR0xFfS4ke0NMQVNTX05BTUVfU0hPV31gXG5jb25zdCBTRUxFQ1RPUl9NRU5VID0gJy5kcm9wZG93bi1tZW51J1xuY29uc3QgU0VMRUNUT1JfTkFWQkFSID0gJy5uYXZiYXInXG5jb25zdCBTRUxFQ1RPUl9OQVZCQVJfTkFWID0gJy5uYXZiYXItbmF2J1xuY29uc3QgU0VMRUNUT1JfVklTSUJMRV9JVEVNUyA9ICcuZHJvcGRvd24tbWVudSAuZHJvcGRvd24taXRlbTpub3QoLmRpc2FibGVkKTpub3QoOmRpc2FibGVkKSdcblxuY29uc3QgUExBQ0VNRU5UX1RPUCA9IGlzUlRMKCkgPyAndG9wLWVuZCcgOiAndG9wLXN0YXJ0J1xuY29uc3QgUExBQ0VNRU5UX1RPUEVORCA9IGlzUlRMKCkgPyAndG9wLXN0YXJ0JyA6ICd0b3AtZW5kJ1xuY29uc3QgUExBQ0VNRU5UX0JPVFRPTSA9IGlzUlRMKCkgPyAnYm90dG9tLWVuZCcgOiAnYm90dG9tLXN0YXJ0J1xuY29uc3QgUExBQ0VNRU5UX0JPVFRPTUVORCA9IGlzUlRMKCkgPyAnYm90dG9tLXN0YXJ0JyA6ICdib3R0b20tZW5kJ1xuY29uc3QgUExBQ0VNRU5UX1JJR0hUID0gaXNSVEwoKSA/ICdsZWZ0LXN0YXJ0JyA6ICdyaWdodC1zdGFydCdcbmNvbnN0IFBMQUNFTUVOVF9MRUZUID0gaXNSVEwoKSA/ICdyaWdodC1zdGFydCcgOiAnbGVmdC1zdGFydCdcbmNvbnN0IFBMQUNFTUVOVF9UT1BDRU5URVIgPSAndG9wJ1xuY29uc3QgUExBQ0VNRU5UX0JPVFRPTUNFTlRFUiA9ICdib3R0b20nXG5cbmNvbnN0IERlZmF1bHQgPSB7XG4gIGF1dG9DbG9zZTogdHJ1ZSxcbiAgYm91bmRhcnk6ICdjbGlwcGluZ1BhcmVudHMnLFxuICBkaXNwbGF5OiAnZHluYW1pYycsXG4gIG9mZnNldDogWzAsIDJdLFxuICBwb3BwZXJDb25maWc6IG51bGwsXG4gIHJlZmVyZW5jZTogJ3RvZ2dsZSdcbn1cblxuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIGF1dG9DbG9zZTogJyhib29sZWFufHN0cmluZyknLFxuICBib3VuZGFyeTogJyhzdHJpbmd8ZWxlbWVudCknLFxuICBkaXNwbGF5OiAnc3RyaW5nJyxcbiAgb2Zmc2V0OiAnKGFycmF5fHN0cmluZ3xmdW5jdGlvbiknLFxuICBwb3BwZXJDb25maWc6ICcobnVsbHxvYmplY3R8ZnVuY3Rpb24pJyxcbiAgcmVmZXJlbmNlOiAnKHN0cmluZ3xlbGVtZW50fG9iamVjdCknXG59XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIERyb3Bkb3duIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZylcblxuICAgIHRoaXMuX3BvcHBlciA9IG51bGxcbiAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUgLy8gZHJvcGRvd24gd3JhcHBlclxuICAgIC8vIHRvZG86IHY2IHJldmVydCAjMzcwMTEgJiBjaGFuZ2UgbWFya3VwIGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS9kb2NzLzUuMi9mb3Jtcy9pbnB1dC1ncm91cC9cbiAgICB0aGlzLl9tZW51ID0gU2VsZWN0b3JFbmdpbmUubmV4dCh0aGlzLl9lbGVtZW50LCBTRUxFQ1RPUl9NRU5VKVswXSB8fFxuICAgICAgU2VsZWN0b3JFbmdpbmUucHJldih0aGlzLl9lbGVtZW50LCBTRUxFQ1RPUl9NRU5VKVswXSB8fFxuICAgICAgU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9NRU5VLCB0aGlzLl9wYXJlbnQpXG4gICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlXG4gIH1cblxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUVcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICB0b2dnbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU2hvd24oKSA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KClcbiAgfVxuXG4gIHNob3coKSB7XG4gICAgaWYgKGlzRGlzYWJsZWQodGhpcy5fZWxlbWVudCkgfHwgdGhpcy5faXNTaG93bigpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xuICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgIH1cblxuICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1csIHJlbGF0ZWRUYXJnZXQpXG5cbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2NyZWF0ZVBvcHBlcigpXG5cbiAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgYWRkIGV4dHJhXG4gICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB0byB0aGUgYm9keSdzIGltbWVkaWF0ZSBjaGlsZHJlbjtcbiAgICAvLyBvbmx5IG5lZWRlZCBiZWNhdXNlIG9mIGJyb2tlbiBldmVudCBkZWxlZ2F0aW9uIG9uIGlPU1xuICAgIC8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxNC8wMi9tb3VzZV9ldmVudF9idWIuaHRtbFxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgIXRoaXMuX3BhcmVudC5jbG9zZXN0KFNFTEVDVE9SX05BVkJBUl9OQVYpKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pKSB7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vbihlbGVtZW50LCAnbW91c2VvdmVyJywgbm9vcClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9lbGVtZW50LmZvY3VzKClcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpXG5cbiAgICB0aGlzLl9tZW51LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XKVxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1cpXG4gICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04sIHJlbGF0ZWRUYXJnZXQpXG4gIH1cblxuICBoaWRlKCkge1xuICAgIGlmIChpc0Rpc2FibGVkKHRoaXMuX2VsZW1lbnQpIHx8ICF0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfVxuXG4gICAgdGhpcy5fY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpXG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KClcbiAgICB9XG5cbiAgICBzdXBlci5kaXNwb3NlKClcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpXG4gICAgaWYgKHRoaXMuX3BvcHBlcikge1xuICAgICAgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpIHtcbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFLCByZWxhdGVkVGFyZ2V0KVxuICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIHJlbW92ZSB0aGUgZXh0cmFcbiAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHdlIGFkZGVkIGZvciBpT1Mgc3VwcG9ydFxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikpIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9mZihlbGVtZW50LCAnbW91c2VvdmVyJywgbm9vcClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgdGhpcy5fbWVudS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVylcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XKVxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJylcbiAgICBNYW5pcHVsYXRvci5yZW1vdmVEYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsICdwb3BwZXInKVxuICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTiwgcmVsYXRlZFRhcmdldClcbiAgfVxuXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0gc3VwZXIuX2dldENvbmZpZyhjb25maWcpXG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWZlcmVuY2UgPT09ICdvYmplY3QnICYmICFpc0VsZW1lbnQoY29uZmlnLnJlZmVyZW5jZSkgJiZcbiAgICAgIHR5cGVvZiBjb25maWcucmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgLy8gUG9wcGVyIHZpcnR1YWwgZWxlbWVudHMgcmVxdWlyZSBhIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBtZXRob2RcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7TkFNRS50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFwicmVmZXJlbmNlXCIgcHJvdmlkZWQgdHlwZSBcIm9iamVjdFwiIHdpdGhvdXQgYSByZXF1aXJlZCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiIG1ldGhvZC5gKVxuICAgIH1cblxuICAgIHJldHVybiBjb25maWdcbiAgfVxuXG4gIF9jcmVhdGVQb3BwZXIoKSB7XG4gICAgaWYgKHR5cGVvZiBQb3BwZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXCdzIGRyb3Bkb3ducyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKScpXG4gICAgfVxuXG4gICAgbGV0IHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9lbGVtZW50XG5cbiAgICBpZiAodGhpcy5fY29uZmlnLnJlZmVyZW5jZSA9PT0gJ3BhcmVudCcpIHtcbiAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9wYXJlbnRcbiAgICB9IGVsc2UgaWYgKGlzRWxlbWVudCh0aGlzLl9jb25maWcucmVmZXJlbmNlKSkge1xuICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IGdldEVsZW1lbnQodGhpcy5fY29uZmlnLnJlZmVyZW5jZSlcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9jb25maWcucmVmZXJlbmNlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuX2NvbmZpZy5yZWZlcmVuY2VcbiAgICB9XG5cbiAgICBjb25zdCBwb3BwZXJDb25maWcgPSB0aGlzLl9nZXRQb3BwZXJDb25maWcoKVxuICAgIHRoaXMuX3BvcHBlciA9IFBvcHBlci5jcmVhdGVQb3BwZXIocmVmZXJlbmNlRWxlbWVudCwgdGhpcy5fbWVudSwgcG9wcGVyQ29uZmlnKVxuICB9XG5cbiAgX2lzU2hvd24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lbnUuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVylcbiAgfVxuXG4gIF9nZXRQbGFjZW1lbnQoKSB7XG4gICAgY29uc3QgcGFyZW50RHJvcGRvd24gPSB0aGlzLl9wYXJlbnRcblxuICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRU5EKSkge1xuICAgICAgcmV0dXJuIFBMQUNFTUVOVF9SSUdIVFxuICAgIH1cblxuICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QU1RBUlQpKSB7XG4gICAgICByZXR1cm4gUExBQ0VNRU5UX0xFRlRcbiAgICB9XG5cbiAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUFVQX0NFTlRFUikpIHtcbiAgICAgIHJldHVybiBQTEFDRU1FTlRfVE9QQ0VOVEVSXG4gICAgfVxuXG4gICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BET1dOX0NFTlRFUikpIHtcbiAgICAgIHJldHVybiBQTEFDRU1FTlRfQk9UVE9NQ0VOVEVSXG4gICAgfVxuXG4gICAgLy8gV2UgbmVlZCB0byB0cmltIHRoZSB2YWx1ZSBiZWNhdXNlIGN1c3RvbSBwcm9wZXJ0aWVzIGNhbiBhbHNvIGluY2x1ZGUgc3BhY2VzXG4gICAgY29uc3QgaXNFbmQgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX21lbnUpLmdldFByb3BlcnR5VmFsdWUoJy0tYnMtcG9zaXRpb24nKS50cmltKCkgPT09ICdlbmQnXG5cbiAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUFVQKSkge1xuICAgICAgcmV0dXJuIGlzRW5kID8gUExBQ0VNRU5UX1RPUEVORCA6IFBMQUNFTUVOVF9UT1BcbiAgICB9XG5cbiAgICByZXR1cm4gaXNFbmQgPyBQTEFDRU1FTlRfQk9UVE9NRU5EIDogUExBQ0VNRU5UX0JPVFRPTVxuICB9XG5cbiAgX2RldGVjdE5hdmJhcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX05BVkJBUikgIT09IG51bGxcbiAgfVxuXG4gIF9nZXRPZmZzZXQoKSB7XG4gICAgY29uc3QgeyBvZmZzZXQgfSA9IHRoaXMuX2NvbmZpZ1xuXG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gb2Zmc2V0LnNwbGl0KCcsJykubWFwKHZhbHVlID0+IE51bWJlci5wYXJzZUludCh2YWx1ZSwgMTApKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcG9wcGVyRGF0YSA9PiBvZmZzZXQocG9wcGVyRGF0YSwgdGhpcy5fZWxlbWVudClcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0XG4gIH1cblxuICBfZ2V0UG9wcGVyQ29uZmlnKCkge1xuICAgIGNvbnN0IGRlZmF1bHRCc1BvcHBlckNvbmZpZyA9IHtcbiAgICAgIHBsYWNlbWVudDogdGhpcy5fZ2V0UGxhY2VtZW50KCksXG4gICAgICBtb2RpZmllcnM6IFt7XG4gICAgICAgIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgYm91bmRhcnk6IHRoaXMuX2NvbmZpZy5ib3VuZGFyeVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcbiAgICAgICAgfVxuICAgICAgfV1cbiAgICB9XG5cbiAgICAvLyBEaXNhYmxlIFBvcHBlciBpZiB3ZSBoYXZlIGEgc3RhdGljIGRpc3BsYXkgb3IgRHJvcGRvd24gaXMgaW4gTmF2YmFyXG4gICAgaWYgKHRoaXMuX2luTmF2YmFyIHx8IHRoaXMuX2NvbmZpZy5kaXNwbGF5ID09PSAnc3RhdGljJykge1xuICAgICAgTWFuaXB1bGF0b3Iuc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCAncG9wcGVyJywgJ3N0YXRpYycpIC8vIHRvZG86djYgcmVtb3ZlXG4gICAgICBkZWZhdWx0QnNQb3BwZXJDb25maWcubW9kaWZpZXJzID0gW3tcbiAgICAgICAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgIH1dXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRlZmF1bHRCc1BvcHBlckNvbmZpZyxcbiAgICAgIC4uLih0eXBlb2YgdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcoZGVmYXVsdEJzUG9wcGVyQ29uZmlnKSA6IHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcpXG4gICAgfVxuICB9XG5cbiAgX3NlbGVjdE1lbnVJdGVtKHsga2V5LCB0YXJnZXQgfSkge1xuICAgIGNvbnN0IGl0ZW1zID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9WSVNJQkxFX0lURU1TLCB0aGlzLl9tZW51KS5maWx0ZXIoZWxlbWVudCA9PiBpc1Zpc2libGUoZWxlbWVudCkpXG5cbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gaWYgdGFyZ2V0IGlzbid0IGluY2x1ZGVkIGluIGl0ZW1zIChlLmcuIHdoZW4gZXhwYW5kaW5nIHRoZSBkcm9wZG93bilcbiAgICAvLyBhbGxvdyBjeWNsaW5nIHRvIGdldCB0aGUgbGFzdCBpdGVtIGluIGNhc2Uga2V5IGVxdWFscyBBUlJPV19VUF9LRVlcbiAgICBnZXROZXh0QWN0aXZlRWxlbWVudChpdGVtcywgdGFyZ2V0LCBrZXkgPT09IEFSUk9XX0RPV05fS0VZLCAhaXRlbXMuaW5jbHVkZXModGFyZ2V0KSkuZm9jdXMoKVxuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gRHJvcGRvd24uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpXG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgIH1cblxuICAgICAgZGF0YVtjb25maWddKClcbiAgICB9KVxuICB9XG5cbiAgc3RhdGljIGNsZWFyTWVudXMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYnV0dG9uID09PSBSSUdIVF9NT1VTRV9CVVRUT04gfHwgKGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQua2V5ICE9PSBUQUJfS0VZKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgb3BlblRvZ2dsZXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfVE9HR0xFX1NIT1dOKVxuXG4gICAgZm9yIChjb25zdCB0b2dnbGUgb2Ygb3BlblRvZ2dsZXMpIHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBEcm9wZG93bi5nZXRJbnN0YW5jZSh0b2dnbGUpXG4gICAgICBpZiAoIWNvbnRleHQgfHwgY29udGV4dC5fY29uZmlnLmF1dG9DbG9zZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29tcG9zZWRQYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKClcbiAgICAgIGNvbnN0IGlzTWVudVRhcmdldCA9IGNvbXBvc2VkUGF0aC5pbmNsdWRlcyhjb250ZXh0Ll9tZW51KVxuICAgICAgaWYgKFxuICAgICAgICBjb21wb3NlZFBhdGguaW5jbHVkZXMoY29udGV4dC5fZWxlbWVudCkgfHxcbiAgICAgICAgKGNvbnRleHQuX2NvbmZpZy5hdXRvQ2xvc2UgPT09ICdpbnNpZGUnICYmICFpc01lbnVUYXJnZXQpIHx8XG4gICAgICAgIChjb250ZXh0Ll9jb25maWcuYXV0b0Nsb3NlID09PSAnb3V0c2lkZScgJiYgaXNNZW51VGFyZ2V0KVxuICAgICAgKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIFRhYiBuYXZpZ2F0aW9uIHRocm91Z2ggdGhlIGRyb3Bkb3duIG1lbnUgb3IgZXZlbnRzIGZyb20gY29udGFpbmVkIGlucHV0cyBzaG91bGRuJ3QgY2xvc2UgdGhlIG1lbnVcbiAgICAgIGlmIChjb250ZXh0Ll9tZW51LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkgJiYgKChldmVudC50eXBlID09PSAna2V5dXAnICYmIGV2ZW50LmtleSA9PT0gVEFCX0tFWSkgfHwgL2lucHV0fHNlbGVjdHxvcHRpb258dGV4dGFyZWF8Zm9ybS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpKSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0geyByZWxhdGVkVGFyZ2V0OiBjb250ZXh0Ll9lbGVtZW50IH1cblxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldC5jbGlja0V2ZW50ID0gZXZlbnRcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5fY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGRhdGFBcGlLZXlkb3duSGFuZGxlcihldmVudCkge1xuICAgIC8vIElmIG5vdCBhbiBVUCB8IERPV04gfCBFU0NBUEUga2V5ID0+IG5vdCBhIGRyb3Bkb3duIGNvbW1hbmRcbiAgICAvLyBJZiBpbnB1dC90ZXh0YXJlYSAmJiBpZiBrZXkgaXMgb3RoZXIgdGhhbiBFU0NBUEUgPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuXG4gICAgY29uc3QgaXNJbnB1dCA9IC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpXG4gICAgY29uc3QgaXNFc2NhcGVFdmVudCA9IGV2ZW50LmtleSA9PT0gRVNDQVBFX0tFWVxuICAgIGNvbnN0IGlzVXBPckRvd25FdmVudCA9IFtBUlJPV19VUF9LRVksIEFSUk9XX0RPV05fS0VZXS5pbmNsdWRlcyhldmVudC5rZXkpXG5cbiAgICBpZiAoIWlzVXBPckRvd25FdmVudCAmJiAhaXNFc2NhcGVFdmVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGlzSW5wdXQgJiYgIWlzRXNjYXBlRXZlbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblxuICAgIC8vIHRvZG86IHY2IHJldmVydCAjMzcwMTEgJiBjaGFuZ2UgbWFya3VwIGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS9kb2NzLzUuMi9mb3Jtcy9pbnB1dC1ncm91cC9cbiAgICBjb25zdCBnZXRUb2dnbGVCdXR0b24gPSB0aGlzLm1hdGNoZXMoU0VMRUNUT1JfREFUQV9UT0dHTEUpID9cbiAgICAgIHRoaXMgOlxuICAgICAgKFNlbGVjdG9yRW5naW5lLnByZXYodGhpcywgU0VMRUNUT1JfREFUQV9UT0dHTEUpWzBdIHx8XG4gICAgICAgIFNlbGVjdG9yRW5naW5lLm5leHQodGhpcywgU0VMRUNUT1JfREFUQV9UT0dHTEUpWzBdIHx8XG4gICAgICAgIFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfREFUQV9UT0dHTEUsIGV2ZW50LmRlbGVnYXRlVGFyZ2V0LnBhcmVudE5vZGUpKVxuXG4gICAgY29uc3QgaW5zdGFuY2UgPSBEcm9wZG93bi5nZXRPckNyZWF0ZUluc3RhbmNlKGdldFRvZ2dsZUJ1dHRvbilcblxuICAgIGlmIChpc1VwT3JEb3duRXZlbnQpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICBpbnN0YW5jZS5zaG93KClcbiAgICAgIGluc3RhbmNlLl9zZWxlY3RNZW51SXRlbShldmVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5faXNTaG93bigpKSB7IC8vIGVsc2UgaXMgZXNjYXBlIGFuZCB3ZSBjaGVjayBpZiBpdCBpcyBzaG93blxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgIGluc3RhbmNlLmhpZGUoKVxuICAgICAgZ2V0VG9nZ2xlQnV0dG9uLmZvY3VzKClcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICovXG5cbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUsIERyb3Bkb3duLmRhdGFBcGlLZXlkb3duSGFuZGxlcilcbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSwgU0VMRUNUT1JfTUVOVSwgRHJvcGRvd24uZGF0YUFwaUtleWRvd25IYW5kbGVyKVxuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSwgRHJvcGRvd24uY2xlYXJNZW51cylcbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZVVBfREFUQV9BUEksIERyb3Bkb3duLmNsZWFyTWVudXMpXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgRHJvcGRvd24uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKS50b2dnbGUoKVxufSlcblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oRHJvcGRvd24pXG5cbmV4cG9ydCBkZWZhdWx0IERyb3Bkb3duXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjIuMik6IHV0aWwvc2Nyb2xsQmFyLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0IFNlbGVjdG9yRW5naW5lIGZyb20gJy4uL2RvbS9zZWxlY3Rvci1lbmdpbmUnXG5pbXBvcnQgTWFuaXB1bGF0b3IgZnJvbSAnLi4vZG9tL21hbmlwdWxhdG9yJ1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSAnLi9pbmRleCdcblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBTRUxFQ1RPUl9GSVhFRF9DT05URU5UID0gJy5maXhlZC10b3AsIC5maXhlZC1ib3R0b20sIC5pcy1maXhlZCwgLnN0aWNreS10b3AnXG5jb25zdCBTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCA9ICcuc3RpY2t5LXRvcCdcbmNvbnN0IFBST1BFUlRZX1BBRERJTkcgPSAncGFkZGluZy1yaWdodCdcbmNvbnN0IFBST1BFUlRZX01BUkdJTiA9ICdtYXJnaW4tcmlnaHQnXG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIFNjcm9sbEJhckhlbHBlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBkb2N1bWVudC5ib2R5XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgZ2V0V2lkdGgoKSB7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9pbm5lcldpZHRoI3VzYWdlX25vdGVzXG4gICAgY29uc3QgZG9jdW1lbnRXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aFxuICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cuaW5uZXJXaWR0aCAtIGRvY3VtZW50V2lkdGgpXG4gIH1cblxuICBoaWRlKCkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpXG4gICAgdGhpcy5fZGlzYWJsZU92ZXJGbG93KClcbiAgICAvLyBnaXZlIHBhZGRpbmcgdG8gZWxlbWVudCB0byBiYWxhbmNlIHRoZSBoaWRkZW4gc2Nyb2xsYmFyIHdpZHRoXG4gICAgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgUFJPUEVSVFlfUEFERElORywgY2FsY3VsYXRlZFZhbHVlID0+IGNhbGN1bGF0ZWRWYWx1ZSArIHdpZHRoKVxuICAgIC8vIHRyaWNrOiBXZSBhZGp1c3QgcG9zaXRpdmUgcGFkZGluZ1JpZ2h0IGFuZCBuZWdhdGl2ZSBtYXJnaW5SaWdodCB0byBzdGlja3ktdG9wIGVsZW1lbnRzIHRvIGtlZXAgc2hvd2luZyBmdWxsd2lkdGhcbiAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9GSVhFRF9DT05URU5ULCBQUk9QRVJUWV9QQURESU5HLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlICsgd2lkdGgpXG4gICAgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQsIFBST1BFUlRZX01BUkdJTiwgY2FsY3VsYXRlZFZhbHVlID0+IGNhbGN1bGF0ZWRWYWx1ZSAtIHdpZHRoKVxuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCAnb3ZlcmZsb3cnKVxuICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgUFJPUEVSVFlfUEFERElORylcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQsIFBST1BFUlRZX1BBRERJTkcpXG4gICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCwgUFJPUEVSVFlfTUFSR0lOKVxuICB9XG5cbiAgaXNPdmVyZmxvd2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRXaWR0aCgpID4gMFxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfZGlzYWJsZU92ZXJGbG93KCkge1xuICAgIHRoaXMuX3NhdmVJbml0aWFsQXR0cmlidXRlKHRoaXMuX2VsZW1lbnQsICdvdmVyZmxvdycpXG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nXG4gIH1cblxuICBfc2V0RWxlbWVudEF0dHJpYnV0ZXMoc2VsZWN0b3IsIHN0eWxlUHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSB0aGlzLmdldFdpZHRoKClcbiAgICBjb25zdCBtYW5pcHVsYXRpb25DYWxsQmFjayA9IGVsZW1lbnQgPT4ge1xuICAgICAgaWYgKGVsZW1lbnQgIT09IHRoaXMuX2VsZW1lbnQgJiYgd2luZG93LmlubmVyV2lkdGggPiBlbGVtZW50LmNsaWVudFdpZHRoICsgc2Nyb2xsYmFyV2lkdGgpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NhdmVJbml0aWFsQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHkpXG4gICAgICBjb25zdCBjYWxjdWxhdGVkVmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHN0eWxlUHJvcGVydHkpXG4gICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHN0eWxlUHJvcGVydHksIGAke2NhbGxiYWNrKE51bWJlci5wYXJzZUZsb2F0KGNhbGN1bGF0ZWRWYWx1ZSkpfXB4YClcbiAgICB9XG5cbiAgICB0aGlzLl9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHNlbGVjdG9yLCBtYW5pcHVsYXRpb25DYWxsQmFjaylcbiAgfVxuXG4gIF9zYXZlSW5pdGlhbEF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5KSB7XG4gICAgY29uc3QgYWN0dWFsVmFsdWUgPSBlbGVtZW50LnN0eWxlLmdldFByb3BlcnR5VmFsdWUoc3R5bGVQcm9wZXJ0eSlcbiAgICBpZiAoYWN0dWFsVmFsdWUpIHtcbiAgICAgIE1hbmlwdWxhdG9yLnNldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wZXJ0eSwgYWN0dWFsVmFsdWUpXG4gICAgfVxuICB9XG5cbiAgX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoc2VsZWN0b3IsIHN0eWxlUHJvcGVydHkpIHtcbiAgICBjb25zdCBtYW5pcHVsYXRpb25DYWxsQmFjayA9IGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHkpXG4gICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gcmVtb3ZlIHRoZSBwcm9wZXJ0eSBpZiB0aGUgdmFsdWUgaXMgYG51bGxgOyB0aGUgdmFsdWUgY2FuIGFsc28gYmUgemVyb1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoc3R5bGVQcm9wZXJ0eSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIE1hbmlwdWxhdG9yLnJlbW92ZURhdGFBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wZXJ0eSlcbiAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoc3R5bGVQcm9wZXJ0eSwgdmFsdWUpXG4gICAgfVxuXG4gICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayhzZWxlY3RvciwgbWFuaXB1bGF0aW9uQ2FsbEJhY2spXG4gIH1cblxuICBfYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayhzZWxlY3RvciwgY2FsbEJhY2spIHtcbiAgICBpZiAoaXNFbGVtZW50KHNlbGVjdG9yKSkge1xuICAgICAgY2FsbEJhY2soc2VsZWN0b3IpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHNlbCBvZiBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yLCB0aGlzLl9lbGVtZW50KSkge1xuICAgICAgY2FsbEJhY2soc2VsKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTY3JvbGxCYXJIZWxwZXJcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMi4yKTogdXRpbC9iYWNrZHJvcC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZG9tL2V2ZW50LWhhbmRsZXInXG5pbXBvcnQgeyBleGVjdXRlLCBleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uLCBnZXRFbGVtZW50LCByZWZsb3cgfSBmcm9tICcuL2luZGV4J1xuaW1wb3J0IENvbmZpZyBmcm9tICcuL2NvbmZpZydcblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FID0gJ2JhY2tkcm9wJ1xuY29uc3QgQ0xBU1NfTkFNRV9GQURFID0gJ2ZhZGUnXG5jb25zdCBDTEFTU19OQU1FX1NIT1cgPSAnc2hvdydcbmNvbnN0IEVWRU5UX01PVVNFRE9XTiA9IGBtb3VzZWRvd24uYnMuJHtOQU1FfWBcblxuY29uc3QgRGVmYXVsdCA9IHtcbiAgY2xhc3NOYW1lOiAnbW9kYWwtYmFja2Ryb3AnLFxuICBjbGlja0NhbGxiYWNrOiBudWxsLFxuICBpc0FuaW1hdGVkOiBmYWxzZSxcbiAgaXNWaXNpYmxlOiB0cnVlLCAvLyBpZiBmYWxzZSwgd2UgdXNlIHRoZSBiYWNrZHJvcCBoZWxwZXIgd2l0aG91dCBhZGRpbmcgYW55IGVsZW1lbnQgdG8gdGhlIGRvbVxuICByb290RWxlbWVudDogJ2JvZHknIC8vIGdpdmUgdGhlIGNob2ljZSB0byBwbGFjZSBiYWNrZHJvcCB1bmRlciBkaWZmZXJlbnQgZWxlbWVudHNcbn1cblxuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gIGNsaWNrQ2FsbGJhY2s6ICcoZnVuY3Rpb258bnVsbCknLFxuICBpc0FuaW1hdGVkOiAnYm9vbGVhbicsXG4gIGlzVmlzaWJsZTogJ2Jvb2xlYW4nLFxuICByb290RWxlbWVudDogJyhlbGVtZW50fHN0cmluZyknXG59XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIEJhY2tkcm9wIGV4dGVuZHMgQ29uZmlnIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpXG4gICAgdGhpcy5faXNBcHBlbmRlZCA9IGZhbHNlXG4gICAgdGhpcy5fZWxlbWVudCA9IG51bGxcbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0XG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZVxuICB9XG5cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FXG4gIH1cblxuICAvLyBQdWJsaWNcbiAgc2hvdyhjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5fY29uZmlnLmlzVmlzaWJsZSkge1xuICAgICAgZXhlY3V0ZShjYWxsYmFjaylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2FwcGVuZCgpXG5cbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZ2V0RWxlbWVudCgpXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkKSB7XG4gICAgICByZWZsb3coZWxlbWVudClcbiAgICB9XG5cbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XKVxuXG4gICAgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XG4gICAgICBleGVjdXRlKGNhbGxiYWNrKVxuICAgIH0pXG4gIH1cblxuICBoaWRlKGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XG4gICAgICBleGVjdXRlKGNhbGxiYWNrKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fZ2V0RWxlbWVudCgpLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XKVxuXG4gICAgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLmRpc3Bvc2UoKVxuICAgICAgZXhlY3V0ZShjYWxsYmFjaylcbiAgICB9KVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzQXBwZW5kZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VET1dOKVxuXG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmUoKVxuICAgIHRoaXMuX2lzQXBwZW5kZWQgPSBmYWxzZVxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0RWxlbWVudCgpIHtcbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGJhY2tkcm9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgIGJhY2tkcm9wLmNsYXNzTmFtZSA9IHRoaXMuX2NvbmZpZy5jbGFzc05hbWVcbiAgICAgIGlmICh0aGlzLl9jb25maWcuaXNBbmltYXRlZCkge1xuICAgICAgICBiYWNrZHJvcC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSlcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZWxlbWVudCA9IGJhY2tkcm9wXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRcbiAgfVxuXG4gIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xuICAgIC8vIHVzZSBnZXRFbGVtZW50KCkgd2l0aCB0aGUgZGVmYXVsdCBcImJvZHlcIiB0byBnZXQgYSBmcmVzaCBFbGVtZW50IG9uIGVhY2ggaW5zdGFudGlhdGlvblxuICAgIGNvbmZpZy5yb290RWxlbWVudCA9IGdldEVsZW1lbnQoY29uZmlnLnJvb3RFbGVtZW50KVxuICAgIHJldHVybiBjb25maWdcbiAgfVxuXG4gIF9hcHBlbmQoKSB7XG4gICAgaWYgKHRoaXMuX2lzQXBwZW5kZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9nZXRFbGVtZW50KClcbiAgICB0aGlzLl9jb25maWcucm9vdEVsZW1lbnQuYXBwZW5kKGVsZW1lbnQpXG5cbiAgICBFdmVudEhhbmRsZXIub24oZWxlbWVudCwgRVZFTlRfTU9VU0VET1dOLCAoKSA9PiB7XG4gICAgICBleGVjdXRlKHRoaXMuX2NvbmZpZy5jbGlja0NhbGxiYWNrKVxuICAgIH0pXG5cbiAgICB0aGlzLl9pc0FwcGVuZGVkID0gdHJ1ZVxuICB9XG5cbiAgX2VtdWxhdGVBbmltYXRpb24oY2FsbGJhY2spIHtcbiAgICBleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uKGNhbGxiYWNrLCB0aGlzLl9nZXRFbGVtZW50KCksIHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhY2tkcm9wXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjIuMik6IHV0aWwvZm9jdXN0cmFwLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9kb20vZXZlbnQtaGFuZGxlcidcbmltcG9ydCBTZWxlY3RvckVuZ2luZSBmcm9tICcuLi9kb20vc2VsZWN0b3ItZW5naW5lJ1xuaW1wb3J0IENvbmZpZyBmcm9tICcuL2NvbmZpZydcblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FID0gJ2ZvY3VzdHJhcCdcbmNvbnN0IERBVEFfS0VZID0gJ2JzLmZvY3VzdHJhcCdcbmNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBFVkVOVF9GT0NVU0lOID0gYGZvY3VzaW4ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9LRVlET1dOX1RBQiA9IGBrZXlkb3duLnRhYiR7RVZFTlRfS0VZfWBcblxuY29uc3QgVEFCX0tFWSA9ICdUYWInXG5jb25zdCBUQUJfTkFWX0ZPUldBUkQgPSAnZm9yd2FyZCdcbmNvbnN0IFRBQl9OQVZfQkFDS1dBUkQgPSAnYmFja3dhcmQnXG5cbmNvbnN0IERlZmF1bHQgPSB7XG4gIGF1dG9mb2N1czogdHJ1ZSxcbiAgdHJhcEVsZW1lbnQ6IG51bGwgLy8gVGhlIGVsZW1lbnQgdG8gdHJhcCBmb2N1cyBpbnNpZGUgb2Zcbn1cblxuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIGF1dG9mb2N1czogJ2Jvb2xlYW4nLFxuICB0cmFwRWxlbWVudDogJ2VsZW1lbnQnXG59XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIEZvY3VzVHJhcCBleHRlbmRzIENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKVxuICAgIHRoaXMuX2lzQWN0aXZlID0gZmFsc2VcbiAgICB0aGlzLl9sYXN0VGFiTmF2RGlyZWN0aW9uID0gbnVsbFxuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlXG4gIH1cblxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUVcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICBhY3RpdmF0ZSgpIHtcbiAgICBpZiAodGhpcy5faXNBY3RpdmUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb25maWcuYXV0b2ZvY3VzKSB7XG4gICAgICB0aGlzLl9jb25maWcudHJhcEVsZW1lbnQuZm9jdXMoKVxuICAgIH1cblxuICAgIEV2ZW50SGFuZGxlci5vZmYoZG9jdW1lbnQsIEVWRU5UX0tFWSkgLy8gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBmb2N1cyBsb29wXG4gICAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9GT0NVU0lOLCBldmVudCA9PiB0aGlzLl9oYW5kbGVGb2N1c2luKGV2ZW50KSlcbiAgICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWURPV05fVEFCLCBldmVudCA9PiB0aGlzLl9oYW5kbGVLZXlkb3duKGV2ZW50KSlcblxuICAgIHRoaXMuX2lzQWN0aXZlID0gdHJ1ZVxuICB9XG5cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzQWN0aXZlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9pc0FjdGl2ZSA9IGZhbHNlXG4gICAgRXZlbnRIYW5kbGVyLm9mZihkb2N1bWVudCwgRVZFTlRfS0VZKVxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfaGFuZGxlRm9jdXNpbihldmVudCkge1xuICAgIGNvbnN0IHsgdHJhcEVsZW1lbnQgfSA9IHRoaXMuX2NvbmZpZ1xuXG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gZG9jdW1lbnQgfHwgZXZlbnQudGFyZ2V0ID09PSB0cmFwRWxlbWVudCB8fCB0cmFwRWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50cyA9IFNlbGVjdG9yRW5naW5lLmZvY3VzYWJsZUNoaWxkcmVuKHRyYXBFbGVtZW50KVxuXG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdHJhcEVsZW1lbnQuZm9jdXMoKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fbGFzdFRhYk5hdkRpcmVjdGlvbiA9PT0gVEFCX05BVl9CQUNLV0FSRCkge1xuICAgICAgZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0uZm9jdXMoKVxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50c1swXS5mb2N1cygpXG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZUtleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQua2V5ICE9PSBUQUJfS0VZKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9sYXN0VGFiTmF2RGlyZWN0aW9uID0gZXZlbnQuc2hpZnRLZXkgPyBUQUJfTkFWX0JBQ0tXQVJEIDogVEFCX05BVl9GT1JXQVJEXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRm9jdXNUcmFwXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjIuMik6IG1vZGFsLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0IHsgZGVmaW5lSlF1ZXJ5UGx1Z2luLCBnZXRFbGVtZW50RnJvbVNlbGVjdG9yLCBpc1JUTCwgaXNWaXNpYmxlLCByZWZsb3cgfSBmcm9tICcuL3V0aWwvaW5kZXgnXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4vZG9tL2V2ZW50LWhhbmRsZXInXG5pbXBvcnQgU2VsZWN0b3JFbmdpbmUgZnJvbSAnLi9kb20vc2VsZWN0b3ItZW5naW5lJ1xuaW1wb3J0IFNjcm9sbEJhckhlbHBlciBmcm9tICcuL3V0aWwvc2Nyb2xsYmFyJ1xuaW1wb3J0IEJhc2VDb21wb25lbnQgZnJvbSAnLi9iYXNlLWNvbXBvbmVudCdcbmltcG9ydCBCYWNrZHJvcCBmcm9tICcuL3V0aWwvYmFja2Ryb3AnXG5pbXBvcnQgRm9jdXNUcmFwIGZyb20gJy4vdXRpbC9mb2N1c3RyYXAnXG5pbXBvcnQgeyBlbmFibGVEaXNtaXNzVHJpZ2dlciB9IGZyb20gJy4vdXRpbC9jb21wb25lbnQtZnVuY3Rpb25zJ1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUgPSAnbW9kYWwnXG5jb25zdCBEQVRBX0tFWSA9ICdicy5tb2RhbCdcbmNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJ1xuY29uc3QgRVNDQVBFX0tFWSA9ICdFc2NhcGUnXG5cbmNvbnN0IEVWRU5UX0hJREUgPSBgaGlkZSR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0hJREVfUFJFVkVOVEVEID0gYGhpZGVQcmV2ZW50ZWQke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9ISURERU4gPSBgaGlkZGVuJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0hPVyA9IGBzaG93JHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0hPV04gPSBgc2hvd24ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9SRVNJWkUgPSBgcmVzaXplJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfQ0xJQ0tfRElTTUlTUyA9IGBjbGljay5kaXNtaXNzJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfTU9VU0VET1dOX0RJU01JU1MgPSBgbW91c2Vkb3duLmRpc21pc3Mke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9LRVlET1dOX0RJU01JU1MgPSBga2V5ZG93bi5kaXNtaXNzJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkgPSBgY2xpY2ske0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gXG5cbmNvbnN0IENMQVNTX05BTUVfT1BFTiA9ICdtb2RhbC1vcGVuJ1xuY29uc3QgQ0xBU1NfTkFNRV9GQURFID0gJ2ZhZGUnXG5jb25zdCBDTEFTU19OQU1FX1NIT1cgPSAnc2hvdydcbmNvbnN0IENMQVNTX05BTUVfU1RBVElDID0gJ21vZGFsLXN0YXRpYydcblxuY29uc3QgT1BFTl9TRUxFQ1RPUiA9ICcubW9kYWwuc2hvdydcbmNvbnN0IFNFTEVDVE9SX0RJQUxPRyA9ICcubW9kYWwtZGlhbG9nJ1xuY29uc3QgU0VMRUNUT1JfTU9EQUxfQk9EWSA9ICcubW9kYWwtYm9keSdcbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFID0gJ1tkYXRhLWJzLXRvZ2dsZT1cIm1vZGFsXCJdJ1xuXG5jb25zdCBEZWZhdWx0ID0ge1xuICBiYWNrZHJvcDogdHJ1ZSxcbiAgZm9jdXM6IHRydWUsXG4gIGtleWJvYXJkOiB0cnVlXG59XG5cbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICBiYWNrZHJvcDogJyhib29sZWFufHN0cmluZyknLFxuICBmb2N1czogJ2Jvb2xlYW4nLFxuICBrZXlib2FyZDogJ2Jvb2xlYW4nXG59XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIE1vZGFsIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZylcblxuICAgIHRoaXMuX2RpYWxvZyA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfRElBTE9HLCB0aGlzLl9lbGVtZW50KVxuICAgIHRoaXMuX2JhY2tkcm9wID0gdGhpcy5faW5pdGlhbGl6ZUJhY2tEcm9wKClcbiAgICB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKClcbiAgICB0aGlzLl9pc1Nob3duID0gZmFsc2VcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZVxuICAgIHRoaXMuX3Njcm9sbEJhciA9IG5ldyBTY3JvbGxCYXJIZWxwZXIoKVxuXG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlXG4gIH1cblxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUVcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICB0b2dnbGUocmVsYXRlZFRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3cocmVsYXRlZFRhcmdldClcbiAgfVxuXG4gIHNob3cocmVsYXRlZFRhcmdldCkge1xuICAgIGlmICh0aGlzLl9pc1Nob3duIHx8IHRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVywge1xuICAgICAgcmVsYXRlZFRhcmdldFxuICAgIH0pXG5cbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlXG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZVxuXG4gICAgdGhpcy5fc2Nyb2xsQmFyLmhpZGUoKVxuXG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfT1BFTilcblxuICAgIHRoaXMuX2FkanVzdERpYWxvZygpXG5cbiAgICB0aGlzLl9iYWNrZHJvcC5zaG93KCgpID0+IHRoaXMuX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpKVxuICB9XG5cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFKVxuXG4gICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9pc1Nob3duID0gZmFsc2VcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlXG4gICAgdGhpcy5fZm9jdXN0cmFwLmRlYWN0aXZhdGUoKVxuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVylcblxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4gdGhpcy5faGlkZU1vZGFsKCksIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2lzQW5pbWF0ZWQoKSlcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgZm9yIChjb25zdCBodG1sRWxlbWVudCBvZiBbd2luZG93LCB0aGlzLl9kaWFsb2ddKSB7XG4gICAgICBFdmVudEhhbmRsZXIub2ZmKGh0bWxFbGVtZW50LCBFVkVOVF9LRVkpXG4gICAgfVxuXG4gICAgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpXG4gICAgdGhpcy5fZm9jdXN0cmFwLmRlYWN0aXZhdGUoKVxuICAgIHN1cGVyLmRpc3Bvc2UoKVxuICB9XG5cbiAgaGFuZGxlVXBkYXRlKCkge1xuICAgIHRoaXMuX2FkanVzdERpYWxvZygpXG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9pbml0aWFsaXplQmFja0Ryb3AoKSB7XG4gICAgcmV0dXJuIG5ldyBCYWNrZHJvcCh7XG4gICAgICBpc1Zpc2libGU6IEJvb2xlYW4odGhpcy5fY29uZmlnLmJhY2tkcm9wKSwgLy8gJ3N0YXRpYycgb3B0aW9uIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB0cnVlLCBhbmQgYm9vbGVhbnMgd2lsbCBrZWVwIHRoZWlyIHZhbHVlLFxuICAgICAgaXNBbmltYXRlZDogdGhpcy5faXNBbmltYXRlZCgpXG4gICAgfSlcbiAgfVxuXG4gIF9pbml0aWFsaXplRm9jdXNUcmFwKCkge1xuICAgIHJldHVybiBuZXcgRm9jdXNUcmFwKHtcbiAgICAgIHRyYXBFbGVtZW50OiB0aGlzLl9lbGVtZW50XG4gICAgfSlcbiAgfVxuXG4gIF9zaG93RWxlbWVudChyZWxhdGVkVGFyZ2V0KSB7XG4gICAgLy8gdHJ5IHRvIGFwcGVuZCBkeW5hbWljIG1vZGFsXG4gICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMuX2VsZW1lbnQpKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZCh0aGlzLl9lbGVtZW50KVxuICAgIH1cblxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKVxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgdHJ1ZSlcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKVxuICAgIHRoaXMuX2VsZW1lbnQuc2Nyb2xsVG9wID0gMFxuXG4gICAgY29uc3QgbW9kYWxCb2R5ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9NT0RBTF9CT0RZLCB0aGlzLl9kaWFsb2cpXG4gICAgaWYgKG1vZGFsQm9keSkge1xuICAgICAgbW9kYWxCb2R5LnNjcm9sbFRvcCA9IDBcbiAgICB9XG5cbiAgICByZWZsb3codGhpcy5fZWxlbWVudClcblxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1cpXG5cbiAgICBjb25zdCB0cmFuc2l0aW9uQ29tcGxldGUgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fY29uZmlnLmZvY3VzKSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzdHJhcC5hY3RpdmF0ZSgpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0XG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2sodHJhbnNpdGlvbkNvbXBsZXRlLCB0aGlzLl9kaWFsb2csIHRoaXMuX2lzQW5pbWF0ZWQoKSlcbiAgfVxuXG4gIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZRE9XTl9ESVNNSVNTLCBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQua2V5ICE9PSBFU0NBUEVfS0VZKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmtleWJvYXJkKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgdGhpcy5oaWRlKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKVxuICAgIH0pXG5cbiAgICBFdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9SRVNJWkUsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duICYmICF0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgdGhpcy5fYWRqdXN0RGlhbG9nKClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFRE9XTl9ESVNNSVNTLCBldmVudCA9PiB7XG4gICAgICAvLyBhIGJhZCB0cmljayB0byBzZWdyZWdhdGUgY2xpY2tzIHRoYXQgbWF5IHN0YXJ0IGluc2lkZSBkaWFsb2cgYnV0IGVuZCBvdXRzaWRlLCBhbmQgYXZvaWQgbGlzdGVuIHRvIHNjcm9sbGJhciBjbGlja3NcbiAgICAgIEV2ZW50SGFuZGxlci5vbmUodGhpcy5fZWxlbWVudCwgRVZFTlRfQ0xJQ0tfRElTTUlTUywgZXZlbnQyID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQgIT09IGV2ZW50LnRhcmdldCB8fCB0aGlzLl9lbGVtZW50ICE9PSBldmVudDIudGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSAnc3RhdGljJykge1xuICAgICAgICAgIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCkge1xuICAgICAgICAgIHRoaXMuaGlkZSgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIF9oaWRlTW9kYWwoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdHJ1ZSlcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcpXG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKVxuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlXG5cbiAgICB0aGlzLl9iYWNrZHJvcC5oaWRlKCgpID0+IHtcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX09QRU4pXG4gICAgICB0aGlzLl9yZXNldEFkanVzdG1lbnRzKClcbiAgICAgIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4pXG4gICAgfSlcbiAgfVxuXG4gIF9pc0FuaW1hdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUpXG4gIH1cblxuICBfdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpIHtcbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFX1BSRVZFTlRFRClcbiAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGlzTW9kYWxPdmVyZmxvd2luZyA9IHRoaXMuX2VsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuICAgIGNvbnN0IGluaXRpYWxPdmVyZmxvd1kgPSB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WVxuICAgIC8vIHJldHVybiBpZiB0aGUgZm9sbG93aW5nIGJhY2tncm91bmQgdHJhbnNpdGlvbiBoYXNuJ3QgeWV0IGNvbXBsZXRlZFxuICAgIGlmIChpbml0aWFsT3ZlcmZsb3dZID09PSAnaGlkZGVuJyB8fCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NUQVRJQykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghaXNNb2RhbE92ZXJmbG93aW5nKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9ICdoaWRkZW4nXG4gICAgfVxuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU1RBVElDKVxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU1RBVElDKVxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3dZID0gaW5pdGlhbE92ZXJmbG93WVxuICAgICAgfSwgdGhpcy5fZGlhbG9nKVxuICAgIH0sIHRoaXMuX2RpYWxvZylcblxuICAgIHRoaXMuX2VsZW1lbnQuZm9jdXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBmb2xsb3dpbmcgbWV0aG9kcyBhcmUgdXNlZCB0byBoYW5kbGUgb3ZlcmZsb3dpbmcgbW9kYWxzXG4gICAqL1xuXG4gIF9hZGp1c3REaWFsb2coKSB7XG4gICAgY29uc3QgaXNNb2RhbE92ZXJmbG93aW5nID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSB0aGlzLl9zY3JvbGxCYXIuZ2V0V2lkdGgoKVxuICAgIGNvbnN0IGlzQm9keU92ZXJmbG93aW5nID0gc2Nyb2xsYmFyV2lkdGggPiAwXG5cbiAgICBpZiAoaXNCb2R5T3ZlcmZsb3dpbmcgJiYgIWlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgY29uc3QgcHJvcGVydHkgPSBpc1JUTCgpID8gJ3BhZGRpbmdMZWZ0JyA6ICdwYWRkaW5nUmlnaHQnXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW3Byb3BlcnR5XSA9IGAke3Njcm9sbGJhcldpZHRofXB4YFxuICAgIH1cblxuICAgIGlmICghaXNCb2R5T3ZlcmZsb3dpbmcgJiYgaXNNb2RhbE92ZXJmbG93aW5nKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IGlzUlRMKCkgPyAncGFkZGluZ1JpZ2h0JyA6ICdwYWRkaW5nTGVmdCdcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbcHJvcGVydHldID0gYCR7c2Nyb2xsYmFyV2lkdGh9cHhgXG4gICAgfVxuICB9XG5cbiAgX3Jlc2V0QWRqdXN0bWVudHMoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9ICcnXG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSAnJ1xuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnLCByZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gTW9kYWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpXG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgIH1cblxuICAgICAgZGF0YVtjb25maWddKHJlbGF0ZWRUYXJnZXQpXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gKi9cblxuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUsIGZ1bmN0aW9uIChldmVudCkge1xuICBjb25zdCB0YXJnZXQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRoaXMpXG5cbiAgaWYgKFsnQScsICdBUkVBJ10uaW5jbHVkZXModGhpcy50YWdOYW1lKSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgfVxuXG4gIEV2ZW50SGFuZGxlci5vbmUodGFyZ2V0LCBFVkVOVF9TSE9XLCBzaG93RXZlbnQgPT4ge1xuICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgLy8gb25seSByZWdpc3RlciBmb2N1cyByZXN0b3JlciBpZiBtb2RhbCB3aWxsIGFjdHVhbGx5IGdldCBzaG93blxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgRXZlbnRIYW5kbGVyLm9uZSh0YXJnZXQsIEVWRU5UX0hJRERFTiwgKCkgPT4ge1xuICAgICAgaWYgKGlzVmlzaWJsZSh0aGlzKSkge1xuICAgICAgICB0aGlzLmZvY3VzKClcbiAgICAgIH1cbiAgICB9KVxuICB9KVxuXG4gIC8vIGF2b2lkIGNvbmZsaWN0IHdoZW4gY2xpY2tpbmcgbW9kYWwgdG9nZ2xlciB3aGlsZSBhbm90aGVyIG9uZSBpcyBvcGVuXG4gIGNvbnN0IGFscmVhZHlPcGVuID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShPUEVOX1NFTEVDVE9SKVxuICBpZiAoYWxyZWFkeU9wZW4pIHtcbiAgICBNb2RhbC5nZXRJbnN0YW5jZShhbHJlYWR5T3BlbikuaGlkZSgpXG4gIH1cblxuICBjb25zdCBkYXRhID0gTW9kYWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0YXJnZXQpXG5cbiAgZGF0YS50b2dnbGUodGhpcylcbn0pXG5cbmVuYWJsZURpc21pc3NUcmlnZ2VyKE1vZGFsKVxuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihNb2RhbClcblxuZXhwb3J0IGRlZmF1bHQgTW9kYWxcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMi4yKTogb2ZmY2FudmFzLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0IHtcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luLFxuICBnZXRFbGVtZW50RnJvbVNlbGVjdG9yLFxuICBpc0Rpc2FibGVkLFxuICBpc1Zpc2libGVcbn0gZnJvbSAnLi91dGlsL2luZGV4J1xuaW1wb3J0IFNjcm9sbEJhckhlbHBlciBmcm9tICcuL3V0aWwvc2Nyb2xsYmFyJ1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuL2RvbS9ldmVudC1oYW5kbGVyJ1xuaW1wb3J0IEJhc2VDb21wb25lbnQgZnJvbSAnLi9iYXNlLWNvbXBvbmVudCdcbmltcG9ydCBTZWxlY3RvckVuZ2luZSBmcm9tICcuL2RvbS9zZWxlY3Rvci1lbmdpbmUnXG5pbXBvcnQgQmFja2Ryb3AgZnJvbSAnLi91dGlsL2JhY2tkcm9wJ1xuaW1wb3J0IEZvY3VzVHJhcCBmcm9tICcuL3V0aWwvZm9jdXN0cmFwJ1xuaW1wb3J0IHsgZW5hYmxlRGlzbWlzc1RyaWdnZXIgfSBmcm9tICcuL3V0aWwvY29tcG9uZW50LWZ1bmN0aW9ucydcblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FID0gJ29mZmNhbnZhcydcbmNvbnN0IERBVEFfS0VZID0gJ2JzLm9mZmNhbnZhcydcbmNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJ1xuY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSA9IGBsb2FkJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuY29uc3QgRVNDQVBFX0tFWSA9ICdFc2NhcGUnXG5cbmNvbnN0IENMQVNTX05BTUVfU0hPVyA9ICdzaG93J1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XSU5HID0gJ3Nob3dpbmcnXG5jb25zdCBDTEFTU19OQU1FX0hJRElORyA9ICdoaWRpbmcnXG5jb25zdCBDTEFTU19OQU1FX0JBQ0tEUk9QID0gJ29mZmNhbnZhcy1iYWNrZHJvcCdcbmNvbnN0IE9QRU5fU0VMRUNUT1IgPSAnLm9mZmNhbnZhcy5zaG93J1xuXG5jb25zdCBFVkVOVF9TSE9XID0gYHNob3cke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9TSE9XTiA9IGBzaG93biR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0hJREUgPSBgaGlkZSR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0hJREVfUFJFVkVOVEVEID0gYGhpZGVQcmV2ZW50ZWQke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9ISURERU4gPSBgaGlkZGVuJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfUkVTSVpFID0gYHJlc2l6ZSR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gYGNsaWNrJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuY29uc3QgRVZFTlRfS0VZRE9XTl9ESVNNSVNTID0gYGtleWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZfWBcblxuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUgPSAnW2RhdGEtYnMtdG9nZ2xlPVwib2ZmY2FudmFzXCJdJ1xuXG5jb25zdCBEZWZhdWx0ID0ge1xuICBiYWNrZHJvcDogdHJ1ZSxcbiAga2V5Ym9hcmQ6IHRydWUsXG4gIHNjcm9sbDogZmFsc2Vcbn1cblxuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIGJhY2tkcm9wOiAnKGJvb2xlYW58c3RyaW5nKScsXG4gIGtleWJvYXJkOiAnYm9vbGVhbicsXG4gIHNjcm9sbDogJ2Jvb2xlYW4nXG59XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIE9mZmNhbnZhcyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBzdXBlcihlbGVtZW50LCBjb25maWcpXG5cbiAgICB0aGlzLl9pc1Nob3duID0gZmFsc2VcbiAgICB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpXG4gICAgdGhpcy5fZm9jdXN0cmFwID0gdGhpcy5faW5pdGlhbGl6ZUZvY3VzVHJhcCgpXG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlXG4gIH1cblxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUVcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICB0b2dnbGUocmVsYXRlZFRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3cocmVsYXRlZFRhcmdldClcbiAgfVxuXG4gIHNob3cocmVsYXRlZFRhcmdldCkge1xuICAgIGlmICh0aGlzLl9pc1Nob3duKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XLCB7IHJlbGF0ZWRUYXJnZXQgfSlcblxuICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5faXNTaG93biA9IHRydWVcbiAgICB0aGlzLl9iYWNrZHJvcC5zaG93KClcblxuICAgIGlmICghdGhpcy5fY29uZmlnLnNjcm9sbCkge1xuICAgICAgbmV3IFNjcm9sbEJhckhlbHBlcigpLmhpZGUoKVxuICAgIH1cblxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgdHJ1ZSlcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKVxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1dJTkcpXG5cbiAgICBjb25zdCBjb21wbGV0ZUNhbGxCYWNrID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9jb25maWcuc2Nyb2xsIHx8IHRoaXMuX2NvbmZpZy5iYWNrZHJvcCkge1xuICAgICAgICB0aGlzLl9mb2N1c3RyYXAuYWN0aXZhdGUoKVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XKVxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPV0lORylcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOLCB7IHJlbGF0ZWRUYXJnZXQgfSlcbiAgICB9XG5cbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlQ2FsbEJhY2ssIHRoaXMuX2VsZW1lbnQsIHRydWUpXG4gIH1cblxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5faXNTaG93bikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSlcblxuICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fZm9jdXN0cmFwLmRlYWN0aXZhdGUoKVxuICAgIHRoaXMuX2VsZW1lbnQuYmx1cigpXG4gICAgdGhpcy5faXNTaG93biA9IGZhbHNlXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfSElESU5HKVxuICAgIHRoaXMuX2JhY2tkcm9wLmhpZGUoKVxuXG4gICAgY29uc3QgY29tcGxldGVDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1csIENMQVNTX05BTUVfSElESU5HKVxuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnKVxuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKVxuXG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zY3JvbGwpIHtcbiAgICAgICAgbmV3IFNjcm9sbEJhckhlbHBlcigpLnJlc2V0KClcbiAgICAgIH1cblxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOKVxuICAgIH1cblxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsYmFjaywgdGhpcy5fZWxlbWVudCwgdHJ1ZSlcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpXG4gICAgdGhpcy5fZm9jdXN0cmFwLmRlYWN0aXZhdGUoKVxuICAgIHN1cGVyLmRpc3Bvc2UoKVxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xuICAgIGNvbnN0IGNsaWNrQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSAnc3RhdGljJykge1xuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFX1BSRVZFTlRFRClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuaGlkZSgpXG4gICAgfVxuXG4gICAgLy8gJ3N0YXRpYycgb3B0aW9uIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB0cnVlLCBhbmQgYm9vbGVhbnMgd2lsbCBrZWVwIHRoZWlyIHZhbHVlXG4gICAgY29uc3QgaXNWaXNpYmxlID0gQm9vbGVhbih0aGlzLl9jb25maWcuYmFja2Ryb3ApXG5cbiAgICByZXR1cm4gbmV3IEJhY2tkcm9wKHtcbiAgICAgIGNsYXNzTmFtZTogQ0xBU1NfTkFNRV9CQUNLRFJPUCxcbiAgICAgIGlzVmlzaWJsZSxcbiAgICAgIGlzQW5pbWF0ZWQ6IHRydWUsXG4gICAgICByb290RWxlbWVudDogdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgY2xpY2tDYWxsYmFjazogaXNWaXNpYmxlID8gY2xpY2tDYWxsYmFjayA6IG51bGxcbiAgICB9KVxuICB9XG5cbiAgX2luaXRpYWxpemVGb2N1c1RyYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBGb2N1c1RyYXAoe1xuICAgICAgdHJhcEVsZW1lbnQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9KVxuICB9XG5cbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOX0RJU01JU1MsIGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC5rZXkgIT09IEVTQ0FQRV9LRVkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fY29uZmlnLmtleWJvYXJkKSB7XG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREVfUFJFVkVOVEVEKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdGhpcy5oaWRlKClcbiAgICB9KVxuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApXG4gICAgICB9XG5cbiAgICAgIGRhdGFbY29uZmlnXSh0aGlzKVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICovXG5cbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKVxuXG4gIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgRXZlbnRIYW5kbGVyLm9uZSh0YXJnZXQsIEVWRU5UX0hJRERFTiwgKCkgPT4ge1xuICAgIC8vIGZvY3VzIG9uIHRyaWdnZXIgd2hlbiBpdCBpcyBjbG9zZWRcbiAgICBpZiAoaXNWaXNpYmxlKHRoaXMpKSB7XG4gICAgICB0aGlzLmZvY3VzKClcbiAgICB9XG4gIH0pXG5cbiAgLy8gYXZvaWQgY29uZmxpY3Qgd2hlbiBjbGlja2luZyBhIHRvZ2dsZXIgb2YgYW4gb2ZmY2FudmFzLCB3aGlsZSBhbm90aGVyIGlzIG9wZW5cbiAgY29uc3QgYWxyZWFkeU9wZW4gPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKE9QRU5fU0VMRUNUT1IpXG4gIGlmIChhbHJlYWR5T3BlbiAmJiBhbHJlYWR5T3BlbiAhPT0gdGFyZ2V0KSB7XG4gICAgT2ZmY2FudmFzLmdldEluc3RhbmNlKGFscmVhZHlPcGVuKS5oaWRlKClcbiAgfVxuXG4gIGNvbnN0IGRhdGEgPSBPZmZjYW52YXMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0YXJnZXQpXG4gIGRhdGEudG9nZ2xlKHRoaXMpXG59KVxuXG5FdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9MT0FEX0RBVEFfQVBJLCAoKSA9PiB7XG4gIGZvciAoY29uc3Qgc2VsZWN0b3Igb2YgU2VsZWN0b3JFbmdpbmUuZmluZChPUEVOX1NFTEVDVE9SKSkge1xuICAgIE9mZmNhbnZhcy5nZXRPckNyZWF0ZUluc3RhbmNlKHNlbGVjdG9yKS5zaG93KClcbiAgfVxufSlcblxuRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfUkVTSVpFLCAoKSA9PiB7XG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBTZWxlY3RvckVuZ2luZS5maW5kKCdbYXJpYS1tb2RhbF1bY2xhc3MqPXNob3ddW2NsYXNzKj1vZmZjYW52YXMtXScpKSB7XG4gICAgaWYgKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gIT09ICdmaXhlZCcpIHtcbiAgICAgIE9mZmNhbnZhcy5nZXRPckNyZWF0ZUluc3RhbmNlKGVsZW1lbnQpLmhpZGUoKVxuICAgIH1cbiAgfVxufSlcblxuZW5hYmxlRGlzbWlzc1RyaWdnZXIoT2ZmY2FudmFzKVxuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihPZmZjYW52YXMpXG5cbmV4cG9ydCBkZWZhdWx0IE9mZmNhbnZhc1xuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4yLjIpOiB1dGlsL3Nhbml0aXplci5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IHVyaUF0dHJpYnV0ZXMgPSBuZXcgU2V0KFtcbiAgJ2JhY2tncm91bmQnLFxuICAnY2l0ZScsXG4gICdocmVmJyxcbiAgJ2l0ZW10eXBlJyxcbiAgJ2xvbmdkZXNjJyxcbiAgJ3Bvc3RlcicsXG4gICdzcmMnLFxuICAneGxpbms6aHJlZidcbl0pXG5cbmNvbnN0IEFSSUFfQVRUUklCVVRFX1BBVFRFUk4gPSAvXmFyaWEtW1xcdy1dKiQvaVxuXG4vKipcbiAqIEEgcGF0dGVybiB0aGF0IHJlY29nbml6ZXMgYSBjb21tb25seSB1c2VmdWwgc3Vic2V0IG9mIFVSTHMgdGhhdCBhcmUgc2FmZS5cbiAqXG4gKiBTaG91dC1vdXQgdG8gQW5ndWxhciBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvMTIuMi54L3BhY2thZ2VzL2NvcmUvc3JjL3Nhbml0aXphdGlvbi91cmxfc2FuaXRpemVyLnRzXG4gKi9cbmNvbnN0IFNBRkVfVVJMX1BBVFRFUk4gPSAvXig/Oig/Omh0dHBzP3xtYWlsdG98ZnRwfHRlbHxmaWxlfHNtcyk6fFteIyYvOj9dKig/OlsjLz9dfCQpKS9pXG5cbi8qKlxuICogQSBwYXR0ZXJuIHRoYXQgbWF0Y2hlcyBzYWZlIGRhdGEgVVJMcy4gT25seSBtYXRjaGVzIGltYWdlLCB2aWRlbyBhbmQgYXVkaW8gdHlwZXMuXG4gKlxuICogU2hvdXQtb3V0IHRvIEFuZ3VsYXIgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iLzEyLjIueC9wYWNrYWdlcy9jb3JlL3NyYy9zYW5pdGl6YXRpb24vdXJsX3Nhbml0aXplci50c1xuICovXG5jb25zdCBEQVRBX1VSTF9QQVRURVJOID0gL15kYXRhOig/OmltYWdlXFwvKD86Ym1wfGdpZnxqcGVnfGpwZ3xwbmd8dGlmZnx3ZWJwKXx2aWRlb1xcLyg/Om1wZWd8bXA0fG9nZ3x3ZWJtKXxhdWRpb1xcLyg/Om1wM3xvZ2F8b2dnfG9wdXMpKTtiYXNlNjQsW1xcZCsvYS16XSs9KiQvaVxuXG5jb25zdCBhbGxvd2VkQXR0cmlidXRlID0gKGF0dHJpYnV0ZSwgYWxsb3dlZEF0dHJpYnV0ZUxpc3QpID0+IHtcbiAgY29uc3QgYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgaWYgKGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmluY2x1ZGVzKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgaWYgKHVyaUF0dHJpYnV0ZXMuaGFzKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbihTQUZFX1VSTF9QQVRURVJOLnRlc3QoYXR0cmlidXRlLm5vZGVWYWx1ZSkgfHwgREFUQV9VUkxfUEFUVEVSTi50ZXN0KGF0dHJpYnV0ZS5ub2RlVmFsdWUpKVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBDaGVjayBpZiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB2YWxpZGF0ZXMgdGhlIGF0dHJpYnV0ZS5cbiAgcmV0dXJuIGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmZpbHRlcihhdHRyaWJ1dGVSZWdleCA9PiBhdHRyaWJ1dGVSZWdleCBpbnN0YW5jZW9mIFJlZ0V4cClcbiAgICAuc29tZShyZWdleCA9PiByZWdleC50ZXN0KGF0dHJpYnV0ZU5hbWUpKVxufVxuXG5leHBvcnQgY29uc3QgRGVmYXVsdEFsbG93bGlzdCA9IHtcbiAgLy8gR2xvYmFsIGF0dHJpYnV0ZXMgYWxsb3dlZCBvbiBhbnkgc3VwcGxpZWQgZWxlbWVudCBiZWxvdy5cbiAgJyonOiBbJ2NsYXNzJywgJ2RpcicsICdpZCcsICdsYW5nJywgJ3JvbGUnLCBBUklBX0FUVFJJQlVURV9QQVRURVJOXSxcbiAgYTogWyd0YXJnZXQnLCAnaHJlZicsICd0aXRsZScsICdyZWwnXSxcbiAgYXJlYTogW10sXG4gIGI6IFtdLFxuICBicjogW10sXG4gIGNvbDogW10sXG4gIGNvZGU6IFtdLFxuICBkaXY6IFtdLFxuICBlbTogW10sXG4gIGhyOiBbXSxcbiAgaDE6IFtdLFxuICBoMjogW10sXG4gIGgzOiBbXSxcbiAgaDQ6IFtdLFxuICBoNTogW10sXG4gIGg2OiBbXSxcbiAgaTogW10sXG4gIGltZzogWydzcmMnLCAnc3Jjc2V0JywgJ2FsdCcsICd0aXRsZScsICd3aWR0aCcsICdoZWlnaHQnXSxcbiAgbGk6IFtdLFxuICBvbDogW10sXG4gIHA6IFtdLFxuICBwcmU6IFtdLFxuICBzOiBbXSxcbiAgc21hbGw6IFtdLFxuICBzcGFuOiBbXSxcbiAgc3ViOiBbXSxcbiAgc3VwOiBbXSxcbiAgc3Ryb25nOiBbXSxcbiAgdTogW10sXG4gIHVsOiBbXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVIdG1sKHVuc2FmZUh0bWwsIGFsbG93TGlzdCwgc2FuaXRpemVGdW5jdGlvbikge1xuICBpZiAoIXVuc2FmZUh0bWwubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHVuc2FmZUh0bWxcbiAgfVxuXG4gIGlmIChzYW5pdGl6ZUZ1bmN0aW9uICYmIHR5cGVvZiBzYW5pdGl6ZUZ1bmN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHNhbml0aXplRnVuY3Rpb24odW5zYWZlSHRtbClcbiAgfVxuXG4gIGNvbnN0IGRvbVBhcnNlciA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKClcbiAgY29uc3QgY3JlYXRlZERvY3VtZW50ID0gZG9tUGFyc2VyLnBhcnNlRnJvbVN0cmluZyh1bnNhZmVIdG1sLCAndGV4dC9odG1sJylcbiAgY29uc3QgZWxlbWVudHMgPSBbXS5jb25jYXQoLi4uY3JlYXRlZERvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvckFsbCgnKicpKVxuXG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgIGNvbnN0IGVsZW1lbnROYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgICBpZiAoIU9iamVjdC5rZXlzKGFsbG93TGlzdCkuaW5jbHVkZXMoZWxlbWVudE5hbWUpKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZSgpXG5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgY29uc3QgYXR0cmlidXRlTGlzdCA9IFtdLmNvbmNhdCguLi5lbGVtZW50LmF0dHJpYnV0ZXMpXG4gICAgY29uc3QgYWxsb3dlZEF0dHJpYnV0ZXMgPSBbXS5jb25jYXQoYWxsb3dMaXN0WycqJ10gfHwgW10sIGFsbG93TGlzdFtlbGVtZW50TmFtZV0gfHwgW10pXG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVMaXN0KSB7XG4gICAgICBpZiAoIWFsbG93ZWRBdHRyaWJ1dGUoYXR0cmlidXRlLCBhbGxvd2VkQXR0cmlidXRlcykpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlLm5vZGVOYW1lKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjcmVhdGVkRG9jdW1lbnQuYm9keS5pbm5lckhUTUxcbn1cbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMi4yKTogdXRpbC90ZW1wbGF0ZS1mYWN0b3J5LmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0IHsgRGVmYXVsdEFsbG93bGlzdCwgc2FuaXRpemVIdG1sIH0gZnJvbSAnLi9zYW5pdGl6ZXInXG5pbXBvcnQgeyBnZXRFbGVtZW50LCBpc0VsZW1lbnQgfSBmcm9tICcuLi91dGlsL2luZGV4J1xuaW1wb3J0IFNlbGVjdG9yRW5naW5lIGZyb20gJy4uL2RvbS9zZWxlY3Rvci1lbmdpbmUnXG5pbXBvcnQgQ29uZmlnIGZyb20gJy4vY29uZmlnJ1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUgPSAnVGVtcGxhdGVGYWN0b3J5J1xuXG5jb25zdCBEZWZhdWx0ID0ge1xuICBhbGxvd0xpc3Q6IERlZmF1bHRBbGxvd2xpc3QsXG4gIGNvbnRlbnQ6IHt9LCAvLyB7IHNlbGVjdG9yIDogdGV4dCAsICBzZWxlY3RvcjIgOiB0ZXh0MiAsIH1cbiAgZXh0cmFDbGFzczogJycsXG4gIGh0bWw6IGZhbHNlLFxuICBzYW5pdGl6ZTogdHJ1ZSxcbiAgc2FuaXRpemVGbjogbnVsbCxcbiAgdGVtcGxhdGU6ICc8ZGl2PjwvZGl2Pidcbn1cblxuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIGFsbG93TGlzdDogJ29iamVjdCcsXG4gIGNvbnRlbnQ6ICdvYmplY3QnLFxuICBleHRyYUNsYXNzOiAnKHN0cmluZ3xmdW5jdGlvbiknLFxuICBodG1sOiAnYm9vbGVhbicsXG4gIHNhbml0aXplOiAnYm9vbGVhbicsXG4gIHNhbml0aXplRm46ICcobnVsbHxmdW5jdGlvbiknLFxuICB0ZW1wbGF0ZTogJ3N0cmluZydcbn1cblxuY29uc3QgRGVmYXVsdENvbnRlbnRUeXBlID0ge1xuICBlbnRyeTogJyhzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbnxudWxsKScsXG4gIHNlbGVjdG9yOiAnKHN0cmluZ3xlbGVtZW50KSdcbn1cblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgVGVtcGxhdGVGYWN0b3J5IGV4dGVuZHMgQ29uZmlnIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpXG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGVcbiAgfVxuXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRVxuICB9XG5cbiAgLy8gUHVibGljXG4gIGdldENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fY29uZmlnLmNvbnRlbnQpXG4gICAgICAubWFwKGNvbmZpZyA9PiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihjb25maWcpKVxuICAgICAgLmZpbHRlcihCb29sZWFuKVxuICB9XG5cbiAgaGFzQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb250ZW50KCkubGVuZ3RoID4gMFxuICB9XG5cbiAgY2hhbmdlQ29udGVudChjb250ZW50KSB7XG4gICAgdGhpcy5fY2hlY2tDb250ZW50KGNvbnRlbnQpXG4gICAgdGhpcy5fY29uZmlnLmNvbnRlbnQgPSB7IC4uLnRoaXMuX2NvbmZpZy5jb250ZW50LCAuLi5jb250ZW50IH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdG9IdG1sKCkge1xuICAgIGNvbnN0IHRlbXBsYXRlV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgdGVtcGxhdGVXcmFwcGVyLmlubmVySFRNTCA9IHRoaXMuX21heWJlU2FuaXRpemUodGhpcy5fY29uZmlnLnRlbXBsYXRlKVxuXG4gICAgZm9yIChjb25zdCBbc2VsZWN0b3IsIHRleHRdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuX2NvbmZpZy5jb250ZW50KSkge1xuICAgICAgdGhpcy5fc2V0Q29udGVudCh0ZW1wbGF0ZVdyYXBwZXIsIHRleHQsIHNlbGVjdG9yKVxuICAgIH1cblxuICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVXcmFwcGVyLmNoaWxkcmVuWzBdXG4gICAgY29uc3QgZXh0cmFDbGFzcyA9IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5leHRyYUNsYXNzKVxuXG4gICAgaWYgKGV4dHJhQ2xhc3MpIHtcbiAgICAgIHRlbXBsYXRlLmNsYXNzTGlzdC5hZGQoLi4uZXh0cmFDbGFzcy5zcGxpdCgnICcpKVxuICAgIH1cblxuICAgIHJldHVybiB0ZW1wbGF0ZVxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfdHlwZUNoZWNrQ29uZmlnKGNvbmZpZykge1xuICAgIHN1cGVyLl90eXBlQ2hlY2tDb25maWcoY29uZmlnKVxuICAgIHRoaXMuX2NoZWNrQ29udGVudChjb25maWcuY29udGVudClcbiAgfVxuXG4gIF9jaGVja0NvbnRlbnQoYXJnKSB7XG4gICAgZm9yIChjb25zdCBbc2VsZWN0b3IsIGNvbnRlbnRdIG9mIE9iamVjdC5lbnRyaWVzKGFyZykpIHtcbiAgICAgIHN1cGVyLl90eXBlQ2hlY2tDb25maWcoeyBzZWxlY3RvciwgZW50cnk6IGNvbnRlbnQgfSwgRGVmYXVsdENvbnRlbnRUeXBlKVxuICAgIH1cbiAgfVxuXG4gIF9zZXRDb250ZW50KHRlbXBsYXRlLCBjb250ZW50LCBzZWxlY3Rvcikge1xuICAgIGNvbnN0IHRlbXBsYXRlRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoc2VsZWN0b3IsIHRlbXBsYXRlKVxuXG4gICAgaWYgKCF0ZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnRlbnQgPSB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihjb250ZW50KVxuXG4gICAgaWYgKCFjb250ZW50KSB7XG4gICAgICB0ZW1wbGF0ZUVsZW1lbnQucmVtb3ZlKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpc0VsZW1lbnQoY29udGVudCkpIHtcbiAgICAgIHRoaXMuX3B1dEVsZW1lbnRJblRlbXBsYXRlKGdldEVsZW1lbnQoY29udGVudCksIHRlbXBsYXRlRWxlbWVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb25maWcuaHRtbCkge1xuICAgICAgdGVtcGxhdGVFbGVtZW50LmlubmVySFRNTCA9IHRoaXMuX21heWJlU2FuaXRpemUoY29udGVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRlbXBsYXRlRWxlbWVudC50ZXh0Q29udGVudCA9IGNvbnRlbnRcbiAgfVxuXG4gIF9tYXliZVNhbml0aXplKGFyZykge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcuc2FuaXRpemUgPyBzYW5pdGl6ZUh0bWwoYXJnLCB0aGlzLl9jb25maWcuYWxsb3dMaXN0LCB0aGlzLl9jb25maWcuc2FuaXRpemVGbikgOiBhcmdcbiAgfVxuXG4gIF9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJyA/IGFyZyh0aGlzKSA6IGFyZ1xuICB9XG5cbiAgX3B1dEVsZW1lbnRJblRlbXBsYXRlKGVsZW1lbnQsIHRlbXBsYXRlRWxlbWVudCkge1xuICAgIGlmICh0aGlzLl9jb25maWcuaHRtbCkge1xuICAgICAgdGVtcGxhdGVFbGVtZW50LmlubmVySFRNTCA9ICcnXG4gICAgICB0ZW1wbGF0ZUVsZW1lbnQuYXBwZW5kKGVsZW1lbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0ZW1wbGF0ZUVsZW1lbnQudGV4dENvbnRlbnQgPSBlbGVtZW50LnRleHRDb250ZW50XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGVtcGxhdGVGYWN0b3J5XG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjIuMik6IHRvb2x0aXAuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgKiBhcyBQb3BwZXIgZnJvbSAnQHBvcHBlcmpzL2NvcmUnXG5pbXBvcnQgeyBkZWZpbmVKUXVlcnlQbHVnaW4sIGZpbmRTaGFkb3dSb290LCBnZXRFbGVtZW50LCBnZXRVSUQsIGlzUlRMLCBub29wIH0gZnJvbSAnLi91dGlsL2luZGV4J1xuaW1wb3J0IHsgRGVmYXVsdEFsbG93bGlzdCB9IGZyb20gJy4vdXRpbC9zYW5pdGl6ZXInXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4vZG9tL2V2ZW50LWhhbmRsZXInXG5pbXBvcnQgTWFuaXB1bGF0b3IgZnJvbSAnLi9kb20vbWFuaXB1bGF0b3InXG5pbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tICcuL2Jhc2UtY29tcG9uZW50J1xuaW1wb3J0IFRlbXBsYXRlRmFjdG9yeSBmcm9tICcuL3V0aWwvdGVtcGxhdGUtZmFjdG9yeSdcblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FID0gJ3Rvb2x0aXAnXG5jb25zdCBESVNBTExPV0VEX0FUVFJJQlVURVMgPSBuZXcgU2V0KFsnc2FuaXRpemUnLCAnYWxsb3dMaXN0JywgJ3Nhbml0aXplRm4nXSlcblxuY29uc3QgQ0xBU1NfTkFNRV9GQURFID0gJ2ZhZGUnXG5jb25zdCBDTEFTU19OQU1FX01PREFMID0gJ21vZGFsJ1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XID0gJ3Nob3cnXG5cbmNvbnN0IFNFTEVDVE9SX1RPT0xUSVBfSU5ORVIgPSAnLnRvb2x0aXAtaW5uZXInXG5jb25zdCBTRUxFQ1RPUl9NT0RBTCA9IGAuJHtDTEFTU19OQU1FX01PREFMfWBcblxuY29uc3QgRVZFTlRfTU9EQUxfSElERSA9ICdoaWRlLmJzLm1vZGFsJ1xuXG5jb25zdCBUUklHR0VSX0hPVkVSID0gJ2hvdmVyJ1xuY29uc3QgVFJJR0dFUl9GT0NVUyA9ICdmb2N1cydcbmNvbnN0IFRSSUdHRVJfQ0xJQ0sgPSAnY2xpY2snXG5jb25zdCBUUklHR0VSX01BTlVBTCA9ICdtYW51YWwnXG5cbmNvbnN0IEVWRU5UX0hJREUgPSAnaGlkZSdcbmNvbnN0IEVWRU5UX0hJRERFTiA9ICdoaWRkZW4nXG5jb25zdCBFVkVOVF9TSE9XID0gJ3Nob3cnXG5jb25zdCBFVkVOVF9TSE9XTiA9ICdzaG93bidcbmNvbnN0IEVWRU5UX0lOU0VSVEVEID0gJ2luc2VydGVkJ1xuY29uc3QgRVZFTlRfQ0xJQ0sgPSAnY2xpY2snXG5jb25zdCBFVkVOVF9GT0NVU0lOID0gJ2ZvY3VzaW4nXG5jb25zdCBFVkVOVF9GT0NVU09VVCA9ICdmb2N1c291dCdcbmNvbnN0IEVWRU5UX01PVVNFRU5URVIgPSAnbW91c2VlbnRlcidcbmNvbnN0IEVWRU5UX01PVVNFTEVBVkUgPSAnbW91c2VsZWF2ZSdcblxuY29uc3QgQXR0YWNobWVudE1hcCA9IHtcbiAgQVVUTzogJ2F1dG8nLFxuICBUT1A6ICd0b3AnLFxuICBSSUdIVDogaXNSVEwoKSA/ICdsZWZ0JyA6ICdyaWdodCcsXG4gIEJPVFRPTTogJ2JvdHRvbScsXG4gIExFRlQ6IGlzUlRMKCkgPyAncmlnaHQnIDogJ2xlZnQnXG59XG5cbmNvbnN0IERlZmF1bHQgPSB7XG4gIGFsbG93TGlzdDogRGVmYXVsdEFsbG93bGlzdCxcbiAgYW5pbWF0aW9uOiB0cnVlLFxuICBib3VuZGFyeTogJ2NsaXBwaW5nUGFyZW50cycsXG4gIGNvbnRhaW5lcjogZmFsc2UsXG4gIGN1c3RvbUNsYXNzOiAnJyxcbiAgZGVsYXk6IDAsXG4gIGZhbGxiYWNrUGxhY2VtZW50czogWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXSxcbiAgaHRtbDogZmFsc2UsXG4gIG9mZnNldDogWzAsIDBdLFxuICBwbGFjZW1lbnQ6ICd0b3AnLFxuICBwb3BwZXJDb25maWc6IG51bGwsXG4gIHNhbml0aXplOiB0cnVlLFxuICBzYW5pdGl6ZUZuOiBudWxsLFxuICBzZWxlY3RvcjogZmFsc2UsXG4gIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPicgK1xuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+JyArXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj4nICtcbiAgICAgICAgICAgICc8L2Rpdj4nLFxuICB0aXRsZTogJycsXG4gIHRyaWdnZXI6ICdob3ZlciBmb2N1cydcbn1cblxuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIGFsbG93TGlzdDogJ29iamVjdCcsXG4gIGFuaW1hdGlvbjogJ2Jvb2xlYW4nLFxuICBib3VuZGFyeTogJyhzdHJpbmd8ZWxlbWVudCknLFxuICBjb250YWluZXI6ICcoc3RyaW5nfGVsZW1lbnR8Ym9vbGVhbiknLFxuICBjdXN0b21DbGFzczogJyhzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgZGVsYXk6ICcobnVtYmVyfG9iamVjdCknLFxuICBmYWxsYmFja1BsYWNlbWVudHM6ICdhcnJheScsXG4gIGh0bWw6ICdib29sZWFuJyxcbiAgb2Zmc2V0OiAnKGFycmF5fHN0cmluZ3xmdW5jdGlvbiknLFxuICBwbGFjZW1lbnQ6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXG4gIHBvcHBlckNvbmZpZzogJyhudWxsfG9iamVjdHxmdW5jdGlvbiknLFxuICBzYW5pdGl6ZTogJ2Jvb2xlYW4nLFxuICBzYW5pdGl6ZUZuOiAnKG51bGx8ZnVuY3Rpb24pJyxcbiAgc2VsZWN0b3I6ICcoc3RyaW5nfGJvb2xlYW4pJyxcbiAgdGVtcGxhdGU6ICdzdHJpbmcnLFxuICB0aXRsZTogJyhzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbiknLFxuICB0cmlnZ2VyOiAnc3RyaW5nJ1xufVxuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBUb29sdGlwIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIGlmICh0eXBlb2YgUG9wcGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFwncyB0b29sdGlwcyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKScpXG4gICAgfVxuXG4gICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKVxuXG4gICAgLy8gUHJpdmF0ZVxuICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWVcbiAgICB0aGlzLl90aW1lb3V0ID0gMFxuICAgIHRoaXMuX2lzSG92ZXJlZCA9IG51bGxcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyID0ge31cbiAgICB0aGlzLl9wb3BwZXIgPSBudWxsXG4gICAgdGhpcy5fdGVtcGxhdGVGYWN0b3J5ID0gbnVsbFxuICAgIHRoaXMuX25ld0NvbnRlbnQgPSBudWxsXG5cbiAgICAvLyBQcm90ZWN0ZWRcbiAgICB0aGlzLnRpcCA9IG51bGxcblxuICAgIHRoaXMuX3NldExpc3RlbmVycygpXG5cbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5zZWxlY3Rvcikge1xuICAgICAgdGhpcy5fZml4VGl0bGUoKVxuICAgIH1cbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0XG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZVxuICB9XG5cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FXG4gIH1cblxuICAvLyBQdWJsaWNcbiAgZW5hYmxlKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWVcbiAgfVxuXG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2VcbiAgfVxuXG4gIHRvZ2dsZUVuYWJsZWQoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gIXRoaXMuX2lzRW5hYmxlZFxuICB9XG5cbiAgdG9nZ2xlKCkge1xuICAgIGlmICghdGhpcy5faXNFbmFibGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyLmNsaWNrID0gIXRoaXMuX2FjdGl2ZVRyaWdnZXIuY2xpY2tcbiAgICBpZiAodGhpcy5faXNTaG93bigpKSB7XG4gICAgICB0aGlzLl9sZWF2ZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9lbnRlcigpXG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KVxuXG4gICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9lbGVtZW50LmNsb3Nlc3QoU0VMRUNUT1JfTU9EQUwpLCBFVkVOVF9NT0RBTF9ISURFLCB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyKVxuXG4gICAgaWYgKHRoaXMudGlwKSB7XG4gICAgICB0aGlzLnRpcC5yZW1vdmUoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1vcmlnaW5hbC10aXRsZScpKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgndGl0bGUnLCB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1vcmlnaW5hbC10aXRsZScpKVxuICAgIH1cblxuICAgIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKVxuICAgIHN1cGVyLmRpc3Bvc2UoKVxuICB9XG5cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHVzZSBzaG93IG9uIHZpc2libGUgZWxlbWVudHMnKVxuICAgIH1cblxuICAgIGlmICghKHRoaXMuX2lzV2l0aENvbnRlbnQoKSAmJiB0aGlzLl9pc0VuYWJsZWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9TSE9XKSlcbiAgICBjb25zdCBzaGFkb3dSb290ID0gZmluZFNoYWRvd1Jvb3QodGhpcy5fZWxlbWVudClcbiAgICBjb25zdCBpc0luVGhlRG9tID0gKHNoYWRvd1Jvb3QgfHwgdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuY29udGFpbnModGhpcy5fZWxlbWVudClcblxuICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCB8fCAhaXNJblRoZURvbSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gdG9kbyB2NiByZW1vdmUgdGhpcyBPUiBtYWtlIGl0IG9wdGlvbmFsXG4gICAgaWYgKHRoaXMudGlwKSB7XG4gICAgICB0aGlzLnRpcC5yZW1vdmUoKVxuICAgICAgdGhpcy50aXAgPSBudWxsXG4gICAgfVxuXG4gICAgY29uc3QgdGlwID0gdGhpcy5fZ2V0VGlwRWxlbWVudCgpXG5cbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScsIHRpcC5nZXRBdHRyaWJ1dGUoJ2lkJykpXG5cbiAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gdGhpcy5fY29uZmlnXG5cbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnModGhpcy50aXApKSB7XG4gICAgICBjb250YWluZXIuYXBwZW5kKHRpcClcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0lOU0VSVEVEKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICB0aGlzLl9wb3BwZXIudXBkYXRlKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcG9wcGVyID0gdGhpcy5fY3JlYXRlUG9wcGVyKHRpcClcbiAgICB9XG5cbiAgICB0aXAuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1cpXG5cbiAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgYWRkIGV4dHJhXG4gICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB0byB0aGUgYm9keSdzIGltbWVkaWF0ZSBjaGlsZHJlbjtcbiAgICAvLyBvbmx5IG5lZWRlZCBiZWNhdXNlIG9mIGJyb2tlbiBldmVudCBkZWxlZ2F0aW9uIG9uIGlPU1xuICAgIC8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxNC8wMi9tb3VzZV9ldmVudF9idWIuaHRtbFxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikpIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKGVsZW1lbnQsICdtb3VzZW92ZXInLCBub29wKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfU0hPV04pKVxuXG4gICAgICBpZiAodGhpcy5faXNIb3ZlcmVkID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLl9sZWF2ZSgpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lzSG92ZXJlZCA9IGZhbHNlXG4gICAgfVxuXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy50aXAsIHRoaXMuX2lzQW5pbWF0ZWQoKSlcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0hJREUpKVxuICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdGlwID0gdGhpcy5fZ2V0VGlwRWxlbWVudCgpXG4gICAgdGlwLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XKVxuXG4gICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIHJlbW92ZSB0aGUgZXh0cmFcbiAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHdlIGFkZGVkIGZvciBpT1Mgc3VwcG9ydFxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikpIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9mZihlbGVtZW50LCAnbW91c2VvdmVyJywgbm9vcClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfQ0xJQ0tdID0gZmFsc2VcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfRk9DVVNdID0gZmFsc2VcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfSE9WRVJdID0gZmFsc2VcbiAgICB0aGlzLl9pc0hvdmVyZWQgPSBudWxsIC8vIGl0IGlzIGEgdHJpY2sgdG8gc3VwcG9ydCBtYW51YWwgdHJpZ2dlcmluZ1xuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2lzSG92ZXJlZCkge1xuICAgICAgICB0aXAucmVtb3ZlKClcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKVxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfSElEREVOKSlcblxuICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpXG4gICAgfVxuXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy50aXAsIHRoaXMuX2lzQW5pbWF0ZWQoKSlcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICB0aGlzLl9wb3BwZXIudXBkYXRlKClcbiAgICB9XG4gIH1cblxuICAvLyBQcm90ZWN0ZWRcbiAgX2lzV2l0aENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fZ2V0VGl0bGUoKSlcbiAgfVxuXG4gIF9nZXRUaXBFbGVtZW50KCkge1xuICAgIGlmICghdGhpcy50aXApIHtcbiAgICAgIHRoaXMudGlwID0gdGhpcy5fY3JlYXRlVGlwRWxlbWVudCh0aGlzLl9uZXdDb250ZW50IHx8IHRoaXMuX2dldENvbnRlbnRGb3JUZW1wbGF0ZSgpKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRpcFxuICB9XG5cbiAgX2NyZWF0ZVRpcEVsZW1lbnQoY29udGVudCkge1xuICAgIGNvbnN0IHRpcCA9IHRoaXMuX2dldFRlbXBsYXRlRmFjdG9yeShjb250ZW50KS50b0h0bWwoKVxuXG4gICAgLy8gdG9kbzogcmVtb3ZlIHRoaXMgY2hlY2sgb24gdjZcbiAgICBpZiAoIXRpcCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICB0aXAuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0ZBREUsIENMQVNTX05BTUVfU0hPVylcbiAgICAvLyB0b2RvOiBvbiB2NiB0aGUgZm9sbG93aW5nIGNhbiBiZSBhY2hpZXZlZCB3aXRoIENTUyBvbmx5XG4gICAgdGlwLmNsYXNzTGlzdC5hZGQoYGJzLSR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfS1hdXRvYClcblxuICAgIGNvbnN0IHRpcElkID0gZ2V0VUlEKHRoaXMuY29uc3RydWN0b3IuTkFNRSkudG9TdHJpbmcoKVxuXG4gICAgdGlwLnNldEF0dHJpYnV0ZSgnaWQnLCB0aXBJZClcblxuICAgIGlmICh0aGlzLl9pc0FuaW1hdGVkKCkpIHtcbiAgICAgIHRpcC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGlwXG4gIH1cblxuICBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICB0aGlzLl9uZXdDb250ZW50ID0gY29udGVudFxuICAgIGlmICh0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKVxuICAgICAgdGhpcy5zaG93KClcbiAgICB9XG4gIH1cblxuICBfZ2V0VGVtcGxhdGVGYWN0b3J5KGNvbnRlbnQpIHtcbiAgICBpZiAodGhpcy5fdGVtcGxhdGVGYWN0b3J5KSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZUZhY3RvcnkuY2hhbmdlQ29udGVudChjb250ZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZUZhY3RvcnkgPSBuZXcgVGVtcGxhdGVGYWN0b3J5KHtcbiAgICAgICAgLi4udGhpcy5fY29uZmlnLFxuICAgICAgICAvLyB0aGUgYGNvbnRlbnRgIHZhciBoYXMgdG8gYmUgYWZ0ZXIgYHRoaXMuX2NvbmZpZ2BcbiAgICAgICAgLy8gdG8gb3ZlcnJpZGUgY29uZmlnLmNvbnRlbnQgaW4gY2FzZSBvZiBwb3BvdmVyXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGV4dHJhQ2xhc3M6IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5jdXN0b21DbGFzcylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3RlbXBsYXRlRmFjdG9yeVxuICB9XG5cbiAgX2dldENvbnRlbnRGb3JUZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW1NFTEVDVE9SX1RPT0xUSVBfSU5ORVJdOiB0aGlzLl9nZXRUaXRsZSgpXG4gICAgfVxuICB9XG5cbiAgX2dldFRpdGxlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcudGl0bGUpIHx8IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLW9yaWdpbmFsLXRpdGxlJylcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmdldE9yQ3JlYXRlSW5zdGFuY2UoZXZlbnQuZGVsZWdhdGVUYXJnZXQsIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKCkpXG4gIH1cblxuICBfaXNBbmltYXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLmFuaW1hdGlvbiB8fCAodGhpcy50aXAgJiYgdGhpcy50aXAuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSkpXG4gIH1cblxuICBfaXNTaG93bigpIHtcbiAgICByZXR1cm4gdGhpcy50aXAgJiYgdGhpcy50aXAuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVylcbiAgfVxuXG4gIF9jcmVhdGVQb3BwZXIodGlwKSB7XG4gICAgY29uc3QgcGxhY2VtZW50ID0gdHlwZW9mIHRoaXMuX2NvbmZpZy5wbGFjZW1lbnQgPT09ICdmdW5jdGlvbicgP1xuICAgICAgdGhpcy5fY29uZmlnLnBsYWNlbWVudC5jYWxsKHRoaXMsIHRpcCwgdGhpcy5fZWxlbWVudCkgOlxuICAgICAgdGhpcy5fY29uZmlnLnBsYWNlbWVudFxuICAgIGNvbnN0IGF0dGFjaG1lbnQgPSBBdHRhY2htZW50TWFwW3BsYWNlbWVudC50b1VwcGVyQ2FzZSgpXVxuICAgIHJldHVybiBQb3BwZXIuY3JlYXRlUG9wcGVyKHRoaXMuX2VsZW1lbnQsIHRpcCwgdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKGF0dGFjaG1lbnQpKVxuICB9XG5cbiAgX2dldE9mZnNldCgpIHtcbiAgICBjb25zdCB7IG9mZnNldCB9ID0gdGhpcy5fY29uZmlnXG5cbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBvZmZzZXQuc3BsaXQoJywnKS5tYXAodmFsdWUgPT4gTnVtYmVyLnBhcnNlSW50KHZhbHVlLCAxMCkpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBwb3BwZXJEYXRhID0+IG9mZnNldChwb3BwZXJEYXRhLCB0aGlzLl9lbGVtZW50KVxuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXRcbiAgfVxuXG4gIF9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJyA/IGFyZy5jYWxsKHRoaXMuX2VsZW1lbnQpIDogYXJnXG4gIH1cblxuICBfZ2V0UG9wcGVyQ29uZmlnKGF0dGFjaG1lbnQpIHtcbiAgICBjb25zdCBkZWZhdWx0QnNQb3BwZXJDb25maWcgPSB7XG4gICAgICBwbGFjZW1lbnQ6IGF0dGFjaG1lbnQsXG4gICAgICBtb2RpZmllcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdmbGlwJyxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHRoaXMuX2NvbmZpZy5mYWxsYmFja1BsYWNlbWVudHNcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgYm91bmRhcnk6IHRoaXMuX2NvbmZpZy5ib3VuZGFyeVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdhcnJvdycsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgZWxlbWVudDogYC4ke3RoaXMuY29uc3RydWN0b3IuTkFNRX0tYXJyb3dgXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3ByZVNldFBsYWNlbWVudCcsXG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICBwaGFzZTogJ2JlZm9yZU1haW4nLFxuICAgICAgICAgIGZuOiBkYXRhID0+IHtcbiAgICAgICAgICAgIC8vIFByZS1zZXQgUG9wcGVyJ3MgcGxhY2VtZW50IGF0dHJpYnV0ZSBpbiBvcmRlciB0byByZWFkIHRoZSBhcnJvdyBzaXplcyBwcm9wZXJseS5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgUG9wcGVyIG1peGVzIHVwIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGRpbWVuc2lvbnMgc2luY2UgdGhlIGluaXRpYWwgYXJyb3cgc3R5bGUgaXMgZm9yIHRvcCBwbGFjZW1lbnRcbiAgICAgICAgICAgIHRoaXMuX2dldFRpcEVsZW1lbnQoKS5zZXRBdHRyaWJ1dGUoJ2RhdGEtcG9wcGVyLXBsYWNlbWVudCcsIGRhdGEuc3RhdGUucGxhY2VtZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi5kZWZhdWx0QnNQb3BwZXJDb25maWcsXG4gICAgICAuLi4odHlwZW9mIHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcgPT09ICdmdW5jdGlvbicgPyB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKGRlZmF1bHRCc1BvcHBlckNvbmZpZykgOiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKVxuICAgIH1cbiAgfVxuXG4gIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgdHJpZ2dlcnMgPSB0aGlzLl9jb25maWcudHJpZ2dlci5zcGxpdCgnICcpXG5cbiAgICBmb3IgKGNvbnN0IHRyaWdnZXIgb2YgdHJpZ2dlcnMpIHtcbiAgICAgIGlmICh0cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9DTElDSyksIHRoaXMuX2NvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQpXG4gICAgICAgICAgY29udGV4dC50b2dnbGUoKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICE9PSBUUklHR0VSX01BTlVBTCkge1xuICAgICAgICBjb25zdCBldmVudEluID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/XG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfTU9VU0VFTlRFUikgOlxuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0ZPQ1VTSU4pXG4gICAgICAgIGNvbnN0IGV2ZW50T3V0ID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/XG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfTU9VU0VMRUFWRSkgOlxuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0ZPQ1VTT1VUKVxuXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBldmVudEluLCB0aGlzLl9jb25maWcuc2VsZWN0b3IsIGV2ZW50ID0+IHtcbiAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50KVxuICAgICAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbZXZlbnQudHlwZSA9PT0gJ2ZvY3VzaW4nID8gVFJJR0dFUl9GT0NVUyA6IFRSSUdHRVJfSE9WRVJdID0gdHJ1ZVxuICAgICAgICAgIGNvbnRleHQuX2VudGVyKClcbiAgICAgICAgfSlcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIGV2ZW50T3V0LCB0aGlzLl9jb25maWcuc2VsZWN0b3IsIGV2ZW50ID0+IHtcbiAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50KVxuICAgICAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbZXZlbnQudHlwZSA9PT0gJ2ZvY3Vzb3V0JyA/IFRSSUdHRVJfRk9DVVMgOiBUUklHR0VSX0hPVkVSXSA9XG4gICAgICAgICAgICBjb250ZXh0Ll9lbGVtZW50LmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpXG5cbiAgICAgICAgICBjb250ZXh0Ll9sZWF2ZSgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5faGlkZU1vZGFsSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgIHRoaXMuaGlkZSgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9NT0RBTCksIEVWRU5UX01PREFMX0hJREUsIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIpXG4gIH1cblxuICBfZml4VGl0bGUoKSB7XG4gICAgY29uc3QgdGl0bGUgPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgndGl0bGUnKVxuXG4gICAgaWYgKCF0aXRsZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpICYmICF0aGlzLl9lbGVtZW50LnRleHRDb250ZW50LnRyaW0oKSkge1xuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aXRsZSlcbiAgICB9XG5cbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1icy1vcmlnaW5hbC10aXRsZScsIHRpdGxlKSAvLyBETyBOT1QgVVNFIElULiBJcyBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0aXRsZScpXG4gIH1cblxuICBfZW50ZXIoKSB7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24oKSB8fCB0aGlzLl9pc0hvdmVyZWQpIHtcbiAgICAgIHRoaXMuX2lzSG92ZXJlZCA9IHRydWVcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2lzSG92ZXJlZCA9IHRydWVcblxuICAgIHRoaXMuX3NldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2lzSG92ZXJlZCkge1xuICAgICAgICB0aGlzLnNob3coKVxuICAgICAgfVxuICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheS5zaG93KVxuICB9XG5cbiAgX2xlYXZlKCkge1xuICAgIGlmICh0aGlzLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2lzSG92ZXJlZCA9IGZhbHNlXG5cbiAgICB0aGlzLl9zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5faXNIb3ZlcmVkKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpXG4gICAgICB9XG4gICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5LmhpZGUpXG4gIH1cblxuICBfc2V0VGltZW91dChoYW5kbGVyLCB0aW1lb3V0KSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpXG4gICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoaGFuZGxlciwgdGltZW91dClcbiAgfVxuXG4gIF9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX2FjdGl2ZVRyaWdnZXIpLmluY2x1ZGVzKHRydWUpXG4gIH1cblxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgIGNvbnN0IGRhdGFBdHRyaWJ1dGVzID0gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudClcblxuICAgIGZvciAoY29uc3QgZGF0YUF0dHJpYnV0ZSBvZiBPYmplY3Qua2V5cyhkYXRhQXR0cmlidXRlcykpIHtcbiAgICAgIGlmIChESVNBTExPV0VEX0FUVFJJQlVURVMuaGFzKGRhdGFBdHRyaWJ1dGUpKSB7XG4gICAgICAgIGRlbGV0ZSBkYXRhQXR0cmlidXRlc1tkYXRhQXR0cmlidXRlXVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbmZpZyA9IHtcbiAgICAgIC4uLmRhdGFBdHRyaWJ1dGVzLFxuICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9KVxuICAgIH1cbiAgICBjb25maWcgPSB0aGlzLl9tZXJnZUNvbmZpZ09iaihjb25maWcpXG4gICAgY29uZmlnID0gdGhpcy5fY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpXG4gICAgdGhpcy5fdHlwZUNoZWNrQ29uZmlnKGNvbmZpZylcbiAgICByZXR1cm4gY29uZmlnXG4gIH1cblxuICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcbiAgICBjb25maWcuY29udGFpbmVyID0gY29uZmlnLmNvbnRhaW5lciA9PT0gZmFsc2UgPyBkb2N1bWVudC5ib2R5IDogZ2V0RWxlbWVudChjb25maWcuY29udGFpbmVyKVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcuZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25maWcuZGVsYXkgPSB7XG4gICAgICAgIHNob3c6IGNvbmZpZy5kZWxheSxcbiAgICAgICAgaGlkZTogY29uZmlnLmRlbGF5XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcudGl0bGUgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25maWcudGl0bGUgPSBjb25maWcudGl0bGUudG9TdHJpbmcoKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uZmlnLmNvbnRlbnQgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25maWcuY29udGVudCA9IGNvbmZpZy5jb250ZW50LnRvU3RyaW5nKClcbiAgICB9XG5cbiAgICByZXR1cm4gY29uZmlnXG4gIH1cblxuICBfZ2V0RGVsZWdhdGVDb25maWcoKSB7XG4gICAgY29uc3QgY29uZmlnID0ge31cblxuICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuX2NvbmZpZykge1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFtrZXldICE9PSB0aGlzLl9jb25maWdba2V5XSkge1xuICAgICAgICBjb25maWdba2V5XSA9IHRoaXMuX2NvbmZpZ1trZXldXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uZmlnLnNlbGVjdG9yID0gZmFsc2VcbiAgICBjb25maWcudHJpZ2dlciA9ICdtYW51YWwnXG5cbiAgICAvLyBJbiB0aGUgZnV0dXJlIGNhbiBiZSByZXBsYWNlZCB3aXRoOlxuICAgIC8vIGNvbnN0IGtleXNXaXRoRGlmZmVyZW50VmFsdWVzID0gT2JqZWN0LmVudHJpZXModGhpcy5fY29uZmlnKS5maWx0ZXIoZW50cnkgPT4gdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2VudHJ5WzBdXSAhPT0gdGhpcy5fY29uZmlnW2VudHJ5WzBdXSlcbiAgICAvLyBgT2JqZWN0LmZyb21FbnRyaWVzKGtleXNXaXRoRGlmZmVyZW50VmFsdWVzKWBcbiAgICByZXR1cm4gY29uZmlnXG4gIH1cblxuICBfZGlzcG9zZVBvcHBlcigpIHtcbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpXG4gICAgICB0aGlzLl9wb3BwZXIgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gVG9vbHRpcC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZylcblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKVxuICAgICAgfVxuXG4gICAgICBkYXRhW2NvbmZpZ10oKVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oVG9vbHRpcClcblxuZXhwb3J0IGRlZmF1bHQgVG9vbHRpcFxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4yLjIpOiBwb3BvdmVyLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0IHsgZGVmaW5lSlF1ZXJ5UGx1Z2luIH0gZnJvbSAnLi91dGlsL2luZGV4J1xuaW1wb3J0IFRvb2x0aXAgZnJvbSAnLi90b29sdGlwJ1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUgPSAncG9wb3ZlcidcblxuY29uc3QgU0VMRUNUT1JfVElUTEUgPSAnLnBvcG92ZXItaGVhZGVyJ1xuY29uc3QgU0VMRUNUT1JfQ09OVEVOVCA9ICcucG9wb3Zlci1ib2R5J1xuXG5jb25zdCBEZWZhdWx0ID0ge1xuICAuLi5Ub29sdGlwLkRlZmF1bHQsXG4gIGNvbnRlbnQ6ICcnLFxuICBvZmZzZXQ6IFswLCA4XSxcbiAgcGxhY2VtZW50OiAncmlnaHQnLFxuICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJwb3BvdmVyXCIgcm9sZT1cInRvb2x0aXBcIj4nICtcbiAgICAnPGRpdiBjbGFzcz1cInBvcG92ZXItYXJyb3dcIj48L2Rpdj4nICtcbiAgICAnPGgzIGNsYXNzPVwicG9wb3Zlci1oZWFkZXJcIj48L2gzPicgK1xuICAgICc8ZGl2IGNsYXNzPVwicG9wb3Zlci1ib2R5XCI+PC9kaXY+JyArXG4gICAgJzwvZGl2PicsXG4gIHRyaWdnZXI6ICdjbGljaydcbn1cblxuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIC4uLlRvb2x0aXAuRGVmYXVsdFR5cGUsXG4gIGNvbnRlbnQ6ICcobnVsbHxzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbiknXG59XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIFBvcG92ZXIgZXh0ZW5kcyBUb29sdGlwIHtcbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlXG4gIH1cblxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUVcbiAgfVxuXG4gIC8vIE92ZXJyaWRlc1xuICBfaXNXaXRoQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VGl0bGUoKSB8fCB0aGlzLl9nZXRDb250ZW50KClcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2dldENvbnRlbnRGb3JUZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW1NFTEVDVE9SX1RJVExFXTogdGhpcy5fZ2V0VGl0bGUoKSxcbiAgICAgIFtTRUxFQ1RPUl9DT05URU5UXTogdGhpcy5fZ2V0Q29udGVudCgpXG4gICAgfVxuICB9XG5cbiAgX2dldENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5jb250ZW50KVxuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gUG9wb3Zlci5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZylcblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKVxuICAgICAgfVxuXG4gICAgICBkYXRhW2NvbmZpZ10oKVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oUG9wb3ZlcilcblxuZXhwb3J0IGRlZmF1bHQgUG9wb3ZlclxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4yLjIpOiBzY3JvbGxzcHkuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgeyBkZWZpbmVKUXVlcnlQbHVnaW4sIGdldEVsZW1lbnQsIGlzRGlzYWJsZWQsIGlzVmlzaWJsZSB9IGZyb20gJy4vdXRpbC9pbmRleCdcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi9kb20vZXZlbnQtaGFuZGxlcidcbmltcG9ydCBTZWxlY3RvckVuZ2luZSBmcm9tICcuL2RvbS9zZWxlY3Rvci1lbmdpbmUnXG5pbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tICcuL2Jhc2UtY29tcG9uZW50J1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUgPSAnc2Nyb2xsc3B5J1xuY29uc3QgREFUQV9LRVkgPSAnYnMuc2Nyb2xsc3B5J1xuY29uc3QgRVZFTlRfS0VZID0gYC4ke0RBVEFfS0VZfWBcbmNvbnN0IERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknXG5cbmNvbnN0IEVWRU5UX0FDVElWQVRFID0gYGFjdGl2YXRlJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfQ0xJQ0sgPSBgY2xpY2ske0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJID0gYGxvYWQke0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gXG5cbmNvbnN0IENMQVNTX05BTUVfRFJPUERPV05fSVRFTSA9ICdkcm9wZG93bi1pdGVtJ1xuY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUgPSAnYWN0aXZlJ1xuXG5jb25zdCBTRUxFQ1RPUl9EQVRBX1NQWSA9ICdbZGF0YS1icy1zcHk9XCJzY3JvbGxcIl0nXG5jb25zdCBTRUxFQ1RPUl9UQVJHRVRfTElOS1MgPSAnW2hyZWZdJ1xuY29uc3QgU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVAgPSAnLm5hdiwgLmxpc3QtZ3JvdXAnXG5jb25zdCBTRUxFQ1RPUl9OQVZfTElOS1MgPSAnLm5hdi1saW5rJ1xuY29uc3QgU0VMRUNUT1JfTkFWX0lURU1TID0gJy5uYXYtaXRlbSdcbmNvbnN0IFNFTEVDVE9SX0xJU1RfSVRFTVMgPSAnLmxpc3QtZ3JvdXAtaXRlbSdcbmNvbnN0IFNFTEVDVE9SX0xJTktfSVRFTVMgPSBgJHtTRUxFQ1RPUl9OQVZfTElOS1N9LCAke1NFTEVDVE9SX05BVl9JVEVNU30gPiAke1NFTEVDVE9SX05BVl9MSU5LU30sICR7U0VMRUNUT1JfTElTVF9JVEVNU31gXG5jb25zdCBTRUxFQ1RPUl9EUk9QRE9XTiA9ICcuZHJvcGRvd24nXG5jb25zdCBTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUgPSAnLmRyb3Bkb3duLXRvZ2dsZSdcblxuY29uc3QgRGVmYXVsdCA9IHtcbiAgb2Zmc2V0OiBudWxsLCAvLyBUT0RPOiB2NiBAZGVwcmVjYXRlZCwga2VlcCBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcmVhc29uc1xuICByb290TWFyZ2luOiAnMHB4IDBweCAtMjUlJyxcbiAgc21vb3RoU2Nyb2xsOiBmYWxzZSxcbiAgdGFyZ2V0OiBudWxsLFxuICB0aHJlc2hvbGQ6IFswLjEsIDAuNSwgMV1cbn1cblxuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIG9mZnNldDogJyhudW1iZXJ8bnVsbCknLCAvLyBUT0RPIHY2IEBkZXByZWNhdGVkLCBrZWVwIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSByZWFzb25zXG4gIHJvb3RNYXJnaW46ICdzdHJpbmcnLFxuICBzbW9vdGhTY3JvbGw6ICdib29sZWFuJyxcbiAgdGFyZ2V0OiAnZWxlbWVudCcsXG4gIHRocmVzaG9sZDogJ2FycmF5J1xufVxuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBTY3JvbGxTcHkgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKVxuXG4gICAgLy8gdGhpcy5fZWxlbWVudCBpcyB0aGUgb2JzZXJ2YWJsZXNDb250YWluZXIgYW5kIGNvbmZpZy50YXJnZXQgdGhlIG1lbnUgbGlua3Mgd3JhcHBlclxuICAgIHRoaXMuX3RhcmdldExpbmtzID0gbmV3IE1hcCgpXG4gICAgdGhpcy5fb2JzZXJ2YWJsZVNlY3Rpb25zID0gbmV3IE1hcCgpXG4gICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnQpLm92ZXJmbG93WSA9PT0gJ3Zpc2libGUnID8gbnVsbCA6IHRoaXMuX2VsZW1lbnRcbiAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsXG4gICAgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsXG4gICAgdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhID0ge1xuICAgICAgdmlzaWJsZUVudHJ5VG9wOiAwLFxuICAgICAgcGFyZW50U2Nyb2xsVG9wOiAwXG4gICAgfVxuICAgIHRoaXMucmVmcmVzaCgpIC8vIGluaXRpYWxpemVcbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0XG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZVxuICB9XG5cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FXG4gIH1cblxuICAvLyBQdWJsaWNcbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplVGFyZ2V0c0FuZE9ic2VydmFibGVzKClcbiAgICB0aGlzLl9tYXliZUVuYWJsZVNtb290aFNjcm9sbCgpXG5cbiAgICBpZiAodGhpcy5fb2JzZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vYnNlcnZlciA9IHRoaXMuX2dldE5ld09ic2VydmVyKClcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHNlY3Rpb24gb2YgdGhpcy5fb2JzZXJ2YWJsZVNlY3Rpb25zLnZhbHVlcygpKSB7XG4gICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHNlY3Rpb24pXG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICBzdXBlci5kaXNwb3NlKClcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XG4gICAgLy8gVE9ETzogb24gdjYgdGFyZ2V0IHNob3VsZCBiZSBnaXZlbiBleHBsaWNpdGx5ICYgcmVtb3ZlIHRoZSB7dGFyZ2V0OiAnc3MtdGFyZ2V0J30gY2FzZVxuICAgIGNvbmZpZy50YXJnZXQgPSBnZXRFbGVtZW50KGNvbmZpZy50YXJnZXQpIHx8IGRvY3VtZW50LmJvZHlcblxuICAgIC8vIFRPRE86IHY2IE9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnMuIFVzZSByb290TWFyZ2luIG9ubHlcbiAgICBjb25maWcucm9vdE1hcmdpbiA9IGNvbmZpZy5vZmZzZXQgPyBgJHtjb25maWcub2Zmc2V0fXB4IDBweCAtMzAlYCA6IGNvbmZpZy5yb290TWFyZ2luXG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZy50aHJlc2hvbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25maWcudGhyZXNob2xkID0gY29uZmlnLnRocmVzaG9sZC5zcGxpdCgnLCcpLm1hcCh2YWx1ZSA9PiBOdW1iZXIucGFyc2VGbG9hdCh2YWx1ZSkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9XG5cbiAgX21heWJlRW5hYmxlU21vb3RoU2Nyb2xsKCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLnNtb290aFNjcm9sbCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gdW5yZWdpc3RlciBhbnkgcHJldmlvdXMgbGlzdGVuZXJzXG4gICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9jb25maWcudGFyZ2V0LCBFVkVOVF9DTElDSylcblxuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9jb25maWcudGFyZ2V0LCBFVkVOVF9DTElDSywgU0VMRUNUT1JfVEFSR0VUX0xJTktTLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBvYnNlcnZhYmxlU2VjdGlvbiA9IHRoaXMuX29ic2VydmFibGVTZWN0aW9ucy5nZXQoZXZlbnQudGFyZ2V0Lmhhc2gpXG4gICAgICBpZiAob2JzZXJ2YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICBjb25zdCByb290ID0gdGhpcy5fcm9vdEVsZW1lbnQgfHwgd2luZG93XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IG9ic2VydmFibGVTZWN0aW9uLm9mZnNldFRvcCAtIHRoaXMuX2VsZW1lbnQub2Zmc2V0VG9wXG4gICAgICAgIGlmIChyb290LnNjcm9sbFRvKSB7XG4gICAgICAgICAgcm9vdC5zY3JvbGxUbyh7IHRvcDogaGVpZ2h0LCBiZWhhdmlvcjogJ3Ntb290aCcgfSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENocm9tZSA2MCBkb2Vzbid0IHN1cHBvcnQgYHNjcm9sbFRvYFxuICAgICAgICByb290LnNjcm9sbFRvcCA9IGhlaWdodFxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBfZ2V0TmV3T2JzZXJ2ZXIoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHJvb3Q6IHRoaXMuX3Jvb3RFbGVtZW50LFxuICAgICAgdGhyZXNob2xkOiB0aGlzLl9jb25maWcudGhyZXNob2xkLFxuICAgICAgcm9vdE1hcmdpbjogdGhpcy5fY29uZmlnLnJvb3RNYXJnaW5cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4gdGhpcy5fb2JzZXJ2ZXJDYWxsYmFjayhlbnRyaWVzKSwgb3B0aW9ucylcbiAgfVxuXG4gIC8vIFRoZSBsb2dpYyBvZiBzZWxlY3Rpb25cbiAgX29ic2VydmVyQ2FsbGJhY2soZW50cmllcykge1xuICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBlbnRyeSA9PiB0aGlzLl90YXJnZXRMaW5rcy5nZXQoYCMke2VudHJ5LnRhcmdldC5pZH1gKVxuICAgIGNvbnN0IGFjdGl2YXRlID0gZW50cnkgPT4ge1xuICAgICAgdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnZpc2libGVFbnRyeVRvcCA9IGVudHJ5LnRhcmdldC5vZmZzZXRUb3BcbiAgICAgIHRoaXMuX3Byb2Nlc3ModGFyZ2V0RWxlbWVudChlbnRyeSkpXG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50U2Nyb2xsVG9wID0gKHRoaXMuX3Jvb3RFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuc2Nyb2xsVG9wXG4gICAgY29uc3QgdXNlclNjcm9sbHNEb3duID0gcGFyZW50U2Nyb2xsVG9wID49IHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YS5wYXJlbnRTY3JvbGxUb3BcbiAgICB0aGlzLl9wcmV2aW91c1Njcm9sbERhdGEucGFyZW50U2Nyb2xsVG9wID0gcGFyZW50U2Nyb2xsVG9wXG5cbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIGlmICghZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbFxuICAgICAgICB0aGlzLl9jbGVhckFjdGl2ZUNsYXNzKHRhcmdldEVsZW1lbnQoZW50cnkpKVxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVudHJ5SXNMb3dlclRoYW5QcmV2aW91cyA9IGVudHJ5LnRhcmdldC5vZmZzZXRUb3AgPj0gdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnZpc2libGVFbnRyeVRvcFxuICAgICAgLy8gaWYgd2UgYXJlIHNjcm9sbGluZyBkb3duLCBwaWNrIHRoZSBiaWdnZXIgb2Zmc2V0VG9wXG4gICAgICBpZiAodXNlclNjcm9sbHNEb3duICYmIGVudHJ5SXNMb3dlclRoYW5QcmV2aW91cykge1xuICAgICAgICBhY3RpdmF0ZShlbnRyeSlcbiAgICAgICAgLy8gaWYgcGFyZW50IGlzbid0IHNjcm9sbGVkLCBsZXQncyBrZWVwIHRoZSBmaXJzdCB2aXNpYmxlIGl0ZW0sIGJyZWFraW5nIHRoZSBpdGVyYXRpb25cbiAgICAgICAgaWYgKCFwYXJlbnRTY3JvbGxUb3ApIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHdlIGFyZSBzY3JvbGxpbmcgdXAsIHBpY2sgdGhlIHNtYWxsZXN0IG9mZnNldFRvcFxuICAgICAgaWYgKCF1c2VyU2Nyb2xsc0Rvd24gJiYgIWVudHJ5SXNMb3dlclRoYW5QcmV2aW91cykge1xuICAgICAgICBhY3RpdmF0ZShlbnRyeSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfaW5pdGlhbGl6ZVRhcmdldHNBbmRPYnNlcnZhYmxlcygpIHtcbiAgICB0aGlzLl90YXJnZXRMaW5rcyA9IG5ldyBNYXAoKVxuICAgIHRoaXMuX29ic2VydmFibGVTZWN0aW9ucyA9IG5ldyBNYXAoKVxuXG4gICAgY29uc3QgdGFyZ2V0TGlua3MgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX1RBUkdFVF9MSU5LUywgdGhpcy5fY29uZmlnLnRhcmdldClcblxuICAgIGZvciAoY29uc3QgYW5jaG9yIG9mIHRhcmdldExpbmtzKSB7XG4gICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgYW5jaG9yIGhhcyBhbiBpZCBhbmQgaXMgbm90IGRpc2FibGVkXG4gICAgICBpZiAoIWFuY2hvci5oYXNoIHx8IGlzRGlzYWJsZWQoYW5jaG9yKSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvYnNlcnZhYmxlU2VjdGlvbiA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoYW5jaG9yLmhhc2gsIHRoaXMuX2VsZW1lbnQpXG5cbiAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBvYnNlcnZhYmxlU2VjdGlvbiBleGlzdHMgJiBpcyB2aXNpYmxlXG4gICAgICBpZiAoaXNWaXNpYmxlKG9ic2VydmFibGVTZWN0aW9uKSkge1xuICAgICAgICB0aGlzLl90YXJnZXRMaW5rcy5zZXQoYW5jaG9yLmhhc2gsIGFuY2hvcilcbiAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZVNlY3Rpb25zLnNldChhbmNob3IuaGFzaCwgb2JzZXJ2YWJsZVNlY3Rpb24pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3Byb2Nlc3ModGFyZ2V0KSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZVRhcmdldCA9PT0gdGFyZ2V0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9jbGVhckFjdGl2ZUNsYXNzKHRoaXMuX2NvbmZpZy50YXJnZXQpXG4gICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gdGFyZ2V0XG4gICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgdGhpcy5fYWN0aXZhdGVQYXJlbnRzKHRhcmdldClcblxuICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0FDVElWQVRFLCB7IHJlbGF0ZWRUYXJnZXQ6IHRhcmdldCB9KVxuICB9XG5cbiAgX2FjdGl2YXRlUGFyZW50cyh0YXJnZXQpIHtcbiAgICAvLyBBY3RpdmF0ZSBkcm9wZG93biBwYXJlbnRzXG4gICAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNKSkge1xuICAgICAgU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUsIHRhcmdldC5jbG9zZXN0KFNFTEVDVE9SX0RST1BET1dOKSlcbiAgICAgICAgLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGxpc3RHcm91cCBvZiBTZWxlY3RvckVuZ2luZS5wYXJlbnRzKHRhcmdldCwgU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVApKSB7XG4gICAgICAvLyBTZXQgdHJpZ2dlcmVkIGxpbmtzIHBhcmVudHMgYXMgYWN0aXZlXG4gICAgICAvLyBXaXRoIGJvdGggPHVsPiBhbmQgPG5hdj4gbWFya3VwIGEgcGFyZW50IGlzIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIGFueSBuYXYgYW5jZXN0b3JcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBTZWxlY3RvckVuZ2luZS5wcmV2KGxpc3RHcm91cCwgU0VMRUNUT1JfTElOS19JVEVNUykpIHtcbiAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9jbGVhckFjdGl2ZUNsYXNzKHBhcmVudCkge1xuICAgIHBhcmVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFKVxuXG4gICAgY29uc3QgYWN0aXZlTm9kZXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKGAke1NFTEVDVE9SX1RBUkdFVF9MSU5LU30uJHtDTEFTU19OQU1FX0FDVElWRX1gLCBwYXJlbnQpXG4gICAgZm9yIChjb25zdCBub2RlIG9mIGFjdGl2ZU5vZGVzKSB7XG4gICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgfVxuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gU2Nyb2xsU3B5LmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApXG4gICAgICB9XG5cbiAgICAgIGRhdGFbY29uZmlnXSgpXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gKi9cblxuRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSwgKCkgPT4ge1xuICBmb3IgKGNvbnN0IHNweSBvZiBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfU1BZKSkge1xuICAgIFNjcm9sbFNweS5nZXRPckNyZWF0ZUluc3RhbmNlKHNweSlcbiAgfVxufSlcblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oU2Nyb2xsU3B5KVxuXG5leHBvcnQgZGVmYXVsdCBTY3JvbGxTcHlcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMi4yKTogdGFiLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0IHsgZGVmaW5lSlF1ZXJ5UGx1Z2luLCBnZXRFbGVtZW50RnJvbVNlbGVjdG9yLCBnZXROZXh0QWN0aXZlRWxlbWVudCwgaXNEaXNhYmxlZCB9IGZyb20gJy4vdXRpbC9pbmRleCdcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi9kb20vZXZlbnQtaGFuZGxlcidcbmltcG9ydCBTZWxlY3RvckVuZ2luZSBmcm9tICcuL2RvbS9zZWxlY3Rvci1lbmdpbmUnXG5pbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tICcuL2Jhc2UtY29tcG9uZW50J1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUgPSAndGFiJ1xuY29uc3QgREFUQV9LRVkgPSAnYnMudGFiJ1xuY29uc3QgRVZFTlRfS0VZID0gYC4ke0RBVEFfS0VZfWBcblxuY29uc3QgRVZFTlRfSElERSA9IGBoaWRlJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfSElEREVOID0gYGhpZGRlbiR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX1NIT1cgPSBgc2hvdyR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX1NIT1dOID0gYHNob3duJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkgPSBgY2xpY2ske0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9LRVlET1dOID0gYGtleWRvd24ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJID0gYGxvYWQke0VWRU5UX0tFWX1gXG5cbmNvbnN0IEFSUk9XX0xFRlRfS0VZID0gJ0Fycm93TGVmdCdcbmNvbnN0IEFSUk9XX1JJR0hUX0tFWSA9ICdBcnJvd1JpZ2h0J1xuY29uc3QgQVJST1dfVVBfS0VZID0gJ0Fycm93VXAnXG5jb25zdCBBUlJPV19ET1dOX0tFWSA9ICdBcnJvd0Rvd24nXG5cbmNvbnN0IENMQVNTX05BTUVfQUNUSVZFID0gJ2FjdGl2ZSdcbmNvbnN0IENMQVNTX05BTUVfRkFERSA9ICdmYWRlJ1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XID0gJ3Nob3cnXG5jb25zdCBDTEFTU19EUk9QRE9XTiA9ICdkcm9wZG93bidcblxuY29uc3QgU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFID0gJy5kcm9wZG93bi10b2dnbGUnXG5jb25zdCBTRUxFQ1RPUl9EUk9QRE9XTl9NRU5VID0gJy5kcm9wZG93bi1tZW51J1xuY29uc3QgTk9UX1NFTEVDVE9SX0RST1BET1dOX1RPR0dMRSA9ICc6bm90KC5kcm9wZG93bi10b2dnbGUpJ1xuXG5jb25zdCBTRUxFQ1RPUl9UQUJfUEFORUwgPSAnLmxpc3QtZ3JvdXAsIC5uYXYsIFtyb2xlPVwidGFibGlzdFwiXSdcbmNvbnN0IFNFTEVDVE9SX09VVEVSID0gJy5uYXYtaXRlbSwgLmxpc3QtZ3JvdXAtaXRlbSdcbmNvbnN0IFNFTEVDVE9SX0lOTkVSID0gYC5uYXYtbGluayR7Tk9UX1NFTEVDVE9SX0RST1BET1dOX1RPR0dMRX0sIC5saXN0LWdyb3VwLWl0ZW0ke05PVF9TRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEV9LCBbcm9sZT1cInRhYlwiXSR7Tk9UX1NFTEVDVE9SX0RST1BET1dOX1RPR0dMRX1gXG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSA9ICdbZGF0YS1icy10b2dnbGU9XCJ0YWJcIl0sIFtkYXRhLWJzLXRvZ2dsZT1cInBpbGxcIl0sIFtkYXRhLWJzLXRvZ2dsZT1cImxpc3RcIl0nIC8vIHRvZG86djY6IGNvdWxkIGJlIG9ubHkgYHRhYmBcbmNvbnN0IFNFTEVDVE9SX0lOTkVSX0VMRU0gPSBgJHtTRUxFQ1RPUl9JTk5FUn0sICR7U0VMRUNUT1JfREFUQV9UT0dHTEV9YFxuXG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRV9BQ1RJVkUgPSBgLiR7Q0xBU1NfTkFNRV9BQ1RJVkV9W2RhdGEtYnMtdG9nZ2xlPVwidGFiXCJdLCAuJHtDTEFTU19OQU1FX0FDVElWRX1bZGF0YS1icy10b2dnbGU9XCJwaWxsXCJdLCAuJHtDTEFTU19OQU1FX0FDVElWRX1bZGF0YS1icy10b2dnbGU9XCJsaXN0XCJdYFxuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBUYWIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG4gICAgdGhpcy5fcGFyZW50ID0gdGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX1RBQl9QQU5FTClcblxuICAgIGlmICghdGhpcy5fcGFyZW50KSB7XG4gICAgICByZXR1cm5cbiAgICAgIC8vIHRvZG86IHNob3VsZCBUaHJvdyBleGNlcHRpb24gb24gdjZcbiAgICAgIC8vIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZWxlbWVudC5vdXRlckhUTUx9IGhhcyBub3QgYSB2YWxpZCBwYXJlbnQgJHtTRUxFQ1RPUl9JTk5FUl9FTEVNfWApXG4gICAgfVxuXG4gICAgLy8gU2V0IHVwIGluaXRpYWwgYXJpYSBhdHRyaWJ1dGVzXG4gICAgdGhpcy5fc2V0SW5pdGlhbEF0dHJpYnV0ZXModGhpcy5fcGFyZW50LCB0aGlzLl9nZXRDaGlsZHJlbigpKVxuXG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV04sIGV2ZW50ID0+IHRoaXMuX2tleWRvd24oZXZlbnQpKVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUVcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICBzaG93KCkgeyAvLyBTaG93cyB0aGlzIGVsZW0gYW5kIGRlYWN0aXZhdGUgdGhlIGFjdGl2ZSBzaWJsaW5nIGlmIGV4aXN0c1xuICAgIGNvbnN0IGlubmVyRWxlbSA9IHRoaXMuX2VsZW1lbnRcbiAgICBpZiAodGhpcy5fZWxlbUlzQWN0aXZlKGlubmVyRWxlbSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFNlYXJjaCBmb3IgYWN0aXZlIHRhYiBvbiBzYW1lIHBhcmVudCB0byBkZWFjdGl2YXRlIGl0XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fZ2V0QWN0aXZlRWxlbSgpXG5cbiAgICBjb25zdCBoaWRlRXZlbnQgPSBhY3RpdmUgP1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIoYWN0aXZlLCBFVkVOVF9ISURFLCB7IHJlbGF0ZWRUYXJnZXQ6IGlubmVyRWxlbSB9KSA6XG4gICAgICBudWxsXG5cbiAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcihpbm5lckVsZW0sIEVWRU5UX1NIT1csIHsgcmVsYXRlZFRhcmdldDogYWN0aXZlIH0pXG5cbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgfHwgKGhpZGVFdmVudCAmJiBoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2RlYWN0aXZhdGUoYWN0aXZlLCBpbm5lckVsZW0pXG4gICAgdGhpcy5fYWN0aXZhdGUoaW5uZXJFbGVtLCBhY3RpdmUpXG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9hY3RpdmF0ZShlbGVtZW50LCByZWxhdGVkRWxlbSkge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFKVxuXG4gICAgdGhpcy5fYWN0aXZhdGUoZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KSkgLy8gU2VhcmNoIGFuZCBhY3RpdmF0ZS9zaG93IHRoZSBwcm9wZXIgc2VjdGlvblxuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSAhPT0gJ3RhYicpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpXG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIHRydWUpXG4gICAgICB0aGlzLl90b2dnbGVEcm9wRG93bihlbGVtZW50LCB0cnVlKVxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIoZWxlbWVudCwgRVZFTlRfU0hPV04sIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZEVsZW1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgZWxlbWVudCwgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFKSlcbiAgfVxuXG4gIF9kZWFjdGl2YXRlKGVsZW1lbnQsIHJlbGF0ZWRFbGVtKSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgZWxlbWVudC5ibHVyKClcblxuICAgIHRoaXMuX2RlYWN0aXZhdGUoZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KSkgLy8gU2VhcmNoIGFuZCBkZWFjdGl2YXRlIHRoZSBzaG93biBzZWN0aW9uIHRvb1xuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSAhPT0gJ3RhYicpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgZmFsc2UpXG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKVxuICAgICAgdGhpcy5fdG9nZ2xlRHJvcERvd24oZWxlbWVudCwgZmFsc2UpXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcihlbGVtZW50LCBFVkVOVF9ISURERU4sIHsgcmVsYXRlZFRhcmdldDogcmVsYXRlZEVsZW0gfSlcbiAgICB9XG5cbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCBlbGVtZW50LCBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUpKVxuICB9XG5cbiAgX2tleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoIShbQVJST1dfTEVGVF9LRVksIEFSUk9XX1JJR0hUX0tFWSwgQVJST1dfVVBfS0VZLCBBUlJPV19ET1dOX0tFWV0uaW5jbHVkZXMoZXZlbnQua2V5KSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpLy8gc3RvcFByb3BhZ2F0aW9uL3ByZXZlbnREZWZhdWx0IGJvdGggYWRkZWQgdG8gc3VwcG9ydCB1cC9kb3duIGtleXMgd2l0aG91dCBzY3JvbGxpbmcgdGhlIHBhZ2VcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgY29uc3QgaXNOZXh0ID0gW0FSUk9XX1JJR0hUX0tFWSwgQVJST1dfRE9XTl9LRVldLmluY2x1ZGVzKGV2ZW50LmtleSlcbiAgICBjb25zdCBuZXh0QWN0aXZlRWxlbWVudCA9IGdldE5leHRBY3RpdmVFbGVtZW50KHRoaXMuX2dldENoaWxkcmVuKCkuZmlsdGVyKGVsZW1lbnQgPT4gIWlzRGlzYWJsZWQoZWxlbWVudCkpLCBldmVudC50YXJnZXQsIGlzTmV4dCwgdHJ1ZSlcblxuICAgIGlmIChuZXh0QWN0aXZlRWxlbWVudCkge1xuICAgICAgbmV4dEFjdGl2ZUVsZW1lbnQuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pXG4gICAgICBUYWIuZ2V0T3JDcmVhdGVJbnN0YW5jZShuZXh0QWN0aXZlRWxlbWVudCkuc2hvdygpXG4gICAgfVxuICB9XG5cbiAgX2dldENoaWxkcmVuKCkgeyAvLyBjb2xsZWN0aW9uIG9mIGlubmVyIGVsZW1lbnRzXG4gICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfSU5ORVJfRUxFTSwgdGhpcy5fcGFyZW50KVxuICB9XG5cbiAgX2dldEFjdGl2ZUVsZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldENoaWxkcmVuKCkuZmluZChjaGlsZCA9PiB0aGlzLl9lbGVtSXNBY3RpdmUoY2hpbGQpKSB8fCBudWxsXG4gIH1cblxuICBfc2V0SW5pdGlhbEF0dHJpYnV0ZXMocGFyZW50LCBjaGlsZHJlbikge1xuICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKHBhcmVudCwgJ3JvbGUnLCAndGFibGlzdCcpXG5cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICB0aGlzLl9zZXRJbml0aWFsQXR0cmlidXRlc09uQ2hpbGQoY2hpbGQpXG4gICAgfVxuICB9XG5cbiAgX3NldEluaXRpYWxBdHRyaWJ1dGVzT25DaGlsZChjaGlsZCkge1xuICAgIGNoaWxkID0gdGhpcy5fZ2V0SW5uZXJFbGVtZW50KGNoaWxkKVxuICAgIGNvbnN0IGlzQWN0aXZlID0gdGhpcy5fZWxlbUlzQWN0aXZlKGNoaWxkKVxuICAgIGNvbnN0IG91dGVyRWxlbSA9IHRoaXMuX2dldE91dGVyRWxlbWVudChjaGlsZClcbiAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCBpc0FjdGl2ZSlcblxuICAgIGlmIChvdXRlckVsZW0gIT09IGNoaWxkKSB7XG4gICAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyhvdXRlckVsZW0sICdyb2xlJywgJ3ByZXNlbnRhdGlvbicpXG4gICAgfVxuXG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpXG4gICAgfVxuXG4gICAgdGhpcy5fc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMoY2hpbGQsICdyb2xlJywgJ3RhYicpXG5cbiAgICAvLyBzZXQgYXR0cmlidXRlcyB0byB0aGUgcmVsYXRlZCBwYW5lbCB0b29cbiAgICB0aGlzLl9zZXRJbml0aWFsQXR0cmlidXRlc09uVGFyZ2V0UGFuZWwoY2hpbGQpXG4gIH1cblxuICBfc2V0SW5pdGlhbEF0dHJpYnV0ZXNPblRhcmdldFBhbmVsKGNoaWxkKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0RWxlbWVudEZyb21TZWxlY3RvcihjaGlsZClcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyh0YXJnZXQsICdyb2xlJywgJ3RhYnBhbmVsJylcblxuICAgIGlmIChjaGlsZC5pZCkge1xuICAgICAgdGhpcy5fc2V0QXR0cmlidXRlSWZOb3RFeGlzdHModGFyZ2V0LCAnYXJpYS1sYWJlbGxlZGJ5JywgYCMke2NoaWxkLmlkfWApXG4gICAgfVxuICB9XG5cbiAgX3RvZ2dsZURyb3BEb3duKGVsZW1lbnQsIG9wZW4pIHtcbiAgICBjb25zdCBvdXRlckVsZW0gPSB0aGlzLl9nZXRPdXRlckVsZW1lbnQoZWxlbWVudClcbiAgICBpZiAoIW91dGVyRWxlbS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfRFJPUERPV04pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB0b2dnbGUgPSAoc2VsZWN0b3IsIGNsYXNzTmFtZSkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoc2VsZWN0b3IsIG91dGVyRWxlbSlcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShjbGFzc05hbWUsIG9wZW4pXG4gICAgICB9XG4gICAgfVxuXG4gICAgdG9nZ2xlKFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSwgQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgdG9nZ2xlKFNFTEVDVE9SX0RST1BET1dOX01FTlUsIENMQVNTX05BTUVfU0hPVylcbiAgICBvdXRlckVsZW0uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgb3BlbilcbiAgfVxuXG4gIF9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyhlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGUpKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIF9lbGVtSXNBY3RpdmUoZWxlbSkge1xuICAgIHJldHVybiBlbGVtLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0FDVElWRSlcbiAgfVxuXG4gIC8vIFRyeSB0byBnZXQgdGhlIGlubmVyIGVsZW1lbnQgKHVzdWFsbHkgdGhlIC5uYXYtbGluaylcbiAgX2dldElubmVyRWxlbWVudChlbGVtKSB7XG4gICAgcmV0dXJuIGVsZW0ubWF0Y2hlcyhTRUxFQ1RPUl9JTk5FUl9FTEVNKSA/IGVsZW0gOiBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0lOTkVSX0VMRU0sIGVsZW0pXG4gIH1cblxuICAvLyBUcnkgdG8gZ2V0IHRoZSBvdXRlciBlbGVtZW50ICh1c3VhbGx5IHRoZSAubmF2LWl0ZW0pXG4gIF9nZXRPdXRlckVsZW1lbnQoZWxlbSkge1xuICAgIHJldHVybiBlbGVtLmNsb3Nlc3QoU0VMRUNUT1JfT1VURVIpIHx8IGVsZW1cbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IFRhYi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpXG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgIH1cblxuICAgICAgZGF0YVtjb25maWddKClcbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAqL1xuXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgVGFiLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcykuc2hvdygpXG59KVxuXG4vKipcbiAqIEluaXRpYWxpemUgb24gZm9jdXNcbiAqL1xuRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSwgKCkgPT4ge1xuICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1RPR0dMRV9BQ1RJVkUpKSB7XG4gICAgVGFiLmdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudClcbiAgfVxufSlcbi8qKlxuICogalF1ZXJ5XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKFRhYilcblxuZXhwb3J0IGRlZmF1bHQgVGFiXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjIuMik6IHRvYXN0LmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0IHsgZGVmaW5lSlF1ZXJ5UGx1Z2luLCByZWZsb3cgfSBmcm9tICcuL3V0aWwvaW5kZXgnXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4vZG9tL2V2ZW50LWhhbmRsZXInXG5pbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tICcuL2Jhc2UtY29tcG9uZW50J1xuaW1wb3J0IHsgZW5hYmxlRGlzbWlzc1RyaWdnZXIgfSBmcm9tICcuL3V0aWwvY29tcG9uZW50LWZ1bmN0aW9ucydcblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FID0gJ3RvYXN0J1xuY29uc3QgREFUQV9LRVkgPSAnYnMudG9hc3QnXG5jb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YFxuXG5jb25zdCBFVkVOVF9NT1VTRU9WRVIgPSBgbW91c2VvdmVyJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfTU9VU0VPVVQgPSBgbW91c2VvdXQke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9GT0NVU0lOID0gYGZvY3VzaW4ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9GT0NVU09VVCA9IGBmb2N1c291dCR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0hJREUgPSBgaGlkZSR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0hJRERFTiA9IGBoaWRkZW4ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9TSE9XID0gYHNob3cke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9TSE9XTiA9IGBzaG93biR7RVZFTlRfS0VZfWBcblxuY29uc3QgQ0xBU1NfTkFNRV9GQURFID0gJ2ZhZGUnXG5jb25zdCBDTEFTU19OQU1FX0hJREUgPSAnaGlkZScgLy8gQGRlcHJlY2F0ZWQgLSBrZXB0IGhlcmUgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbmNvbnN0IENMQVNTX05BTUVfU0hPVyA9ICdzaG93J1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XSU5HID0gJ3Nob3dpbmcnXG5cbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICBhbmltYXRpb246ICdib29sZWFuJyxcbiAgYXV0b2hpZGU6ICdib29sZWFuJyxcbiAgZGVsYXk6ICdudW1iZXInXG59XG5cbmNvbnN0IERlZmF1bHQgPSB7XG4gIGFuaW1hdGlvbjogdHJ1ZSxcbiAgYXV0b2hpZGU6IHRydWUsXG4gIGRlbGF5OiA1MDAwXG59XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIFRvYXN0IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZylcblxuICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsXG4gICAgdGhpcy5faGFzTW91c2VJbnRlcmFjdGlvbiA9IGZhbHNlXG4gICAgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiA9IGZhbHNlXG4gICAgdGhpcy5fc2V0TGlzdGVuZXJzKClcbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0XG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZVxuICB9XG5cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FXG4gIH1cblxuICAvLyBQdWJsaWNcbiAgc2hvdygpIHtcbiAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XKVxuXG4gICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9jbGVhclRpbWVvdXQoKVxuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5hbmltYXRpb24pIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0ZBREUpXG4gICAgfVxuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XSU5HKVxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04pXG5cbiAgICAgIHRoaXMuX21heWJlU2NoZWR1bGVIaWRlKClcbiAgICB9XG5cbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9ISURFKSAvLyBAZGVwcmVjYXRlZFxuICAgIHJlZmxvdyh0aGlzLl9lbGVtZW50KVxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1csIENMQVNTX05BTUVfU0hPV0lORylcblxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZy5hbmltYXRpb24pXG4gIH1cblxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5pc1Nob3duKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUpXG5cbiAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfSElERSkgLy8gQGRlcHJlY2F0ZWRcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1dJTkcsIENMQVNTX05BTUVfU0hPVylcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTilcbiAgICB9XG5cbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XSU5HKVxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZy5hbmltYXRpb24pXG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpXG5cbiAgICBpZiAodGhpcy5pc1Nob3duKCkpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1cpXG4gICAgfVxuXG4gICAgc3VwZXIuZGlzcG9zZSgpXG4gIH1cblxuICBpc1Nob3duKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1cpXG4gIH1cblxuICAvLyBQcml2YXRlXG5cbiAgX21heWJlU2NoZWR1bGVIaWRlKCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLmF1dG9oaWRlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5faGFzTW91c2VJbnRlcmFjdGlvbiB8fCB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmhpZGUoKVxuICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheSlcbiAgfVxuXG4gIF9vbkludGVyYWN0aW9uKGV2ZW50LCBpc0ludGVyYWN0aW5nKSB7XG4gICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICBjYXNlICdtb3VzZW92ZXInOlxuICAgICAgY2FzZSAnbW91c2VvdXQnOiB7XG4gICAgICAgIHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gPSBpc0ludGVyYWN0aW5nXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ2ZvY3VzaW4nOlxuICAgICAgY2FzZSAnZm9jdXNvdXQnOiB7XG4gICAgICAgIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSBpc0ludGVyYWN0aW5nXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNJbnRlcmFjdGluZykge1xuICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IG5leHRFbGVtZW50ID0gZXZlbnQucmVsYXRlZFRhcmdldFxuICAgIGlmICh0aGlzLl9lbGVtZW50ID09PSBuZXh0RWxlbWVudCB8fCB0aGlzLl9lbGVtZW50LmNvbnRhaW5zKG5leHRFbGVtZW50KSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fbWF5YmVTY2hlZHVsZUhpZGUoKVxuICB9XG5cbiAgX3NldExpc3RlbmVycygpIHtcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VPVkVSLCBldmVudCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKGV2ZW50LCB0cnVlKSlcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VPVVQsIGV2ZW50ID0+IHRoaXMuX29uSW50ZXJhY3Rpb24oZXZlbnQsIGZhbHNlKSlcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfRk9DVVNJTiwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgdHJ1ZSkpXG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0ZPQ1VTT1VULCBldmVudCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKGV2ZW50LCBmYWxzZSkpXG4gIH1cblxuICBfY2xlYXJUaW1lb3V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KVxuICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsXG4gIH1cblxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBUb2FzdC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZylcblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFbY29uZmlnXSh0aGlzKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICovXG5cbmVuYWJsZURpc21pc3NUcmlnZ2VyKFRvYXN0KVxuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihUb2FzdClcblxuZXhwb3J0IGRlZmF1bHQgVG9hc3RcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMi4yKTogaW5kZXgudW1kLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0IEFsZXJ0IGZyb20gJy4vc3JjL2FsZXJ0J1xuaW1wb3J0IEJ1dHRvbiBmcm9tICcuL3NyYy9idXR0b24nXG5pbXBvcnQgQ2Fyb3VzZWwgZnJvbSAnLi9zcmMvY2Fyb3VzZWwnXG5pbXBvcnQgQ29sbGFwc2UgZnJvbSAnLi9zcmMvY29sbGFwc2UnXG5pbXBvcnQgRHJvcGRvd24gZnJvbSAnLi9zcmMvZHJvcGRvd24nXG5pbXBvcnQgTW9kYWwgZnJvbSAnLi9zcmMvbW9kYWwnXG5pbXBvcnQgT2ZmY2FudmFzIGZyb20gJy4vc3JjL29mZmNhbnZhcydcbmltcG9ydCBQb3BvdmVyIGZyb20gJy4vc3JjL3BvcG92ZXInXG5pbXBvcnQgU2Nyb2xsU3B5IGZyb20gJy4vc3JjL3Njcm9sbHNweSdcbmltcG9ydCBUYWIgZnJvbSAnLi9zcmMvdGFiJ1xuaW1wb3J0IFRvYXN0IGZyb20gJy4vc3JjL3RvYXN0J1xuaW1wb3J0IFRvb2x0aXAgZnJvbSAnLi9zcmMvdG9vbHRpcCdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBBbGVydCxcbiAgQnV0dG9uLFxuICBDYXJvdXNlbCxcbiAgQ29sbGFwc2UsXG4gIERyb3Bkb3duLFxuICBNb2RhbCxcbiAgT2ZmY2FudmFzLFxuICBQb3BvdmVyLFxuICBTY3JvbGxTcHksXG4gIFRhYixcbiAgVG9hc3QsXG4gIFRvb2x0aXBcbn1cbiIsIiQoZnVuY3Rpb24gKCkge1xyXG4gICAgdG9nZ2xlQ29ubmVjdGlvblN0cmluZ0FuZFByZWZpeCgpO1xyXG5cclxuICAgIC8vIFNob3cgaGlkZSB0aGUgY29ubmVjdGlvbiBzdHJpbmcgd2hlbiBhIHByb3ZpZGVyIGlzIHNlbGVjdGVkXHJcbiAgICAkKFwiI0RhdGFiYXNlUHJvdmlkZXJcIikuY2hhbmdlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0b2dnbGVDb25uZWN0aW9uU3RyaW5nQW5kUHJlZml4KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBSZWZyZXNoIHRoZSByZWNpcGUgZGVzY3JpcHRpb25cclxuICAgICQoXCIjcmVjaXBlcyBkaXYgYVwiKS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmVmcmVzaERlc2NyaXB0aW9uKCQodGhpcykpO1xyXG4gICAgfSk7XHJcbn0pO1xyXG5cclxuLy8gU2hvdyBvciBoaWRlIHRoZSBjb25uZWN0aW9uIHN0cmluZyBvciB0YWJsZSBwcmVmaXggc2VjdGlvbiB3aGVuIHRoZSBkYXRhYmFzZSBwcm92aWRlciBpcyBzZWxlY3RlZFxyXG5mdW5jdGlvbiB0b2dnbGVDb25uZWN0aW9uU3RyaW5nQW5kUHJlZml4KCkge1xyXG4gICAgJChcIiNEYXRhYmFzZVByb3ZpZGVyIG9wdGlvbjpzZWxlY3RlZFwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAkKHRoaXMpLmRhdGEoXCJjb25uZWN0aW9uLXN0cmluZ1wiKS50b0xvd2VyQ2FzZSgpID09PSBcInRydWVcIlxyXG4gICAgICAgICAgICA/ICQoXCIuY29ubmVjdGlvblN0cmluZ1wiKS5zaG93KClcclxuICAgICAgICAgICAgOiAkKFwiLmNvbm5lY3Rpb25TdHJpbmdcIikuaGlkZSgpO1xyXG5cclxuICAgICAgICAkKHRoaXMpLmRhdGEoXCJ0YWJsZS1wcmVmaXhcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cnVlXCJcclxuICAgICAgICAgICAgPyAkKFwiLnRhYmxlUHJlZml4XCIpLnNob3coKVxyXG4gICAgICAgICAgICA6ICQoXCIudGFibGVQcmVmaXhcIikuaGlkZSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgICQodGhpcykuZGF0YShcImNvbm5lY3Rpb24tc3RyaW5nXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwidHJ1ZVwiXHJcbiAgICAgICAgICAgID8gJChcIi5wd2RcIikuYXR0cigncmVxdWlyZWQnLCAncmVxdWlyZWQnKVxyXG4gICAgICAgICAgICA6ICQoXCIucHdkXCIpLnJlbW92ZUF0dHIoJ3JlcXVpcmVkJyk7XHJcblxyXG4gICAgICAgICQoXCIjY29ubmVjdGlvblN0cmluZ0hpbnRcIikudGV4dCgkKHRoaXMpLmRhdGEoXCJjb25uZWN0aW9uLXN0cmluZy1zYW1wbGVcIikpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8vIFNob3cgdGhlIHJlY2lwZSBkZXNjcmlwdGlvblxyXG5mdW5jdGlvbiByZWZyZXNoRGVzY3JpcHRpb24odGFyZ2V0KSB7XHJcbiAgICB2YXIgcmVjaXBlTmFtZSA9ICQodGFyZ2V0KS5kYXRhKFwicmVjaXBlLW5hbWVcIik7XHJcbiAgICB2YXIgcmVjaXBlRGlzcGxheU5hbWUgPSAkKHRhcmdldCkuZGF0YShcInJlY2lwZS1kaXNwbGF5LW5hbWVcIik7XHJcbiAgICB2YXIgcmVjaXBlRGVzY3JpcHRpb24gPSAkKHRhcmdldCkuZGF0YShcInJlY2lwZS1kZXNjcmlwdGlvblwiKTtcclxuICAgICQoXCIjcmVjaXBlQnV0dG9uXCIpLnRleHQocmVjaXBlRGlzcGxheU5hbWUpO1xyXG4gICAgJChcIiNSZWNpcGVOYW1lXCIpLnZhbChyZWNpcGVOYW1lKTtcclxuICAgICQoXCIjcmVjaXBlQnV0dG9uXCIpLmF0dHIoXCJ0aXRsZVwiLCByZWNpcGVEZXNjcmlwdGlvbik7XHJcbiAgICAkKFwiI3JlY2lwZUJ1dHRvblwiKS5mb2N1cygpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRMb2NhbGl6YXRpb25VcmwoKSB7XHJcbiAgICB2YXIgY3VsdHVyZXNMaXN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2N1bHR1cmVzTGlzdCcpO1xyXG4gICAgd2luZG93LmxvY2F0aW9uID0gY3VsdHVyZXNMaXN0Lm9wdGlvbnNbY3VsdHVyZXNMaXN0LnNlbGVjdGVkSW5kZXhdLmRhdGFzZXQudXJsO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0b2dnbGVQYXNzd29yZFZpc2liaWxpdHkocGFzc3dvcmRDdGwsIHRvZ2dsZVBhc3N3b3JkQ3RsKVxyXG57XHJcbiAgICAvLyB0b2dnbGUgdGhlIHR5cGUgYXR0cmlidXRlXHJcbiAgICB0eXBlID0gcGFzc3dvcmRDdGwuZ2V0QXR0cmlidXRlKCd0eXBlJykgPT09ICdwYXNzd29yZCcgPyAndGV4dCcgOiAncGFzc3dvcmQnO1xyXG4gICAgcGFzc3dvcmRDdGwuc2V0QXR0cmlidXRlKCd0eXBlJywgdHlwZSk7XHJcblxyXG4gICAgLy8gdG9nZ2xlIHRoZSBleWUgc2xhc2ggaWNvblxyXG4gICAgaWNvbiA9IHRvZ2dsZVBhc3N3b3JkQ3RsLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2ljb24nKVswXTtcclxuICAgIGlmKGljb24uZ2V0QXR0cmlidXRlKCdkYXRhLWljb24nKSl7IC8vIGlmIHRoZSBpY29uIGlzIHJlbmRlcmVkIGFzIGEgc3ZnXHJcbiAgICAgICAgdHlwZSA9PT0gJ3Bhc3N3b3JkJyA/IGljb24uc2V0QXR0cmlidXRlKCdkYXRhLWljb24nLCAnZXllJykgOiBpY29uLnNldEF0dHJpYnV0ZSgnZGF0YS1pY29uJywgJ2V5ZS1zbGFzaCcpO1xyXG4gICAgfVxyXG4gICAgZWxzZXsgLy8gaWYgdGhlIGljb24gaXMgc3RpbGwgYSA8aT4gZWxlbWVudFxyXG4gICAgICAgIHR5cGUgPT09ICdwYXNzd29yZCcgPyBpY29uLmNsYXNzTGlzdC5yZW1vdmUoJ2ZhLWV5ZS1zbGFzaCcpIDogaWNvbi5jbGFzc0xpc3QucmVtb3ZlKCdmYS1leWUnKTtcclxuICAgICAgICB0eXBlID09PSAncGFzc3dvcmQnID8gaWNvbi5jbGFzc0xpc3QuYWRkKCdmYS1leWUnKSA6IGljb24uY2xhc3NMaXN0LmFkZCgnZmEtZXllLXNsYXNoJyk7XHJcbiAgICB9XHJcbn1cclxuIiwiKGZ1bmN0aW9uICgkKSB7XHJcblxyXG4gICAgJC5mbi5zdHJlbmd0aCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIHZhciBzZXR0aW5ncyA9ICQuZXh0ZW5kKHtcclxuICAgICAgICAgICAgbWluTGVuZ3RoOiA4LFxyXG4gICAgICAgICAgICB1cHBlckNhc2U6IGZhbHNlLFxyXG4gICAgICAgICAgICBsb3dlckNhc2U6IGZhbHNlLFxyXG4gICAgICAgICAgICBudW1iZXJzOiBmYWxzZSxcclxuICAgICAgICAgICAgc3BlY2lhbGNoYXJzOiBmYWxzZSxcclxuICAgICAgICAgICAgdGFyZ2V0OiAnJyxcclxuICAgICAgICAgICAgc3R5bGU6ICcnXHJcbiAgICAgICAgfSwgb3B0aW9ucyk7XHJcblxyXG5cclxuICAgICAgICB2YXIgY2FwaXRhbGxldHRlcnMgPSAwO1xyXG4gICAgICAgIHZhciBsb3dlcmxldHRlcnMgPSAwO1xyXG4gICAgICAgIHZhciBudW1iZXJzID0gMDtcclxuICAgICAgICB2YXIgc3BlY2lhbGNoYXJzID0gMDtcclxuXHJcbiAgICAgICAgdmFyIHVwcGVyQ2FzZSA9IG5ldyBSZWdFeHAoJ1tBLVpdJyk7XHJcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IG5ldyBSZWdFeHAoJ1thLXpdJyk7XHJcbiAgICAgICAgdmFyIG51bWJlciA9IG5ldyBSZWdFeHAoJ1swLTldJyk7XHJcbiAgICAgICAgdmFyIHNwZWNpYWxjaGFyID0gbmV3IFJlZ0V4cCgnW15BLVphLXowLTldJyk7XHJcblxyXG4gICAgICAgIHZhciB2YWxpZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICBjcmVhdGVQcm9ncmVzc0JhcigwLCAnJyk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGdldFBlcmNlbnRhZ2UoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gKChiIC8gYSkgKiAxMDApLnRvRml4ZWQoMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXRMZXZlbCh2YWx1ZSkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHZhbHVlID49IDEwMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiYmctc3VjY2Vzc1wiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gNTApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImJnLXdhcm5pbmdcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHZhbHVlID09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJzsgLy8gZ3JheWVkXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBcImJnLWRhbmdlclwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tTdHJlbmd0aCh2YWx1ZSkge1xyXG5cclxuICAgICAgICAgICAgbWluTGVuZ3RoID0gdmFsdWUubGVuZ3RoID49IHNldHRpbmdzLm1pbkxlbmd0aCA/IDEgOiAwO1xyXG4gICAgICAgICAgICBjYXBpdGFsbGV0dGVycyA9ICFzZXR0aW5ncy51cHBlckNhc2UgfHwgdmFsdWUubWF0Y2godXBwZXJDYXNlKSA/IDEgOiAwO1xyXG4gICAgICAgICAgICBsb3dlcmxldHRlcnMgPSAhc2V0dGluZ3MubG93ZXJDYXNlIHx8IHZhbHVlLm1hdGNoKGxvd2VyQ2FzZSkgPyAxIDogMDtcclxuICAgICAgICAgICAgbnVtYmVycyA9ICFzZXR0aW5ncy5udW1iZXJzIHx8IHZhbHVlLm1hdGNoKG51bWJlcikgPyAxIDogMDtcclxuICAgICAgICAgICAgc3BlY2lhbGNoYXJzID0gIXNldHRpbmdzLnNwZWNpYWxjaGFycyB8fCB2YWx1ZS5tYXRjaChzcGVjaWFsY2hhcikgPyAxIDogMDtcclxuXHJcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IG1pbkxlbmd0aCArIGNhcGl0YWxsZXR0ZXJzICsgbG93ZXJsZXR0ZXJzICsgbnVtYmVycyArIHNwZWNpYWxjaGFycztcclxuICAgICAgICAgICAgdmFyIHBlcmNlbnRhZ2UgPSBnZXRQZXJjZW50YWdlKDUsIHRvdGFsKTtcclxuXHJcbiAgICAgICAgICAgIHZhbGlkID0gcGVyY2VudGFnZSA+PSAxMDA7XHJcblxyXG4gICAgICAgICAgICBjcmVhdGVQcm9ncmVzc0JhcihwZXJjZW50YWdlLCBnZXRMZXZlbChwZXJjZW50YWdlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVQcm9ncmVzc0JhcihwZXJjZW50YWdlLCBsZXZlbCkge1xyXG4gICAgICAgICAgICB2YXIgZWwgPSAkKCc8ZGl2IGNsYXNzPVwicHJvZ3Jlc3NcIiB2YWx1ZT1cIicgKyBwZXJjZW50YWdlICsgJ1wiIHN0eWxlPVwiJyArIHNldHRpbmdzLnN0eWxlICsgJ1wiIG1heD1cIjEwMFwiIGFyaWEtZGVzY3JpYmVkYnk9XCJcIj48ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtYmFyICcgKyBsZXZlbCArICdcIiByb2xlPVwicHJvZ3Jlc3MtYmFyXCIgc3R5bGU9XCJ3aWR0aDogJyArIHBlcmNlbnRhZ2UgKyAnJTtcIj48L2Rpdj48L2Rpdj4nKTtcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9ICQoc2V0dGluZ3MudGFyZ2V0KTtcclxuICAgICAgICAgICAgdGFyZ2V0LmVtcHR5KCk7XHJcbiAgICAgICAgICAgIHRhcmdldC5hcHBlbmQoZWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5iaW5kKCdrZXl1cCBrZXlkb3duJywgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGNoZWNrU3RyZW5ndGgoJCh0aGlzKS52YWwoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5iaW5kKCdkcm9wJywgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGNoZWNrU3RyZW5ndGgoZXZlbnQub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcInRleHRcIikpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnBhcmVudHMoJ2Zvcm0nKS5vbignc3VibWl0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59KGpRdWVyeSkpO1xyXG4gICAgIl19
