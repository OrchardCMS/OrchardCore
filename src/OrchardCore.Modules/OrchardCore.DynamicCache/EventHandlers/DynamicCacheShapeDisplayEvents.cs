using System.Text.Encodings.Web;
using Cysharp.Text;
using Microsoft.AspNetCore.Html;
using Microsoft.Extensions.Options;
using OrchardCore.DisplayManagement;
using OrchardCore.DisplayManagement.Implementation;
using OrchardCore.Environment.Cache;

namespace OrchardCore.DynamicCache.EventHandlers;

/// <summary>
/// Caches shapes in the default <see cref="IDynamicCacheService"/> implementation.
/// It uses the shape's metadata cache context to define the cache parameters.
/// </summary>
public class DynamicCacheShapeDisplayEvents : IShapeDisplayEvents
{
    private readonly Dictionary<string, CacheContext> _cached = [];
    private readonly Stack<CacheContext> _activeCacheContexts = [];

    private readonly IDynamicCacheService _dynamicCacheService;
    private readonly ICacheScopeManager _cacheScopeManager;
    private readonly HtmlEncoder _htmlEncoder;
    private readonly CacheOptions _cacheOptions;

    public DynamicCacheShapeDisplayEvents(
        IDynamicCacheService dynamicCacheService,
        ICacheScopeManager cacheScopeManager,
        HtmlEncoder htmlEncoder,
        IOptions<CacheOptions> options)
    {
        _dynamicCacheService = dynamicCacheService;
        _cacheScopeManager = cacheScopeManager;
        _htmlEncoder = htmlEncoder;
        _cacheOptions = options.Value;
    }

    public async Task DisplayingAsync(ShapeDisplayContext context)
    {
        if (!_cacheOptions.Enabled)
        {
            return;
        }

        // The shape has cache settings and no content yet.
        if (context.Shape.Metadata.IsCached && context.ChildContent == null)
        {
            var cacheContext = context.Shape.Metadata.Cache();
            _cacheScopeManager.EnterScope(cacheContext);
            _activeCacheContexts.Push(cacheContext);

            var cachedContent = await _dynamicCacheService.GetCachedValueAsync(cacheContext);

            if (cachedContent != null)
            {
                // The contents of this shape was found in the cache.
                // Add the cacheContext to _cached so that we don't try to cache the content again in the DisplayedAsync method.
                _cached[cacheContext.CacheId] = cacheContext;
                context.ChildContent = new HtmlString(cachedContent);
            }
        }
        else
        {
            _activeCacheContexts.Push(null);
        }
    }

    public async Task DisplayedAsync(ShapeDisplayContext context)
    {
        if (!_cacheOptions.Enabled)
        {
            return;
        }

        // If the shape is not configured to be cached, continue as usual.
        if (!_activeCacheContexts.TryPeek(out var cacheContext) || cacheContext == null)
        {
            context.ChildContent ??= HtmlString.Empty;

            return;
        }

        // If we have got this far, then this shape is configured to be cached.
        // We need to determine whether or not the ChildContent of this shape was retrieved from the cache by the DisplayingAsync method above, as opposed to generated by the View Engine.
        // ChildContent will be generated by the View Engine if it was not available in the cache when we rendered the shape.
        // In this instance, we need insert the ChildContent into the cache so that subsequent attempt to render this shape can take advantage of the cached content.

        // If the ChildContent was retrieved form the cache, then the Cache Context will be present in the _cached collection (see the DisplayingAsync method in this class).
        // So, if the cache context is not present in the _cached collection, we need to insert the ChildContent value into the cache:
        if (!_cached.Remove(cacheContext.CacheId) && context.ChildContent != null)
        {
            // The content is pre-encoded in the cache so we don't have to do it every time it's rendered.
            using var sw = new ZStringWriter();

            // 'ChildContent' may be a 'ViewBufferTextWriterContent' on which we can't
            // call 'WriteTo()' twice, so here we update it with a new 'HtmlString()'.
            context.ChildContent.WriteTo(sw, _htmlEncoder);

            if (_cacheOptions.DebugMode)
            {
                var contentBuilder = new HtmlContentBuilder();
                var debugLog = Guid.NewGuid();

                contentBuilder.AppendLine();
                contentBuilder.AppendHtmlLine($"<!-- START CACHED SHAPE: {cacheContext.CacheId} ({debugLog})");
                contentBuilder.AppendHtmlLine($"          VARY BY: {string.Join(", ", cacheContext.Contexts)}");
                contentBuilder.AppendHtmlLine($"     DEPENDENCIES: {string.Join(", ", cacheContext.Tags)}");
                contentBuilder.AppendHtmlLine($"       EXPIRES ON: {cacheContext.ExpiresOn}");
                contentBuilder.AppendHtmlLine($"    EXPIRES AFTER: {cacheContext.ExpiresAfter}");
                contentBuilder.AppendHtmlLine($"  EXPIRES SLIDING: {cacheContext.ExpiresSliding}");
                contentBuilder.AppendHtmlLine("-->");

                contentBuilder.AppendHtml(sw.ToString());

                contentBuilder.AppendLine();
                contentBuilder.AppendHtmlLine($"<!-- END CACHED SHAPE: {cacheContext.CacheId} ({debugLog}) -->");

                context.ChildContent = contentBuilder;

                using var swForCache = new ZStringWriter();
                context.ChildContent.WriteTo(swForCache, _htmlEncoder);

                await _dynamicCacheService.SetCachedValueAsync(cacheContext, swForCache.ToString());
            }
            else
            {
                var content = sw.ToString();
                context.ChildContent = new HtmlString(content);
                await _dynamicCacheService.SetCachedValueAsync(cacheContext, content);
            }
        }
    }

    public Task DisplayingFinalizedAsync(ShapeDisplayContext context)
    {
        if (!_cacheOptions.Enabled)
        {
            return Task.CompletedTask;
        }

        if (_activeCacheContexts.TryPop(out var cacheContext) && cacheContext != null)
        {
            _cacheScopeManager.ExitScope();
        }

        return Task.CompletedTask;
    }
}
