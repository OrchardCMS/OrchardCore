using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

#nullable enable

namespace OrchardCore.DisplayManagement.SourceGenerators;

[Generator]
public class ArgumentsProviderGenerator : IIncrementalGenerator
{
    private const string GenerateArgumentsProviderAttributeFullName = "OrchardCore.DisplayManagement.GenerateArgumentsProviderAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Filter classes with the GenerateArgumentsProvider attribute using ForAttributeWithMetadataName
        var classDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                GenerateArgumentsProviderAttributeFullName,
                predicate: static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                transform: static (context, _) => GetTargetType(context))
            .Where(static m => m is not null);

        // Generate source
        context.RegisterSourceOutput(classDeclarations.Collect(),
            static (spc, types) => Execute(types!, spc));
    }

    private static INamedTypeSymbol? GetTargetType(GeneratorAttributeSyntaxContext context)
    {
        return context.TargetSymbol as INamedTypeSymbol;
    }

    private static void Execute(ImmutableArray<INamedTypeSymbol> types, SourceProductionContext context)
    {
        if (types.IsDefaultOrEmpty)
        {
            return;
        }

        foreach (var typeSymbol in types.Distinct<INamedTypeSymbol>(SymbolEqualityComparer.Default))
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            var source = GenerateArgumentsProviderImplementation(typeSymbol);
            if (!string.IsNullOrEmpty(source))
            {
                context.AddSource($"{typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Replace("global::", "").Replace(".", "_").Replace("<", "_").Replace(">", "_")}.g.cs", 
                    SourceText.From(source, Encoding.UTF8));
            }
        }
    }

    private static string GenerateArgumentsProviderImplementation(INamedTypeSymbol typeSymbol)
    {
        // Get all public instance properties
        var properties = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public &&
                       !p.IsStatic &&
                       p.GetMethod != null)
            .ToList();

        if (properties.Count == 0)
        {
            return string.Empty;
        }

        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Build the containment hierarchy
        var containingTypes = new System.Collections.Generic.Stack<INamedTypeSymbol>();
        var current = typeSymbol.ContainingType;
        while (current != null)
        {
            containingTypes.Push(current);
            current = current.ContainingType;
        }

        var namespaceName = typeSymbol.ContainingNamespace?.ToDisplayString();
        var hasNamespace = !string.IsNullOrEmpty(namespaceName) && namespaceName != "<global namespace>";

        var currentIndent = "";

        // Always add namespace if it exists (using traditional block syntax for compatibility)
        if (hasNamespace)
        {
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
            currentIndent = "    ";
        }

        // Generate containing type declarations (for nested types)
        while (containingTypes.Count > 0)
        {
            var containingType = containingTypes.Pop();
            var containingKeyword = containingType.IsRecord ? "partial record" : "partial class";
            var containingAccessibility = GetAccessibilityText(containingType.DeclaredAccessibility, containingType.ContainingType != null);

            sb.AppendLine($"{currentIndent}{containingAccessibility} {containingKeyword} {containingType.Name}");
            sb.AppendLine($"{currentIndent}{{");
            currentIndent += "    ";
        }

        // Generate the actual type
        var isRecord = typeSymbol.IsRecord;
        var keyword = isRecord ? "partial record" : "partial class";
        var accessibilityStr = GetAccessibilityText(typeSymbol.DeclaredAccessibility, typeSymbol.ContainingType != null);

        sb.AppendLine($"{currentIndent}{accessibilityStr} {keyword} {typeSymbol.Name} : global::OrchardCore.DisplayManagement.IArgumentsProvider");
        sb.AppendLine($"{currentIndent}{{");
        sb.AppendLine($"{currentIndent}    private static readonly string[] s_names = new string[]");
        sb.AppendLine($"{currentIndent}    {{");
        for (int i = 0; i < properties.Count; i++)
        {
            var property = properties[i];
            sb.AppendLine($"{currentIndent}        \"{property.Name}\",");
        }
        sb.AppendLine($"{currentIndent}    }};");
        sb.AppendLine();
        sb.AppendLine($"{currentIndent}    global::OrchardCore.DisplayManagement.INamedEnumerable<object> global::OrchardCore.DisplayManagement.IArgumentsProvider.GetArguments()");
        sb.AppendLine($"{currentIndent}    {{");
        sb.AppendLine($"{currentIndent}        var values = new object?[{properties.Count}];");
        sb.AppendLine();

        for (int i = 0; i < properties.Count; i++)
        {
            var property = properties[i];
            // Use 'this.' prefix to ensure we're accessing the instance property correctly
            sb.AppendLine($"{currentIndent}        values[{i}] = this.{property.Name};");
        }

        sb.AppendLine();
        sb.AppendLine($"{currentIndent}        return global::OrchardCore.DisplayManagement.Arguments.From(values, s_names);");
        sb.AppendLine($"{currentIndent}    }}");
        sb.AppendLine($"{currentIndent}}}");

        // Close containing types
        current = typeSymbol.ContainingType;
        while (current != null)
        {
            currentIndent = currentIndent.Substring(4); // Remove one level of indentation
            sb.AppendLine($"{currentIndent}}}");
            current = current.ContainingType;
        }

        // Close namespace
        if (hasNamespace)
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private static string GetAccessibilityText(Accessibility accessibility, bool isNested)
    {
        // For top-level types (not nested), we can't use private/protected modifiers
        if (!isNested)
        {
            return accessibility switch
            {
                Accessibility.Public => "public",
                Accessibility.Internal => "internal",
                _ => "internal" // Default to internal for top-level types
            };
        }

        // For nested types, we can use all accessibility modifiers
        return accessibility switch
        {
            Accessibility.Private => "private",
            Accessibility.Protected => "protected",
            Accessibility.Internal => "internal",
            Accessibility.Public => "public",
            Accessibility.ProtectedOrInternal => "protected internal",
            Accessibility.ProtectedAndInternal => "private protected",
            _ => "public"
        };
    }
}

