using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace OrchardCore.DisplayManagement.SourceGenerators;

[Generator]
public class ArgumentsProviderGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Filter classes with the GenerateArgumentsProvider attribute
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // Combine with compilation
        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        // Generate source
        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Left, source.Right, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax or RecordDeclarationSyntax;
    }

    private static TypeDeclarationSyntax GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var typeDeclaration = (TypeDeclarationSyntax)context.Node;

        // Check if the type has the GenerateArgumentsProvider attribute
        foreach (var attributeList in typeDeclaration.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                var symbol = context.SemanticModel.GetSymbolInfo(attribute).Symbol;
                if (symbol is IMethodSymbol attributeSymbol)
                {
                    var attributeType = attributeSymbol.ContainingType;
                    if (attributeType.Name == "GenerateArgumentsProviderAttribute" &&
                        attributeType.ContainingNamespace.ToDisplayString() == "OrchardCore.DisplayManagement")
                    {
                        return typeDeclaration;
                    }
                }
            }
        }

        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<TypeDeclarationSyntax> types, SourceProductionContext context)
    {
        if (types.IsDefaultOrEmpty)
        {
            return;
        }

        foreach (var typeDeclaration in types.Distinct())
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            var semanticModel = compilation.GetSemanticModel(typeDeclaration.SyntaxTree);
            var typeSymbol = semanticModel.GetDeclaredSymbol(typeDeclaration) as INamedTypeSymbol;

            if (typeSymbol is null)
            {
                continue;
            }

            var source = GenerateArgumentsProviderImplementation(typeSymbol);
            if (!string.IsNullOrEmpty(source))
            {
                context.AddSource($"{typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Replace("global::", "").Replace(".", "_").Replace("<", "_").Replace(">", "_")}.g.cs", 
                    SourceText.From(source, Encoding.UTF8));
            }
        }
    }

    private static string GenerateArgumentsProviderImplementation(INamedTypeSymbol typeSymbol)
    {
        // Get all public instance properties
        var properties = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public &&
                       !p.IsStatic &&
                       p.GetMethod != null)
            .ToList();

        if (properties.Count == 0)
        {
            return string.Empty;
        }

        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Build the containment hierarchy
        var containingTypes = new System.Collections.Generic.Stack<INamedTypeSymbol>();
        var current = typeSymbol.ContainingType;
        while (current != null)
        {
            containingTypes.Push(current);
            current = current.ContainingType;
        }

        var namespaceName = typeSymbol.ContainingNamespace?.ToDisplayString();
        var hasNamespace = !string.IsNullOrEmpty(namespaceName) && namespaceName != "<global namespace>";

        var currentIndent = "";

        // Always add namespace if it exists (using traditional block syntax for compatibility)
        if (hasNamespace)
        {
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
            currentIndent = "    ";
        }

        // Generate containing type declarations (for nested types)
        while (containingTypes.Count > 0)
        {
            var containingType = containingTypes.Pop();
            var containingKeyword = containingType.IsRecord ? "partial record" : "partial class";
            var containingAccessibility = GetAccessibilityText(containingType.DeclaredAccessibility, containingType.ContainingType != null);

            sb.AppendLine($"{currentIndent}{containingAccessibility} {containingKeyword} {containingType.Name}");
            sb.AppendLine($"{currentIndent}{{");
            currentIndent += "    ";
        }

        // Generate the actual type
        var isRecord = typeSymbol.IsRecord;
        var keyword = isRecord ? "partial record" : "partial class";
        var accessibilityStr = GetAccessibilityText(typeSymbol.DeclaredAccessibility, typeSymbol.ContainingType != null);

        sb.AppendLine($"{currentIndent}{accessibilityStr} {keyword} {typeSymbol.Name} : global::OrchardCore.DisplayManagement.IArgumentsProvider");
        sb.AppendLine($"{currentIndent}{{");
        sb.AppendLine($"{currentIndent}    private static readonly string[] s_names = new string[]");
        sb.AppendLine($"{currentIndent}    {{");
        for (int i = 0; i < properties.Count; i++)
        {
            var property = properties[i];
            sb.AppendLine($"{currentIndent}        \"{property.Name}\",");
        }
        sb.AppendLine($"{currentIndent}    }};");

        sb.AppendLine($"{currentIndent}    global::OrchardCore.DisplayManagement.INamedEnumerable<object> global::OrchardCore.DisplayManagement.IArgumentsProvider.GetArguments()");
        sb.AppendLine($"{currentIndent}    {{");
        sb.AppendLine($"{currentIndent}        var values = new object[{properties.Count}];");
        sb.AppendLine();

        for (int i = 0; i < properties.Count; i++)
        {
            var property = properties[i];
            // Use 'this.' prefix to ensure we're accessing the instance property correctly
            sb.AppendLine($"{currentIndent}        values[{i}] = this.{property.Name};");
        }

        sb.AppendLine();
        sb.AppendLine($"{currentIndent}        return global::OrchardCore.DisplayManagement.Arguments.From(values, s_names);");
        sb.AppendLine($"{currentIndent}    }}");
        sb.AppendLine($"{currentIndent}}}");

        // Close containing types
        current = typeSymbol.ContainingType;
        while (current != null)
        {
            currentIndent = currentIndent.Substring(4); // Remove one level of indentation
            sb.AppendLine($"{currentIndent}}}");
            current = current.ContainingType;
        }

        // Close namespace
        if (hasNamespace)
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private static string GetAccessibilityText(Accessibility accessibility, bool isNested)
    {
        // For top-level types (not nested), we can't use private/protected modifiers
        if (!isNested)
        {
            return accessibility switch
            {
                Accessibility.Public => "public",
                Accessibility.Internal => "internal",
                _ => "internal" // Default to internal for top-level types
            };
        }

        // For nested types, we can use all accessibility modifiers
        return accessibility switch
        {
            Accessibility.Private => "private",
            Accessibility.Protected => "protected",
            Accessibility.Internal => "internal",
            Accessibility.Public => "public",
            Accessibility.ProtectedOrInternal => "protected internal",
            Accessibility.ProtectedAndInternal => "private protected",
            _ => "public"
        };
    }
}

