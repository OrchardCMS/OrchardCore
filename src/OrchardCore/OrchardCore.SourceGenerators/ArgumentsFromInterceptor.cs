using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

#nullable enable

namespace OrchardCore.DisplayManagement.SourceGenerators;

/// <summary>
/// Interceptor-based source generator that optimizes Arguments.From calls with anonymous types.
/// This generator intercepts calls and redirects them to use the Arguments.From(object[], string[]) overload
/// directly, avoiding the overhead of the generic reflection-based path.
/// </summary>
[Generator]
public class ArgumentsFromInterceptor : IIncrementalGenerator
{
    private const string ArgumentsFromMethodName = "From";
    private const string ArgumentsTypeName = "Arguments";
    private const string ArgumentsNamespace = "OrchardCore.DisplayManagement";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all invocations of Arguments.From<T>(anonymousType)
        var invocations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsArgumentsFromInvocation(node),
                transform: static (context, ct) => GetInvocationInfo(context, ct))
            .Where(static info => info is not null);

        // Generate interceptors
        context.RegisterSourceOutput(
            invocations.Collect(),
            static (spc, invocations) => Execute(invocations!, spc));
    }

    private static bool IsArgumentsFromInvocation(SyntaxNode node)
    {
        if (node is not InvocationExpressionSyntax invocation)
        {
            return false;
        }

        // Check if it looks like Arguments.From(...)
        return invocation.Expression is MemberAccessExpressionSyntax memberAccess &&
               memberAccess.Name.Identifier.Text == ArgumentsFromMethodName;
    }

    private static InvocationInfo? GetInvocationInfo(GeneratorSyntaxContext context, CancellationToken ct)
    {
        var invocation = (InvocationExpressionSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        // Get the symbol for the method being called
        var symbolInfo = semanticModel.GetSymbolInfo(invocation, ct);
        if (symbolInfo.Symbol is not IMethodSymbol methodSymbol)
        {
            return null;
        }

        // Check if it's Arguments.From<T>(T propertyObject)
        if (methodSymbol.Name != ArgumentsFromMethodName ||
            methodSymbol.ContainingType?.ToDisplayString() != $"{ArgumentsNamespace}.{ArgumentsTypeName}" ||
            !methodSymbol.IsGenericMethod ||
            methodSymbol.TypeArguments.Length != 1)
        {
            return null;
        }

        var typeArgument = methodSymbol.TypeArguments[0];

        // Check if the type argument is an anonymous type
        if (!typeArgument.IsAnonymousType)
        {
            return null;
        }

        // Skip nested anonymous types for simplicity
        if(typeArgument.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic && p.Type.IsAnonymousType)
            .Any())
        {
            return null;
        }

        // Get the properties from the anonymous type
        var properties = typeArgument.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic)
            .Select(p => new PropertyInfo(p.Name, p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)))
            .ToImmutableArray();

        if (properties.IsEmpty)
        {
            return null;
        }

        // Get location information for the interceptor
        var location = context.SemanticModel.GetInterceptableLocation(invocation, ct);
        if (location == null)
        {
            return null;
        }

        return new InvocationInfo(
            location,
            properties,
            typeArgument);
    }

    private static void Execute(ImmutableArray<InvocationInfo> invocations, SourceProductionContext context)
    {
        if (invocations.IsEmpty)
        {
            return;
        }

        var sb = new StringBuilder();

        // Add the InterceptsLocationAttribute to the generated file
        sb.Append("""
                    // <auto-generated />
                    using OrchardCore.DisplayManagement;

                    namespace System.Runtime.CompilerServices
                    {
                        [global::System.Diagnostics.Conditional("DEBUG")]
                        [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                        sealed file class InterceptsLocationAttribute : global::System.Attribute
                        {
                            public InterceptsLocationAttribute(int version, string data)
                            {
                                _ = version;
                                _ = data;
                            }
                        }
                    }

                    namespace OrchardCore.DisplayManagement.Generated
                    {
                        file static class InterceptorsHelper
                        {
                            // Cast method - thanks to type inference when calling methods it
                            // is possible to cast object to type without knowing the type name
                            public static T Cast<T>(object obj, T type)
                            {
                                return (T)obj;
                            }
                        }
                    """);

        sb.AppendLine();

        // Generate interceptors for all invocations
        foreach (var info in invocations)
        {
            GenerateInterceptor(sb, info);
        }

        sb.Append('}');
        sb.AppendLine();

        context.AddSource("ArgumentsFromInterceptors.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void GenerateInterceptor(StringBuilder sb, InvocationInfo info)
    {
        var uniqueId = Guid.NewGuid().ToString("N");
        
        sb.AppendLine($"    file static class Interceptor_{uniqueId}");
        sb.AppendLine("    {");
        
        // Generate the static property names array
        sb.AppendLine($"        private static readonly string[] s_names =");
        sb.AppendLine("        [");
        foreach (var prop in info.Properties)
        {
            sb.AppendLine($"            \"{prop.Name}\",");
        }
        sb.AppendLine("        ];");
        sb.AppendLine();

        // Generate the interceptor method
        sb.AppendLine($"        [global::System.Runtime.CompilerServices.InterceptsLocation({info.Location.Version}, \"{info.Location.Data}\")]");
        sb.AppendLine($"        public static global::OrchardCore.DisplayManagement.INamedEnumerable<object> InterceptFrom<T>(T anonymousObject) where T : notnull");
        sb.AppendLine("        {");

        // To cast the anonymous object to the correct type, we can use a new instance of the anonymous type and rely on type inference
        sb.AppendLine($"            var typedObject = InterceptorsHelper.Cast(anonymousObject, new {{ {string.Join(", ", info.Properties.Select(p => $"{p.Name} = ({p.TypeName})default")) } }});");

        // Create the values array - using direct initialization with typed property access
        sb.AppendLine($"            return global::OrchardCore.DisplayManagement.Arguments.From(");
        sb.AppendLine("                [");
        for (var i = 0; i < info.Properties.Length; i++)
        {
            var prop = info.Properties[i];
            var comma = i < info.Properties.Length - 1 ? "," : "";
            sb.AppendLine($"                    typedObject.{prop.Name}{comma}");
        }
        sb.AppendLine("                ],");
        sb.AppendLine($"                s_names);");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private sealed class InvocationInfo
    {
        public InvocationInfo(InterceptableLocation location, ImmutableArray<PropertyInfo> properties, ITypeSymbol anonymousType)
        {
            Location = location;
            Properties = properties;
            AnonymousType = anonymousType;
        }

        public InterceptableLocation Location { get; }
        public ImmutableArray<PropertyInfo> Properties { get; }
        public ITypeSymbol AnonymousType { get; }
    }

    private sealed class PropertyInfo
    {
        public PropertyInfo(string name, string typeName)
        {
            Name = name;
            TypeName = typeName;
        }

        public string Name { get; }
        public string TypeName { get; }
    }
}
